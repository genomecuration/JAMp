/*
 * CanvasXpress 7.3 - JavaScript Canvas Library
 *
 * Copyright (c) 2009-2013 Isaac Neuhaus
 *
 * imnphd@gmail.com
 *
 *
 * Redistributions of this source code must retain this copyright
 * notice and the following disclaimer.
 *
 * CanvasXpress is licensed under the terms of the Open Source
 * GPL version 3.0 license.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial use may be granted to the extent that this source code
 * does NOT become part of any other Open Source or Commercially licensed
 * development library or toolkit without explicit permission.
 *
 * Network graphs were implemented based on the HeyGraph by Tom Martin
 * <http://www.heychinaski.com>.
 *
 * Thanks to Mingyi Liu for his contributions with the Ext-JS panel and
 * network graphs and Charles Tilford for his input to the Genome Browser.
 *
 */

function str_repeat(b, a) {
    for (var c = []; a > 0; c[--a] = b) {}
    return (c.join(""))
}

function sprintf() {
    var g = 0,
        e, h = arguments[g++],
        k = [],
        d, j, l, b;
    while (h) {
        if (d = /^[^\x25]+/.exec(h)) {
            k.push(d[0])
        } else {
            if (d = /^\x25{2}/.exec(h)) {
                k.push("%")
            } else {
                if (d = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(h)) {
                    if (((e = arguments[d[1] || g++]) == null) || (e == undefined)) {
                        throw ("Too few arguments.")
                    }
                    if (/[^s]/.test(d[7]) && (typeof(e) != "number")) {
                        throw ("Expecting number but found " + typeof(e))
                    }
                    switch (d[7]) {
                        case "b":
                            e = e.toString(2);
                            break;
                        case "c":
                            e = String.fromCharCode(e);
                            break;
                        case "d":
                            e = parseInt(e);
                            break;
                        case "e":
                            e = d[6] ? e.toExponential(d[6]) : e.toExponential();
                            break;
                        case "f":
                            e = d[6] ? parseFloat(e).toFixed(d[6]) : parseFloat(e);
                            break;
                        case "o":
                            e = e.toString(8);
                            break;
                        case "s":
                            e = ((e = String(e)) && d[6] ? e.substring(0, d[6]) : e);
                            break;
                        case "u":
                            e = Math.abs(e);
                            break;
                        case "x":
                            e = e.toString(16);
                            break;
                        case "X":
                            e = e.toString(16).toUpperCase();
                            break
                    }
                    e = (/[def]/.test(d[7]) && d[2] && e > 0 ? "+" + e : e);
                    l = d[3] ? d[3] == "0" ? "0" : d[3].charAt(1) : " ";
                    b = d[5] - String(e).length;
                    j = d[5] ? str_repeat(l, b) : "";
                    k.push(d[4] ? e + j : j + e)
                } else {
                    throw ("Huh ?!")
                }
            }
        }
        h = h.substring(d[0].length)
    }
    return k.join("")
};
var dateFormat = function() {
    var a = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
        b = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        d = /[^-+\dA-Z]/g,
        c = function(f, e) {
            f = String(f);
            e = e || 2;
            while (f.length < e) {
                f = "0" + f
            }
            return f
        };
    return function(i, v, q) {
        var g = dateFormat;
        if (arguments.length == 1 && Object.prototype.toString.call(i) == "[object String]" && !/\d/.test(i)) {
            v = i;
            i = undefined
        }
        i = i ? new Date(i) : new Date;
        if (isNaN(i)) {
            throw SyntaxError("invalid date")
        }
        v = String(g.masks[v] || v || g.masks["default"]);
        if (v.slice(0, 4) == "UTC:") {
            v = v.slice(4);
            q = true
        }
        var t = q ? "getUTC" : "get",
            l = i[t + "Date"](),
            e = i[t + "Day"](),
            j = i[t + "Month"](),
            p = i[t + "FullYear"](),
            r = i[t + "Hours"](),
            k = i[t + "Minutes"](),
            u = i[t + "Seconds"](),
            n = i[t + "Milliseconds"](),
            f = q ? 0 : i.getTimezoneOffset(),
            h = {
                d: l,
                dd: c(l),
                ddd: g.i18n.dayNames[e],
                dddd: g.i18n.dayNames[e + 7],
                m: j + 1,
                mm: c(j + 1),
                mmm: g.i18n.monthNames[j],
                mmmm: g.i18n.monthNames[j + 12],
                yy: String(p).slice(2),
                yyyy: p,
                h: r % 12 || 12,
                hh: c(r % 12 || 12),
                H: r,
                HH: c(r),
                M: k,
                MM: c(k),
                s: u,
                ss: c(u),
                l: c(n, 3),
                L: c(n > 99 ? Math.round(n / 10) : n),
                t: r < 12 ? "a" : "p",
                tt: r < 12 ? "am" : "pm",
                T: r < 12 ? "A" : "P",
                TT: r < 12 ? "AM" : "PM",
                Z: q ? "UTC" : (String(i).match(b) || [""]).pop().replace(d, ""),
                o: (f > 0 ? "-" : "+") + c(Math.floor(Math.abs(f) / 60) * 100 + Math.abs(f) % 60, 4),
                S: ["th", "st", "nd", "rd"][l % 10 > 3 ? 0 : (l % 100 - l % 10 != 10) * l % 10]
            };
        return v.replace(a, function(m) {
            return m in h ? h[m] : m.slice(1, m.length - 1)
        })
    }
}();
dateFormat.masks = {
    "default": "ddd mmm dd yyyy HH:MM:ss",
    shortDate: "m/d/yy",
    mediumDate: "mmm d, yyyy",
    longDate: "mmmm d, yyyy",
    fullDate: "dddd, mmmm d, yyyy",
    shortTime: "h:MM TT",
    mediumTime: "h:MM:ss TT",
    longTime: "h:MM:ss TT Z",
    isoDate: "yyyy-mm-dd",
    isoTime: "HH:MM:ss",
    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};
dateFormat.i18n = {
    dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
Date.prototype.format = function(a, b) {
    return dateFormat(this, a, b)
};
if (typeof(CanvasXpress) == "undefined") {
    CanvasXpress = {}
}
var CanvasXpress = function(g, e, b, c, d, f, a) {
    this.$ = function(h) {
        return document.getElementById(h)
    };
    this.$cX = function(j, m, k) {
        var l = document.createElement(j);
        if (m) {
            for (var h in m) {
                l[h] = m[h]
            }
        }
        if (k) {
            for (var h in k) {
                l.style[h] = k[h]
            }
        }
        return l
    };
    if (!g) {
        g = this.createNewTarget()
    } else {
        if (typeof(g) == "object") {
            e = g.data || false;
            b = g.config || false;
            c = g.events || false;
            d = g.hidden || false;
            f = g.info || false;
            a = g.check || false;
            g = g.renderTo || this.createNewTarget()
        }
    }
    this.setInit = function() {
        this.version = 7.3;
        this.target = g;
        this.events = c;
        this.info = f;
        this.userId = 5851132401134230;
        this.startTime = new Date().getTime()
    };
    this.validateParameters = function() {
        this.validateData();
        this.validateConfig();
        this.validateEvents();
        this.validateInfo()
    };
    this.validateData = function() {
        if (e && !this.subBrowser) {
            try {
                JSON.stringify(e)
            } catch (h) {
                alert("Data object malformed:\n" + h)
            }
        }
    };
    this.validateConfig = function() {
        this.addConfigLocation();
        if (!b) {
            b = {}
        } else {
            if (!this.subBrowser) {
                try {
                    JSON.stringify(b)
                } catch (h) {
                    alert("Config object malformed:\n" + h)
                }
            }
        }
        this.userConfig = b
    };
    this.validateEvents = function() {};
    this.validateInfo = function() {
        if (!f) {
            f = ""
        }
    };
    this.addConfigLocation = function() {
        var o = window.location.href.split(/&/);
        if (o && o.length > 0) {
            for (var j = 0; j < o.length; j++) {
                var h = o[j].match(/canvasXpress=(\{.+\})/);
                if (h && h.length > 1) {
                    var n = decodeURIComponent(JSON.stringify(h[1]).replace(/^\"/, "").replace(/\"$/, ""));
                    var k;
                    try {
                        k = JSON.parse(n)
                    } catch (m) {
                        alert("Location parameters malformed:\n" + m)
                    }
                    if (k) {
                        if (!b) {
                            b = {}
                        }
                        for (var l in k) {
                            if (!b[l]) {
                                b[l] = k[l]
                            }
                        }
                    }
                }
            }
        }
    };
    this.newId = function(j) {
        var l = 0;
        var h = this.target + j + l;
        var k = this.$(h);
        while (k) {
            l++;
            h = this.target + j + l;
            k = this.$(h)
        }
        return h
    };
    this.createNewTarget = function() {
        var h = this.$cX("canvas", {
            id: this.newId("canvasXpress")
        });
        document.body.appendChild(h);
        return h.id
    };
    this.insertTarget = function(k, m, j, l, i) {
        if (k && m) {
            var n = this.$(k);
            if (n) {
                return
            } else {
                n = this.$cX("canvas", {
                    id: k,
                    width: j,
                    height: l
                })
            } if (i) {
                m.parentNode.insertBefore(n, m.nextSibling)
            } else {
                m.parentNode.insertBefore(n, m)
            }
        }
    };
    this.removeTarget = function(h) {
        var i = this.$(h);
        if (i) {
            i.parentNode.removeChild(i)
        }
    };
    this.save = function(i, h) {
        if (this.remoteService) {
            if (h == "save") {
                this.addRemoteDataSaveForm(i)
            } else {
                this.saveRemote(h)
            }
        } else {
            return {
                renderTo: this.target,
                data: this.data,
                config: this.getConfig(),
                events: this.events
            }
        }
    };
    this.print = function(h) {
        return function(i) {
            h.resetConfigurator();
            alert("A new window will open so you can right click on the graph and save it");
            if (h.isIE) {
                var k = h.canvas.parentNode.childNodes[0];
                return window.open().document.write("<html><body>" + k.innerHTML + "</body></html>")
            } else {
                var j = h.canvas.toDataURL("image/png");
                return window.open().document.write('<html><body><img src="' + j + '" /></body></html>')
            }
        }
    }(this);
    this.exportToExcel = function(k) {
        var j = "";
        for (var h = 0; h < k.length; h++) {
            j += k[h].join("%09") + "%0D"
        }
        return window.open("data:text/tab-separeted-values," + j)
    };
    this.exporttoHTML = function(k) {
        var j = "<table>";
        for (var h = 0; h < k.length; h++) {
            j += "<tr><td>";
            j += k[h].join("</td><td>");
            j += "</td></tr>"
        }
        j += "</table>";
        return window.open().document.write(j)
    };
    this.exporttoHTML = function(k) {
        var j = "<table>";
        for (var h = 0; h < k.length; h++) {
            j += "<tr><td>";
            j += k[h].join("</td><td>");
            j += "</td></tr>"
        }
        j += "</table>";
        return window.open().document.write(j)
    };
    this.arrayToHTML = function(m) {
        var l = '<div style="padding:2px;"><table style="border-collapse: collapse;">';
        for (var k = 0; k < m[0].length; k++) {
            l += "<tr>";
            for (var h = 0; h < m[0][k].length; h++) {
                if (m[1][k][h] && m[1][k][h] == "cxy") {
                    l += '<td class="' + (m[1][k][h] || "cxb") + '">' + this.bestFormatNumber(m[0][k][h]) + "</td>"
                } else {
                    l += '<td class="' + (m[1][k][h] || "cxb") + '">' + m[0][k][h] + "</td>"
                }
            }
            l += "</tr>"
        }
        l += "</table></div>";
        return l
    };
    this.prettyJSON = function(h, q) {
        var r = function(i) {
            if (typeof(i) == "object") {
                if (i === null) {
                    return "null"
                }
                if (i.constructor == (new Array).constructor) {
                    return "array"
                }
                if (i.constructor == (new Date).constructor) {
                    return "date"
                }
                if (i.constructor == (new RegExp).constructor) {
                    return "regex"
                }
                return "object"
            }
            return typeof(i)
        };
        if (!q) {
            q = ""
        }
        var s;
        var n = "  ";
        var j = r(h);
        var l = 0;
        if (j == "array") {
            if (h.length == 0) {
                return "[]"
            }
            s = "["
        } else {
            for (var p in h) {
                l++;
                break
            }
            if (l == 0) {
                return "{}"
            }
            s = "{"
        }
        l = 0;
        for (var m in h) {
            v = h[m];
            if (l > 0) {
                s += ","
            }
            if (j == "array") {
                s += ("\n" + q + n)
            } else {
                s += ("\n" + q + n + '"' + m + '": ')
            }
            switch (r(v)) {
                case "array":
                case "object":
                    s += this.prettyJSON(v, (q + n));
                    break;
                case "boolean":
                case "number":
                    s += v.toString();
                    break;
                case "null":
                    s += "null";
                    break;
                case "string":
                    s += ('"' + v + '"');
                    break;
                default:
            }
            l++
        }
        if (j == "array") {
            s += ("\n" + q + "]")
        } else {
            s += ("\n" + q + "}")
        }
        return s
    };
    this.dumpToConsole = function(h) {
        console.log(this.target);
        console.log(this.prettyJSON(h))
    };
    this.profile = function(j) {
        var h = new Date().getTime();
        var i = this.profileTime || this.startTime;
        if (!j) {
            j = ""
        }
        console.log(this.target + ": " + j + ": " + (h - i));
        this.profileTime = h
    };
    this.stack = function() {
        if (this.debug) {
            for (var h in this) {
                if (arguments.callee.caller === this[h]) {
                    CanvasXpress.stack[this.target].push(h);
                    return
                }
            }
        }
    };
    this.initialize = function() {
        this.initCSS();
        this.setInit();
        this.initCrossBrowser(a);
        this.validateParameters();
        this.initConfig(b);
        this.initViewport(d);
        this.initUtils();
        this.initPrimitives();
        this.initExample();
        this.initData(e);
        this.initLayout();
        this.initEvents();
        this.initAnimation();
        this.initRemote();
        this.initGraph();
        this.showToolbar(true)
    };
    this.initialize();
    CanvasXpress.references.push(this);
    CanvasXpress.stack[this.target] = []
};
CanvasXpress.references = [];
CanvasXpress.cacheImages = {};
CanvasXpress.cacheImagesReady = false;
CanvasXpress.cachePatterns = {};
CanvasXpress.cacheText = {};
CanvasXpress.stack = {};
CanvasXpress.current = false;
CanvasXpress.resizing = false;
CanvasXpress.getObject = function(c, b) {
    for (var a = 0; a < CanvasXpress.references.length; a++) {
        if (CanvasXpress.references[a].target == c) {
            return CanvasXpress.references[a]
        }
    }
    if (b) {
        return CanvasXpress.injectObject(c)
    }
};
CanvasXpress.injectObject = function(d) {
    var a = document.getElementById(d);
    if (!a) {
        var b = document.createElement("canvas");
        b.id = d;
        b.width = 100;
        b.height = 100;
        document.body.appendChild(b);
        a = new CanvasXpress(d, false, false, false, true)
    }
    return a
};
CanvasXpress.setExampleContainer = function(a) {
    if (!a) {
        a = "Show-All"
    }
    var j = CanvasXpress.getObject("CanvasXpress-Silent", true);
    var d = j.getWindowSize();
    var e = j.getWindowScroll();
    var c = Math.max(0, ((d[0] - 500) / 2) + e[0]);
    var h = Math.max(0, ((d[1] - 500) / 2) + e[1]);
    var g = j.$cX("div", {
        id: a + "-cX-API-Example",
        className: "CanvasXpressConfiguratorExample draggable"
    }, {
        width: "535px",
        maxHeight: "500px",
        cursor: "move",
        display: "block",
        padding: "10px",
        position: "absolute",
        overflow: "hidden",
        paddingBottom: "35px",
        left: c + "px",
        top: h + "px"
    });
    var b = j.$cX("span", {
        id: a + "-cX-API-ExampleSpan",
        className: "CanvasXpressConfiguratorExample",
        innerHTML: ""
    });
    var f = j.$cX("img", {
        id: a + "-cX-API-ExampleClose",
        className: "CanvasXpressConfigurator",
        property: a,
        src: j.imageDir + "cancel1.png",
        alt: "Close",
        title: "Close"
    });
    var i = j.$cX("div", {
        id: a + "-cX-API-ExampleContent",
        className: "CanvasXpressConfiguratorExampleContent",
    }, {
        maxWidth: "535px",
        maxHeight: "500px",
        overflow: "auto"
    });
    g.appendChild(b);
    g.appendChild(f);
    g.appendChild(j.$cX("br"));
    g.appendChild(i);
    document.body.appendChild(g);
    return j
};
CanvasXpress.showExample = function(h, g) {
    if (g) {
        var c = CanvasXpress.setExampleContainer(g);
        var b = c.$(g + "-cX-API-Example");
        var f = c.$(g + "-cX-API-ExampleSpan");
        var d = c.$(g + "-cX-API-ExampleClose");
        var a = c.$(g + "-cX-API-ExampleContent");
        d.onclick = function() {
            var e = c.$(this.property + "-cX-API-Example");
            if (e) {
                c.removeEvtListener(e, "mousedown", c.registerMousemove, false);
                var i = e.getElementsByTagName("canvas");
                while (i.length > 0) {
                    c.destroy(i[0].id)
                }
                e.parentNode.removeChild(e)
            }
        };
        c.addEvtListener(b, "mousedown", c.registerMousemove, false);
        c.stopEvent(h);
        c.cancelEvent(h);
        c.clickExamplePropertyDescription(h, g, true);
        return false
    }
};
CanvasXpress.showAllExamples = function(w, y) {
    var o = CanvasXpress.setExampleContainer();
    var u = o.$("Show-All-cX-API-Example");
    var g = o.$("Show-All-cX-API-ExampleSpan");
    var m = o.$("Show-All-cX-API-ExampleClose");
    var p = o.$("Show-All-cX-API-ExampleContent");
    m.onclick = function() {
        var c = o.$(this.property + "-cX-API-Example");
        if (c) {
            clearInterval(x);
            o.removeEvtListener(c, "mousedown", o.registerMousemove, false);
            var e = c.getElementsByTagName("canvas");
            while (e.length > 0) {
                o.destroy(e[0].id)
            }
            c.parentNode.removeChild(c)
        }
    };
    p.appendChild(o.$cX("canvas", {
        id: "Show-All-cX-API-Example-Canvas",
        width: 500,
        height: 500
    }));
    o.addEvtListener(u, "mousedown", o.registerMousemove, false);
    o.stopEvent(w);
    o.cancelEvent(w);
    new CanvasXpress("Show-All-cX-API-Example-Canvas");
    var a = [];
    var l = y ? [y] : o.getKeys(CanvasXpress.doc.M).sort();
    for (var s = 0; s < l.length; s++) {
        var k = l[s];
        for (var q = 0; q < CanvasXpress.doc.M[k]["P"].length; q++) {
            var b = CanvasXpress.doc.M[k]["P"][q];
            var n = CanvasXpress.doc.P[b];
            if (n.H) {
                var h = o.getExamplesDocObject(b);
                a = a.concat(h)
            }
        }
    }
    var r = 0;
    var d = "Show-All-cX-API-Example-Canvas";
    var f = function() {
        o.destroy(d);
        d = a[r][0];
        o.insertTarget(d, p, 500, 500);
        var z = a[r][1];
        var A = a[r][2];
        A.disableToolbar = true;
        var e = new CanvasXpress(d, z, A);
        g.innerHTML = d.replace("CanvasXpress-Silent-cX-ConfiguratorExample-", "").split("-")[0];
        var t = a[r][3];
        if (t) {
            for (var j = 0; j < t.length; j++) {
                if (t[j].match(/:/)) {
                    var c = t[j].split(":");
                    e[c.shift()].apply(e, c)
                } else {
                    e[t[j]]()
                }
            }
        }
        r++;
        if (r == a.length) {
            r = 0
        }
    };
    var x = setInterval(function() {
        f()
    }, 200);
    return false
};
CanvasXpress.prototype.initCrossBrowser = function(a) {
    this.getWindowSize = function() {
        if (typeof window.innerWidth != "undefined") {
            return [window.innerWidth, window.innerHeight]
        } else {
            if (typeof document.documentElement != "undefined" && typeof document.documentElement.clientWidth != "undefined" && document.documentElement.clientWidth != 0) {
                return [document.documentElement.clientWidth, document.documentElement.clientHeight]
            } else {
                return [document.getElementsByTagName("body")[0].clientWidth, document.getElementsByTagName("body")[0].clientHeight]
            }
        }
    };
    this.getWindowScroll = function() {
        var e, g;
        if (typeof pageXOffset != "undefined") {
            e = pageXOffset
        } else {
            var c = document.body;
            var f = document.documentElement;
            f = (f.clientWidth) ? f : c;
            e = f.scrollLeft
        } if (typeof pageYOffset != "undefined") {
            g = pageYOffset
        } else {
            var c = document.body;
            var f = document.documentElement;
            f = (f.clientHeight) ? f : c;
            g = f.scrollTop
        }
        return [e, g]
    };
    this.hasClass = function(b, c) {
        return new RegExp("(\\s|^)" + c + "(\\s|$)").test(b.className)
    };
    this.addClass = function(b, c) {
        if (!this.hasClass(b, c)) {
            b.className += (b.className ? " " : "") + c
        }
    };
    this.removeClass = function(b, c) {
        if (this.hasClass(b, c)) {
            b.className = b.className.replace(new RegExp("(\\s|^)" + c + "(\\s|$)"), " ").replace(/^\s+|\s+$/g, "")
        }
    };
    this.cancelEvent = function(b) {
        if (!b) {
            b = window.event
        }
        if (b.preventDefault) {
            b.preventDefault()
        } else {
            b.returnValue = false
        }
    };
    this.stopEvent = function(b) {
        if (!b) {
            b = window.event
        }
        if (b.stopPropagation) {
            b.stopPropagation()
        } else {
            b.cancelBubble = true
        }
    };
    this.normalizeEvtName = function(b) {
        return this.isIE ? "on" + b : b
    };
    this.addEvtListener = function(g, d, h, b) {
        if (g && d && h) {
            if (!this.registeredEvents) {
                this.registeredEvents = {}
            }
            if (g.id) {
                if (!this.registeredEvents[g.id]) {
                    this.registeredEvents[g.id] = {}
                }
                this.registeredEvents[g.id][d] = [h, b]
            } else {
                if (!this.registeredEvents[g]) {
                    this.registeredEvents[g] = {}
                }
                this.registeredEvents[g][d] = [h, b]
            } if (this.isIE) {
                g.attachEvent(this.normalizeEvtName(d), h)
            } else {
                g.addEventListener(d, h, b);
                if (d == "mousewheel") {
                    g.addEventListener("DOMMouseScroll", h, b)
                }
            }
        }
    };
    this.removeEvtListener = function(i, h, j, g) {
        if (i && h && j) {
            var d = this.registeredEvents[i.id || i];
            if (d && d.hasOwnProperty(h)) {
                delete(d[h]);
                if (this.isIE) {
                    i.detachEvent(this.normalizeEvtName(h), j)
                } else {
                    i.removeEventListener(h, j, g);
                    if (h == "mousewheel") {
                        i.removeEventListener("DOMMouseScroll", j, g)
                    }
                }
                var b = this.getKeys(this.registeredEvents[i.id || i]);
                if (b && b.length < 1) {
                    delete(this.registeredEvents[i.id || i])
                }
            }
        }
    };
    this.addRemoveEvtListener = function(b, h, g, i, d) {
        if (b && h && g && i) {
            this[b](h, g, i, d)
        }
    };
    this.purgeEventListeners = function() {
        for (var b in this.registeredEvents) {
            var d = this.$(b) || b;
            for (var c in this.registeredEvents[b]) {
                this.removeEvtListener(d, c, this.registeredEvents[b][0], this.registeredEvents[b][1])
            }
        }
    };
    this.preventSelection = function() {
        if (document.selection) {
            document.selection.empty()
        } else {
            if (window.getSelection) {
                window.getSelection().removeAllRanges()
            }
        }
    };
    this.getTargetEvent = function(b) {
        if (this.isIE && this.useFlashIE && this.browserVersion < 9) {
            return b.srcElement.parentNode
        } else {
            return b.target || b.srcElement
        }
    };
    this.isGoogleChromeFrame = function() {
        if (this.browser == "Explorer" && this.browserVersion < 9 && !a) {
            if (navigator.userAgent.toLowerCase().indexOf("chromeframe") < 0) {
                try {
                    var c = document.createElement("script");
                    c.type = "text/javascript";
                    c.src = "http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js";
                    document.getElementsByTagName("head")[0].appendChild(c);
                    CFInstall.check({
                        mode: "overlay"
                    })
                } catch (b) {
                    alert("CanvasXpress works much faster in fully HTML 5 compliant browsers.\nPlease consider installing Google chrome frame to make this browser compliant.")
                }
            }
        }
    };
    this.dataBrowser = [{
        string: navigator.platform,
        subString: "iPhone",
        identity: "iPhone"
    }, {
        string: navigator.platform,
        subString: "iPod",
        identity: "iPod"
    }, {
        string: navigator.userAgent,
        subString: "iPad",
        identity: "iPad"
    }, {
        string: navigator.userAgent,
        subString: "Android",
        identity: "Android"
    }, {
        string: navigator.userAgent,
        subString: "BlackBerry",
        identity: "BlackBerry"
    }, {
        string: navigator.userAgent,
        subString: "Chrome",
        identity: "Chrome"
    }, {
        string: navigator.userAgent,
        subString: "OmniWeb",
        versionSearch: "OmniWeb/",
        identity: "OmniWeb"
    }, {
        string: navigator.vendor,
        subString: "Apple",
        identity: "Safari",
        versionSearch: "Version"
    }, {
        prop: window.opera,
        identity: "Opera"
    }, {
        string: navigator.vendor,
        subString: "iCab",
        identity: "iCab"
    }, {
        string: navigator.vendor,
        subString: "KDE",
        identity: "Konqueror"
    }, {
        string: navigator.userAgent,
        subString: "Firefox",
        identity: "Firefox"
    }, {
        string: navigator.vendor,
        subString: "Camino",
        identity: "Camino"
    }, {
        string: navigator.userAgent,
        subString: "Netscape",
        identity: "Netscape"
    }, {
        string: navigator.userAgent,
        subString: "MSIE",
        identity: "Explorer",
        versionSearch: "MSIE"
    }, {
        string: navigator.userAgent,
        subString: "Gecko",
        identity: "Mozilla",
        versionSearch: "rv"
    }, {
        string: navigator.userAgent,
        subString: "Mozilla",
        identity: "Netscape",
        versionSearch: "Mozilla"
    }];
    this.dataOS = [{
        string: navigator.platform,
        subString: "Win",
        identity: "Windows"
    }, {
        string: navigator.platform,
        subString: "Mac",
        identity: "Mac"
    }, {
        string: navigator.platform,
        subString: "iPhone",
        identity: "iPhone"
    }, {
        string: navigator.platform,
        subString: "iPod",
        identity: "iPod"
    }, {
        string: navigator.userAgent,
        subString: "iPad",
        identity: "iPad"
    }, {
        string: navigator.userAgent,
        subString: "Android",
        identity: "Android"
    }, {
        string: navigator.userAgent,
        subString: "BlackBerry",
        identity: "BlackBerry"
    }, {
        string: navigator.platform,
        subString: "Linux",
        identity: "Linux"
    }];
    this.isSubstandardBrowser = function() {
        if ((this.browser == "Firefox" && this.browserVersion > 4) || (this.browser == "Opera" && this.browserVersion > 9) || (this.browser == "Safari" && this.browserVersion > 4) || (this.browser == "Chrome" && this.browserVersion > 1)) {
            return false
        } else {
            return true
        }
    };
    this.isMobileApp = function() {
        if (this.browser.match(/iPhone|iPod|iPad|Android|BlackBerry/i)) {
            return true
        } else {
            return false
        }
    };
    this.searchString = function(e) {
        for (var b = 0; b < e.length; b++) {
            var c = e[b].string;
            var d = e[b].prop;
            this.versionSearchString = e[b].versionSearch || e[b].identity;
            if (c) {
                if (c.indexOf(e[b].subString) != -1) {
                    return e[b].identity
                }
            } else {
                if (d) {
                    return e[b].identity
                }
            }
        }
    };
    this.searchVersion = function(c) {
        var b = c.indexOf(this.versionSearchString);
        if (b == -1) {
            return
        }
        return parseFloat(c.substring(b + this.versionSearchString.length + 1))
    };
    this.initializeBrowser = function() {
        this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
        this.browserVersion = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "an unknown version";
        this.browserOS = this.searchString(this.dataOS) || "an unknown OS";
        if (this.browser == "Explorer") {
            this.isIE = true;
            this.subBrowser = true;
            this.mobileApp = false
        } else {
            this.isIE = false;
            this.subBrowser = this.isSubstandardBrowser();
            this.mobileApp = this.isMobileApp()
        }
        this.isGoogleChromeFrame()
    };
    this.initializeBrowser()
};
CanvasXpress.prototype.initCSS = function() {
    var a = " table.shorts{margin:2px 3px;padding:2px 3px;border:1px solid #fafafa;border-collapse:collapse;font-size:x-small}";
    a += " td.k{text-align:center;padding:2px 5px;margin:2px 5px;border:1px solid #cccccc;}";
    a += " td.d{padding:2px 5px;margin:2px 5px;border:1px solid #cccccc;}";
    a += " th.d{padding:2px 5px;margin:2px 5px;border:1px solid #cccccc;}";
    a += " th.cxx,th.cxz,th.cxb,th.cxs,th.cxv,td.cxx,td.cxz,td.cxb,td.cxs,td.cxv{background-image:url(http://www.canvasxpress.org/images/accordion.png);background-repeat:repeat-x;border:1px solid #cccccc;vertical-align:middle;}";
    a += " td.cxx,td.cxz,td.cxb,td.cxs,td.cxv{font:normal 11px arial,tahoma,sans-serif;line-height:16px;background:#fefefe;padding:1px;}";
    a += " td.cxy{font:normal 11px arial,tahoma,sans-serif;line-height:16px;border:1px solid #cccccc;vertical-align:middle;text-align:right;background:#fefefe;padding:1px;}";
    a += " div.cxc{left:0px;top:0px;margin-left:5px;margin-top:2px;white-space:nowrap;overflow:hidden;}";
    a += " div.CanvasXpressSaveForm{border: 1px solid rgb(113,139,183);border-radius: 5px;background-color: rgb(240,240,240);color: rgb(34,34,34);font: normal 11px arial, tahoma, sans-serif;margin: 8px;padding: 8px;position: absolute;white-space: nowrap;}";
    a += " div.CanvasXpressCode {border: 1px solid rgb(113,139,183);border-radius: 5px;background-color: rgb(240,240,240);cursor: move;color: rgb(34,34,34);font: normal 11px arial, tahoma, sans-serif;margin: 2px 3px;padding: 2px 3px;position: absolute;white-space: nowrap;}";
    a += " img.CanvasXpressCode {cursor: default;float: right;height: 13px;margin: 2px 3px 0px 0px;padding-bottom: 5px;width: 13px;-moz-user-select: none;-khtml-user-select: none;-webkit-user-select: none;-o-user-select: none;-user-select: none;}";
    a += " div.CanvasXpressCodeContainer {background-color: rgb(240,240,240);clear: both;max-height: 500px;max-width: 600px;overflow: auto;}";
    a += " div.CanvasXpressCodeContent {background-color: rgb(240,240,240);margin: 2px 3px;padding: 2px 3px;}";
    a += " pre.CanvasXpressCodeContent {background-color: rgb(240,240,240);border: none;margin: 0px;padding: 10px;white-space: pre;}";
    a += " div.CanvasXpressDrag{opacity:0.5;filter:alpha(opacity=50);background-color:rgb(240,240,240);position:absolute;}";
    a += " div.CanvasXpressTooltip{border:1px solid rgb(113,139,183);border-radius:5px;background-color:rgb(240,240,240);cursor:move;color:rgb(34,34,34);font:normal 11px arial,tahoma,sans-serif;margin:2px 3px;overflow:hidden;padding:2px 3px;position:absolute;white-space:nowrap;}";
    a += " img.CanvasXpressTooltip{cursor:default;float:right;height:13px;margin:2px 3px 0px 0px;width:13px;cursor:default;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " span.CanvasXpressTooltip{border:1px solid rgb(113,139,183);border-radius:5px;background-color:rgb(240,240,240);cursor:move;color:rgb(34,34,34);font:normal 11px arial,tahoma,sans-serif;margin:2px 3px;overflow:hidden;padding:2px 3px;position:absolute;white-space:nowrap;}";
    a += " div.CanvasXpressDataTable{border:1px solid rgb(113,139,183);border-radius:5px;background-color:rgb(240,240,240);clear:both;color:rgb(34,34,34);font:normal 11px arial,tahoma,sans-serif;overflow:hidden;position:absolute;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressDataTableToolbar{border:0px;border-radius:5px 5px 0px 0px;background-color:rgb(240,240,240);color:rgb(34,34,34);cursor:move;font:normal 11px arial,tahoma,sans-serif;height:18px;left:0px;line-height:100%;position:absolute;top:0px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " img.CanvasXpressDataTableToolbarImage{cursor:default;float:right;height:13px;margin:2px 3px 0px 0px;width:13px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressDataTableContainer{background-color:rgb(240,240,240);border-radius:0px 0px 5px 5px;color:rgb(34,34,34);display:block;font:normal 11px arial,tahoma,sans-serif;left:0px;line-height:100%;position:absolute;top:20px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressDataTableVertical{background-color:rgb(240,240,240);overflow:auto;position:absolute;right:2px;top:2px;width:18px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressDataTableHorizontal{background-color:rgb(240,240,240);bottom:2px;height:18px;left:2px;overflow:auto;position:absolute;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressDataTableResizer{background-color:rgb(240,240,240);background-image:url(http://www.canvasxpress.org/images/resize_w.png);background-repeat:no-repeat;cursor:se-resize;bottom:1px;height:15px;position:absolute;right:1px;width:15px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " table.CanvasXpressDataTable{border:0px;border-spacing:1px;color:rgb(34,34,34);font:normal 11px arial,tahoma,sans-serif;left:1px;line-height:20px;position:absolute;table-layout:fixed;top:1px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressDataTableMask{border:0px;left:1px;position:absolute;top:1px;overflow:hidden;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " th.CanvasXpressTableCellHead{background-image:url(http://www.canvasxpress.org/images/accordion.png);background-repeat:repeat-x;border-left:1px solid #ffffff;border-top:1px solid #ffffff;color:rgb(34,34,34);font:normal 11px arial,tahoma,sans-serif;line-height:20px;padding:0px;text-align:left;vertical-align:middle;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " th.CanvasXpressTableCellHeadActive{background-image:url(http://www.canvasxpress.org/images/accordion_active.png);background-repeat:repeat-x;border-left:1px solid #ffffff;border-top:1px solid #ffffff;color:rgb(34,34,34);font:normal 11px arial,tahoma,sans-serif;line-height:20px;padding:0px;text-align:left;vertical-align:middle;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " a.CanvasXpressTableCellHead{background:no-repeat left center;background-color:#dfe8f9;background-image:url(http://www.canvasxpress.org/images/header_arrow_down.png);cursor:pointer;display:none;height:20px;position:absolute;right:0px;top:0px;white-space:normal;width:14px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " a.CanvasXpressTableCellHeadActive{background:no-repeat left center;background-color:#dfe8f9;background-image:url(http://www.canvasxpress.org/images/header_arrow_down.png);cursor:pointer;display:block;height:20px;position:absolute;right:0px;top:0px;white-space:normal;width:14px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " td.CanvasXpressTableCell{background-color:#ffffff;border:0px;color:rgb(34,34,34);font:normal 11px arial,tahoma,sans-serif;line-height:20px;padding:0px;vertical-align:middle;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " td.CanvasXpressTableCellActive{background-color:#dfe8f9;border:0px;color:rgb(34,34,34);font:normal 11px arial,tahoma,sans-serif;line-height:20px;padding:0px;vertical-align:middle;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressTableCell{font:normal 11px arial,tahoma,sans-serif;line-height:20px;margin:2px 2px 1px 5px;overflow:hidden;position:relative;text-overflow:ellipsis;white-space:nowrap;}";
    a += " div.CanvasXpressTableCellSortAsc{background:url(http://www.canvasxpress.org/images/sort_asc.gif) no-repeat right 7px;font:normal 11px arial,tahoma,sans-serif;line-height:20px;margin:2px 2px 1px 5px;overflow:hidden;white-space:nowrap;}";
    a += " div.CanvasXpressTableCellSortDesc{background:url(http://www.canvasxpress.org/images/sort_desc.gif) no-repeat right 7px;font:normal 11px arial,tahoma,sans-serif;line-height:20px;margin:2px 2px 1px 5px;overflow:hidden;white-space:nowrap;}";
    a += " div.CanvasXpressConfigurator{background-color:rgb(240,240,240);border-radius:5px;border:1px solid rgb(113,139,183);box-shadow:rgba(154,154,154,0.2) 3px 3px;color:rgb(34,34,34);cursor:default;font:normal 11px arial,tahoma,sans-serif;line-height:16px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " span.CanvasXpressConfigurator{cursor:default;font:normal 11px arial,tahoma,sans-serif;line-height:16px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " textarea.CanvasXpressConfigurator{background-color:rgb(240,240,240);border-radius:5px;border:1px solid rgb(113,139,183);box-shadow:rgba(154,154,154,0.2) 3px 3px;color:rgb(34,34,34);cursor:default;font:normal 11px arial,tahoma,sans-serif;line-height:16px;}";
    a += " img.CanvasXpressConfigurator{cursor:default;float:right;height:13px;margin-left:2px;width:13px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " select.CanvasXpressConfigurator{background-color:rgb(255,255,255);border:1px solid rgb(113,139,183);color:rgb(34,34,34);cursor:default;font:normal 11px arial,tahoma,sans-serif;line-height:16px;padding-left:3px;}";
    a += " input.CanvasXpressConfigurator{background-color:rgb(255,255,255);border:1px solid rgb(113,139,183);color:rgb(34,34,34);cursor:default;font:normal 11px arial,tahoma,sans-serif;line-height:16px;padding-left:3px;}";
    a += " div.CanvasXpressConfiguratorOptions{cursor:default;font:normal 11px arial,tahoma,sans-serif;height:100px;line-height:16px;margin-top:8px;overflow:auto;width:180px;}";
    a += " div.CanvasXpressConfiguratorFilter{background-color:rgb(240,240,240);border-radius:5px;border:1px solid rgb(113,139,183);box-shadow:rgba(154,154,154,0.2) 3px 3px;color:rgb(34,34,34);font:normal 11px arial,tahoma,sans-serif;line-height:16px;}";
    a += " select.CanvasXpressConfiguratorFilter{border:1px solid rgb(113,139,183);font:normal 11px arial,tahoma,sans-serif;line-height:16px;}";
    a += " input.CanvasXpressConfiguratorFilter{border:1px solid rgb(113,139,183);font:normal 11px arial,tahoma,sans-serif;line-height:16px;}";
    a += " div.CanvasXpressConfiguratorExample{background-color:rgb(240,240,240);border-radius:5px;border:1px solid rgb(113,139,183);box-shadow:rgba(154,154,154,0.2) 3px 3px;color:rgb(34,34,34);font:normal 11px arial,tahoma,sans-serif;line-height:16px;}";
    a += " span.CanvasXpressConfiguratorExample{cursor:default;font:normal 11px arial,tahoma,sans-serif;line-height:16px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressConfiguratorColor{border:1px solid rgb(113,139,183);font:normal 11px arial,tahoma,sans-serif;line-height:16px;}";
    a += " div.accordionHead{margin-top:2px;height:16px;overflow:hidden;float:left;cursor:pointer;vertical-align:middle;text-align:left;display:table-cell;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.accordionContent{overflow:auto;}";
    a += " div.hoverable:hover{background-color:#dfe8f6}";
    a += " div.CanvasXpressContainer{position:relative;float:left;}";
    a += " div.CanvasXpressHandler{position:relative;float:left;background-position:50% 50%;background-repeat:no-repeat;}";
    a += " div.CanvasXpressWrapper{position:relative;float:left;line-height:100%;}";
    a += " div.CanvasXpressDataFilter{color:rgb(34,34,34);font:normal 11px arial,tahoma,sans-serif;line-height:100%;margin:0px;padding:0px;position:absolute;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressDataFilterToolbar{background-image:url(http://www.canvasxpress.org/images/accordion.png);background-repeat:repeat-x;border:1px solid rgb(113,139,183);border-radius:5px;color:rgb(34,34,34);cursor:move;font:normal 11px arial,tahoma,sans-serif;height:18px;left:0px;line-height:100%;margin:0px;padding:2px;position:absolute;top:0px;}";
    a += " span.CanvasXpressDataFilterToolbarText{font:normal 11px arial,tahoma,sans-serif;left:8px;line-height:100%;position:relative;top:5px;}";
    a += " img.CanvasXpressDataFilterToolbarImage{cursor:default;width:13px;height:13px;margin-top:2px;margin-right:2px;float:right;}";
    a += " span.CanvasXpressDataFilterText{background-image:url(http://www.canvasxpress.org/images/arrowright.png);background-repeat:no-repeat;background-position:-3px;font:normal 11px arial,tahoma,sans-serif;left:8px;line-height:100%;position:relative;top:5px;}";
    a += " span.CanvasXpressDataFilterTextActive{background-image:url(http://www.canvasxpress.org/images/arrowdown.png);background-repeat:no-repeat;background-position:-3px;font:normal 11px arial,tahoma,sans-serif;left:8px;line-height:100%;position:relative;top:5px;}";
    a += " div.CanvasXpressDataFilterContainer{border:0px;left:0px;margin:0px;padding:0px;position:absolute;top:24px;}";
    a += " div.CanvasXpressDataFilterContainerMask{background-color:#ffffff;border:1px solid #d0d0d0;margin:1px 3px 3px 3px;overflow-x:hidden;overflow-y:scroll;}";
    a += " div.CanvasXpressDataFilterContainerItem{background-color:#ffffff;color:#4181ba;height:15px;padding:1px 0px 0px 1px;}";
    a += " div.CanvasXpressDataFilterContainerItemSelected{background-color:#4181ba;color:rgb(255,255,255);height:15px;padding:1px 0px 0px 1px;}";
    a += " div.CanvasXpressDataFilterContainerHoverable{border:1px solid rgb(113,139,183);margin:2px;margin-bottom:4px;}";
    a += " div.CanvasXpressDataFilterContainerHoverable:hover{background-color:#dfe8f6}";
    a += " div.CanvasXpressDataFilterContainerNumeric{background-color:#ffffff;border:1px solid rgb(113,139,183);clear:both;height:14px;margin:2px;}";
    a += " div.CanvasXpressDataFilterContainerMin{background-image:url(http://www.canvasxpress.org/images/move_right.png);background-repeat:no-repeat;float:left;height:14px;position:relative;width:14px;z-index:10002;}";
    a += " div.CanvasXpressDataFilterContainerMax{background-image:url(http://www.canvasxpress.org/images/move_left.png);background-repeat:no-repeat;float:left;height:14px;position:relative;width:14px;z-index:10002;}";
    a += " div.CanvasXpressDataFilterContainerRange{background-color:#4181ba;float:left;height:14px;left:0px;position:relative;z-index:10001;}";
    a += " select.CanvasXpressDataFilterContainerString{background-color:rgb(255,255,255);font:normal 11px arial,tahoma,sans-serif;margin-left:3px;margin-bottom:3px;}";
    a += " div.CanvasXpressDataFilterHead{background-image:url(http://www.canvasxpress.org/images/accordion.png);background-repeat:repeat-x;border:1px solid rgb(113,139,183);border-radius:5px 5px 5px 5px;color:rgb(34,34,34);cursor:pointer;float:left;height:18px;margin-top:2px;overflow:hidden;padding:2px;text-align:left;vertical-align:middle;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressDataFilterHeadActive{background-color:rgb(240,240,240);background-image:url(http://www.canvasxpress.org/images/accordion_active.png);background-repeat:repeat-x;border:1px solid rgb(113,139,183);border-radius:5px 5px 0px 0px;color:rgb(34,34,34);cursor:pointer;float:left;height:18px;margin-top:2px;overflow:hidden;padding:2px;text-align:left;vertical-align:middle;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressDataFilterContent{background-color:rgb(255,255,255);border:1px solid rgb(113,139,183);border-radius:0px 0px 5px 5px;border-top:0px;color:rgb(113,139,183);overflow:auto;padding:2px;}";
    a += " div.CanvasXpressLink{background-color:rgb(240,240,240);background-image:url(http://www.canvasxpress.org/images/menu.gif);background-repeat:repeat-y;border:1px solid rgb(113,139,183);border-radius:3px;box-shadow:rgba(154,154,154,0.2) 3px 3px;color:rgb(34,34,34);cursor:default;font:normal 11px arial,tahoma,sans-serif;line-height:100%;margin:0px;padding:0px;position:absolute;-moz-box-shadow:rgba(154,154,154,0.2) 3px 3px;}";
    a += " div.CanvasXpressMenu{background-color:rgb(240,240,240);background-image:url(http://www.canvasxpress.org/images/menu.gif);background-repeat:repeat-y;border:1px solid rgb(113,139,183);border-radius:3px;box-shadow:rgba(154,154,154,0.2) 3px 3px;color:rgb(34,34,34);cursor:default;font:normal 11px arial,tahoma,sans-serif;line-height:100%;margin:0px;padding:0px;position:absolute;-moz-box-shadow:rgba(154,154,154,0.2) 3px 3px;}";
    a += " ul.CanvasXpressList{background:transparent;border:0px none;cursor:default;list-style:none;margin:0px;overflow:hidden;padding:2px;}";
    a += " li.CanvasXpressListItemSep{cursor:default;display:block;font:normal 11px arial,tahoma,sans-serif;font-size:1px;line-height:1px;list-style:none;margin:0px;padding:1px;white-space:nowrap;}";
    a += " li.CanvasXpressListItem{cursor:default;display:block;font:normal 11px arial,tahoma,sans-serif;line-height:100%;list-style:none;margin:0px;padding:1px;white-space:nowrap;}";
    a += " li.CanvasXpressListItemActive{background-color:rgb(219,236,244);background-image:url(http://www.canvasxpress.org/images/item-over.gif);background-repeat:repeat-x;background-position:left bottom;border-color:rgb(170,204,246);border-style:solid;border-width:1px 0px;cursor:default;display:block;font:normal 11px arial,tahoma,sans-serif;line-height:100%;list-style:none;margin:0px 1px;padding:0px;white-space:nowrap;}";
    a += " li.CanvasXpressListItemScrollTop{background-image:url(http://www.canvasxpress.org/images/mini-top-grey.png);background-repeat:no-repeat;background-position:50% 50%;border:0px;cursor:pointer;height:9px;line-height:9px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " li.CanvasXpressListItemScrollTopActive{background-color:rgb(219,236,244);background-image:url(http://www.canvasxpress.org/images/mini-top.png);background-repeat:no-repeat;background-position:50% 50%;border:1px;border-color:rgb(170,204,246);border-style:solid;cursor:pointer;height:7px;line-height:7px;width:100%-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " li.CanvasXpressListItemScrollBottom{background-image:url(http://www.canvasxpress.org/images/mini-bottom-grey.png);background-repeat:no-repeat;background-position:50% 50%;border:0px;cursor:pointer;height:9px;line-height:9px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " li.CanvasXpressListItemScrollBottomActive{background-color:rgb(219,236,244);background-image:url(http://www.canvasxpress.org/images/mini-bottom.png);background-repeat:no-repeat;background-position:50% 50%;border:1px;border-color:rgb(170,204,246);border-style:solid;cursor:pointer;height:7px;line-height:7px;width:100%-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " a.CanvasXpressListItemA{color:rgb(34,34,34);cursor:pointer;display:block;font:normal 11px arial,tahoma,sans-serif;line-height:16px;list-style:none;outline-style:none;outline-width:0px;padding:3px 21px 3px 27px;position:relative;text-decoration:none;white-space:nowrap;}";
    a += " a.CanvasXpressListItemAArrow{background:url(http://www.canvasxpress.org/images/menu-parent.gif) no-repeat scroll right 50% transparent;color:rgb(34,34,34);cursor:pointer;display:block;font:normal 11px arial,tahoma,sans-serif;line-height:16px;list-style:none;outline-style:none;outline-width:0px;padding:3px 21px 3px 27px;position:relative;text-decoration:none;white-space:nowrap;}";
    a += " a.CanvasXpressListItemAActive{border-color:rgb(170,204,246);border-style:solid;border-width:0px 1px;color:rgb(34,34,34);cursor:pointer;display:block;font:normal 11px arial,tahoma,sans-serif;line-height:16px;list-style:none;outline-style:none;outline-width:0px;margin:0px -1px;padding:3px 21px 3px 27px;position:relative;text-decoration:none !important;white-space:nowrap;}";
    a += " a.CanvasXpressListItemAArrowActive{background:url(http://www.canvasxpress.org/images/menu-parent.gif) no-repeat scroll right 50% transparent;border-color:rgb(170,204,246);border-style:solid;border-width:0px 1px;color:rgb(34,34,34);cursor:pointer;display:block;font:normal 11px arial,tahoma,sans-serif;line-height:16px;list-style:none;margin:0px -1px;outline-style:none;outline-width:0px;padding:3px 21px 3px 27px;position:relative;text-decoration:none !important;white-space:nowrap;}";
    a += " img.CanvasXpressListIcon{background-position:center;border:0px none;color:rgb(34,34,34);cursor:pointer;font:normal 11px arial,tahoma,sans-serif;height:16px;left:3px;line-height:16px;list-style:none;margin:0px;padding:0px;position:absolute;top:3px;vertical-align:top;width:16px;white-space:nowrap;}";
    a += " span.CanvasXpressListItemText{color:rgb(34,34,34);cursor:pointer;font:normal 11px arial,tahoma,sans-serif;line-height:16px;list-style:none;margin-right:50px;white-space:nowrap;}";
    a += " span.CanvasXpressListItemTextShort{color:rgb(34,34,34);cursor:pointer;font:italic 9px arial,tahoma,sans-serif;line-height:16px;list-style:none;position:absolute;right:4px;white-space:nowrap;}";
    a += " span.CanvasXpressListItemTextSep{background-color:rgb(224,224,224);border-bottom:1px solid;border-bottom-color:rgb(255,255,255);cursor:default;display:block;font:normal 11px arial,tahoma,sans-serif;font-size:1px;line-height:1px;list-style:none;margin:2px 3px;overflow:hidden;white-space:nowrap;}";
    a += " img.CanvasXpressToolbarHelp{cursor:default;float:right;height:13px;margin-left:2px;width:13px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " div.CanvasXpressToolbarHelp{background-color:rgb(240,240,240);border-radius:5px;border:1px solid rgb(113,139,183);box-shadow:rgba(154,154,154,0.2) 3px 3px;color:rgb(34,34,34);cursor:default;font:normal 11px arial,tahoma,sans-serif;line-height:16px;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    a += " p.CanvasXpressToolbarHelp{cursor:default;font:normal 11px arial,tahoma,sans-serif;line-height:16px;margin:0px;padding:5px 5px 5px 20px;}";
    a += " img.CanvasXpressToolbarImage{margin-left:4px;float:right;}";
    a += " canvas.CanvasXpress{-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;-user-select:none;}";
    var b = document.createElement("style");
    b.type = "text/css";
    if (b.styleSheet) {
        b.styleSheet.cssText = a
    } else {
        b.appendChild(document.createTextNode(a))
    }
    document.getElementsByTagName("head")[0].appendChild(b)
};
CanvasXpress.prototype.initConfig = function(a) {
    this.setConfigDefaults = function() {
        this.config = [];
        this.graphType = "Bar";
        this.config.push("graphType");
        this.graphOrientation = "horizontal";
        this.config.push("graphOrientation");
        this.transparency = null;
        this.config.push("transparency");
        this.canvasBox = true;
        this.config.push("canvasBox");
        this.canvasBoxColor = "rgb(204,204,204)";
        this.config.push("canvasBoxColor");
        this.useFlashIE = true;
        this.config.push("useFlashIE");
        this.loadImagesTimeOut = 100;
        this.config.push("loadImagesTimeOut");
        this.functions = [];
        this.gradient = false;
        this.config.push("gradient");
        this.gradientType = "radial";
        this.config.push("gradientType");
        this.gradientOrientation = "vertical";
        this.config.push("gradientOrientation");
        this.gradientRatio = 1.3;
        this.config.push("gradientRatio");
        this.adjustAspectRatio = true;
        this.config.push("adjustAspectRatio");
        this.adjustAspectRatioMax = 3;
        this.config.push("adjustAspectRatioMax");
        this.adjustAspectRatioYTries = 0;
        this.adjustAspectRatioXTries = 0;
        this.variableSeparationFactor = 2;
        this.config.push("variableSeparationFactor");
        this.sampleSeparationFactor = 1;
        this.config.push("sampleSeparationFactor");
        this.widthFactor = 1;
        this.config.push("widthFactor");
        this.acknowledgment = false;
        this.config.push("acknowledgment");
        this.acknowledgmentIcon = "cx.png";
        this.config.push("acknowledgmentIcon");
        this.acknowledgmentIconPosition = "inside";
        this.config.push("acknowledgmentIconPosition");
        this.foreground = "rgb(0,0,0)";
        this.config.push("foreground");
        this.foregroundWindow = "rgb(0,0,0)";
        this.config.push("foregroundWindow");
        this.background = "rgb(255,255,255)";
        this.config.push("background");
        this.backgroundWindow = "rgb(244,244,244)";
        this.config.push("backgroundWindow");
        this.backgroundType = "solid";
        this.config.push("backgroundType");
        this.backgroundImage = false;
        this.config.push("backgroundImage");
        this.backgroundVideo = false;
        this.config.push("backgroundVideo");
        this.backgroundWindowGradientOrientation = "vertical";
        this.config.push("backgroundWindowGradientOrientation");
        this.backgroundGradient1Color = "rgb(0,0,200)";
        this.config.push("backgroundGradient1Color");
        this.backgroundGradient2Color = "rgb(0,0,36)";
        this.config.push("backgroundGradient2Color");
        this.backgroundWindowGradient1Color = "rgb(0,0,200)";
        this.config.push("backgroundWindowGradient1Color");
        this.backgroundWindowGradient2Color = "rgb(0,0,36)";
        this.config.push("backgroundWindowGradient2Color");
        this.margin = 5;
        this.config.push("margin");
        this.marginLeft = 20;
        this.config.push("marginLeft");
        this.marginTop = 20;
        this.config.push("marginTop");
        this.marginBottom = 20;
        this.config.push("marginBottom");
        this.marginRight = 20;
        this.config.push("marginRight");
        this.showShadow = false;
        this.config.push("showShadow");
        this.showTextShadow = false;
        this.config.push("showTextShadow");
        this.shadowOffsetX = 1;
        this.config.push("shadowOffsetX");
        this.shadowOffsetY = 1;
        this.config.push("shadowOffsetY");
        this.shadowBlur = 2;
        this.config.push("shadowBlur");
        this.shadowColor = "rgba(0,0,0,0.5)";
        this.config.push("shadowColor");
        this.videoControls = true;
        this.config.push("videoControls");
        this.videoAutoplay = true;
        this.config.push("videoAutoplay");
        this.videoLoop = false;
        this.config.push("videoLoop");
        this.videoPreload = "none";
        this.config.push("videoPreload");
        this.videoData = "{}";
        this.config.push("videoData");
        this.videoPoster = "";
        this.config.push("videoPoster");
        this.videoClassName = "video-js vjs-default-skin";
        this.config.push("videoClassName");
        this.videoPlaybackRate = 1;
        this.config.push("videoPlaybackRate");
        this.videoCurrentTime = false;
        this.config.push("videoCurrentTime");
        this.videoGrid = false;
        this.config.push("videoGrid");
        this.videoGridStep = 10;
        this.config.push("videoGridStep");
        this.videoColor = "rgb(255,0,0)";
        this.config.push("videoColor");
        this.fontName = "Verdana";
        this.config.push("fontName");
        this.fontStyle = "";
        this.config.push("fontStyle");
        this.fontSize = 12;
        this.config.push("fontSize");
        this.font = this.fontStyle + " " + this.fontSize + "pt " + this.fontName;
        this.align = "center";
        this.config.push("align");
        this.baseline = "middle";
        this.config.push("baseline");
        this.maxTextSize = 14;
        this.config.push("maxTextSize");
        this.minTextSize = 4;
        this.config.push("minTextSize");
        this.autoScaleFont = true;
        this.config.push("autoScaleFont");
        this.scaleTextConstantMult = 40;
        this.scaleTextConstantAdd = 2.5;
        this.title = false;
        this.config.push("title");
        this.titleHeight = 30;
        this.config.push("titleHeight");
        this.titleColor = "rgb(0,0,0)";
        this.config.push("titleColor");
        this.subtitle = false;
        this.config.push("subtitle");
        this.subtitleHeight = 16;
        this.config.push("subtitleHeight");
        this.subtitleColor = "rgb(0,0,0)";
        this.config.push("subtitleColor");
        this.citation = false;
        this.config.push("citation");
        this.citationColor = "rgb(0,0,0)";
        this.config.push("citationColor");
        this.citationFontStyle = "";
        this.config.push("citationFontStyle");
        this.citationFontSize = 7;
        this.config.push("citationFontSize");
        this.citationFont = this.citationFontStyle + " " + this.citationFontSize + "Pt " + this.fontName;
        this.citationScaleFontFactor = 1;
        this.config.push("citationScaleFontFactor");
        this.dashLength = 8;
        this.config.push("dashLength");
        this.dotLength = 1;
        this.config.push("dotLength");
        this.arrowPointSize = 10;
        this.config.push("arrowPointSize");
        this.capType = "butt";
        this.config.push("capType");
        this.joinType = "mitter";
        this.config.push("joinType");
        this.lineWidthEvent = 2;
        this.config.push("lineWidthEvent");
        this.outlineWidth = 1;
        this.config.push("outlineWidth");
        this.lines = [];
        this.colorScheme = "user";
        this.config.push("colorScheme");
        this.colors0 = ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(0,255,0)", "rgb(255,255,0)", "rgb(0,255,255)", "rgb(255,0,255)", "rgb(153,51,0)", "rgb(0,0,128)", "rgb(128,128,0)", "rgb(255,102,0)", "rgb(0,128,128)", "rgb(102,0,102)", "rgb(255,153,204)", "rgb(102,102,153)", "rgb(51,51,0)", "rgb(255,204,153)", "rgb(204,255,255)", "rgb(153,153,255)", "rgb(255,128,128)", "rgb(51,102,255)", "rgb(51,153,102)", "rgb(255,204,0)", "rgb(0,204,255)", "rgb(208,32,144)", "rgb(153,51,102)", "rgb(0,102,204)", "rgb(153,204,0)", "rgb(255,153,0)", "rgb(51,204,204)", "rgb(204,153,255)", "rgb(128,0,0)", "rgb(51,51,153)", "rgb(0,128,0)", "rgb(255,255,204)", "rgb(153,204,255)", "rgb(128,0,128)"];
        this.colors1 = ["rgb(0,0,255)", "rgb(255,0,77)", "rgb(255,191,0)", "rgb(116,255,0)", "rgb(164,0,255)", "rgb(255,116,0)", "rgb(255,255,0)", "rgb(0,255,255)", "rgb(255,0,0)", "rgb(255,211,0)", "rgb(61,0,255)", "rgb(0,255,0)", "rgb(255,0,255)", "rgb(255,146,0)", "rgb(211,255,0)", "rgb(0,144,255)", "rgb(109,0,255)", "rgb(255,73,0)", "rgb(255,232,0)", "rgb(0,255,146)", "rgb(255,0,144)", "rgb(255,170,0)", "rgb(170,255,0)", "rgb(0,77,255)"];
        this.colors2 = ["rgb(60,60,157)", "rgb(157,60,90)", "rgb(157,133,60)", "rgb(104,157,60)", "rgb(122,60,157)", "rgb(157,104,60)", "rgb(157,157,60)", "rgb(60,157,157)", "rgb(157,60,60)", "rgb(157,140,60)", "rgb(83,60,157)", "rgb(60,157,60)", "rgb(157,60,157)", "rgb(157,115,60)", "rgb(140,157,60)", "rgb(60,115,157)", "rgb(102,60,157)", "rgb(157,88,60)", "rgb(157,148,60)", "rgb(60,157,115)", "rgb(157,60,115)", "rgb(157,125,60)", "rgb(125,157,60)", "rgb(60,90,157)"];
        this.colors3 = ["rgb(0,0,117)", "rgb(117,0,36)", "rgb(117,88,0)", "rgb(53,117,0)", "rgb(76,0,117)", "rgb(117,53,0)", "rgb(117,117,0)", "rgb(0,117,117)", "rgb(117,0,0)", "rgb(117,97,0)", "rgb(28,0,117)", "rgb(0,117,0)", "rgb(117,0,117)", "rgb(117,67,0)", "rgb(97,117,0)", "rgb(0,66,117)", "rgb(50,0,117)", "rgb(117,33,0)", "rgb(117,107,0)", "rgb(0,117,67)", "rgb(117,0,66)", "rgb(117,78,0)", "rgb(78,117,0)", "rgb(0,36,117)"];
        this.colors4 = ["rgb(101,101,255)", "rgb(255,101,147)", "rgb(255,216,101)", "rgb(171,255,101)", "rgb(200,101,255)", "rgb(255,171,101)", "rgb(255,255,101)", "rgb(101,255,255)", "rgb(255,101,101)", "rgb(255,229,101)", "rgb(137,101,255)", "rgb(101,255,101)", "rgb(255,101,255)", "rgb(255,189,101)", "rgb(229,255,101)", "rgb(101,188,255)", "rgb(167,101,255)", "rgb(255,145,101)", "rgb(255,241,101)", "rgb(101,255,189)", "rgb(255,101,188)", "rgb(255,204,101)", "rgb(204,255,101)", "rgb(101,147,255)"];
        this.colors5 = ["rgb(181,181,255)", "rgb(255,181,203)", "rgb(255,237,181)", "rgb(215,255,181)", "rgb(229,181,255)", "rgb(255,215,181)", "rgb(255,255,181)", "rgb(181,255,255)", "rgb(255,181,181)", "rgb(255,242,181)", "rgb(199,181,255)", "rgb(181,255,181)", "rgb(255,181,255)", "rgb(255,223,181)", "rgb(242,255,181)", "rgb(181,223,255)", "rgb(213,181,255)", "rgb(255,202,181)", "rgb(255,248,181)", "rgb(181,255,223)", "rgb(255,181,223)", "rgb(255,230,181)", "rgb(230,255,181)", "rgb(181,203,255)"];
        this.colors6 = ["rgb(254,41,108)", "rgb(72,126,182)", "rgb(167,206,49)", "rgb(248,204,3)", "rgb(255,140,2)", "rgb(105,150,150)", "rgb(183,120,68)", "rgb(131,172,208)", "rgb(194,224,118)", "rgb(250,220,90)", "rgb(255,84,159)", "rgb(255,175,84)", "rgb(154,184,183)", "rgb(210,166,131)", "rgb(61,105,155)", "rgb(135,172,34)", "rgb(205,169,8)", "rgb(208,33,88)", "rgb(208,115,0)", "rgb(86,118,118)"];
        this.colors = this.colors6;
        this.config.push("colors");
        this.colorHSV = [0, 0, 1];
        this.colorRGB = [1, 1, 1];
        this.oddColor = this.background;
        this.config.push("oddColor");
        this.evenColor = "rgb(240,240,240)";
        this.config.push("evenColor");
        this.patternImages = ["patt_diag_nw_se.png", "patt_diag_sw_ne.png", "patt_hor.png", "patt_ver.png", "patt_polkadot.png", "patt_cross.png", "patt_ver_hor.png", "patt_square.png", "patt_circles.png", "patt_plus.png", "patt_squigle.png", "patt_stairs.png", "patt_art.png", "patt_cx.png"];
        this.config.push("patternImages");
        this.patternNames = ["hatchForward", "hatchReverse", "stripeHorizontal", "stripeVertical", "polkaDot", "crossHatch", "crossStripe", "squares", "circles", "plus", "squigles", "brick", "art", "cx"];
        this.config.push("patternNames");
        this.patterns = ["solid"];
        this.config.push("patterns");
        this.shapes = ["sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "pacman", "pacman2", "mdavid", "rect2", "rect3", "arc", "rectangle", "image"];
        this.config.push("shapes");
        this.sizes = [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34];
        this.config.push("sizes");
        this.images = [];
        this.config.push("images");
        this.timeFormat = "isoDate";
        this.config.push("timeFormat");
        this.maxSmpStringLen = 50;
        this.config.push("maxSmpStringLen");
        this.smpLabelDescription = false;
        this.config.push("smpLabelDescription");
        this.smpTitle = false;
        this.config.push("smpTitle");
        this.smpTitleFontStyle = "";
        this.config.push("smpTitleFontStyle");
        this.smpTitleFontSize = 10;
        this.config.push("smpTitleFontSize");
        this.smpTitleFont = this.smpTitleFontStyle + " " + this.smpTitleFontSize + "Pt " + this.fontName;
        this.smpTitleFontColor = this.foreground;
        this.config.push("smpTitleFontColor");
        this.smpTitleScaleFontFactor = 1;
        this.config.push("smpTitleScaleFontFactor");
        this.smpLabelFontStyle = "";
        this.config.push("smpLabelFontStyle");
        this.smpLabelFontSize = 10;
        this.config.push("smpLabelFontSize");
        this.smpLabelFont = this.smpLabelFontStyle + " " + this.smpLabelFontSize + "Pt " + this.fontName;
        this.smpLabelFontColor = this.foreground;
        this.config.push("smpLabelFontColor");
        this.smpLabelScaleFontFactor = 1;
        this.config.push("smpLabelScaleFontFactor");
        this.smpLabelRotate = 0;
        this.config.push("smpLabelRotate");
        this.smpLabelInterval = 1;
        this.config.push("smpLabelInterval");
        this.showSampleNames = true;
        this.config.push("showSampleNames");
        this.highlightSmp = [];
        this.config.push("highlightSmp");
        this.smpHighlightColor = "rgb(255,0,0)";
        this.config.push("smpHighlightColor");
        this.filterSmpBy = [];
        this.config.push("filterSmpBy");
        this.filterSmpByOp = [];
        this.filterSmpByValue = [];
        this.filterSmpByCase = [];
        this.filteredSmpIndices = [];
        this.maxVarStringLen = 30;
        this.config.push("maxVarStringLen");
        this.varLabelDescription = false;
        this.config.push("varLabelDescription");
        this.varTitle = false;
        this.config.push("varTitle");
        this.varTitleFontStyle = "";
        this.config.push("varTitleFontStyle");
        this.varTitleFontSize = 10;
        this.config.push("varTitleFontSize");
        this.varTitleFont = this.varTitleFontStyle + " " + this.varTitleFontSize + "Pt " + this.fontName;
        this.varTitleFontColor = this.foreground;
        this.config.push("varTitleFontColor");
        this.varTitleScaleFontFactor = 1;
        this.config.push("varTitleScaleFontFactor");
        this.varLabelFontStyle = "";
        this.config.push("varLabelFontStyle");
        this.varLabelFontSize = 10;
        this.config.push("varLabelFontSize");
        this.varLabelFont = this.varLabelFontStyle + " " + this.varLabelFontSize + "Pt " + this.fontName;
        this.varLabelFontColor = this.foreground;
        this.config.push("varLabelFontColor");
        this.varLabelScaleFontFactor = 1;
        this.config.push("varLabelScaleFontFactor");
        this.varLabelRotate = 0;
        this.config.push("varLabelRotate");
        this.varLabelInterval = 1;
        this.config.push("varLabelInterval");
        this.showVariableNames = true;
        this.config.push("showVariableNames");
        this.highlightVar = [];
        this.config.push("highlightVar");
        this.varHighlightColor = "rgb(255,0,0)";
        this.config.push("varHighlightColor");
        this.filterVarBy = [];
        this.config.push("filterVarBy");
        this.filterVarByOp = [];
        this.filterVarByValue = [];
        this.filterVarByCase = [];
        this.filteredVarIndices = [];
        this.overlaysWidth = 30;
        this.config.push("overlaysWidth");
        this.smpOverlays = [];
        this.config.push("smpOverlays");
        this.varOverlays = [];
        this.config.push("varOverlays");
        this.showOverlays = true;
        this.config.push("showOverlays");
        this.showLevelOverlays = true;
        this.config.push("showLevelOverlays");
        this.overlayFontStyle = "";
        this.config.push("overlayFontStyle");
        this.overlayFontSize = 6;
        this.config.push("overlayFontSize");
        this.overlayFont = this.overlayFontStyle + " " + this.overlayFontSize + "Pt " + this.fontName;
        this.overlayFontColor = this.foreground;
        this.config.push("overlayFontColor");
        this.overlayScaleFontFactor = 1;
        this.config.push("overlayScaleFontFactor");
        this.smpOverlayRecycleColors = false;
        this.config.push("smpOverlayRecycleColors");
        this.varOverlayRecycleColors = false;
        this.config.push("varOverlayRecycleColors");
        this.showLegend = true;
        this.config.push("showLegend");
        this.legendPosition = "right";
        this.config.push("legendPosition");
        this.legendColor = this.foreground;
        this.config.push("legendColor");
        this.legendBox = true;
        this.config.push("legendBox");
        this.legendBoxColor = "rgb(204,204,204)";
        this.config.push("legendBoxColor");
        this.legendBackgroundColor = this.background;
        this.config.push("legendBackgroundColor");
        this.legendFontStyle = "";
        this.config.push("legendFontStyle");
        this.legendFontSize = 10;
        this.config.push("legendFontSize");
        this.legendFont = this.legendFontStyle + " " + this.legendFontSize + "Pt " + this.fontName;
        this.legendScaleFontFactor = 1;
        this.config.push("legendScaleFontFactor");
        this.showIndicators = true;
        this.config.push("showIndicators");
        this.indicatorsPosition = "bottom";
        this.config.push("indicatorsPosition");
        this.showDecorations = false;
        this.config.push("showDecorations");
        this.decorationsPosition = "bottom";
        this.config.push("decorationsPosition");
        this.decorationsColor = this.foreground;
        this.config.push("decorationsColor");
        this.decorationFontStyle = "";
        this.config.push("decorationFontStyle");
        this.decorationFontSize = 10;
        this.config.push("decorationFontSize");
        this.decorationFont = this.decorationFontStyle + " " + this.decorationFontSize + "Pt " + this.fontName;
        this.decorationScaleFontFactor = 1;
        this.config.push("decorationScaleFontFactor");
        this.decorationsWidth = 10;
        this.config.push("decorationsWidth");
        this.decorationsHeight = 20;
        this.config.push("decorationsHeight");
        this.decorationsType = "bar";
        this.config.push("decorationsType");
        this.decorations = [];
        this.config.push("decorations");
        this.showDecorationsKaplanMeyerConfidence = false;
        this.config.push("showDecorationsKaplanMeyerConfidence");
        this.decorationsColors = [];
        this.config.push("decorationsColors");
        this.decorationsProperties = {};
        this.config.push("decorationsProperties");
        this.isGroupedData = false;
        this.isTransformedData = false;
        this.isBoxPlotCalc = false;
        this.isMarketDataFormated = false;
        this.isMarketSwitched = false;
        this.isGraphTime = false;
        this.config.push("isGraphTime");
        this.groupingFactors = [];
        this.segregateSamplesBy = false;
        this.config.push("segregateSamplesBy");
        this.segregateVariablesBy = false;
        this.config.push("segregateVariablesBy");
        this.isLogData = false;
        this.config.push("isLogData");
        this.smpSort = -1;
        this.varSort = -1;
        this.tmpAsciiArray = [];
        this.sortDir = "ascending";
        this.config.push("sortDir");
        this.transformBase = 2;
        this.config.push("transformBase");
        this.transformType = false;
        this.config.push("transformType");
        this.ratioReference = 0;
        this.config.push("ratioReference");
        this.zscoreAxis = "samples";
        this.config.push("zscoreAxis");
        this.showErrorBars = true;
        this.config.push("showErrorBars");
        this.showErrorBarsWidth = 2;
        this.config.push("showErrorBarsWidth");
        this.missingDataColor = "rgb(255,255,0)";
        this.config.push("missingDataColor");
        this.randomData = false;
        this.randomDataUniform = false;
        this.config.push("randomDataUniform");
        this.randomDataSymmetrical = false;
        this.config.push("randomDataSymmetrical");
        this.randomDataMissing = false;
        this.config.push("randomDataMissing");
        this.randomDataMean = 100;
        this.config.push("randomDataMean");
        this.randomDataSigma = 50;
        this.config.push("randomDataSigma");
        this.randomDataVariables = 6;
        this.config.push("randomDataVariables");
        this.randomDataSamples = 12;
        this.config.push("randomDataSamples");
        this.randomDataVariableAnnotations = 2;
        this.config.push("randomDataVariableAnnotations");
        this.randomDataSampleAnnotations = 3;
        this.config.push("randomDataSampleAnnotations");
        this.randomDataVariableAnnotationRatio = 2;
        this.config.push("randomDataVariableAnnotationRatio");
        this.randomDataSampleAnnotationRatio = 2;
        this.config.push("randomDataSampleAnnotationRatio");
        this.randomMissingDataPercentage = 0;
        this.config.push("randomMissingDataPercentage");
        this.randomNetworkReduce = true;
        this.config.push("randomNetworkReduce");
        this.randomNetworkNodes = 50;
        this.config.push("randomNetworkNodes");
        this.randomNetworkNodeEdgesMax = 5;
        this.config.push("randomNetworkNodeEdgesMax");
        this.zoom = 1;
        this.config.push("zoom");
        this.zoomGlobal = 1;
        this.zoomStep = 0.2;
        this.config.push("zoomStep");
        this.zoomVariablesDisable = false;
        this.config.push("zoomVariablesDisable");
        this.zoomSamplesDisable = false;
        this.config.push("zoomSamplesDisable");
        this.panningX = 0;
        this.config.push("panningX");
        this.panningY = 0;
        this.config.push("panningY");
        this.panningGlobalX = 0;
        this.panningGlobalY = 0;
        this.panningStep = 0.2;
        this.config.push("panningStep");
        this.distance = "euclidian";
        this.config.push("distance");
        this.linkage = "single";
        this.config.push("linkage");
        this.clusterAxis = "samples";
        this.config.push("clusterAxis");
        this.kmeansClusters = 3;
        this.config.push("kmeansClusters");
        this.maxIterations = 10;
        this.config.push("maxIterations");
        this.imputeMethod = "mean";
        this.config.push("imputeMethod");
        this.centerData = false;
        this.config.push("centerData");
        this.useSmpVarIndexOnClustering = false;
        this.config.push("useSmpVarIndexOnClustering");
        this.xAxisAbsMax = null;
        this.xAxisAbsMin = null;
        this.xAxisMaxStrLength = false;
        this.setMaxX = null;
        this.config.push("setMaxX");
        this.setMinX = null;
        this.config.push("setMinX");
        this.xAxisCurrent = 0;
        this.config.push("xAxisCurrent");
        this.xAxisTitle = false;
        this.config.push("xAxisTitle");
        this.xAxis = [];
        this.config.push("xAxis");
        this.xAxisTickStyle = "solid";
        this.config.push("xAxisTickStyle");
        this.xAxisTickFormat = false;
        this.config.push("xAxisTickFormat");
        this.xAxisTickColor = "rgb(204,204,204)";
        this.config.push("xAxisTickColor");
        this.xAxisExact = false;
        this.config.push("xAxisExact");
        this.xAxisValues = [];
        this.config.push("xAxisValues");
        this.xAxisMinorValues = [];
        this.config.push("xAxisMinorValues");
        this.xAxisTransform = false;
        this.config.push("xAxisTransform");
        this.xAxisTransformTicks = true;
        this.config.push("xAxisTransformTicks");
        this.xAxisShow = true;
        this.config.push("xAxisShow");
        this.xAxisTicks = 5;
        this.config.push("xAxisTicks");
        this.xAxisMinorTicks = true;
        this.config.push("xAxisMinorTicks");
        this.timeValues = [];
        this.config.push("timeValues");
        this.timeValueIndices = [];
        this.config.push("timeValueIndices");
        this.timeTicksFirst = false;
        this.config.push("timeTicksFirst");
        this.xAxis2AbsMax = null;
        this.xAxis2AbsMin = null;
        this.xAxis2MaxStrLength = false;
        this.setMaxX2 = null;
        this.config.push("setMaxX2");
        this.setMinX2 = null;
        this.config.push("setMinX2");
        this.xAxis2Title = false;
        this.config.push("xAxis2Title");
        this.xAxis2TickFormat = false;
        this.config.push("xAxis2TickFormat");
        this.xAxis2Exact = false;
        this.config.push("xAxis2Exact");
        this.xAxis2Values = [];
        this.config.push("xAxis2Values");
        this.xAxis2MinorValues = [];
        this.config.push("xAxis2MinorValues");
        this.xAxis2Show = true;
        this.config.push("xAxis2Show");
        this.xAxis2Ticks = null;
        this.yAxisAbsMax = null;
        this.yAxisAbsMin = null;
        this.yAxisMaxStrLength = false;
        this.setMaxY = null;
        this.config.push("setMaxY");
        this.setMinY = null;
        this.config.push("setMinY");
        this.yAxisCurrent = 0;
        this.config.push("yAxisCurrent");
        this.yAxisTitle = false;
        this.config.push("yAxisTitle");
        this.yAxis = [];
        this.config.push("yAxis");
        this.yAxisTickStyle = "solid";
        this.config.push("yAxisTickStyle");
        this.yAxisTickFormat = false;
        this.config.push("yAxisTickFormat");
        this.yAxisTickColor = "rgb(204,204,204)";
        this.config.push("yAxisTickColor");
        this.yAxisExact = false;
        this.config.push("yAxisExact");
        this.yAxisValues = [];
        this.config.push("yAxisValues");
        this.yAxisMinorValues = [];
        this.config.push("yAxisMinorValues");
        this.yAxisTransform = false;
        this.config.push("yAxisTransform");
        this.yAxisTransformTicks = true;
        this.config.push("yAxisTransformTicks");
        this.yAxisShow = true;
        this.config.push("yAxisShow");
        this.yAxisTicks = 5;
        this.config.push("yAxisTicks");
        this.yAxisMinorTicks = true;
        this.config.push("yAxisMinorTicks");
        this.zAxisAbsMax = null;
        this.zAxisAbsMin = null;
        this.zAxisMaxStrLength = false;
        this.setMaxZ = null;
        this.config.push("setMaxZ");
        this.setMinZ = null;
        this.config.push("setMinZ");
        this.zAxisCurrent = 0;
        this.config.push("zAxisCurrent");
        this.zAxisTitle = false;
        this.config.push("zAxisTitle");
        this.zAxis = [];
        this.config.push("zAxis");
        this.zAxisTickStyle = "solid";
        this.config.push("zAxisTickStyle");
        this.zAxisTickFormat = false;
        this.config.push("zAxisTickFormat");
        this.zAxisTickColor = "rgb(204,204,204)";
        this.config.push("zAxisTickColor");
        this.zAxisExact = false;
        this.config.push("zAxisExact");
        this.zAxisValues = [];
        this.config.push("zAxisValues");
        this.zAxisMinorValues = [];
        this.config.push("zAxisMinorValues");
        this.zAxisShow = true;
        this.config.push("zAxisShow");
        this.zAxisTicks = 10;
        this.rAxisAbsMax = null;
        this.rAxisAbsMin = null;
        this.rAxisMaxStrLength = false;
        this.rAxisTickColor = "rgb(0,0,0)";
        this.config.push("rAxisTickColor");
        this.rAxisValues = [];
        this.config.push("rAxisValues");
        this.rAxisMinorValues = [];
        this.config.push("rAxisMinorValues");
        this.rAxisShow = true;
        this.config.push("rAxisShow");
        this.rAxisLabelOrientation = "perpendicular";
        this.config.push("rAxisLabelOrientation");
        this.rAxisTicks = 5;
        this.config.push("rAxisTicks");
        this.axisTickColor = this.foreground;
        this.config.push("axisTickColor");
        this.axisTickFontStyle = "";
        this.config.push("axisTickFontStyle");
        this.axisTickFontSize = 10;
        this.config.push("axisTickFontSize");
        this.axisTickFont = this.axisTickFontStyle + " " + this.axisTickFontSize + "Pt " + this.fontName;
        this.axisTickScaleFontFactor = 1;
        this.config.push("axisTickScaleFontFactor");
        this.axisTitleColor = this.foreground;
        this.config.push("axisTitleColor");
        this.axisTitleFontStyle = "";
        this.config.push("axisTitleFontStyle");
        this.axisTitleFontSize = 10;
        this.config.push("axisTitleFontSize");
        this.axisTitleFont = this.axisTitleFontStyle + " " + this.axisTitleFontSize + "Pt " + this.fontName;
        this.axisTitleScaleFontFactor = 1;
        this.config.push("axisTitleScaleFontFactor");
        this.axisExtension = 0.1;
        this.config.push("axisExtension");
        this.setMax = null;
        this.setMin = null;
        this.smpHairline = false;
        this.config.push("smpHairline");
        this.smpHairlineWidth = 0.3;
        this.config.push("smpHairlineWidth");
        this.smpHairlineColor = "rgb(204,204,204)";
        this.config.push("smpHairlineColor");
        this.blockContrast = false;
        this.config.push("blockContrast");
        this.plotByVariable = false;
        this.config.push("plotByVariable");
        this.is3DPlot = false;
        this.config.push("is3DPlot");
        this.showDataValues = false;
        this.config.push("showDataValues");
        this.jitter = false;
        this.config.push("jitter");
        this.lineDecoration = "symbol";
        this.config.push("lineDecoration");
        this.coordinateLineColor = false;
        this.config.push("coordinateLineColor");
        this.lineThickness = 1;
        this.config.push("lineThickness");
        this.lineType = "rect";
        this.config.push("lineType");
        this.tension = 0.3;
        this.config.push("tension");
        this.boxPlotOutliersRatio = 8;
        this.config.push("boxPlotOutliersRatio");
        this.showBoxplotOriginalData = false;
        this.config.push("showBoxplotOriginalData");
        this.boxplotDataPointRatio = 2;
        this.config.push("boxplotDataPointRatio");
        this.boxplotDataPointTransparency = 0.5;
        this.config.push("boxplotDataPointTransparency");
        this.areaIsCumulative = false;
        this.config.push("areaIsCumulative");
        this.colorBy = false;
        this.config.push("colorBy");
        this.shapeBy = false;
        this.config.push("shapeBy");
        this.shapeByData = false;
        this.config.push("shapeByData");
        this.shapeByShape = false;
        this.config.push("shapeByShape");
        this.sizeBy = false;
        this.config.push("sizeBy");
        this.sizeByData = false;
        this.config.push("sizeByData");
        this.outlineBy = false;
        this.config.push("outlineBy");
        this.outlineByData = false;
        this.config.push("outlineByData");
        this.scatterType = false;
        this.config.push("scatterType");
        this.functionIntervals = 25;
        this.config.push("functionIntervals");
        this.selectDataMode = "area";
        this.config.push("selectDataMode");
        this.selectDataModeDescription = false;
        this.config.push("selectDataModeDescription");
        this.selectDataPoint = [];
        this.hideDataPoint = [];
        this.isSelectDataPoints = 0;
        this.isHistogram = false;
        this.config.push("isHistogram");
        this.histogramBarWidth = 0.5;
        this.config.push("histogramBarWidth");
        this.histogramBins = 20;
        this.config.push("histogramBins");
        this.isCreateHistogram = false;
        this.scatterPlotMatrix = false;
        this.config.push("scatterPlotMatrix");
        this.scatterPlotMatrixType = "both";
        this.config.push("scatterPlotMatrixType");
        this.xRotate = 45;
        this.config.push("xRotate");
        this.yRotate = 0;
        this.config.push("yRotate");
        this.zRotate = 0;
        this.config.push("zRotate");
        this.x3DRatio = 1;
        this.config.push("x3DRatio");
        this.y3DRatio = 1;
        this.config.push("y3DRatio");
        this.z3DRatio = 1;
        this.config.push("z3DRatio");
        this.bar3DInverseWeight = 1;
        this.config.push("bar3DInverseWeight");
        this.minRotate = null;
        this.config.push("minRotate");
        this.maxRotate = null;
        this.config.push("maxRotate");
        this.show3DGrid = true;
        this.config.push("show3DGrid");
        this.rotationDelay = 100;
        this.config.push("rotationDelay");
        this.rotationSensitivity = 45;
        this.config.push("rotationSensitivity");
        this.rotationStep = 2;
        this.config.push("rotationStep");
        this.cullingThreshold = 10000;
        this.config.push("cullingThreshold");
        this.indicatorCenter = "white";
        this.config.push("indicatorCenter");
        this.indicatorHeight = 8;
        this.config.push("indicatorHeight");
        this.indicatorWidth = 1;
        this.config.push("indicatorWidth");
        this.heatmapType = "blue-red";
        this.config.push("heatmapType");
        this.varIndicesStart = -1;
        this.smpIndicesStart = -1;
        this.isMultidimensionalHeatmap = false;
        this.varTitleLabelOverlayPosition = "bottom";
        this.config.push("varTitleLabelOverlayPosition");
        this.correlationAxis = "samples";
        this.config.push("correlationAxis");
        this.correlationAnchorLegend = false;
        this.config.push("correlationAnchorLegend");
        this.correlationAnchorLegendAlignWidth = 40;
        this.config.push("correlationAnchorLegendAlignWidth");
        this.correlationLabelInterval = 1;
        this.config.push("correlationLabelInterval");
        this.showSmpDendrogram = false;
        this.config.push("showSmpDendrogram");
        this.showVarDendrogram = false;
        this.config.push("showVarDendrogram");
        this.varDendrogramPosition = "top";
        this.config.push("varDendrogramPosition");
        this.smpDendrogramPosition = "left";
        this.config.push("smpDendrogramPosition");
        this.dendrogramSpace = 6;
        this.config.push("dendrogramSpace");
        this.dendrogramHang = false;
        this.config.push("dendrogramHang");
        this.dendrogramHeight = false;
        this.config.push("dendrogramHeight");
        this.dendrogramColor = "rgb(204,204,204)";
        this.config.push("dendrogramColor");
        this.vennLegendColors = false;
        this.config.push("vennLegendColors");
        this.vennGroups = 4;
        this.config.push("vennGroups");
        this.vennCompartments = ["A", "B", "AB", "C", "AC", "BC", "ABC", "D", "AD", "BD", "CD", "ABD", "ACD", "BCD", "ABCD"];
        this.vennColors = [];
        this.config.push("vennColors");
        this.pieType = "separated";
        this.config.push("pieType");
        this.pieSegmentPrecision = 0;
        this.config.push("pieSegmentPrecision");
        this.pieSegmentSeparation = 3;
        this.config.push("pieSegmentSeparation");
        this.pieSegmentLabels = "inside";
        this.config.push("pieSegmentLabels");
        this.maxPieSectors = 20;
        this.config.push("maxPieSectors");
        this.showPieGrid = true;
        this.config.push("showPieGrid");
        this.showPieValues = true;
        this.config.push("showPieValues");
        this.showPieSampleLabel = true;
        this.config.push("showPieSampleLabel");
        this.startPieSectors = 0;
        this.config.push("startPieSectors");
        this.circularCenterProportion = 0.3;
        this.config.push("circularCenterProportion");
        this.arcSegmentsSeparation = 8;
        this.config.push("arcSegmentsSeparation");
        this.ringSeparation = 9;
        this.config.push("ringSeparation");
        this.ringsType = [];
        this.config.push("ringsType");
        this.ringsWeight = [];
        this.config.push("ringsWeight");
        this.rAxis = false;
        this.config.push("rAxis");
        this.rAxisZero = false;
        this.config.push("rAxisZero");
        this.showRingLegend = true;
        this.config.push("showRingLegend");
        this.showCircularConnections = true;
        this.config.push("showCircularConnections");
        this.circularLetterSeparationFactor = 2;
        this.config.push("circularLetterSeparationFactor");
        this.circularConnectionsTransparency = 0.5;
        this.config.push("circularConnectionsTransparency");
        this.smpLabelOrientation = "perpendicular";
        this.config.push("smpLabelOrientation");
        this.showVolume = true;
        this.config.push("showVolume");
        this.stockIndicators = ["Sma5", "Sma10", "Sma25"];
        this.config.push("stockIndicators");
        this.sma5Color = "rgb(255,0,0)";
        this.config.push("sma5Color");
        this.sma10Color = "rgb(0,255,0)";
        this.config.push("sma10Color");
        this.sma20Color = "rgb(0,0,255)";
        this.config.push("sma20Color");
        this.sma25Color = "rgb(255,0,255)";
        this.config.push("sma25Color");
        this.sma50Color = "rgb(0,0,0)";
        this.config.push("sma50Color");
        this.calculateLayout = true;
        this.config.push("calculateLayout");
        this.networkFreeze = false;
        this.config.push("networkFreeze");
        this.networkFreezeOnLoad = false;
        this.config.push("networkFreezeOnLoad");
        this.networkStack = [];
        this.subNetworks = false;
        this.networkStackStates = 8;
        this.config.push("networkStackStates");
        this.networkStackIndex = 0;
        this.approximateNodePositions = false;
        this.config.push("approximateNodePositions");
        this.networkLayoutType = "forceDirected";
        this.config.push("networkLayoutType");
        this.networkForceConstant = 0;
        this.config.push("networkForceConstant");
        this.temperature = 0;
        this.config.push("temperature");
        this.initialTemperature = 0;
        this.config.push("initialTemperature");
        this.networkNodeMinDistance = 4;
        this.config.push("networkNodeMinDistance");
        this.attractiveForceFunction = "FruchtermanReingold";
        this.config.push("attractiveForceFunction");
        this.repulsiveForceFunction = "square";
        this.config.push("repulsiveForceFunction");
        this.networkRoot = false;
        this.config.push("networkRoot");
        this.showNetworkRadialLayout = false;
        this.config.push("showNetworkRadialLayout");
        this.networkDepth = 0;
        this.networkDivisions = 0;
        this.preScaleNetwork = false;
        this.config.push("preScaleNetwork");
        this.showNetworkNodesLegend = true;
        this.config.push("showNetworkNodesLegend");
        this.showNetworkEdgesLegend = true;
        this.config.push("showNetworkEdgesLegend");
        this.showNetworkTextLegend = true;
        this.config.push("showNetworkTextLegend");
        this.showNetworkDecorationsLegend = true;
        this.config.push("showNetworkDecorationsLegend");
        this.highlightNode = [];
        this.config.push("highlightNode");
        this.nodeHighlightColor = "rgb(255,0,0)";
        this.config.push("nodeHighlightColor");
        this.selectNode = {};
        this.isSelectNodes = 0;
        this.showNodeNameThreshold = 50;
        this.config.push("showNodeNameThreshold");
        this.showHiddenChildEdges = true;
        this.config.push("showHiddenChildEdges");
        this.nodeSize = this.preScaleNetwork ? 10 : 20;
        this.config.push("nodeSize");
        this.edgeWidth = 1;
        this.config.push("edgeWidth");
        this.layoutTime = 15;
        this.config.push("layoutTime");
        this.nodeFontStyle = "";
        this.config.push("nodeFontStyle");
        this.nodeFontSize = this.nodeSize;
        this.config.push("nodeFontSize");
        this.nodeFont = this.nodeFontStyle + " " + this.nodeFontSize + "Pt " + this.fontName;
        this.nodeFontColor = this.foreground;
        this.config.push("nodeFontColor");
        this.nodeScaleFontFactor = 1;
        this.config.push("nodeScaleFontFactor");
        this.colorNodeBy = false;
        this.config.push("colorNodeBy");
        this.shapeNodeBy = false;
        this.config.push("shapeNodeBy");
        this.sizeNodeBy = false;
        this.config.push("sizeNodeBy");
        this.colorEdgeBy = false;
        this.config.push("colorEdgeBy");
        this.shapeEdgeBy = false;
        this.config.push("shapeEdgeBy");
        this.sizeEdgeBy = false;
        this.config.push("sizeEdgeBy");
        this.sizeDecorationBy = false;
        this.config.push("sizeDecorationBy");
        this.is3DNetwork = false;
        this.config.push("is3DNetwork");
        this.network2DRotate = 0;
        this.skipClick = false;
        this.autoHideOnDecorationsCenter = false;
        this.config.push("autoHideOnDecorationsCenter");
        this.networkNodesOnTop = true;
        this.config.push("networkNodesOnTop");
        this.overrideEventlessNodes = false;
        this.config.push("overrideEventlessNodes");
        this.overrideAnchorNodes = false;
        this.config.push("overrideAnchorNodes");
        this.moveParentsWithChildren = false;
        this.config.push("moveParentsWithChildren");
        this.nodeConfigurableProperties = ["x", "y", "z", "parentNode", "shape", "color", "outline", "size", "width", "height", "pattern", "rotate", "outlineWidth", "imagePath", "zIndex", "eventless", "hide", "hideLabel", "anchor"];
        this.config.push("nodeConfigurableProperties");
        this.edgeConfigurableProperties = ["color", "width", "cap", "exact", "type"];
        this.config.push("edgeConfigurableProperties");
        this.filterNodeBy = [];
        this.config.push("filterNodeBy");
        this.filterNodeByOp = [];
        this.filterNodeByValue = [];
        this.filterNodeByCase = [];
        this.filterEdgeBy = [];
        this.config.push("filterEdgeBy");
        this.filterEdgeByOp = [];
        this.filterEdgeByValue = [];
        this.filterEdgeByCase = [];
        this.genomeTicks = 50;
        this.config.push("genomeTicks");
        this.trackNameFontStyle = "";
        this.config.push("trackNameFontStyle");
        this.trackNameFontSize = 10;
        this.config.push("trackNameFontSize");
        this.trackNameFont = this.trackNameFontStyle + " " + this.trackNameFontSize + "Pt " + this.fontName;
        this.trackNameFontColor = this.background;
        this.config.push("trackNameFontColor");
        this.subtracksMaxDefault = 8;
        this.config.push("subtracksMaxDefault");
        this.showFeatureNameThereshold = 20;
        this.config.push("showFeatureNameThereshold");
        this.featureNameFontStyle = "";
        this.config.push("featureNameFontStyle");
        this.featureNameFontSize = 8;
        this.config.push("featureNameFontSize");
        this.featureNameFont = this.featureNameFontStyle + " " + this.featureNameFontSize + "Pt " + this.fontName;
        this.featureNameFontColor = this.background;
        this.config.push("featureNameFontColor");
        this.maxFeatureStringLen = 50;
        this.config.push("maxFeatureStringLen");
        this.featureWidthDefault = 3;
        this.config.push("featureWidthDefault");
        this.featureHeightDefault = 14;
        this.config.push("featureHeightDefault");
        this.featureTraceHeight = 40;
        this.config.push("featureTraceHeight");
        this.featureTraceTrim = 1;
        this.config.push("featureTraceTrim");
        this.featureTracesShow = true;
        this.config.push("featureTracesShow");
        this.featureQualityHeight = 12;
        this.config.push("featureQualityHeight");
        this.featureQualityValues = false;
        this.config.push("featureQualityValues");
        this.featureQualityShow = true;
        this.config.push("featureQualityShow");
        this.featureSignalToNoiseHeight = 12;
        this.config.push("featureSignalToNoiseHeight");
        this.featureSignalToNoiseValues = false;
        this.config.push("featureSignalToNoiseValues");
        this.featureSignalToNoiseShow = true;
        this.config.push("featureSignalToNoiseShow");
        this.featureCoordinateHeight = 12;
        this.config.push("featureCoordinateHeight");
        this.featureCoordinateShow = true;
        this.config.push("featureCoordinateShow");
        this.featureTranslateHeight = 12;
        this.config.push("featureTranslateHeight");
        this.featureTranslateShow = true;
        this.config.push("featureTranslateShow");
        this.featureTypeDefault = "line";
        this.config.push("featureTypeDefault");
        this.featureStaggered = false;
        this.config.push("featureStaggered");
        this.sequenceFontStyle = "";
        this.config.push("sequenceFontStyle");
        this.sequenceFontSize = 10;
        this.config.push("sequenceFontSize");
        this.sequenceFont = this.sequenceFontStyle + " " + this.sequenceFontSize + "Pt " + this.fontName;
        this.sequenceFill = false;
        this.config.push("sequenceFill");
        this.sequenceGAPColor = "rgb(255,0,255)";
        this.config.push("sequenceGAPColor");
        this.sequenceAColor = "rgb(0,103,0)";
        this.config.push("sequenceAColor");
        this.sequenceBColor = "rgb(0,0,0)";
        this.config.push("sequenceBColor");
        this.sequenceCColor = "rgb(0,0,255)";
        this.config.push("sequenceCColor");
        this.sequenceDColor = "rgb(0,0,0)";
        this.config.push("sequenceDColor");
        this.sequenceEColor = "rgb(0,0,0)";
        this.config.push("sequenceEColor");
        this.sequenceFColor = "rgb(0,0,255)";
        this.config.push("sequenceFColor");
        this.sequenceGColor = "rgb(0,0,0)";
        this.config.push("sequenceGColor");
        this.sequenceHColor = "rgb(255,0,0)";
        this.config.push("sequenceHColor");
        this.sequenceIColor = "rgb(0,103,0)";
        this.config.push("sequenceIColor");
        this.sequenceKColor = "rgb(255,0,0)";
        this.config.push("sequenceKColor");
        this.sequenceLColor = "rgb(0,103,0)";
        this.config.push("sequenceLColor");
        this.sequenceMColor = "rgb(0,103,0)";
        this.config.push("sequenceMColor");
        this.sequenceNColor = "rgb(0,0,0)";
        this.config.push("sequenceNColor");
        this.sequencePColor = "rgb(255,165,0)";
        this.config.push("sequencePColor");
        this.sequenceQColor = "rgb(0,0,0)";
        this.config.push("sequenceQColor");
        this.sequenceRColor = "rgb(255,0,0)";
        this.config.push("sequenceRColor");
        this.sequenceSColor = "rgb(255,165,0)";
        this.config.push("sequenceSColor");
        this.sequenceTColor = "rgb(255,0,0)";
        this.config.push("sequenceTColor");
        this.sequenceUColor = "rgb(255,0,0)";
        this.config.push("sequenceUColor");
        this.sequenceVColor = "rgb(0,103,0)";
        this.config.push("sequenceVColor");
        this.sequenceWColor = "rgb(0,0,255)";
        this.config.push("sequenceWColor");
        this.sequenceXColor = "rgb(0,0,0)";
        this.config.push("sequenceXColor");
        this.sequenceYColor = "rgb(0,0,255)";
        this.config.push("sequenceYColor");
        this.sequenceZColor = "rgb(0,0,0)";
        this.config.push("sequenceZColor");
        this.sequenceStartColor = "rgb(0,204,0)";
        this.config.push("sequenceStartColor");
        this.sequenceEndColor = "rgb(255,0,0)";
        this.config.push("sequenceEndColor");
        this.wireColor = this.isVML ? "rgb(204,204,204)" : "rgba(204,204,204,0.1)";
        this.config.push("wireColor");
        this.periodTicksLabels = 5;
        this.config.push("periodTicksLabels");
        this.genomeResolution = "low";
        this.trackConfigurableProperties = ["name", "hideName", "hideFeatureNames", "type", "height", "fill", "outline", "hide", "connect", "subtracksMax", "highlight"];
        this.config.push("trackConfigurableProperties");
        this.featureConfigurableProperties = ["id", "name", "label", "hideName", "fill", "outline", "dir", "showDir", "connect", "offset", "data", "subtype", "quality", "signalToNoise", "coordinate", "sequence", "trace", "gaps", "translate", "hide", "counter"];
        this.config.push("featureConfigurableProperties");
        this.filterFeatureBy = [];
        this.config.push("filterFeatureBy");
        this.filterFeatureByOp = [];
        this.filterFeatureByValue = [];
        this.filterFeatureByCase = [];
        this.errors = [];
        this.debug = false;
        this.config.push("debug");
        this.showVersion = true;
        this.config.push("showVersion");
        this.showCode = false;
        this.config.push("showCode");
        this.codeType = "params";
        this.config.push("codeType");
        this.skin = "grey";
        this.config.push("skin");
        this.skinProperties = ["skinBackgroundColor", "skinBorderColor", "skinColor", "skinShadowColor"];
        this.skinPropertiesBlue = ["rgb(223,232,246)", "rgb(224,224,224)", "rgb(68,68,68)", "rgba(204,204,204,0.2)"];
        this.skinPropertiesGrey = ["rgb(240,240,240)", "rgb(113,139,183)", "rgb(34,34,34)", "rgba(154,154,154,0.2)"];
        this.selectedBackgroundColor = "rgb(255,0,0)";
        this.config.push("selectedBackgroundColor");
        this.disableMenu = false;
        this.config.push("disableMenu");
        this.disableToolbar = false;
        this.config.push("disableToolbar");
        this.toolbarPermanent = false;
        this.config.push("toolbarPermanent");
        this.disableDataTable = false;
        this.config.push("disableDataTable");
        this.disableDataFilters = false;
        this.config.push("disableDataFilters");
        this.disableConfigurator = false;
        this.config.push("disableConfigurator");
        this.isLayoutConfigurator = false;
        this.config.push("isLayoutConfigurator");
        this.resizable = true;
        this.config.push("resizable");
        this.showAdvancedConfiguration = false;
        this.config.push("showAdvancedConfiguration");
        this.configuratorWidth = 250;
        this.config.push("configuratorWidth");
        this.configuratorExamplesSize = 400;
        this.config.push("configuratorExamplesSize");
        this.alignConfiguratorExamples = false;
        this.config.push("alignConfiguratorExamples");
        this.showConfiguratorExamplesOnSelect = false;
        this.config.push("showConfiguratorExamplesOnSelect");
        this.dataFilterWidth = 200;
        this.config.push("dataFilterWidth");
        this.resizeWidthOnLayout = true;
        this.config.push("resizeWidthOnLayout");
        this.resizeHeightOnLayout = true;
        this.config.push("resizeHeightOnLayout");
        this.disableEvents = false;
        this.config.push("disableEvents");
        this.eventKeys = true;
        this.config.push("eventKeys");
        this.eventArrowKeys = true;
        this.config.push("eventArrowKeys");
        this.eventPlusMinusKeys = false;
        this.config.push("eventPlusMinusKeys");
        this.helpKeyEvents = true;
        this.config.push("helpKeyEvents");
        this.maintainZoomOnDrag = false;
        this.config.push("maintainZoomOnDrag");
        this.infoTimeOut = 3000;
        this.config.push("infoTimeOut");
        this.infoStartTime = new Date().getTime();
        this.infoTimeIn = 50;
        this.config.push("infoTimeIn");
        this.dataEvent = [];
        this.broadcast = true;
        this.config.push("broadcast");
        this.broadcastType = "var";
        this.config.push("broadcastType");
        this.destroyCanvasXpressZombies = true;
        this.config.push("destroyCanvasXpressZombies");
        this.monitorCanvasXpressZombiesTime = 30000;
        this.config.push("monitorCanvasXpressZombiesTime");
        this.resizerBackgroundColor = this.isIE ? "rgb(204,204,204)" : "rgba(204,204,204,0.7)";
        this.config.push("resizerBackgroundColor");
        this.resizerBackgroundColorCurrent = "rgb(237,247,255)";
        this.config.push("resizerBackgroundColorCurrent");
        this.resizerBackgroundColorOutlineCurrent = "rgb(59,138,229)";
        this.config.push("resizerBackgroundColorOutlineCurrent");
        this.resizerTransparency = true;
        this.config.push("resizerTransparency");
        this.resizerType = false;
        this.config.push("resizerType");
        this.resizerDraw = false;
        this.config.push("resizerDraw");
        this.resizerPosition = "bottom";
        this.config.push("resizerPosition");
        this.resizerWidth = 50;
        this.config.push("resizerWidth");
        this.resizerBackgroundImage = false;
        this.config.push("resizerBackgroundImage");
        this.resizerDataIndex = 0;
        this.config.push("resizerDataIndex");
        this.resizerEventData = {};
        this.showAnimation = false;
        this.config.push("showAnimation");
        this.showAnimationFontStyle = "";
        this.config.push("showAnimationFontStyle");
        this.showAnimationFontSize = 10;
        this.config.push("showAnimationFontSize");
        this.showAnimationFont = this.showAnimationFontStyle + " " + this.showAnimationFontSize + "Pt " + this.fontName;
        this.showAnimationFontColor = this.background;
        this.config.push("showAnimationFontColor");
        this.animationTime = 30;
        this.config.push("animationTime");
        this.animationType = "grow";
        this.config.push("animationType");
        this.animationCycles = 20;
        this.config.push("animationCycles");
        this.snapshotCopyChangeOnly = true;
        this.config.push("snapshotCopyChangeOnly");
        this.snapshots = [];
        this.isAnimation = false;
        this.weight = 1;
        this.scaleX = 1;
        this.scaleY = 1;
        this.translateX = 0;
        this.translateY = 0;
        this.offsetX = 0;
        this.offsetY = 0;
        this.layoutWidth = 0;
        this.layoutHeight = 0;
        this.layout = "1X1";
        this.config.push("layout");
        this.layoutComb = false;
        this.config.push("layoutComb");
        this.layoutAdjust = false;
        this.config.push("layoutAdjust");
        this.layoutCurrent = 0;
        this.layoutMaxVarLegend = 0;
        this.layoutMulticolor = true;
        this.config.push("layoutMulticolor");
        this.layoutAxis = 3;
        this.imageDir = "http://canvasxpress.org/images/";
        this.config.push("imageDir");
        this.playButton = "control_play_blue.png";
        this.config.push("playButton");
        this.stopButton = "control_stop_blue.png";
        this.config.push("stopButton");
        this.previousButton = "control_rewind_blue.png";
        this.config.push("previousButton");
        this.nextButton = "control_forward_blue.png";
        this.config.push("nextButton");
        this.dropdownButton = "menu_dropdown.png";
        this.config.push("dropdownButton");
        this.remoteService = false;
        this.config.push("remoteService");
        this.remoteParams = {};
        this.config.push("remoteParams");
        this.remoteDirection = "next";
        this.config.push("remoteDirection");
        this.remoteParentId = "";
        this.remoteDataIndex = 0;
        this.remoteIds = [];
        this.remoteWindow = 1;
        this.config.push("remoteWindow");
        this.remoteAutoPlay = false;
        this.config.push("remoteAutoPlay");
        this.remoteAutoPlayDelay = 3000;
        this.config.push("remoteAutoPlayDelay");
        this.remoteUpdating = false;
        this.remoteUpdate = false;
        this.config.push("remoteUpdate");
        this.remoteUpdateDelay = 10000;
        this.config.push("remoteUpdateDelay");
        this.skipConfigurableProperties = true;
        this.config.push("skipConfigurableProperties");
        this.nodesProperties = [];
        this.config.push("nodesProperties");
        this.edgesProperties = [];
        this.config.push("edgesProperties");
        this.featuresProperties = [];
        this.config.push("featuresProperties");
        this.filterType = "and";
        this.config.push("filterType");
        this.filterSkipNullKeys = false;
        this.config.push("filterSkipNullKeys");
        this.showDataTable = false;
        this.config.push("showDataTable");
        this.dataTableTransposed = true;
        this.config.push("dataTableTransposed");
        this.maxRows = 10;
        this.config.push("maxRows");
        this.maxCols = 6;
        this.config.push("maxCols");
        this.colWidth = 100;
        this.config.push("colWidth");
        this.rowHeight = 18;
        this.config.push("rowHeight");
        this.freezeColLeft = 0;
        this.config.push("freezeColLeft");
        this.freezeColRight = 0;
        this.config.push("freezeColRight");
        this.freezeRowTop = 0;
        this.config.push("freezeRowTop");
        this.freezeRowBottom = 0;
        this.config.push("freezeRowBottom");
        this.refresehDataTableOnDraw = false;
        this.config.push("refresehDataTableOnDraw");
        this.showDataTableOnSelect = false;
        this.config.push("showDataTableOnSelect");
        this.networkShowDataTable = "nodes";
        this.config.push("networkShowDataTable");
        this.startCol = 0;
        this.startRow = 0;
        this.dataTableColumnWidth = [];
        this.dataTableRowHeight = []
    };
    this.setInitialConfig = function() {
        if (this.userConfig) {
            for (var b in this.userConfig) {
                this[b] = this.userConfig[b]
            }
        }
    };
    this.resetConfig = function(b) {
        var d = {};
        if (b) {
            for (var c = 0; c < b.length; c++) {
                d[b[c]] = this[b[c]]
            }
        }
        this.setConfigDefaults();
        for (var c in d) {
            this[c] = d[c]
        }
    };
    this.updateConfig = function(c) {
        if (c) {
            this.userConfig = c;
            for (var b in c) {
                this[b] = c[b]
            }
        }
    };
    this.getConfig = function() {
        var d = {};
        for (var c = 0; c < this.config.length; c++) {
            var b = this.config[c];
            if (this[b] != undefined) {
                d[b] = this[b]
            }
        }
        return d
    };
    this.getUserConfig = function() {
        return this.userConfig
    };
    this.setSkin = function(c) {
        if (!c) {
            c = this.skin
        }
        for (var b = 0; b < this.skinProperties.length; b++) {
            if (c == "blue") {
                this[this.skinProperties[b]] = this.skinPropertiesBlue[b]
            } else {
                this[this.skinProperties[b]] = this.skinPropertiesGrey[b]
            }
        }
        if (c == "blue") {
            this.skinHighlight = "rgb(250,250,250)"
        } else {
            this.skinHighlight = "rgb(223,232,246)"
        }
    };
    this.setPath = function() {
        var d = document.getElementsByTagName("script");
        if (d) {
            for (var c = 0; c < d.length; c++) {
                if (!d[c].src) {
                    continue
                }
                var e = d[c].src;
                var b = e.lastIndexOf("/");
                var h = e.substring(0, b + 1);
                var g = e.substring(b + 1);
                if (g.match(/canvasXpress/)) {
                    this.path = h
                }
            }
        }
    };
    this.getNewCanvasContext = function(d) {
        var b = this.$(d);
        if (b && b.tagName.toLowerCase() == "canvas") {} else {
            b = this.$cX("canvas", {
                id: d
            });
            document.body.appendChild(b)
        } if (this.browser == "Explorer" && (this.browserVersion < 9 && navigator.userAgent.toLowerCase().indexOf("chromeframe") < 0)) {
            if (this.useFlashIE) {
                if (typeof FlashCanvas != "undefined") {
                    FlashCanvas.initElement(b)
                }
            } else {
                window.G_vmlCanvasManager.initElement(b)
            }
        }
        return b.getContext("2d")
    };
    this.setCanvas = function() {
        var f = this.$(this.target);
        if (f) {
            if (this.browser == "Explorer" && (this.browserVersion < 9 && navigator.userAgent.toLowerCase().indexOf("chromeframe") < 0)) {
                if (this.useFlashIE) {
                    this.isVML = false;
                    if (typeof FlashCanvas != "undefined") {
                        FlashCanvas.setOptions({
                            disableContextMenu: true,
                            swfPath: "http://www.canvasxpress.org/js/"
                        });
                        this.canvas = FlashCanvas.initElement(f)
                    }
                } else {
                    this.isVML = true;
                    this.canvas = window.G_vmlCanvasManager.initElement(f)
                }
            } else {
                this.isVML = false;
                this.canvas = f
            }
            this.ctx = this.canvas.getContext("2d");
            if ((this.backgroundType == "video" || this.graphType == "Video") && this.backgroundVideo) {
                if (this.graphType == "Video") {
                    this.backgroundType = "video"
                }
                this.isVideo = true;
                var e = this.$cX("script", {
                    type: "text/javascript",
                    src: "http://vjs.zencdn.net/c/video.js"
                });
                var d = this.$cX("link", {
                    type: "text/css",
                    rel: "stylesheet",
                    href: "http://vjs.zencdn.net/c/video-js.css"
                });
                var b = document.getElementsByTagName("head")[0];
                b.appendChild(d);
                b.appendChild(e);
                this.background = "rgba(255,255,255,0)";
                this.legendBackgroundColor = "rgba(255,255,255,0)";
                this.disableToolbar = true
            } else {
                this.isVideo = false
            }
        }
    };
    this.inititalizeConfig = function() {
        this.setConfigDefaults();
        if (a) {
            if (a.graphType == "Network") {
                if (!a.backgroundType) {
                    this.backgroundType = "gradient";
                    this.nodeFontColor = this.background
                }
            }
            for (var b = 0; b < this.config.length; b++) {
                var c = this.config[b];
                if (a.hasOwnProperty(c)) {
                    this[c] = a[c]
                }
            }
        }
        if (this.isVML) {
            this.showAnimation = false
        }
        this.setSkin();
        this.setPath();
        this.setCanvas()
    };
    this.inititalizeConfig()
};
CanvasXpress.prototype.initColor = function() {
    this.validateColor = function(b, a) {
        b = b.toString();
        if (b.match(/^rgba?\((\d{1,3},\d{1,3},\d{1,3})(?:,([0-9\.]+))?/i)) {
            if (RegExp.$2) {
                b = "rgba(" + RegExp.$1 + "," + RegExp.$2 + ")"
            } else {
                b = "rgb(" + RegExp.$1 + ")"
            }
        } else {
            if (b.match(/^#?[0-9abcdef]/i)) {
                b = this.hexToRgb(b)
            } else {
                b = false
            }
        }
        return b && a != null ? this.addColorTransparency(b, a) : b
    };
    this.darkenLightenColor = function(j, e) {
        j = this.rgbToHex(j).substring(1, 7);
        var i = parseInt(j, 16);
        var h = (i >> 16) + e;
        h = h > 255 ? 255 : h < 0 ? 0 : h;
        var f = ((i >> 8) & 255) + e;
        f = f > 255 ? 255 : f < 0 ? 0 : f;
        var d = (i & 255) + e;
        d = d > 255 ? 255 : d < 0 ? 0 : d;
        j = d | (f << 8) | (h << 16);
        return this.hexToRgb(j.toString(16))
    };
    this.rgbToHex = function(b) {
        var a = function(c) {
            c = parseInt(c, 10);
            if (isNaN(c)) {
                return "00"
            }
            c = Math.max(0, Math.min(c, 255));
            return "0123456789ABCDEF".charAt((c - c % 16) / 16) + "0123456789ABCDEF".charAt(c % 16)
        };
        if (b && b.substr(0, 1) === "#") {
            return b
        }
        if (b && b.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/)) {
            return "#" + a(RegExp.$1) + a(RegExp.$2) + a(RegExp.$3)
        } else {
            return b
        }
    };
    this.hexToRgb = function(c) {
        var b = function() {
            return parseInt(c.substring(0, 2), 16)
        };
        var a = function() {
            return parseInt(c.substring(2, 4), 16)
        };
        var d = function() {
            return parseInt(c.substring(4, 6), 16)
        };
        c = c.charAt(0) == "#" ? c.substring(1, 7) : c;
        return "rgb(" + b() + "," + a() + "," + d() + ")"
    };
    this.addColorTransparency = function(b, a) {
        if (b && b.match(/^rgba?\((\d{1,3},\d{1,3},\d{1,3})(?:,([0-9\.]+))?/i)) {
            if (RegExp.$2) {
                return "rgba(" + RegExp.$1 + "," + a + ")"
            } else {
                return "rgba(" + RegExp.$1 + "," + a + ")"
            }
        } else {
            return false
        }
    };
    this.disableGradientTransparencyShadow = function() {
        this.gradientTemp = this.gradient;
        this.transparencyTemp = this.transparency;
        this.showShadowTemp = this.showShadow;
        this.gradient = false;
        this.transparency = null;
        this.showShadow = false
    };
    this.enableGradientTransparencyShadow = function() {
        this.gradient = this.gradientTemp;
        this.transparency = this.transparencyTemp;
        this.showShadow = this.showShadowTemp
    };
    this.getGradientColor = function(h) {
        if (h.match(/^rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(?:,([0-9\.]+))?/i)) {
            var f = Math.floor(parseInt(RegExp.$1) / this.gradientRatio);
            var e = Math.floor(parseInt(RegExp.$2) / this.gradientRatio);
            var a = Math.floor(parseInt(RegExp.$3) / this.gradientRatio);
            var d = RegExp.$4 ? parseFloat(RegExp.$4) : false;
            if (d) {
                return "rgba(" + f + "," + e + "," + a + "," + d + ")"
            } else {
                return "rgb(" + f + "," + e + "," + a + ")"
            }
        } else {
            return false
        }
    };
    this.setGradient = function(e, d, c, b, a) {
        if (this.gradientType == "radial") {
            this.setRadialGradient(e, d, c, b, false, false, true)
        } else {
            this.setLinearGradient(e, d, c, b, a, false, true)
        }
    };
    this.setLinearGradient = function(c, i, a, f, e, b, d) {
        if (!d) {
            this.ctx.save()
        }
        var h = this.ctx.createLinearGradient(c, i, a, f);
        if (!b) {
            b = this.getGradientColor(e);
            h.addColorStop(0, b);
            h.addColorStop(0.6, e);
            h.addColorStop(1, e)
        } else {
            h.addColorStop(0, e);
            h.addColorStop(1, b)
        }
        this.ctx.fillStyle = h
    };
    this.setRadialGradient = function(j, h, a, e, d, c, i) {
        if (!i) {
            this.ctx.save()
        }
        var b = a / 5.5;
        var f = this.ctx.createRadialGradient(j - b, h - b, 1, j, h, a);
        if (!d) {
            if (this.transparency != null) {
                d = "rgba(0,0,0," + this.transparency + ")"
            } else {
                d = "rgb(0,0,0)"
            }
        }
        if (!c) {
            c = "rgba(0,0,0,0)"
        }
        f.addColorStop(0, e);
        f.addColorStop(1, d);
        f.addColorStop(1, c);
        this.ctx.fillStyle = f
    }
};
CanvasXpress.prototype.initText = function() {
    this.setTextShadow = function(a) {
        if (this.showTextShadow) {
            if (a) {
                this.ctx.shadowOffsetX = this.shadowOffsetX;
                this.ctx.shadowOffsetY = this.shadowOffsetY;
                this.ctx.shadowBlur = this.shadowBlur;
                this.ctx.shadowColor = this.shadowColor
            } else {
                this.ctx.shadowOffsetX = 0;
                this.ctx.shadowOffsetY = 0;
                this.ctx.shadowBlur = 0;
                this.ctx.shadowColor = this.background
            }
        }
    };
    this.drawTextMultiple = function(v, u, p, n, o, r, q, d, e, w) {
        var h = v.split(/\n/);
        if (!n) {
            n = this.font
        }
        var k = this.getFontPt(n) + 4;
        if (h.length % 2) {
            p -= (parseInt(h.length / 2) * k) + (k / 2)
        } else {
            p = (p - parseInt(h.length / 2) * k)
        }
        for (var j = 0; j < h.length; j++) {
            this.drawText(h[j], u, p, n, o, r, q, d, e, w);
            p += k
        }
    };
    this.drawArcText = function(C, B, z, d, D, u, p, v, k, w, g, j) {
        var q = [];
        if (C == null) {
            return
        }
        if (!this.ctx) {
            if (this.debug) {
                alert("Dude, there is no canvas")
            }
            return
        }
        if (isNaN(B) || isNaN(z)) {
            if (this.debug) {
                alert("Not a valid coordinate (" + B + ", " + z + ") to draw " + C)
            }
            return
        }
        if (!j && !isNaN(C)) {
            C = this.formatNumber(C)
        }
        if (!B) {
            B = 0
        }
        if (!z) {
            z = 0
        }
        if (!p) {
            p = this.font
        }
        if (!v) {
            v = this.foreground
        }
        if (!k) {
            k = this.align
        }
        if (!w) {
            w = this.baseline
        }
        this.ctx.save();
        this.ctx.strokeStyle = v;
        this.ctx.fillStyle = v;
        this.ctx.font = p;
        this.ctx.textAlign = k;
        this.ctx.textBaseline = w;
        this.setTextShadow(true);
        var o = u / (C.length * this.circularLetterSeparationFactor);
        var A = D + (u / 2) + (o / 2) - (o * (C.length / 2));
        this.ctx.translate(B, z);
        this.ctx.rotate(A);
        for (var n = 0; n < C.length; n++) {
            this.ctx.save();
            this.ctx.rotate((n * o) + (Math.PI / 2));
            this.ctx.fillText(C[n], 0, -d);
            this.ctx.restore()
        }
        this.ctx.restore();
        this.setTextShadow(false);
        return q
    };
    this.drawText = function(o, l, k, z, B, D, C, g, q, p, i) {
        var j = 0;
        var r = function(c) {
            c.shift();
            var f = [];
            var m = (Math.PI / 2) + g == 0 ? -Math.PI / 2 : g - Math.PI / 2;
            var b = ["poly"];
            var t = c.shift() - l;
            var h = c.shift() - k;
            var a = c.shift() - l;
            var s = c.shift() - k;
            f.push((h * Math.sin(m)) - (t * Math.cos(m)));
            f.push((h * Math.cos(m)) + (t * Math.sin(m)));
            f.push((s * Math.sin(m)) - (t * Math.cos(m)));
            f.push((s * Math.cos(m)) + (t * Math.sin(m)));
            f.push((s * Math.sin(m)) - (a * Math.cos(m)));
            f.push((s * Math.cos(m)) + (a * Math.sin(m)));
            f.push((h * Math.sin(m)) - (a * Math.cos(m)));
            f.push((h * Math.cos(m)) + (a * Math.sin(m)));
            while (f.length > 1) {
                b.push(f.shift() + l);
                b.push(f.shift() + k)
            }
            return b
        };
        var E = [];
        if (o == null) {
            return
        }
        if (this.isMultipleLines(o)) {
            return this.drawTextMultiple(o, l, k, z, B, D, C, g, q, p)
        }
        if (!this.ctx) {
            if (this.debug) {
                alert("Dude, there is no canvas")
            }
            return
        }
        if (isNaN(l) || isNaN(k)) {
            if (this.debug) {
                alert("Not a valid coordinate (" + l + ", " + k + ") to draw " + o)
            }
            return
        }
        if (g < (Math.PI / -2) || g > (Math.PI / 2)) {
            if (this.debug) {
                alert("Dude, you can only rotate between -PI/2 and PI/2")
            }
            return
        }
        if (!l) {
            l = 0
        }
        if (!k) {
            k = 0
        }
        if (!z) {
            z = this.font
        }
        if (!B) {
            B = this.foreground
        }
        if (!D) {
            D = this.align
        }
        if (!C) {
            C = this.baseline
        }
        var n = this.measureText(o, z);
        var u = this.getFontPt(z);
        if (q) {
            while (n > q && j < 10) {
                o = o.substring(0, o.length - 1);
                n = this.measureText(o, z);
                j++
            }
        }
        var A, e, v, d;
        if (D == "left") {
            A = l;
            v = A + n
        } else {
            if (D == "right") {
                A = l - n;
                v = l
            } else {
                A = l - (n / 2);
                v = l + (n / 2)
            }
        } if (C == "top") {
            e = k;
            d = e + u
        } else {
            if (C == "bottom") {
                e = k - u;
                d = k
            } else {
                e = k - (u / 2);
                d = k + (u / 2)
            }
        }
        E = ["rect", A, e, v, d];
        if (g) {
            E = r(E)
        }
        this.ctx.save();
        this.ctx.strokeStyle = B;
        this.ctx.fillStyle = B;
        this.ctx.font = z;
        this.ctx.save();
        this.ctx.translate(l, k);
        this.ctx.textAlign = D;
        this.ctx.textBaseline = C;
        this.setTextShadow(true);
        if (g) {
            this.ctx.rotate(g)
        }
        if (p) {
            this.ctx.strokeText(o, 0, 0)
        } else {
            this.ctx.fillText(o, 0, 0)
        }
        this.ctx.restore();
        this.setTextShadow(false);
        return E
    };
    this.isMultipleLines = function(b) {
        var a = b.toString().split(/\n/);
        return a.length - 1
    };
    this.capitalize = function(a) {
        if (a) {
            return a.charAt(0).toUpperCase() + a.slice(1)
        }
    };
    this.measureTextMultiple = function(d, e) {
        var b = d.split(/\n/);
        var a = 0;
        if (!this.ctx) {
            return 0
        }
        if (!e) {
            e = this.font
        }
        this.ctx.font = e;
        for (var c = 0; c < b.length; c++) {
            a = Math.max(a, this.ctx.measureText(b[c]).width)
        }
        return a
    };
    this.measureText = function(a, b) {
        if (!a || !this.ctx) {
            return 0
        }
        a = a.toString();
        if (!b) {
            b = this.font
        }
        if (!CanvasXpress.cacheText[b]) {
            CanvasXpress.cacheText[b] = {}
        }
        if (!CanvasXpress.cacheText[b][a]) {
            this.ctx.font = b;
            if (this.isMultipleLines(a)) {
                CanvasXpress.cacheText[b][a] = this.measureTextMultiple(a, b)
            } else {
                CanvasXpress.cacheText[b][a] = this.ctx.measureText(a).width
            }
        }
        return CanvasXpress.cacheText[b][a]
    };
    this.scaleTextToFont = function(b, d, a) {
        var c = this.fontStyle + " " + d + "pt " + this.fontName;
        if (b) {
            while (this.measureText(b, c) > a && d >= this.minTextSize) {
                d -= 2;
                c = this.fontStyle + " " + d + "pt " + this.fontName
            }
        }
        return c
    };
    this.getFontPt = function(a) {
        return Math.max(1, parseInt(a.match(/[\-\d]+/)[0]))
    };
    this.scaleTextToSize = function(a) {
        var d = this.scaleTextConstantMult;
        if (!a) {
            a = 1
        }
        return Math.ceil(1 / Math.sqrt(a) * d)
    };
    this.formatNumber = function(g, c) {
        if (!c) {
            c = 2
        }
        if (g.toString().length >= 7) {
            var b = sprintf("%." + c + "e", Number(g));
            var a = sprintf("%." + c + "f", Number(g));
            if (a.toString().length > b.toString().length) {
                return b.toString()
            } else {
                return a.toString()
            }
        } else {
            return g.toString()
        }
    };
    this.bestFormatNumber = function(b, a) {
        if (typeof b === "number" && b % 1 == 0) {
            return b
        } else {
            if (a != null && a < 1) {
                return sprintf("%.0f", Number(b))
            } else {
                if (Math.abs(b) < 0.001) {
                    return sprintf("%.2e", Number(b))
                } else {
                    return sprintf("%.3f", Number(b))
                }
            }
        }
    };
    this.getMaxText = function(d) {
        var f = "";
        var b = 0;
        for (var e = 0; e < d.length; e++) {
            var g = this.measureText(d[e].toString(), this.font);
            if (g > b) {
                f = d[e].toString();
                b = g
            }
        }
        return f
    };
    this.shortenText = function(c, b, a) {
        if (!c) {
            return ""
        }
        c = c.toString();
        if (a && c.length > b) {
            return c.substring(0, Math.max(parseInt(a / b) - 2, 1)) + ".."
        } else {
            if (c.length <= b) {
                return c
            } else {
                return c.substring(0, b - 3) + "..."
            }
        }
    };
    this.convertToNumber = function(a) {
        if (!isNaN(a)) {
            return parseFloat(a)
        } else {
            return a
        }
    }
};
CanvasXpress.prototype.initTime = function() {
    Date.prototype.getWeek = function() {
        var a = new Date(this.getFullYear(), 0, 1);
        return Math.ceil((((this - a) / 86400000) + a.getDay() + 1) / 7)
    };
    Date.prototype.getDayYear = function() {
        var a = new Date(this.getFullYear(), 0, 1);
        return Math.ceil((this - a) / 86400000)
    };
    this.getMillisecond = function(a) {
        return a.getMilliseconds()
    };
    this.getSecond = function(a) {
        return a.getSeconds()
    };
    this.getMinuteSecond = function(a) {
        return a.getMinutes() + ":" + a.getSeconds()
    };
    this.getMinute = function(a) {
        return a.getMinutes()
    };
    this.getHourMinute = function(a) {
        return a.getHours() + ":" + a.getMinutes()
    };
    this.getHour = function(a) {
        return a.getHours()
    };
    this.getYearWeek = function(a) {
        return a.getFullYear() + "-" + a.getWeek()
    };
    this.getYearMonth = function(a) {
        return a.getFullYear() + "-" + a.getMonth()
    };
    this.getYear = function(a) {
        return a.getFullYear()
    };
    this.times = {
        second: 1000,
        minute: 60000,
        hour: 3600000,
        day: 86400000,
        week: 604800000,
        month: 2592000000,
        year: 31556952000
    };
    this.parseDate = function(j) {
        var f = 0;
        var c = 0;
        var e = 0;
        var k = parseInt(j.toString().substring(0, 4));
        var a = parseInt(j.toString().substring(4, 6).replace(/^0/, ""));
        var g = parseInt(j.toString().substring(6, 8).replace(/^0/, ""));
        var b = j.toString().match(/\:/) ? j.toString().substring(10).split(":") : false;
        if (b) {
            f = b[0] ? parseInt(b[0].replace(/^0/, "")) : 0;
            c = b[1] ? parseInt(b[1].replace(/^0/, "")) : 0;
            e = b[2] ? parseInt(b[2].replace(/^0/, "")) : 0
        }
        return new Date(k, a - 1, g, f, c, e)
    };
    this.setTimeAxis = function() {
        var h = this.validateTimeAxis();
        if (h) {
            var g = Date.parse(h[h.length - 1]) - Date.parse(h[0]);
            var d;
            var b = {};
            var c = [];
            this.timeValues = [];
            this.timeValueIndices = [];
            if (g > this.times.year * 2) {
                d = "getYear"
            } else {
                if (g > this.times.month * 2) {
                    d = "getYearMonth"
                } else {
                    if (g > this.times.week * 2) {
                        d = "getYearWeek"
                    } else {
                        if (g < this.times.second) {
                            d = "getMillisecond"
                        } else {
                            if (g < this.times.minute) {
                                d = "getSecond"
                            } else {
                                if (g < this.times.hour / 4) {
                                    d = "getMinuteSecond"
                                } else {
                                    if (g < this.times.hour) {
                                        d = "getMinute"
                                    } else {
                                        if (g < this.times.day / 4) {
                                            d = "getHourMinute"
                                        } else {
                                            if (g < this.times.day) {
                                                d = "getHour"
                                            } else {
                                                d = false
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } if (d) {
                if (this.timeTicksFirst) {
                    for (var a = 0; a < h.length; a++) {
                        var e = this[d](h[a]);
                        if (!b.hasOwnProperty(e)) {
                            c.push(h[a]);
                            this.timeValueIndices.push(a);
                            b[e] = true
                        }
                    }
                } else {
                    for (var a = h.length - 1; a >= 0; a--) {
                        var e = this[d](h[a]);
                        if (!b.hasOwnProperty(e)) {
                            c.unshift(h[a]);
                            this.timeValueIndices.unshift(a);
                            b[e] = true
                        }
                    }
                }
            } else {
                for (var a = 0; a < h.length; a++) {
                    this.timeValues.push(dateFormat(h[a], this.timeFormat));
                    this.timeValueIndices.push(a)
                }
            }
            var g = Date.parse(c[c.length - 1]) - Date.parse(c[c.length - 2]);
            if (d == "getYear" && g < this.times.month * 3) {
                this.timeValues.pop();
                this.timeValueIndices.pop()
            } else {
                if (d == "getYearMonth" && g < this.times.week * 4) {
                    this.timeValues.pop();
                    this.timeValueIndices.pop()
                } else {
                    if (d == "getYearWeek" && g < this.times.day * 7) {
                        this.timeValues.pop();
                        this.timeValueIndices.pop()
                    }
                }
            }
            for (var a = 0; a < c.length; a++) {
                this.timeValues.push(dateFormat(c[a], this.timeFormat))
            }
        }
    };
    this.createRandomTimes = function(b) {
        var e;
        var g = new Date();
        var a = g.getTime();
        var f = [new Date(a)];
        var h = this.isGroupedData ? this.data.w : this.data.y;
        if (!b || !this.times[b]) {
            b = "day"
        }
        for (var c = 0; c < h.smps.length; c++) {
            e = Date.parse(h.smps[c]);
            if (!isNaN(e)) {
                a = e
            } else {
                a -= this.times[b]
            }
            f.unshift(new Date(a))
        }
        return f
    };
    this.validateTimeAxis = function() {
        var f = this.isGroupedData ? this.data.w : this.data.y;
        var a = false;
        var e = [];
        for (var b = 0; b < this.smpIndices.length; b++) {
            var c = this.smpIndices.length != f.smps.length ? Date.parse(f.smps[this.smpIndices[b]]) : Date.parse(f.smps[b]);
            if (isNaN(c)) {
                if (this.isExample) {
                    e = this.createRandomTimes();
                    return e
                } else {
                    a = true;
                    break
                }
            } else {
                e.push(new Date(c))
            }
        }
        return a ? false : e
    }
};
CanvasXpress.prototype.initAttributes = function() {
    this.setShadow = function(a) {
        if (this.showShadow) {
            if (a) {
                this.ctx.shadowOffsetX = this.shadowOffsetX;
                this.ctx.shadowOffsetY = this.shadowOffsetY;
                this.ctx.shadowBlur = this.shadowBlur;
                this.ctx.shadowColor = this.shadowColor
            } else {
                this.ctx.shadowOffsetX = 0;
                this.ctx.shadowOffsetY = 0;
                this.ctx.shadowBlur = 0;
                this.ctx.shadowColor = this.background
            }
        }
    };
    this.validateNumbers = function(b) {
        for (var c = 0; c < b.length; c++) {
            if (isNaN(b[c])) {
                return false
            }
        }
        return true
    };
    this.lineTo = function(b, d, a, c) {
        if (b == a) {
            b = (((b + 0.5) << 1) >> 1) + 0.5;
            a = b
        } else {
            if (d == c) {
                d = (((d + 0.5) << 1) >> 1) + 0.5;
                c = d
            }
        }
        this.ctx.moveTo(b, d);
        this.ctx.lineTo(a, c);
        this.ctx.stroke()
    };
    this.clip = function(q, f, i) {
        var d, c, n, k, g, m, q;
        var o, e, a, j;
        var p = [];
        if (i && i.length == 4) {
            e = i[0];
            o = i[1];
            a = e + i[2];
            j = o + i[3]
        } else {
            e = this.marginLeft + this.offsetX + this.left;
            o = this.marginTop + this.offsetY + this.top;
            a = e + this.x;
            j = o + this.y
        } if (q == "rect") {
            d = this.parseInt(f[0]);
            n = this.parseInt(f[1]);
            c = this.parseInt(d + f[2]);
            k = this.parseInt(n + f[3]);
            if (c > d) {
                if (k > n) {
                    if (d > a + this.outlineWidth || n > j + this.outlineWidth || c < e || k < o) {
                        return false
                    }
                    if (d < e) {
                        d = e
                    }
                    if (c > a) {
                        c = a
                    }
                    if (n < o) {
                        n = o
                    }
                    if (k > j) {
                        k = j
                    }
                } else {
                    if (d > a + this.outlineWidth || k > j + this.outlineWidth || c < e || n < o) {
                        return false
                    }
                    if (d < e) {
                        d = e
                    }
                    if (c > a) {
                        c = a
                    }
                    if (n > j) {
                        n = j
                    }
                    if (k < o) {
                        k = o
                    }
                }
            } else {
                if (k > n) {
                    if (c > a + this.outlineWidth || n > j + this.outlineWidth || d < e || k < o) {
                        return false
                    }
                    if (d > a) {
                        d = a
                    }
                    if (c < e) {
                        c = e
                    }
                    if (n < o) {
                        n = o
                    }
                    if (k > j) {
                        k = j
                    }
                } else {
                    if (c > a + this.outlineWidth || k > j + this.outlineWidth || d < e || n < o) {
                        return false
                    }
                    if (d > a) {
                        d = a
                    }
                    if (c < e) {
                        c = e
                    }
                    if (n > j) {
                        n = j
                    }
                    if (k < o) {
                        k = o
                    }
                }
            }
            p = [d, n, c - d, k - n]
        } else {
            if (q == "poly") {} else {
                if (q == "circle") {
                    d = parseInt(f[0]);
                    n = parseInt(f[1]);
                    if (d > a || d < e || n < o || n > j) {
                        return false
                    }
                    p = [d, n]
                } else {
                    if (q == "line") {
                        d = parseFloat(f[0]);
                        n = parseFloat(f[1]);
                        c = parseFloat(f[2]);
                        k = parseFloat(f[3]);
                        if (d == c) {
                            if (d < e || d > a) {
                                return false
                            } else {
                                if (n > k) {
                                    if (n < o) {
                                        return false
                                    } else {
                                        if (n > j) {
                                            n = j
                                        }
                                    } if (k > j) {
                                        return false
                                    } else {
                                        if (k < o) {
                                            k = o
                                        }
                                    }
                                } else {
                                    if (n > j) {
                                        return false
                                    } else {
                                        if (n < o) {
                                            n = o
                                        }
                                    } if (k < o) {
                                        return false
                                    } else {
                                        if (k > j) {
                                            k = j
                                        }
                                    }
                                }
                            }
                        } else {
                            if (n == k) {
                                if (n < o || n > j) {
                                    return false
                                } else {
                                    if (d > c) {
                                        if (d < e) {
                                            return false
                                        } else {
                                            if (d > a) {
                                                d = a
                                            }
                                        } if (c > a) {
                                            return false
                                        } else {
                                            if (c < e) {
                                                c = e
                                            }
                                        }
                                    } else {
                                        if (d > a) {
                                            return false
                                        } else {
                                            if (d < e) {
                                                d = e
                                            }
                                        } if (c < e) {
                                            return false
                                        } else {
                                            if (c > a) {
                                                c = a
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (d > c) {
                                    if (d < e || c > a) {
                                        return false
                                    } else {
                                        if (n > k) {
                                            if (n < o || k > j) {
                                                return false
                                            } else {
                                                g = n - k;
                                                m = d - c;
                                                if (d > a) {
                                                    n -= (d - a) * g / m;
                                                    d = a
                                                }
                                                if (n > j) {
                                                    d -= (n - j) * m / g;
                                                    n = j
                                                }
                                                if (c < e) {
                                                    k += (e - c) * g / m;
                                                    c = e
                                                }
                                                if (k < o) {
                                                    c += (o - k) * m / g;
                                                    k = o
                                                }
                                            }
                                        } else {
                                            if (k < o || n > j) {
                                                return false
                                            } else {
                                                g = k - n;
                                                m = d - c;
                                                if (d > a) {
                                                    n += (d - a) * g / m;
                                                    d = a
                                                }
                                                if (n < o) {
                                                    d -= (o - n) * m / g;
                                                    n = o
                                                }
                                                if (c < e) {
                                                    k -= (e - c) * g / m;
                                                    c = e
                                                }
                                                if (k > j) {
                                                    c += (k - j) * m / g;
                                                    k = j
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (c < e || d > a) {
                                        return false
                                    } else {
                                        if (n > k) {
                                            if (n < o || k > j) {
                                                return false
                                            } else {
                                                g = n - k;
                                                m = c - d;
                                                if (d < e) {
                                                    n -= (e - d) * g / m;
                                                    d = e
                                                }
                                                if (n > j) {
                                                    d += (n - j) * m / g;
                                                    n = j
                                                }
                                                if (c > a) {
                                                    k += (c - a) * g / m;
                                                    c = a
                                                }
                                                if (k < o) {
                                                    c -= (o - k) * m / g;
                                                    k = o
                                                }
                                            }
                                        } else {
                                            if (k < o || n > j) {
                                                return false
                                            } else {
                                                g = k - n;
                                                m = c - d;
                                                if (d < e) {
                                                    n += (e - d) * g / m;
                                                    d = e
                                                }
                                                if (n < o) {
                                                    d += (o - n) * m / g;
                                                    n = o
                                                }
                                                if (c > a) {
                                                    k -= (c - a) * g / m;
                                                    c = a
                                                }
                                                if (k > j) {
                                                    c -= (k - j) * m / g;
                                                    k = j
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        p = [d, n, c, k]
                    } else {
                        return false
                    }
                }
            }
        }
        return p
    };
    this.lineLength = function(b, d, a, c) {
        return Math.sqrt(Math.pow(a - b, 2) + Math.pow(c - d, 2))
    };
    this.shortenLine = function(b, j, a, i, k, f, l) {
        if (this.validateNumbers([b, j, a, i, k, f])) {
            if (l.match(/bezier/i)) {
                if (l.match(/beziery/i)) {
                    return i > j ? [b, j + k, a, i - f] : [b, j - k, a, i + f]
                } else {
                    return a > b ? [b + k, j, a - f, i] : [b - k, j, a + f, i]
                }
            } else {
                if (l.match(/curved/i)) {
                    return [b, j, a, i]
                } else {
                    var c = Math.atan2(i - j, a - b);
                    var d = Math.cos(c);
                    var h = Math.sin(c);
                    var g = this.lineLength(b, j, a, i);
                    if (g) {
                        while (g < (k + f)) {
                            k /= 1.1;
                            f /= 1.1
                        }
                        b += d * k;
                        j += h * k;
                        a -= d * f;
                        i -= h * f
                    }
                }
            }
            return [b, j, a, i]
        }
    };
    this.errorBar = function(e, g, d, f, a, h) {
        if (!this.isGroupedData && this.isRawData) {}
        if (this.showErrorBars && this.validateNumbers([a])) {
            var b = this.drawLine("line", e, g, d, f, h, false, false, false, false, true);
            if (Math.abs(a) > this.showErrorBarsWidth) {
                if (a > 0) {
                    this.drawLine("line", d, f - a / 2, d, f + a / 2, h, false, false, false, false, true)
                } else {
                    this.drawLine("line", d - a / 2, f, d + a / 2, f, h, false, false, false, false, true)
                }
            }
            return b
        }
    };
    this.splineControlPoint = function(e, m, d, l, c, k) {
        var n = Math.sqrt(Math.pow(d - e, 2) + Math.pow(l - m, 2));
        var h = Math.sqrt(Math.pow(c - d, 2) + Math.pow(k - l, 2));
        var g = this.tension * n / (n + h);
        var f = this.tension - g;
        var b = d + g * (e - c);
        var a = l + g * (m - k);
        var j = d - f * (e - c);
        var i = l - f * (m - k);
        return [b, a, j, i]
    };
    this.drawLine = function(Z, G, a, D, at, am, Y, ad, ab, ao, ap, ar) {
        var S = this;
        var ag;
        var N = [];
        var U = false;
        var z = false;
        var v = false;
        var ah = this.lineWidthEvent;
        var T = function() {
            S.ctx.save();
            if (S.transparency != null) {
                if (am) {
                    am = S.validateColor(am, S.transparency) || S.addColorTransparency(S.foreground, S.transparency)
                } else {
                    am = S.addColorTransparency(S.foreground, S.transparency)
                }
            } else {
                if (am) {
                    am = S.validateColor(am) || S.foreground
                } else {
                    am = S.foreground
                }
            }
            S.ctx.fillStyle = am;
            S.ctx.strokeStyle = am;
            S.ctx.lineWidth = Y ? Y : S.outlineWidth;
            S.ctx.lineCap = ad ? ad : S.capType;
            S.setShadow(true)
        };
        var I = function() {
            S.setShadow(false);
            S.ctx.restore()
        };
        var h = function() {
            var b;
            b = G;
            G = D;
            D = b;
            b = a;
            a = at;
            at = b
        };
        var H = function(t, f) {
            var aC = function(aI, aL, aw, aM) {
                var aH = [];
                for (var aJ = 0; aJ < aI.length; aJ++) {
                    aH.push([(aI[aJ][0] * Math.cos(aL)) - (aI[aJ][1] * Math.sin(aL)), (aI[aJ][0] * Math.sin(aL)) + (aI[aJ][1] * Math.cos(aL))])
                }
                var aK = [];
                for (var aJ = 0; aJ < aH.length; aJ++) {
                    aK.push([aH[aJ][0] + aw, aH[aJ][1] + aM])
                }
                return aK
            };
            var ay = S.arrowPointSize;
            var c = Math.max((ay / 2) - 1, 1);
            var av = Y ? Y / 2 : S.outlineWidth / 2;
            var ax = t ? [
                [0, -ay],
                [0, ay]
            ] : [
                [Math.floor((ay / 2.5)), 0],
                [-ay, -c * Y],
                [-ay, c * Y]
            ];
            var au = D - G;
            var w = at - a;
            if (z) {
                if (z == "Y") {
                    if (Math.abs(w) > Math.abs(au)) {
                        au = 0
                    } else {
                        au = D > G ? S.arrowPointSize : -S.arrowPointSize
                    }
                } else {
                    if (Math.abs(au) > Math.abs(w)) {
                        w = 0
                    } else {
                        w = at > a ? S.arrowPointSize : -S.arrowPointSize
                    }
                }
            } else {
                if (v) {
                    var x = S.lineLength(G, a, D, at);
                    var aE = S.shortenLine(G, a, D, at, 0, x / 2, "line");
                    var y = aE[2];
                    var aD = aE[3];
                    var az = x / 2;
                    var e = v / az;
                    var aA = D > G ? Math.asin((aD - a) / az) : Math.asin(-(aD - a) / az);
                    var b = f ? aA + (Math.PI / 20) : aA - (Math.PI / 20);
                    var aG = G;
                    var aF = D;
                    var s = a;
                    var n = at;
                    if (D > G) {
                        G = y + az * Math.cos(b - e);
                        a = aD + az * Math.sin(b - e);
                        D = y + az * Math.cos(aA - e);
                        at = aD + az * Math.sin(aA - e)
                    } else {
                        G = y + az * Math.cos((b - e) + Math.PI);
                        a = aD + az * Math.sin((b - e) + Math.PI);
                        D = y + az * Math.cos((aA - e) + Math.PI);
                        at = aD + az * Math.sin((aA - e) + Math.PI)
                    }
                    au = D - G;
                    w = at - a
                }
            }
            var p = aC(ax, Math.atan2(w, au), D, at);
            T();
            S.ctx.beginPath();
            S.ctx.moveTo(p[0][0], p[0][1]);
            for (var aB = 1; aB < p.length; aB++) {
                if (!isNaN(p[aB][0]) && !isNaN(p[aB][1])) {
                    S.ctx.lineTo(p[aB][0], p[aB][1])
                }
            }
            if (!t) {
                if (!isNaN(p[0][0]) && !isNaN(p[0][1])) {
                    S.ctx.lineTo(p[0][0], p[0][1])
                }
                S.ctx.closePath();
                S.ctx.fill()
            } else {
                S.ctx.closePath();
                S.ctx.stroke()
            }
            I();
            if (v) {
                G = aG;
                D = aF;
                a = s;
                at = n
            }
        };
        if (Z == "spline") {
            if (G.length < 3) {
                return false
            }
            var aa = [];
            var aq = [];
            var ac = [];
            var af = 0;
            N = ["poly"];
            for (var ak = 0; ak < G.length; ak++) {
                if (this.validateNumbers([G[ak], a[ak]])) {
                    aq.push(G[ak], a[ak]);
                    N.push(G[ak], a[ak] - 2);
                    ac.push(a[ak] + 2, G[ak]);
                    af += 2
                } else {
                    return false
                }
            }
            N = N.concat(ac.reverse());
            T();
            for (var ak = 0; ak < af - 4; ak += 2) {
                aa = aa.concat(this.splineControlPoint(aq[ak], aq[ak + 1], aq[ak + 2], aq[ak + 3], aq[ak + 4], aq[ak + 5]))
            }
            this.ctx.beginPath();
            this.ctx.moveTo(aq[0], aq[1]);
            this.ctx.quadraticCurveTo(aa[0], aa[1], aq[2], aq[3]);
            for (var ak = 2; ak < af - 5; ak += 2) {
                this.ctx.bezierCurveTo(aa[2 * ak - 2], aa[2 * ak - 1], aa[2 * ak], aa[2 * ak + 1], aq[ak + 2], aq[ak + 3])
            }
            this.ctx.moveTo(aq[af - 2], aq[af - 1]);
            this.ctx.quadraticCurveTo(aa[2 * af - 10], aa[2 * af - 9], aq[af - 4], aq[af - 3]);
            this.ctx.stroke();
            I();
            return N
        } else {
            if (Z == "arch") {
                if (G.length != 3 || a.length != 3) {
                    return false
                }
                for (var ak = 0; ak < G.length; ak++) {
                    if (!this.validateNumbers([G[ak], a[ak]])) {
                        return false
                    }
                }
                N = ["poly"];
                T();
                this.ctx.beginPath();
                this.ctx.moveTo(G[0], a[0]);
                this.ctx.quadraticCurveTo(G[1], a[1], G[2], a[2]);
                this.ctx.stroke();
                I()
            } else {
                if (this.validateNumbers([G, a, D, at])) {
                    if (!ab) {
                        ab = 0
                    }
                    if (!ao) {
                        ao = 0
                    }
                    if (Z.match(/bezier/i)) {
                        if (Z.match(/beziery/i)) {
                            ag = "bezierLine";
                            z = "Y";
                            U = "Y";
                            if (ab || ao) {
                                if (at > a) {
                                    if (a + ab > at - ao) {
                                        Z = Z.replace(/beziery/i, "");
                                        ag = "line";
                                        z = false;
                                        U = false
                                    }
                                } else {
                                    if (a - ab < at + ao) {
                                        Z = Z.replace(/beziery/i, "");
                                        ag = "line";
                                        z = false;
                                        U = false
                                    }
                                }
                            }
                        } else {
                            ag = "bezierLine";
                            z = "X";
                            U = "X";
                            if (ab || ao) {
                                if (D > G) {
                                    if (G + ab > D - ao) {
                                        Z = Z.replace(/bezier[x]?/i, "");
                                        ag = "line";
                                        z = false;
                                        U = false
                                    }
                                } else {
                                    if (G - ab < D + ao) {
                                        Z = Z.replace(/bezier[x]?/i, "");
                                        ag = "line";
                                        z = false;
                                        U = false
                                    }
                                }
                            }
                        }
                    } else {
                        if (Z.match(/curved/i)) {
                            if (Z.match(/curvedc/i)) {
                                ag = "curvedLine";
                                v = true;
                                U = true
                            } else {
                                ag = "curvedLine";
                                v = true;
                                U = false
                            }
                        } else {
                            if (Z.match(/dashed/i)) {
                                ag = "dashedLine"
                            } else {
                                if (Z.match(/dotted/i)) {
                                    ag = "dottedLine"
                                } else {
                                    ag = "line"
                                }
                            }
                        }
                    } if ((ab || ao)) {
                        var ae = this.shortenLine(G, a, D, at, ab, ao, Z);
                        G = ae[0];
                        a = ae[1];
                        D = ae[2];
                        at = ae[3]
                    }
                    if (ap) {
                        var L = this.clip("line", [G, a, D, at], ar);
                        if (L) {
                            G = L[0];
                            a = L[1];
                            D = L[2];
                            at = L[3]
                        } else {
                            return false
                        }
                    }
                    switch (ag) {
                        case "dashedLine":
                        case "dottedLine":
                            var l = Math.atan2(at - a, D - G);
                            var R = Math.cos(l);
                            var J = Math.sin(l);
                            var M = this.lineLength(G, a, D, at);
                            var q = ag == "dashedLine" ? this.dashLength : this.dotLength;
                            var aj = Math.floor(M / (q * 2)) - 1;
                            if (aj) {
                                var W = R * q;
                                var V = J * q;
                                var g = G;
                                var an = a;
                                var d = D;
                                var al = at;
                                d = g + W;
                                al = an + V;
                                for (var ak = 0; ak < aj; ak++) {
                                    this.drawLine("line", g, an, d, al, am, Y, ad);
                                    g += (W * 2);
                                    an += (V * 2);
                                    d = g + W;
                                    al = an + V
                                }
                                this.drawLine("line", g, an, d, al, am, Y, ad);
                                N = ["poly", G + ah, a, D + ah, at, D - ah, at, G - ah, a]
                            } else {
                                return false
                            }
                            break;
                        case "bezierLine":
                            if (G == D || a == at) {
                                return this.drawLine("line", G, a, D, at, am, Y, ad, ab, ao, ap, ar)
                            }
                            G = parseInt(G) + 0.5;
                            a = parseInt(a) + 0.5;
                            D = parseInt(D) + 0.5;
                            at = parseInt(at) + 0.5;
                            U = U == "Y" ? "Y" : "X";
                            var P = D > G ? true : false;
                            var o = (G + D) / 2;
                            var m = (a + at) / 2;
                            if (P) {
                                if (U == "X") {
                                    N = ["poly", G, a - 2, o + 2, a - 2, o + 2, at - 2, D, at - 2, D, at + 2, o - 2, at + 2, o - 2, a + 2, G, a + 2]
                                } else {
                                    N = ["poly", G - 2, a, G - 2, m + 2, D - 2, m + 2, D - 2, at, D + 2, at, D + 2, m - 2, G + 2, m - 2, G + 2, a]
                                }
                            } else {
                                if (U == "X") {
                                    N = ["poly", G, a - 2, o - 2, a - 2, o - 2, at - 2, D, at - 2, D, at + 2, o + 2, at + 2, o + 2, a + 2, G, a + 2]
                                } else {
                                    N = ["poly", G - 2, a, G - 2, m - 2, D - 2, m - 2, D - 2, at, D + 2, at, D + 2, m + 2, G + 2, m + 2, G + 2, a]
                                }
                            }
                            T();
                            this.ctx.moveTo(G, a);
                            if (U == "Y") {
                                this.ctx.bezierCurveTo(G, at, D, a, D, at)
                            } else {
                                this.ctx.bezierCurveTo(D, a, G, at, D, at)
                            }
                            this.ctx.stroke();
                            I();
                            break;
                        case "curvedLine":
                            var o = 12;
                            var u = 1;
                            var M = this.lineLength(G, a, D, at);
                            var F = this.shortenLine(G, a, D, at, 0, M / 2, "line");
                            var Q = F[2];
                            var E = F[3];
                            var X = M / 2;
                            var O = ab / X;
                            var K = ao / X;
                            var k = (Q - G);
                            var j = (E - a);
                            var C = U && G > D ? false : !U && D >= G ? true : U;
                            var r = D >= G ? Math.asin(j / X) : Math.asin(-j / X);
                            var ai = r + Math.PI;
                            var B = Math.PI / o;
                            var A = D >= G ? 0 : Math.PI;
                            N = ["poly"];
                            for (var ak = u; ak <= o - u; ak++) {
                                N.push(Q - (X + 2) * Math.cos(r + ((B * ak)) - A));
                                N.push(E - (X + 2) * Math.sin(r + ((B * ak)) - A))
                            }
                            for (var ak = o - u; ak >= u; ak--) {
                                N.push(Q - (X - 2) * Math.cos(r + ((B * ak)) - A));
                                N.push(E - (X - 2) * Math.sin(r + ((B * ak)) - A))
                            }
                            T();
                            this.ctx.beginPath();
                            if (D >= G) {
                                this.ctx.arc(Q, E, X, r - K, ai + O, C)
                            } else {
                                this.ctx.arc(Q, E, X, r + O, ai - K, C)
                            }
                            this.ctx.stroke();
                            I();
                            break;
                        case "line":
                            N = ["poly", G + ah, a, D + ah, at, D - ah, at, G - ah, a];
                            T();
                            this.ctx.beginPath();
                            this.lineTo(G, a, D, at);
                            I();
                            break
                    }
                    if (Z.match(/arrowheadsquaretail|squaretailarrowhead/i)) {
                        v = v ? ao : false;
                        H();
                        h();
                        if (Z.match(/curve/i)) {
                            v = -ab
                        }
                        H(true)
                    } else {
                        if (Z.match(/arrowtailsquarehead|squareheadarrowtail/i)) {
                            v = v ? ao : false;
                            H(true);
                            h();
                            if (Z.match(/curve/i)) {
                                v = -ab
                            }
                            H(false, true)
                        } else {
                            if (Z.match(/arrowhead/i)) {
                                v = v ? ao : false;
                                H()
                            } else {
                                if (Z.match(/squarehead/i)) {
                                    v = v ? ao : false;
                                    H(true)
                                } else {
                                    if (Z.match(/arrowtail/i)) {
                                        h();
                                        if (Z.match(/curve/i)) {
                                            v = -ab
                                        }
                                        H(false, true)
                                    } else {
                                        if (Z.match(/squaretail/i)) {
                                            h();
                                            if (Z.match(/curve/i)) {
                                                v = -ab
                                            }
                                            H(true, true)
                                        } else {
                                            if (Z.match(/arrow/i)) {
                                                v = v ? ao : false;
                                                H();
                                                h();
                                                if (Z.match(/curve/i)) {
                                                    v = -ab
                                                }
                                                H(false, true)
                                            } else {
                                                if (Z.match(/square/i)) {
                                                    v = v ? ao : false;
                                                    H(true);
                                                    h();
                                                    if (Z.match(/curve/i)) {
                                                        v = -ab
                                                    }
                                                    H(true, true)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return N
                } else {
                    return false
                }
            }
        }
    };
    this.polygon = function(l, k, g, e, d, a, i, h, j) {
        return this.drawShape("polygon", l, k, false, false, g, e, d, a, i, h, j)
    };
    this.circle = function(n, m, q, g, i, e, d, a, k, j, l) {
        return this.drawShape("circle", n, m, q, g, i, e, d, a, k, j, l)
    };
    this.rectangle = function(n, m, q, g, i, e, d, a, k, j, l) {
        return this.drawShape("rectangle", n + (q / 2), m + (g / 2), q, g, i, e, d, a, k, j, l)
    };
    this.roundRectangle = function(n, m, q, g, i, e, d, a, k, j, l) {
        return this.drawShape("roundrect", n + (q / 2), m + (g / 2), q, g, i, e, d, a, k, j, l)
    };
    this.rectangleHM = function(n, m, q, g, i, e, d, a, k, j, l) {
        return this.drawShape("rectangleHM", n + (q / 2), m + (g / 2), q, g, i, e, d, a, k, j, l)
    };
    this.drawShape = function(P, L, K, N, ac, ad, W, V, R, J, aj, al, Q, ag, O, ai) {
        var I = this;
        var T = function() {
            I.ctx.save();
            I.ctx.translate(L, K);
            if (R) {
                I.ctx.rotate(R)
            }
            if (I.transparency != null) {
                if (ad) {
                    ad = I.validateColor(ad, I.transparency) || I.addColorTransparency(I.foreground, I.transparency)
                } else {
                    ad = I.addColorTransparency(I.foreground, I.transparency)
                }
            } else {
                if (ad) {
                    ad = I.validateColor(ad) || I.foreground
                } else {
                    ad = I.foreground
                }
            } if (I.gradient) {
                if (I.gradientType == "radial") {
                    I.setGradient(0, 0, Math.max(Math.abs(N), Math.abs(ac)), ad)
                } else {
                    I.setGradient(0, 0, N, ac, ad)
                }
            } else {
                if (V && !V.match(/closed|solid|open/)) {
                    I.ctx.fillStyle = CanvasXpress.cachePatterns[V]
                } else {
                    I.ctx.fillStyle = ad
                }
            } if (W) {
                W = I.validateColor(W) || I.foreground
            }
            I.ctx.strokeStyle = W ? W : I.foreground;
            I.ctx.lineWidth = J ? J : I.outlineWidth;
            I.ctx.lineJoin = I.joinType;
            I.setShadow(true)
        };
        var aq = function(f, d, o) {
            if (P == "image") {} else {
                if (P == "rectangleHM") {
                    if (f) {
                        f[0][0] = Math.round(f[0][0]) + 0.5;
                        f[3][0] = f[0][0];
                        f[1][0] = Math.round(f[1][0]) + 1.5;
                        f[2][0] = f[1][0];
                        f[0][1] = Math.round(f[0][1]) + 0.5;
                        f[1][1] = f[0][1];
                        f[2][1] = Math.round(f[2][1]) + 1.5;
                        f[3][1] = f[2][1];
                        I.ctx.beginPath();
                        I.ctx.moveTo(f[0][0], f[0][1]);
                        for (var e = 1; e < f.length; e++) {
                            I.ctx.lineTo(f[e][0], f[e][1])
                        }
                        if (!d) {
                            I.ctx.closePath()
                        }
                        if (V && V == "open") {
                            I.ctx.stroke()
                        } else {
                            I.ctx.stroke();
                            I.ctx.fill()
                        }
                    }
                } else {
                    if (P == "arch") {
                        I.ctx.beginPath();
                        I.ctx.moveTo(f[0][0], f[0][1]);
                        I.ctx.quadraticCurveTo(f[1][0], f[1][1], f[2][0], f[2][1]);
                        I.ctx.arc(0, 0, ac, N[3], N[2], true);
                        I.ctx.quadraticCurveTo(f[4][0], f[4][1], f[5][0], f[5][1]);
                        I.ctx.arc(0, 0, ac, N[1], N[0], true);
                        I.ctx.closePath();
                        if (V && V == "open") {
                            I.ctx.stroke()
                        } else {
                            I.ctx.stroke();
                            I.ctx.fill()
                        }
                    } else {
                        if (P == "spline") {
                            var h = [];
                            var c = [];
                            var b = [];
                            c.push(o.shift());
                            c.push(o.shift());
                            b.push(o.pop());
                            b.unshift(o.pop());
                            var p = o.length;
                            for (var e = 0; e < p - 4; e += 2) {
                                h = h.concat(I.splineControlPoint(o[e], o[e + 1], o[e + 2], o[e + 3], o[e + 4], o[e + 5]))
                            }
                            I.ctx.beginPath();
                            I.ctx.moveTo(c[0], c[1]);
                            I.ctx.lineTo(o[0], o[1]);
                            I.ctx.quadraticCurveTo(h[0], h[1], o[2], o[3]);
                            for (var e = 2; e < p - 5; e += 2) {
                                I.ctx.bezierCurveTo(h[2 * e - 2], h[2 * e - 1], h[2 * e], h[2 * e + 1], o[e + 2], o[e + 3])
                            }
                            I.ctx.quadraticCurveTo(h[2 * p - 10], h[2 * p - 9], o[p - 2], o[p - 1]);
                            I.ctx.lineTo(b[0], b[1]);
                            I.ctx.lineTo(c[0], c[1]);
                            if (V && V == "open") {
                                I.ctx.stroke()
                            } else {
                                I.ctx.stroke();
                                I.ctx.fill()
                            }
                        } else {
                            if (P == "arc3") {
                                I.ctx.stroke()
                            } else {
                                if (f) {
                                    I.ctx.beginPath();
                                    I.ctx.moveTo(f[0][0] + 0.5, f[0][1] + 0.5);
                                    for (var e = 1; e < f.length; e++) {
                                        I.ctx.lineTo(f[e][0] + 0.5, f[e][1] + 0.5)
                                    }
                                    if (!d) {
                                        I.ctx.closePath()
                                    }
                                }
                                if (V && V == "open") {
                                    I.ctx.stroke()
                                } else {
                                    I.ctx.stroke();
                                    I.ctx.fill()
                                }
                            }
                        }
                    }
                }
            }
            I.setShadow(false);
            I.ctx.restore()
        };
        var ae = function(p) {
            if (p) {
                if (p[0] == "circle") {
                    return p
                }
                var e = p.shift();
                var i = [];
                if (e == "rect") {
                    var o = p.shift() - L;
                    var r = p.shift() - K;
                    var d = p.shift() - L;
                    var f = p.shift() - K;
                    i.push((r * Math.sin(R)) - (o * Math.cos(R)));
                    i.push((r * Math.cos(R)) + (o * Math.sin(R)));
                    i.push((f * Math.sin(R)) - (o * Math.cos(R)));
                    i.push((f * Math.cos(R)) + (o * Math.sin(R)));
                    i.push((f * Math.sin(R)) - (d * Math.cos(R)));
                    i.push((f * Math.cos(R)) + (d * Math.sin(R)));
                    i.push((r * Math.sin(R)) - (d * Math.cos(R)));
                    i.push((r * Math.cos(R)) + (d * Math.sin(R)))
                } else {
                    while (p.length > 1) {
                        var h = p.shift() - L;
                        var b = p.shift() - K;
                        i.push((b * Math.sin(R)) - (h * Math.cos(R)));
                        i.push((b * Math.cos(R)) + (h * Math.sin(R)))
                    }
                }
                var c = ["poly"];
                while (i.length > 1) {
                    c.push(i.shift() + L);
                    c.push(i.shift() + K)
                }
                return c
            }
        };
        var G, H;
        if (V && !V.match(/closed|solid|open/)) {
            var an = V;
            V = "closed";
            this.drawShape(P, L, K, N, ac, ad, W, V, R, J, aj, al, Q, ag, O, ai);
            V = an
        }
        if (P == "polygon" || P == "path" || P == "spline" || P == "arch") {
            var Z = Number.MAX_VALUE;
            var E = Number.MAX_VALUE * -1;
            var Y = Number.MAX_VALUE;
            var D = Number.MAX_VALUE * -1;
            var F = P == "polygon" ? false : true;
            var U = [];
            var ak = [];
            G = [];
            H = ["poly"];
            if (L.length == K.length) {
                if (P == "spline" && L.length < 5) {
                    return false
                }
                if (P == "arch" && (L.length != 6 || K.length != 6 || N.length != 4 || ac == null)) {
                    return false
                }
                for (var ab = 0; ab < L.length; ab++) {
                    if (this.validateNumbers([L[ab], K[ab]])) {
                        Z = Math.min(Z, L[ab]);
                        E = Math.max(E, L[ab]);
                        Y = Math.min(Y, K[ab]);
                        D = Math.max(D, K[ab]);
                        G.push([L[ab], K[ab]]);
                        if (P == "spline") {
                            H.push(L[ab], K[ab] - 2);
                            U.push(K[ab] + 2, L[ab])
                        } else {
                            H.push(L[ab], K[ab])
                        }
                    } else {
                        return false
                    }
                }
                L = P == "arch" ? L[1] : (Z + E) / 2;
                K = P == "arch" ? K[1] : (Y + D) / 2;
                for (var ab = 0; ab < G.length; ab++) {
                    G[ab][0] -= L;
                    G[ab][1] -= K;
                    ak.push(G[ab][0], G[ab][1])
                }
                if (R) {
                    H = ae(H)
                }
                if (G) {
                    if (P == "spline") {
                        H = H.concat(U.reverse())
                    }
                    T(F);
                    aq(G, F, ak);
                    return H
                } else {
                    return false
                }
            } else {
                return false
            }
        } else {
            if (this.validateNumbers([L, K, N, ac])) {
                if (aj) {
                    G = P.match(/rectangle/) ? this.clip("rect", [L - (N / 2), K - (ac / 2), N, ac], al) : this.clip("circle", [L, K], al);
                    if (G) {
                        if (P.match(/rectangle/)) {
                            N = G[2];
                            ac = G[3];
                            L = G[0] + (N / 2);
                            K = G[1] + (ac / 2)
                        } else {
                            L = G[0];
                            K = G[1]
                        }
                    } else {
                        return false
                    }
                }
                var j = N / 2;
                var am = ac / 2;
                var S = ac / N;
                var X = 1.5;
                var H = ["rect", L - j, K - am, L + j, K + am];
                switch (P) {
                    case "image":
                        G = false;
                        if (O) {
                            this.ctx.save();
                            this.ctx.translate(L, K);
                            if (R) {
                                this.ctx.rotate(R)
                            }
                            this.drawImage(CanvasXpress.cacheImages[O], -j * this.zoom, -am * this.zoom, N * this.zoom, ac * this.zoom, O);
                            H = ["rect", L - (j * this.zoom), K - (am * this.zoom), L + (j * this.zoom), K + (am * this.zoom)];
                            this.ctx.restore()
                        }
                        break;
                    case "circle":
                    case "sphere":
                        H = ["circle", L, K, N / 2];
                        G = false;
                        T();
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, N / 2, 0, Math.PI * 2, true);
                        this.ctx.closePath();
                        aq();
                        break;
                    case "box":
                    case "rect":
                    case "rectangle":
                    case "rectangleHM":
                        G = [
                            [-j, -am],
                            [j, -am],
                            [j, am],
                            [-j, am]
                        ];
                        break;
                    case "rect2":
                        return this.drawShape("rectangle", L, K, N, N / 2, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "rect3":
                        return this.drawShape("rectangle", L, K, N, N / 3, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "roundrect":
                        var M = N > ac ? ac / 4 : N / 4;
                        G = false;
                        T();
                        this.ctx.beginPath();
                        this.ctx.moveTo(-j, -am + M);
                        this.ctx.lineTo(-j, am - M);
                        this.ctx.quadraticCurveTo(-j, am, -j + M, am);
                        this.ctx.lineTo(j - M, am);
                        this.ctx.quadraticCurveTo(j, am, j, am - M);
                        this.ctx.lineTo(j, -am + M);
                        this.ctx.quadraticCurveTo(j, -am, j - M, -am);
                        this.ctx.lineTo(-j + M, -am);
                        this.ctx.quadraticCurveTo(-j, -am, -j, -am + M);
                        this.ctx.closePath();
                        aq();
                        break;
                    case "square":
                        G = [
                            [-j, -j],
                            [j, -j],
                            [j, j],
                            [-j, j]
                        ];
                        break;
                    case "triangle":
                        if (N == ac) {
                            return this.drawShape("equilateral", L, K, N, ac, ad, W, V, R, J, aj, al, Q, ag, O, ai)
                        }
                        H = ["poly", L, K - am, L + j, K + am, L - j, K + am];
                        G = [
                            [0, -am],
                            [j, am],
                            [-j, am]
                        ];
                        break;
                    case "triangle2":
                        if (N == ac) {
                            return this.drawShape("equilateral2", L, K, N, ac, ad, W, V, R, J, aj, al, Q, ag, O, ai)
                        }
                        H = ["poly", L, K + am, L + j, K - am, L - j, K - am];
                        G = [
                            [0, am],
                            [j, -am],
                            [-j, -am]
                        ];
                        break;
                    case "equilateral":
                        var M = N * Math.sqrt(3) / 6;
                        var g = M / 2;
                        var v = Math.sqrt((M * M) - (g * g));
                        H = ["poly", L, K - M, L + v, K + g, L - v, K + g];
                        G = [
                            [0, -am],
                            [j, am],
                            [-j, am]
                        ];
                        break;
                    case "equilateral2":
                        var M = N * Math.sqrt(3) / 6;
                        var g = M / 2;
                        var v = Math.sqrt((M * M) - (g * g));
                        H = ["poly", L, K + M, L + v, K - g, L - v, K - g];
                        G = [
                            [0, am],
                            [j, -am],
                            [-j, -am]
                        ];
                        break;
                    case "diamond":
                    case "rhombus":
                        H = ["poly", L, K - am, L + j, K, L, K + am, L - j, K];
                        G = [
                            [0, -am],
                            [j, 0],
                            [0, am],
                            [-j, 0]
                        ];
                        break;
                    case "hexagon":
                        var ah = N / 3;
                        var l = ah - j;
                        G = [
                            [l, -am],
                            [-l, -am],
                            [j, 0],
                            [-l, am],
                            [l, am],
                            [-j, 0]
                        ];
                        break;
                    case "octagon":
                        var ao = N / 4;
                        var aa = ac / 4;
                        G = [
                            [-ao, -am],
                            [ao, -am],
                            [j, -aa],
                            [j, aa],
                            [ao, am],
                            [-ao, am],
                            [-j, aa],
                            [-j, -aa]
                        ];
                        break;
                    case "oval":
                        G = false;
                        T();
                        this.ctx.scale(1, S);
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, N / 2, 0, Math.PI * 2, true);
                        this.ctx.closePath();
                        aq();
                        break;
                    case "oval2":
                        return this.drawShape("oval", L, K, N, N / 2, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "oval3":
                        return this.drawShape("oval", L, K, N, N / 3, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "arc":
                        G = false;
                        T();
                        this.ctx.scale(1, S);
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, N / 2, 0, Math.PI, true);
                        if (V != "open") {
                            this.ctx.closePath()
                        }
                        aq();
                        break;
                    case "arc2":
                        G = false;
                        var B = ac * Math.cos(Q);
                        var ar = ac * Math.sin(Q);
                        var A = ac * Math.cos(ag);
                        var ap = ac * Math.sin(ag);
                        var q = this.shortenLine(0, 0, B, ar, 0, N, "line");
                        var m = this.shortenLine(0, 0, A, ap, 0, N, "line");
                        T();
                        this.ctx.beginPath();
                        this.ctx.moveTo(q[2], q[3]);
                        this.ctx.lineTo(B, ar);
                        this.ctx.arc(0, 0, ac, Q, ag, false);
                        this.ctx.lineTo(m[2], m[3]);
                        this.ctx.arc(0, 0, ac - N, ag, Q, true);
                        this.ctx.closePath();
                        aq();
                        break;
                    case "arc3":
                        G = false;
                        T();
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, N / 2, Q, ag, false);
                        aq();
                        break;
                    case "ellipse":
                        var a = j * 0.5522848;
                        var af = am * 0.5522848;
                        G = false;
                        T();
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, am);
                        this.ctx.bezierCurveTo(0, am - af, j - a, 0, j, 0);
                        this.ctx.bezierCurveTo(j + a, 0, N, am - af, N, am);
                        this.ctx.bezierCurveTo(N, am + af, j + a, ac, j, ac);
                        this.ctx.bezierCurveTo(j - a, ac, 0, am + af, 0, am);
                        this.ctx.closePath();
                        aq();
                        break;
                    case "ellipse2":
                        return this.drawShape("ellipse", L, K, N, N / 2, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "ellipse3":
                        return this.drawShape("ellipse", L, K, N, N / 3, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "plus":
                        G = [
                            [-X, -am],
                            [X, -am],
                            [X, -X],
                            [j, -X],
                            [j, X],
                            [X, X],
                            [X, am],
                            [-X, am],
                            [-X, X],
                            [-j, X],
                            [-j, -X],
                            [-X, -X],
                            [-X, -am]
                        ];
                        break;
                    case "minus":
                        G = [
                            [-j, -X],
                            [j, -X],
                            [j, X],
                            [-j, X],
                            [-j, -X]
                        ];
                        break;
                    case "mdavid":
                        var ah = N / 3;
                        var n = Math.PI / 6;
                        H = ["circle", L, K, N / 2];
                        G = false;
                        T();
                        this.ctx.save();
                        this.ctx.scale(0.8, 0.8);
                        this.ctx.rotate(C * 0.45);
                        this.ctx.beginPath();
                        this.ctx.moveTo(ah, 0);
                        for (var ab = 0; ab < 11; ab++) {
                            this.ctx.rotate(n);
                            if (ab % 2 == 0) {
                                this.ctx.lineTo((ah / 0.55), 0)
                            } else {
                                this.ctx.lineTo(ah, 0)
                            }
                        }
                        this.ctx.closePath();
                        this.ctx.restore();
                        aq();
                        break;
                    case "star":
                        var k = (N / 4);
                        var C = Math.PI / 5;
                        H = ["circle", L, K, N / 2];
                        G = false;
                        T();
                        this.ctx.save();
                        this.ctx.scale(0.7, 0.7);
                        this.ctx.rotate(C * 0.45);
                        this.ctx.beginPath();
                        this.ctx.moveTo(k, 0);
                        for (var ab = 0; ab < 9; ab++) {
                            this.ctx.rotate(C);
                            if (ab % 2 == 0) {
                                this.ctx.lineTo((k / 0.35), 0)
                            } else {
                                this.ctx.lineTo(k, 0)
                            }
                        }
                        this.ctx.closePath();
                        this.ctx.restore();
                        aq();
                        break;
                    case "pie":
                        if (typeof(Q) == "undefined") {
                            Q = 0
                        }
                        if (typeof(ag) == "undefined") {
                            ag = Math.PI * 2
                        }
                        G = false;
                        T();
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, N / 2, Q, ag, false);
                        this.ctx.lineTo(0, 0);
                        this.ctx.closePath();
                        aq();
                        break;
                    case "pie0":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI / 5, O, ai);
                        break;
                    case "pie1":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI / 3.5, O, ai);
                        break;
                    case "pie2":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI / 2, O, ai);
                        break;
                    case "pie3":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI / 1.5, O, ai);
                        break;
                    case "pie4":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI, O, ai);
                        break;
                    case "pie5":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI * 1.2, O, ai);
                        break;
                    case "pie6":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI * 1.4, O, ai);
                        break;
                    case "pie7":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI * 1.6, O, ai);
                        break;
                    case "pie8":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI * 1.8, O, ai);
                        break;
                    case "pie9":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI * 2, O, ai);
                        break;
                    case "pacman":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, Math.PI * 1 / 4, Math.PI * 7 / 4, O, ai);
                        break;
                    case "pacman2":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, Math.PI * 5 / 4, Math.PI * 3 / 4, O, ai);
                        break
                }
                if (R) {
                    H = ae(H)
                }
                if (G) {
                    T();
                    aq(G)
                }
                return H
            } else {
                return false
            }
        }
    };
    this.drawImage = function(b, a, m, k, c, n) {
        if (this.isIE && this.useFlashIE && this.browserVersion < 9 && b == 1) {
            var g = this;
            var d = function() {
                g.drawImage(CanvasXpress.cacheImages[n], a, m, k, c)
            };
            CanvasXpress.cacheImages[n].onload = d;
            CanvasXpress.cacheImages[n].src = n
        } else {
            try {
                this.ctx.drawImage(b, a, m, k, c)
            } catch (j) {
                var g = this;
                setTimeout(function() {
                    g.draw()
                }, 100)
            }
        }
    };
    this.setRGB = function() {
        this.reds = [];
        this.greens = [];
        this.blues = [];
        this.yellows = [];
        this.cyans = [];
        this.purples = [];
        this.greys = [];
        this.indicatorBins = this.scatterPlotMatrix ? Math.min(this.x, this.y) / (this.layoutRows * 2) : Math.min(this.x, this.y) / 4;
        this.indicatorBins = this.indicatorBins > 512 ? 1 : this.indicatorBins > 256 ? 2 : this.indicatorBins > 128 ? 4 : 8;
        var e = this.indicatorBins;
        var c = parseInt(256 / e);
        var d;
        var b = 255;
        for (var a = 0; a < c; a++) {
            this.greys.push("rgb(" + b + "," + b + "," + b + ")");
            b -= e
        }
        if (this.indicatorCenter == "rainbow-green") {
            d = e - 1;
            b = 255;
            for (var a = 0; a < c; a++) {
                this.greens.push("rgb(0,255," + d + ")");
                this.cyans.push("rgb(0," + b + ",255)");
                this.blues.push("rgb(" + d + ",0,255)");
                this.purples.push("rgb(255,0," + b + ")");
                this.reds.push("rgb(255," + d + ",0)");
                this.yellows.push("rgb(" + b + ",255,0)");
                d += e;
                b -= e
            }
        } else {
            if (this.indicatorCenter.match("rainbow")) {
                d = e - 1;
                b = 255;
                for (var a = 0; a < c; a++) {
                    this.reds.push("rgb(255,0," + d + ")");
                    this.purples.push("rgb(" + b + ",0,255)");
                    this.blues.push("rgb(0," + d + ",255)");
                    this.cyans.push("rgb(0,255," + b + ")");
                    this.greens.push("rgb(" + d + ",255,0)");
                    this.yellows.push("rgb(255," + b + ",0)");
                    d += e;
                    b -= e
                }
            } else {
                if (this.indicatorCenter == "black") {
                    d = 255;
                    for (var a = 0; a < c; a++) {
                        this.reds.push("rgb(" + d + ",0,0)");
                        this.purples.push("rgb(" + d + ",0," + d + ")");
                        this.blues.push("rgb(0,0," + d + ")");
                        this.cyans.push("rgb(0," + d + "," + d + ")");
                        this.greens.push("rgb(0," + d + ",0)");
                        this.yellows.push("rgb(" + d + "," + d + ",0)");
                        d -= e
                    }
                } else {
                    this.reds.push("rgb(255,0,0)");
                    this.purples.push("rgb(255,0,255)");
                    this.blues.push("rgb(0,0,255)");
                    this.cyans.push("rgb(0,255,255)");
                    this.greens.push("rgb(0,255,0)");
                    this.yellows.push("rgb(255,255,0)");
                    d = e - 1;
                    for (var a = 0; a < c - 1; a++) {
                        this.reds.push("rgb(255," + d + "," + d + ")");
                        this.purples.push("rgb(255," + d + ",255)");
                        this.blues.push("rgb(" + d + "," + d + ",255)");
                        this.cyans.push("rgb(" + d + ",255,255)");
                        this.greens.push("rgb(" + d + ",255," + d + ")");
                        this.yellows.push("rgb(255,255," + d + ")");
                        d += e
                    }
                }
            }
        }
    };
    this.setLineTypes = function() {
        this.lines = this.getLineTypes()
    };
    this.setCodonTable = function() {
        this.codon = {
            TTT: ["F", "Phe", "Phenylalanine"],
            TCT: ["S", "Ser", "Serine"],
            TAT: ["Y", "Tyr", "Tyrosine"],
            TGT: ["C", "Cys", "Cysteine"],
            TTC: ["F", "Phe", "Phenylalanine"],
            TCC: ["S", "Ser", "Serine"],
            TAC: ["Y", "Tyr", "Tyrosine"],
            TGC: ["C", "Cys", "Cysteine"],
            TTA: ["L", "Leu", "Leucine"],
            TCA: ["S", "Ser", "Serine"],
            TAA: ["*", "Stop", "Ochre"],
            TGA: ["*", "Stop", "Opal"],
            TTG: ["L", "Leu", "Leucine"],
            TCG: ["S", "Ser", "Serine"],
            TAG: ["*", "Stop", "Amber"],
            TGG: ["W", "Trp", "Tryptophan"],
            CTT: ["L", "Leu", "Leucine"],
            CCT: ["P", "Pro", "Proline"],
            CAT: ["H", "His", "Histidine"],
            CGT: ["R", "Arg", "Arginine"],
            CTC: ["L", "Leu", "Leucine"],
            CCC: ["P", "Pro", "Proline"],
            CAC: ["H", "His", "Histidine"],
            CGC: ["R", "Arg", "Arginine"],
            CTA: ["L", "Leu", "Leucine"],
            CCA: ["P", "Pro", "Proline"],
            CAA: ["Q", "Gln", "Glutamine"],
            CGA: ["R", "Arg", "Arginine"],
            CTG: ["L", "Leu", "Leucine"],
            CCG: ["P", "Pro", "Proline"],
            CAG: ["Q", "Gln", "Glutamine"],
            CGG: ["R", "Arg", "Arginine"],
            ATT: ["I", "Ile", "Isoleucine"],
            ACT: ["T", "Thr", "Threonine"],
            AAT: ["N", "Asn", "Asparagine"],
            AGT: ["S", "Ser", "Serine"],
            ATC: ["I", "Ile", "Isoleucine"],
            ACC: ["T", "Thr", "Threonine"],
            AAC: ["N", "Asn", "Asparagine"],
            AGC: ["S", "Ser", "Serine"],
            ATA: ["I", "Ile", "Isoleucine"],
            ACA: ["T", "Thr", "Threonine"],
            AAA: ["K", "Lys", "Lysine"],
            AGA: ["R", "Arg", "Arginine"],
            ATG: ["M", "Met", "Methionine"],
            ACG: ["T", "Thr", "Threonine"],
            AAG: ["K", "Lys", "Lysine"],
            AGG: ["R", "Arg", "Arginine"],
            GTT: ["V", "Val", "Valine"],
            GCT: ["A", "Ala", "Alanine"],
            GAT: ["D", "Asp", "Aspartic acid"],
            GGT: ["G", "Gly", "Glycine"],
            GTC: ["V", "Val", "Valine"],
            GCC: ["A", "Ala", "Alanine"],
            GAC: ["D", "Asp", "Aspartic acid"],
            GGC: ["G", "Gly", "Glycine"],
            GTA: ["V", "Val", "Valine"],
            GCA: ["A", "Ala", "Alanine"],
            GAA: ["E", "Glu", "Glutamic acid"],
            GGA: ["G", "Gly", "Glycine"],
            GTG: ["V", "Val", "Valine"],
            GCG: ["A", "Ala", "Alanine"],
            GAG: ["E", "Glu", "Glutamic acid"],
            GGG: ["G", "Gly", "Glycine"]
        }
    };
    this.setReverseComplement = function() {
        this.reverseComplement = {
            a: "t",
            c: "g",
            g: "c",
            t: "a",
            u: "a",
            A: "T",
            C: "G",
            G: "C",
            T: "A",
            "/": "/",
            "[": "[",
            "]": "]"
        }
    };
    this.initializeAttributes = function() {
        this.setLineTypes();
        this.setRGB();
        this.setCodonTable();
        this.setReverseComplement()
    };
    this.initializeAttributes()
};
CanvasXpress.prototype.initPrimitives = function() {
    this.initText();
    this.initTime();
    this.initColor();
    this.initAttributes()
};
CanvasXpress.prototype.initDimensions = function() {
    this.resizeCanvas = function(d, a, b) {
        if (this.ctx) {
            this.disableGradientTransparencyShadow();
            if (d || a || b) {
                if (a || b) {
                    if (a) {
                        this.width = a;
                        this.originalWidth = a
                    }
                    if (b) {
                        this.height = b;
                        this.originalHeight = b
                    }
                } else {
                    if (d) {
                        this.width = this.originalWidth;
                        this.height = this.originalHeight
                    }
                }
                this.top = this.margin;
                if (this.title) {
                    this.top += this.titleHeight + this.margin;
                    if (this.subtitle) {
                        this.top += this.subtitleHeight + this.margin
                    }
                }
                this.left = this.margin;
                this.right = this.margin;
                this.bottom = this.margin;
                this.dataEvent = []
            }
            if (this.isIE && this.useFlashIE && this.browserVersion < 9) {
                this.canvas.style.width = this.width + "px";
                this.canvas.style.height = this.height + "px";
                this.canvas.firstChild.width = this.width;
                this.canvas.firstChild.height = this.height
            } else {
                this.canvas.width = this.width;
                this.canvas.height = this.height
            } if (this.backgroundType == "image" || this.backgroundType == "windowImage") {
                this.ctx.save();
                this.ctx.translate(0, 0);
                this.drawImage(CanvasXpress.cacheImages[this.backgroundImage], 0, 0, this.width, this.height);
                this.ctx.restore()
            } else {
                if (this.backgroundType == "solid" || this.backgroundType == "window" || this.backgroundType == "windowSolidGradient" || this.backgroundType == "video") {
                    this.rectangle(0, 0, this.width, this.height, this.background, this.background)
                } else {
                    this.setLinearGradient(0, 0, 0, this.height, this.backgroundGradient1Color, this.backgroundGradient2Color);
                    this.ctx.fillRect(0, 0, this.width, this.height)
                }
            }
            this.enableGradientTransparencyShadow()
        }
    };
    this.setWidth = function(a) {
        if (!a) {
            a = 1000
        }
        this.setDimensions(a, this.height)
    };
    this.setHeight = function(a) {
        if (!a) {
            a = 800
        }
        this.setDimensions(this.width, a)
    };
    this.setDimensions = function(a, b) {
        if (!a) {
            a = 1000
        }
        if (!b) {
            b = 1000
        }
        this.canvas.width = a;
        this.canvas.height = b;
        this.resetAxesResizer();
        this.draw(a, b);
        this.resizeAcknowledgmentDiv();
        this.updateRemoteNavigationWindow();
        this.resizeViewport()
    };
    this.initializeDimensions = function() {
        if (this.canvas.width) {
            this.originalWidth = this.canvas.width;
            this.width = this.canvas.width
        } else {
            if (this.width) {
                this.originalWidth = this.width;
                this.canvas.width = this.width
            } else {
                this.width = 600;
                this.originalWidth = this.width;
                this.canvas.width = this.width
            }
        } if (this.canvas.height) {
            this.originalHeight = this.canvas.height;
            this.height = this.canvas.height
        } else {
            if (this.height) {
                this.originalHeight = this.height;
                this.canvas.height = this.height
            } else {
                this.height = 600;
                this.originalHeight = this.height;
                this.canvas.height = this.height
            }
        }
        this.top = this.margin;
        if (this.title) {
            this.top += this.titleHeight + this.margin;
            if (this.subtitle) {
                this.top += this.subtitleHeight + this.margin
            }
        }
        this.left = this.margin;
        this.right = this.margin;
        this.bottom = this.margin;
        this.x = this.width - (this.leftMargin + this.left + this.rightMargin + this.right);
        this.y = this.height - (this.topMargin + this.top + this.bottomMargin + this.bottom)
    };
    this.initializeDimensions()
};
CanvasXpress.prototype.initPlotUtils = function() {
    this.setVideoControls = function() {
        if (this.isVideo) {
            var b = this;
            if (typeof _V_ == "undefined" || !_V_.autoSetupTimeout) {
                setTimeout(function() {
                    b.setVideoControls()
                }, 100)
            } else {
                var f = _V_(this.target + "-cX-Video");
                var a = this.$(this.target + "-cX-Video");
                if (f && a) {
                    a.style.position = "absolute";
                    a.style.background = "transparent";
                    this.video = a.childNodes[0];
                    this.video.style.display = "hidden";
                    this.video.style.zIndex = -1;
                    this.video.playbackRate = this.videoPlaybackRate;
                    b.addEvtListener(this.video, "loadeddata", function() {
                        b.addEvtListener(b.video, "play", b.videoPlay, false)
                    }, false);
                    if (this.videoAutoplay) {
                        f.play();
                        var e = function() {
                            this.play = function() {
                                if (b.video.readyState == 4) {
                                    b.copyVideo(b.video, b.ctx, b.width, b.height);
                                    clearInterval(d)
                                }
                            };
                            var d = setInterval(this.play, 30)
                        };
                        e.call()
                    }
                }
            }
        }
    };
    this.drawCanvasBox = function(a) {
        if (this.canvasBox && (this.graphType != "Network" || a)) {
            this.disableGradientTransparencyShadow();
            this.rectangle(0, 0, this.width - 1, this.height - 1, false, this.canvasBoxColor, "open");
            this.enableGradientTransparencyShadow()
        }
    };
    this.drawPlotWindow = function() {
        if (this.backgroundType.match("window")) {
            this.disableGradientTransparencyShadow();
            var a = this.marginLeft + this.offsetX;
            var b = this.marginTop + this.offsetY;
            if (this.backgroundType == "windowGradient2" || this.backgroundType == "windowSolidGradient") {
                this.ctx.save();
                if (this.backgroundWindowGradientOrientation == "horizontal") {
                    this.setLinearGradient(a + this.left, b, a + this.left + this.x, b, this.backgroundWindowGradient1Color, this.backgroundWindowGradient2Color)
                } else {
                    this.setLinearGradient(a, b + this.top, a, b + this.top + this.y, this.backgroundWindowGradient1Color, this.backgroundWindowGradient2Color)
                }
                this.ctx.fillRect(a + this.left, b + this.top, this.x, this.y)
            } else {
                this.rectangle(a + this.left, b + this.top, this.x, this.y, this.backgroundWindow, this.backgroundWindow)
            }
            this.enableGradientTransparencyShadow()
        }
    };
    this.maskArea = function(d) {
        this.disableGradientTransparencyShadow();
        var h = function(i, e, t, l) {
            this.ctx.fillRect(i, e, t, l)
        };
        var k;
        var f = this.graphType == "Heatmap" ? -1 : 1;
        var b = this.graphType == "Heatmap" ? 2 : 0;
        var r = this.marginLeft + this.offsetX + f;
        var n = this.marginTop + this.offsetY;
        var w = this.outlineWidth + b;
        var p = [0, 0, this.width, this.marginTop];
        var v = [0, 0, this.marginLeft, this.height];
        var a = [0, this.height - this.marginBottom, this.width, this.marginBottom];
        var q = [this.width - this.marginRight, 0, this.marginRight, this.height];
        var g = d ? [r, n, this.left, this.top - w] : [r, n, (this.left + this.x + this.right), this.top - w];
        var m = d ? [r, n + this.top + this.y, this.left - w, this.bottom] : [r, n, this.left - w, (this.top + this.y + this.bottom)];
        var s = d ? [r + this.left + this.x, n + this.top + this.y + w, this.right, this.bottom] : [r, n + this.top + this.y + w, (this.left + this.x + this.right), this.bottom];
        var j = d ? [r + this.left + this.x + w, n, this.right, this.top] : [r + this.left + this.x + w, n, this.right, (this.top + this.y + this.bottom)];
        var o = [p, v, a, q, g, m, s, j];
        if (this.backgroundType == "image" || this.backgroundType == "windowImage") {
            return;
            this.ctx.save();
            this.ctx.translate(0, 0);
            for (var u = 0; u < o.length; u++) {
                o[u].unshift(CanvasXpress.cacheImages[this.backgroundImage])
            }
            k = this.drawImage
        } else {
            if (this.backgroundType == "solid" || this.backgroundType == "window" || this.backgroundType == "windowSolidGradient" || this.backgroundType == "video") {
                for (var u = 0; u < o.length; u++) {
                    o[u].push(this.background);
                    o[u].push(this.background)
                }
                k = this.rectangle
            } else {
                this.setLinearGradient(0, 0, 0, this.height, this.backgroundGradient1Color, this.backgroundGradient2Color);
                k = h
            }
        } if (this.marginTop) {
            k.apply(this, p)
        }
        if (this.marginLeft) {
            k.apply(this, v)
        }
        if (this.marginBottom) {
            k.apply(this, a)
        }
        if (this.marginRight) {
            k.apply(this, q)
        }
        k.apply(this, g);
        k.apply(this, m);
        k.apply(this, s);
        k.apply(this, j);
        if (this.backgroundType == "image" || this.backgroundType == "windowImage") {
            this.ctx.restore()
        }
        this.enableGradientTransparencyShadow()
    };
    this.maskPlotArea = function() {
        this.maskArea()
    };
    this.maskTreeArea = function() {
        this.maskArea(true)
    };
    this.setTrees = function() {
        if (this.showSmpDendrogram && this.data.t && this.data.t.smps) {
            this.smpDendrogram = {};
            this.smpDendrogram.data = [];
            this.smpDendrogram.nodes = [];
            this.smpDendrogram.idxs = [];
            this.smpDendrogram.heights = [];
            this.parseNewick(this.data.t.smps, "smpDendrogram")
        }
        if (this.showVarDendrogram && this.data.t && this.data.t.vars) {
            this.varDendrogram = {};
            this.varDendrogram.data = [];
            this.varDendrogram.nodes = [];
            this.varDendrogram.idxs = [];
            this.varDendrogram.heights = [];
            this.parseNewick(this.data.t.vars, "varDendrogram")
        }
    };
    this.setOverlayColors = function() {
        var l = 0;
        var m = this.isGroupedData ? this.grpIndices : this.smpIndices;
        if (this.smpOverlays.length > 0) {
            if (!this.smpOverlayColors) {
                this.smpOverlayColors = {}
            }
            for (var g = 0; g < this.smpOverlays.length; g++) {
                var f = this.smpOverlays[g];
                if (!this.smpOverlayColors[f]) {
                    this.smpOverlayColors[f] = {}
                }
                if (this.smpOverlayRecycleColors) {
                    l = 0
                }
                if (this.data.x.hasOwnProperty(f)) {
                    if (this.isNumeric(this.data.x[f], true)) {
                        var h = this.range(this.data.x[f], true);
                        for (var e = 0; e < m.length; e++) {
                            var k = m[e];
                            var d = this.isGroupedData ? this.data.w.factors[f][k] : this.data.x[f][k];
                            var b = !isNaN(d) ? this.getHeatmapColor(h[0], h[1], d) : this.missingDataColor;
                            this.smpOverlayColors[f][d.toString()] = b
                        }
                    } else {
                        for (var e = 0; e < m.length; e++) {
                            var k = m[e];
                            var a = this.isGroupedData ? this.data.w.factors[f][k] : this.data.x[f][k];
                            if (!this.smpOverlayColors[f][a]) {
                                this.smpOverlayColors[f][a] = this.colors[l % this.colors.length];
                                l++
                            }
                        }
                    }
                }
            }
        }
        l = 0;
        if (this.varOverlays.length > 0 && this.graphType == "Heatmap") {
            if (!this.varOverlayColors) {
                this.varOverlayColors = {}
            }
            for (var g = 0; g < this.varOverlays.length; g++) {
                var f = this.varOverlays[g];
                if (!this.varOverlayColors[f]) {
                    this.varOverlayColors[f] = {}
                }
                if (this.varOverlayRecycleColors) {
                    l = 0
                }
                if (this.data.z.hasOwnProperty(f)) {
                    if (this.isNumeric(this.data.z[f], true)) {
                        var h = this.range(this.data.z[f], true);
                        for (var e = 0; e < this.varIndices.length; e++) {
                            var k = this.varIndices[e];
                            var d = this.data.z[f][k];
                            var b = !isNaN(d) ? this.getHeatmapColor(h[0], h[1], d) : this.missingDataColor;
                            this.varOverlayColors[f][d.toString()] = b
                        }
                    } else {
                        for (var e = 0; e < this.varIndices.length; e++) {
                            var k = this.varIndices[e];
                            var a = this.data.z[f][k];
                            if (!this.varOverlayColors[f][a]) {
                                this.varOverlayColors[f][a] = this.colors[l % this.colors.length];
                                l++
                            }
                        }
                    }
                }
            }
        }
    };
    this.setOverlayFont = function() {
        var a = Math.min(this.overlayScaleFontFactor * this.overlayFontSize, this.maxTextSize);
        a = parseInt(Math.max(a, this.minTextSize));
        this.overlayFont = this.overlayFontStyle + " " + a + "Pt " + this.fontName
    };
    this.setValidDataColorShapeSize = function() {
        var b = ["color", "shape", "size"];
        for (var a = 0; a < b.length; a++) {
            if (this[b[a] + "By"]) {
                if (this.data.x && !this.data.x[this[b[a] + "By"]] && this.data.z && !this.data.z[this[b[a] + "By"]] && !this.isMultidimensionalHeatmap) {
                    if (this[b[a] + "By"] == "variable" || (this.graphType.match(/Boxplot|Dotplot/))) {
                        continue
                    } else {
                        this[b[a] + "By"] = false
                    }
                }
            }
        }
        if ((this.shapeBy || this.sizeBy) && !this.colorBy && !this.isMultidimensionalHeatmap) {
            this.colorBy = "variable"
        } else {
            if (!this.shapeBy && !this.sizeBy && this.colorBy == "variable") {
                this.colorBy = false
            }
        }
    };
    this.parseNewick = function(b, e) {
        var p = b.split(/,/);
        var v = 0;
        var f = 0;
        var g = 0;
        var m = 1;
        var l = 0;
        var u = 0;
        var a = 0;
        var k = 0;
        for (var s = 0; s < p.length; s++) {
            var q = p[s];
            var h = q.split(/:(?=[0-9\.]+)/);
            var w = h.shift();
            w = w.replace(/[\(\)]/g, "");
            if (this.useSmpVarIndexOnClustering) {
                this[e].nodes.push(e == "smpDendrogram" ? this.data.y.smps[w] : this.data.y.vars[w]);
                this[e].idxs.push(w)
            } else {
                this[e].nodes.push(w);
                this[e].idxs.push(e == "smpDendrogram" ? this.getSampleIndices(w) : this.getVariableIndices(w))
            }
            for (var r = 0; r < h.length; r++) {
                var d = h[r].replace(/[\(\)]/g, "");
                u = Math.max(u, d);
                this[e].heights.push(d)
            }
            this[e].max = u;
            var t = p[s].split("");
            f = 0;
            for (var r = 0; r < t.length; r++) {
                if (t[r] == "(") {
                    v++;
                    f++
                }
                if (t[r] == ")") {
                    v--;
                    f--
                }
            }
            k += f;
            if (g > v) {
                this[e].data.push([m, g, f, k])
            } else {
                this[e].data.push([m, v, f, k])
            }
            g = v;
            a = Math.max(a, g);
            l += f;
            m++
        }
        this[e].unit = u > 0 ? (a * this.dendrogramSpace) / u : 0;
        this[e].depth = a;
        if (l > 0) {
            alert("Dude! Malformed newick tree. There are " + l + " additional right parenthesis!")
        } else {
            if (l < 0) {
                alert("Dude! Malformed newick tree. There are " + Math.abs(l) + " additional left parenthesis!")
            }
        } if (e == "varDendrogram") {
            if (this.varIndicesStart < 0) {
                if (this[e].nodes.length != this.data.y.vars.length) {
                    alert("Dude! The length of the variable nodes in the dendrogram (" + this[e].nodes.length + ") is different to that one in the data (" + this.data.y.vars.length + "). This ain't gonna work!");
                    this.showVarDendrogram = false
                } else {
                    if (this[e].nodes.length != this.varIndices.length) {
                        alert("Ooops! Cannot show dendrogram with " + this[e].nodes.length + " nodes when only " + this.varIndices.length + " variables are visible.");
                        this.showVarDendrogram = false
                    } else {
                        this.varIndices = this[e].idxs
                    }
                }
            } else {
                var o = this.varIndicesStart + this.varIndices.length;
                this.varIndices = [];
                for (var s = this.varIndicesStart; s < o; s++) {
                    this.varIndices.push(this[e].idxs[s])
                }
            }
        } else {
            if (this.smpIndicesStart < 0) {
                if (this[e].nodes.length != this.data.y.smps.length) {
                    alert("Dude! The length of the sample nodes in the dendrogram (" + this[e].nodes.length + ") is different to that one in the data (" + this.data.y.smps.length + "). This ain't gonna work!");
                    this.showSmpDendrogram = false
                } else {
                    if (this[e].nodes.length != this.smpIndices.length) {
                        alert("Ooops! Cannot show dendrogram with " + this[e].nodes.length + " nodes when only " + this.smpIndices.length + " samples visible.");
                        this.showSmpDendrogram = false
                    } else {
                        this.smpIndices = this[e].idxs
                    }
                }
            } else {
                var o = this.smpIndicesStart + this.smpIndices.length;
                this.smpIndices = [];
                for (var s = this.smpIndicesStart; s < o; s++) {
                    this.smpIndices.push(this[e].idxs[s])
                }
            }
        }
    }
};
CanvasXpress.prototype.initGeneralUtils = function() {
    this.modifyObjectArray = function(g, b, h) {
        var a = this[h];
        if (b) {
            var e = {};
            var d = [];
            if (this.isArray(g)) {
                for (var f = 0; f < g.length; f++) {
                    e[g[f]] = 1
                }
            } else {
                e[g] = 1
            }
            for (var f = 0; f < a.length; f++) {
                if (!e.hasOwnProperty(a[f])) {
                    d.push(a[f])
                }
            }
            this[h] = d
        } else {
            if (this.isArray(g)) {
                for (var f = 0; f < g.length; f++) {
                    a.push(g[f])
                }
            } else {
                a.push(g)
            }
        }
    };
    this.getObjectArray = function(a) {
        var b = {};
        if (a && this.isArray(a)) {
            for (var d = 0; d < a.length; d++) {
                b[a[d]] = 1
            }
        }
        return b
    };
    this.isInArray = function(e, b) {
        if (b && !(b.propertyIsEnumerable("length")) && typeof b === "object" && typeof b.length === "number") {
            for (var d = 0; d < b.length; d++) {
                if (b[d] == e) {
                    return true
                }
            }
        }
        return false
    };
    this.isArray = function(a) {
        if (a && !(a.propertyIsEnumerable("length")) && typeof a === "object" && typeof a.length === "number") {
            return true
        } else {
            return false
        }
    };
    this.isObject = function(a) {
        return a instanceof Object
    };
    this.toArray = function(a) {
        return this.isArray(a) ? a : [a]
    };
    this.getKeys = function(d) {
        var b = [];
        if (this.isObject(d)) {
            for (var a in d) {
                b.push(a)
            }
        }
        return b
    };
    this.getUniqueKeys = function(d) {
        var b = {};
        if (this.isArray(d)) {
            d = this.getObjectArray(d)
        }
        if (this.isObject(d)) {
            for (var a in d) {
                b[a] = true
            }
        }
        return this.getKeys(b)
    };
    this.toNumber = function(b, g) {
        var h = [];
        var d = this.isArray(b);
        b = this.toArray(b);
        for (var e = 0; e < b.length; e++) {
            if (g) {
                h.push(parseFloat(b[e]))
            } else {
                h.push(parseInt(b[e]))
            }
        }
        return d ? h : h[0]
    };
    this.cloneObject = function(d) {
        if (d == null || typeof(d) != "object") {
            return d
        }
        var a = new d.constructor();
        for (var b in d) {
            a[b] = this.cloneObject(d[b])
        }
        return a
    };
    this.isSameObject = function(e, d) {
        if (e === d) {
            return true
        }
        if (typeof(e) != "object" || typeof(d) != "object") {
            return false
        }
        for (var f in e) {
            if (e[f] === d[f]) {
                continue
            }
            if (d[f] === undefined || typeof(e[f]) != typeof(d[f])) {
                return false
            }
            if (!this.isSameObject(e[f], d[f])) {
                return false
            }
        }
        for (var f in d) {
            if (e[f] === undefined) {
                return false
            }
        }
        return true
    }
};
CanvasXpress.prototype.initConfigUtils = function() {
    this.getPixelImage = function() {
        if (navigator.onLine) {
            return this.imageDir + "canvasXpress.gif"
        } else {
            if (this.path) {
                return this.path + "canvasXpress.gif"
            } else {
                alert("Dude! I couldn't find canvasXpress.js")
            }
        }
    };
    this.drawTitle = function() {
        var d;
        var b;
        var a;
        if (this.title) {
            b = this.titleHeight / 2;
            d = this.scaleTextToFont(this.title, this.titleHeight - b, this.width);
            this.drawText(this.title, this.width / 2, this.marginTop + (this.titleHeight / 2), d, this.titleColor, "center", "middle");
            if (this.subtitle) {
                a = this.subtitleHeight / 4;
                d = this.scaleTextToFont(this.subtitle, this.subtitleHeight - a, this.x);
                this.drawText(this.subtitle, this.width / 2, (this.marginTop + this.titleHeight) + (this.subtitleHeight / 2), d, this.subtitleColor, "center", "middle")
            }
        }
    };
    this.drawCitation = function(a, e, b) {
        if (this.citation) {
            var d;
            if (!a) {
                a = this.width - this.margin
            }
            if (!e) {
                e = this.height - this.margin
            }
            if (b) {
                d = this.citationFontStyle + " " + (this.citationFontSize * this.citationScaleFontFactor * b) + "Pt " + this.fontName
            } else {
                d = this.citationFontStyle + " " + (this.citationFontSize * this.citationScaleFontFactor) + "Pt " + this.fontName
            }
            this.drawText(this.citation, a, e, d, this.citationColor, "right", "bottom")
        }
    };
    this.drawSelectedBackgroundLabel = function(b, d, a, e) {
        if (this.selectDataMode == "name" && this.isInSelectedDataPoints(b, d)) {
            if (this.selectDataModeDescription && this.data.z && this.data.z[this.selectDataModeDescription]) {
                lab = this.data.z[this.selectDataModeDescription][b] || this.data.y.vars[b]
            } else {
                lab = this.data.y.vars[b]
            }
            this.drawText(lab, a, e, this.varLabelFont, this.foreground, "center", "middle")
        }
    };
    this.drawSelectedBackground = function(g, j, k, b, e, f, d, a, i) {
        if (this.selectDataMode == "area" && this.isInSelectedDataPoints(g, j)) {
            this.drawShape(k, b, e, f + 12, d + 12, this.selectedBackgroundColor, this.foreground, "closed", a, 1, i)
        }
    };
    this.isInSelectedDataPoints = function(a, b) {
        if (this.isSelectDataPoints) {
            if (this.selectDataPoint[a]) {
                if (this.broadcastType == "var") {
                    return true
                } else {
                    if (this.selectDataPoint[a].hasOwnProperty(b)) {
                        return true
                    }
                }
            }
        }
        return false
    };
    this.isVisibleSelectedDataPoint = function(a, b) {
        if (this.isSelectDataPoints) {
            if (this.hideDataPoint.length > 0 && this.hideDataPoint[a]) {
                if (this.broadcastType == "var") {
                    return false
                } else {
                    if (this.hideDataPoint[a].hasOwnProperty(b)) {
                        return false
                    }
                }
            }
        }
        return true
    };
    this.getVarColor = function(a) {
        if (this.isArray(this.highlightVar)) {
            for (var b = 0; b < this.highlightVar.length; b++) {
                if (this.highlightVar[b] == a) {
                    return this.varHighlightColor
                }
            }
        } else {
            if (this.highlightVar == a) {
                return this.varHighlightColor
            }
        }
        return this.varLabelFontColor
    };
    this.getSmpColor = function(b) {
        if (this.isArray(this.highlightSmp)) {
            for (var a = 0; a < this.highlightSmp.length; a++) {
                if (this.highlightSmp[a] == b) {
                    return this.smpHighlightColor
                }
            }
        } else {
            if (this.highlightSmp == b) {
                return this.smpHighlightColor
            }
        }
        return this.smpLabelFontColor
    };
    this.getNodeColor = function(d, a) {
        if (this.isArray(this.highlightNode)) {
            for (var b = 0; b < this.highlightNode.length; b++) {
                if (this.highlightNode[b] == d) {
                    return this.nodeHighlightColor
                }
            }
        } else {
            if (this.highlightNode == d) {
                return this.nodeHighlightColor
            }
        }
        return this.selectNode.hasOwnProperty(d) ? this.nodeHighlightColor : a ? a : this.nodeFontColor
    };
    this.getTechnicalIndicatorColor = function(a) {
        return this[a.toLowerCase() + "Color"] ? this[a.toLowerCase() + "Color"] : "rgb(255,255,0)"
    };
    this.getWorstAspectRatio = function(l, k) {
        if (!l || l.length == 0) {
            return Number.MAX_VALUE
        } else {
            var f = 0;
            var g = 0;
            var b = Number.MAX_VALUE;
            for (var d = 0; d < l.length; d++) {
                var h = l[d].area;
                f += h;
                b = (b < h) ? b : h;
                g = (g > h) ? g : h
            }
            var e = k * k;
            var j = f * f;
            return Math.max(e * g / j, j / (e * b))
        }
    };
    this.setTreemapRowVerticalLayout = function(k, h, g) {
        var d = 0;
        for (var b = 0; b < k.length; b++) {
            d += k[b].area
        }
        var a = d / h;
        var f = 0;
        for (var b = 0; b < k.length; b++) {
            var j = k[b].area / a;
            k[b].coords = {
                width: a,
                height: j,
                left: g.left,
                top: g.top + f
            };
            f += j
        }
        var e = {
            width: g.width - a,
            height: g.height,
            left: g.left + a,
            top: g.top
        };
        e.orientation = Math.min(e.width, e.height);
        if (e.orientation != e.height) {
            this.treemapOrientation = this.treemapOrientation == "horizontal" ? "vertical" : "horizontal"
        }
        return e
    };
    this.setTreemapRowHorizontalLayout = function(l, j, h) {
        var e = 0;
        for (var d = 0; d < l.length; d++) {
            e += l[d].area
        }
        var k = e / j;
        var g = h.top;
        var b = 0;
        for (var d = 0; d < l.length; d++) {
            var a = l[d].area / k;
            l[d].coords = {
                width: a,
                height: k,
                left: h.left + b,
                top: g
            };
            b += a
        }
        var f = {
            width: h.width,
            height: h.height - k,
            left: h.left,
            top: h.top + k
        };
        f.orientation = Math.min(f.width, f.height);
        if (f.orientation != f.width) {
            this.treemapOrientation = this.treemapOrientation == "horizontal" ? "vertical" : "horizontal"
        }
        return f
    };
    this.setTreemapRowLayout = function(a, b, d) {
        if (this.treemapOrientation == "horizontal") {
            return this.setTreemapRowVerticalLayout(a, b, d)
        } else {
            return this.setTreemapRowHorizontalLayout(a, b, d)
        }
    };
    this.computeTreemapDimensions = function(a, d, b, g) {
        if (a.length + d.length == 1) {
            var f = (a.length == 1) ? a : d;
            f[0].coords = g;
            return
        }
        if (a.length >= 2 && d.length == 0) {
            d = [a.shift()]
        }
        if (a.length == 0) {
            if (d.length > 0) {
                this.setTreemapRowLayout(d, b, g)
            }
            return
        }
        var e = a[0];
        if (this.getWorstAspectRatio(d, b) >= this.getWorstAspectRatio([e].concat(d), b)) {
            this.computeTreemapDimensions(a.slice(1), d.concat([e]), b, g)
        } else {
            var h = this.setTreemapRowLayout(d, b, g);
            this.computeTreemapDimensions(a, [], h.orientation, h)
        }
    };
    this.squarifyTreemap = function(a, h) {
        var g = h.width * h.height;
        var f = 0;
        var b = [];
        for (var e = 0; e < a.length; e++) {
            b[e] = parseFloat(a[e].area);
            f += b[e]
        }
        for (var e = 0; e < b.length; e++) {
            a[e].area = g * b[e] / f
        }
        var d = this.treemapOrientation == "horizontal" ? h.height : h.width;
        a.sort(function(j, i) {
            return i.area - j.area
        });
        this.computeTreemapDimensions(a.slice(1), [a[0]], d, h)
    };
    this.processTreemap = function(b, e) {
        if (!this.treemapOrientation) {
            this.treemapOrientation = "horizontal"
        }
        if (e.width >= e.height) {
            this.treemapOrientation = "horizontal"
        } else {
            this.treemapOrientation = "vertical"
        } if (b.length) {
            this.squarifyTreemap(b, e);
            for (var d = 0; d < b.length; d++) {
                var a = b[d].children ? b[d].children : b[d];
                var e = {
                    width: b[d].coords.width,
                    height: b[d].coords.height,
                    left: b[d].coords.left,
                    top: b[d].coords.top
                };
                this.processTreemap(a, e)
            }
        }
        return b
    };
    this.getColor = function(a) {
        for (var b = 0; b < this.data.y.vars.length; b++) {
            if (this.data.y.vars[b] == a) {
                return this.colors[b % this.colors.length]
            }
        }
        return this.colors[0]
    };
    this.getPattern = function(a) {
        if (this.patterns.length > 0) {
            for (var b = 0; b < this.data.y.vars.length; b++) {
                if (this.data.y.vars[b] == a) {
                    return this.patterns[b % this.patterns.length]
                }
            }
        }
        return "closed"
    };
    this.setPieData = function(h, a) {
        var g = {
            no: 0,
            idso: [],
            ids: [],
            data: {},
            oprc: 0,
            tot: this.sum(h)
        };
        for (var e = 0; e < h.length; e++) {
            var b = a ? this.varIndices[e] : e;
            var f = h[b] / g.tot;
            g.data[b] = f;
            if (e >= this.maxPieSectors - 1) {
                g.oprc += f;
                g.idso.push(b);
                g.no++
            } else {
                g.ids.push(b)
            }
        }
        if (g.no) {
            g.ids.push(-1)
        }
        return g
    };
    this.drawPie = function(u, h, g, t, J) {
        var q = function() {
            for (var a = 0; a < u.ids.length; a++) {
                if (isNaN(u.data[a])) {
                    return false
                }
            }
            return true
        };
        var o = this.startPieSectors ? (this.startPieSectors * Math.PI / 180) % 360 : 0;
        var A = this.pieSegmentLabels == "inside" ? t - (t / 3) : t + (t / 10);
        var H = 0;
        var D = this.layoutComb ? this.smpIndices[0] : this.xAxisIndices ? this.xAxisIndices[0] : 0;
        var m = this.ctx.lineWidth;
        if (q()) {
            var z, e;
            for (var E = 0; E < u.ids.length; E++) {
                var n = u.ids[E];
                var v = n > -1 ? u.data[n] : u.oprc;
                var f = E % this.colors.length;
                z = e != null ? parseFloat(e) : parseFloat((Math.PI * (2 * H)) - o);
                e = parseFloat(z + (Math.PI * (2 * (v))));
                var I = (z + e) / 2;
                var C = (e - z) / 32;
                var G = this.transparency != null ? this.validateColor(this.colors[f], this.transparency) : this.colors[f];
                if (this.gradient) {
                    this.setRadialGradient(h, g, t * 1.3, G)
                } else {
                    this.ctx.fillStyle = G
                }
                this.ctx.beginPath();
                this.ctx.lineWidth = this.pieSegmentSeparation;
                this.ctx.strokeStyle = this.pieType == "separated" ? this.background : this.pieType == "solid" ? this.foreground : this.foreground;
                if (this.showShadow) {
                    this.ctx.shadowOffsetX = this.shadowOffsetX;
                    this.ctx.shadowOffsetY = this.shadowOffsetY;
                    this.ctx.shadowBlur = this.shadowBlur;
                    this.ctx.shadowColor = this.shadowColor
                }
                this.ctx.moveTo(h, g);
                this.ctx.arc(h, g, t, z, e, false);
                this.ctx.lineTo(h, g);
                this.ctx.closePath();
                this.ctx.fill();
                if (this.graphType != "Network") {
                    this.ctx.stroke()
                }
                if (this.showShadow) {
                    this.ctx.restore();
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 0;
                    this.ctx.shadowBlur = 0;
                    this.ctx.shadowColor = this.background
                }
                var F = h - Math.sin(I - (Math.PI / 2)) * A;
                var d = g + Math.cos(I - (Math.PI / 2)) * A;
                if (this.graphType != "Network" && this.showPieValues) {
                    this.drawText(sprintf("%." + this.pieSegmentPrecision + "f", v * 100) + "%", F, d, this.axisTickFont, this.axisTickColor, "center", "middle")
                }
                if (J) {
                    F = h + t * Math.cos(z);
                    d = g + t * Math.sin(z);
                    var b = ["poly", h, g, F, d];
                    var o = z;
                    for (var B = 0; B < 32; B++) {
                        o += C;
                        F = h + t * Math.cos(o);
                        d = g + t * Math.sin(o);
                        b.push(F);
                        b.push(d)
                    }
                    b.push(h);
                    b.push(g);
                    if (n > -1) {
                        this.addArea(b, [n, D])
                    } else {
                        u.idso.push(D);
                        this.addArea(b, u.idso)
                    }
                }
                H += v
            }
            this.ctx.lineWidth = m
        }
    };
    this.drawBarPlot = function(M, L, H, A, k, D, x, g, G, F, N, E, P) {
        var n, j, K, C;
        var O = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
        var B = this.variableSeparationFactor / 2;
        var J = k / 2;
        if (F == "vertical") {
            for (var I = 0; I < M.length; I++) {
                n = ((M[I] - G) * x) - g;
                if (!isNaN(n)) {
                    this.addArea(this.rectangle(H + B, A, k - this.variableSeparationFactor, -n, N[I], N[I], E[I], false, false, true), P[I]);
                    K = A - n;
                    C = H + J;
                    if (L[I] && !isNaN(L[I])) {
                        j = ((L[I] / 2) * x) - (g / 2);
                        this.errorBar(C, K, C, K + j, -J, O);
                        this.errorBar(C, K, C, K - j, -J, O)
                    }
                    if (this.showDataValues) {
                        this.drawText(M[I], C, A - (n + this.overlayFontSize), this.overlayFont, N[I], "center", "bottom")
                    }
                }
                H += D
            }
        } else {
            for (var I = 0; I < M.length; I++) {
                n = ((M[I] - G) * x) - g;
                if (!isNaN(n)) {
                    this.addArea(this.rectangle(H, A + B, n, k - this.variableSeparationFactor, N[I], N[I], E[I], false, false, true), P[I]);
                    K = H + n;
                    C = A + J;
                    if (L[I] && !isNaN(L[I])) {
                        j = ((L[I] / 2) * x) - (g / 2);
                        this.errorBar(K, C, K + j, C, J, O);
                        this.errorBar(K, C, K - j, C, J, O)
                    }
                    if (this.showDataValues) {
                        this.drawText(M[I], K + this.overlayFontSize, C, this.overlayFont, N[I], "left", "middle")
                    }
                }
                A += D
            }
        }
    };
    this.drawLinePlot = function(O, N, H, A, x, J, y, G, E, P, C, B, R) {
        var D, M, L, K, j, g, f;
        var v = x / 2;
        var r = x / 3;
        var Q = C == "open" ? P : this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
        var F = O.length - 1;
        var k = [
            [],
            []
        ];
        if (E == "vertical") {
            M = H;
            L = H + J;
            for (var I = 1; I < O.length; I++) {
                D = I - 1;
                j = A - ((O[D] - G) * y);
                g = A - ((O[I] - G) * y);
                if (!isNaN(j)) {
                    if (this.lineDecoration && B) {
                        this.addArea(this.drawShape(B, M, j, r, r, P, Q, C, false, false, true), R[D])
                    }
                    if (N[D] && !isNaN(N[D])) {
                        f = (N[D] / 2) * y;
                        this.errorBar(M, j, M, j + f, -v, P);
                        this.errorBar(M, j, M, j - f, -v, P)
                    }
                    if (this.lineType == "spline") {
                        k[0].push(M);
                        k[1].push(j)
                    }
                }
                if (this.lineType != "spline" && !isNaN(j) && !isNaN(g)) {
                    this.drawLine("line", M, j, L, g, P, this.lineThickness, "butt", false, false, true)
                } else {
                    if (this.lineType == "spline" && isNaN(g)) {
                        this.drawLine("spline", k[0], k[1], false, false, P, this.lineThickness);
                        k = [
                            [],
                            []
                        ]
                    }
                }
                M += J;
                L += J
            }
            if (!isNaN(g)) {
                if (this.lineDecoration && B) {
                    this.addArea(this.drawShape(B, M, g, r, r, P, Q, C, false, false, true), R[F])
                }
                if (N[F] && !isNaN(N[F])) {
                    f = (N[F] / 2) * y;
                    this.errorBar(M, g, M, g + f, -v, P);
                    this.errorBar(M, g, M, g - f, -v, P)
                }
                if (this.lineType == "spline") {
                    k[0].push(M);
                    k[1].push(g)
                }
            }
            if (this.lineType == "spline") {
                this.drawLine("spline", k[0], k[1], false, false, P, this.lineThickness)
            }
        } else {
            j = A;
            g = A + J;
            for (var I = 1; I < O.length; I++) {
                D = I - 1;
                M = H + ((O[D] - G) * y);
                L = H + ((O[I] - G) * y);
                if (!isNaN(M)) {
                    if (this.lineDecoration && B) {
                        this.addArea(this.drawShape(B, M, j, r, r, P, Q, C, false, false, true), R[D])
                    }
                    if (N[D] && !isNaN(N[D])) {
                        K = (N[D] / 2) * y;
                        this.errorBar(M, j, M + K, j, v, P);
                        this.errorBar(M, j, M - K, j, v, P)
                    }
                    if (this.lineType == "spline") {
                        k[0].push(M);
                        k[1].push(j)
                    }
                }
                if (this.lineType != "spline" && !isNaN(M) && !isNaN(L)) {
                    this.drawLine("line", L, g, M, j, P, this.lineThickness, "butt", false, false, true)
                } else {
                    if (this.lineType == "spline" && isNaN(L)) {
                        this.drawLine("spline", k[0], k[1], false, false, P, this.lineThickness);
                        k = [
                            [],
                            []
                        ]
                    }
                }
                j += J;
                g += J
            }
            if (!isNaN(L)) {
                if (this.lineDecoration && B) {
                    this.addArea(this.drawShape(B, L, j, r, r, P, Q, C, false, false, true), R[F])
                }
                if (N[F] && !isNaN(N[F])) {
                    K = (N[F] / 2) * y;
                    this.errorBar(L, j, L + K, j, -v, P);
                    this.errorBar(L, j, L - K, j, -v, P)
                }
                if (this.lineType == "spline") {
                    k[0].push(L);
                    k[1].push(j)
                }
            }
            if (this.lineType == "spline") {
                this.drawLine("spline", k[0], k[1], false, false, P, this.lineThickness)
            }
        }
    };
    this.drawStackedPlot = function(m, h, z, s, e, k, y, f, n, b, r) {
        if (f == "vertical") {
            for (var j = 0; j < m.length; j++) {
                var x = e ? (m[j] * 100 / k) * y : m[j] * y;
                this.addArea(this.rectangle(h, z, s, -x, n[j], this.foreground, b[j]), r[j]);
                z -= x
            }
        } else {
            for (var j = 0; j < m.length; j++) {
                var x = e ? (m[j] * 100 / k) * y : m[j] * y;
                this.addArea(this.rectangle(h, z, x, s, n[j], this.foreground, b[j]), r[j]);
                h += x
            }
        }
    };
    this.drawAreaPlot = function(T, M, E, B, Q, F, D, L, J, S, U, I, V) {
        var K = T.length - 1;
        var N = S && this.lineType == "rect" ? "path" : this.lineType == "rect" ? "polygon" : "spline";
        var R = [];
        var G = [];
        if (this.graphOrientation == "vertical") {
            for (var P = 0; P < T[0].length; P++) {
                R[P] = E
            }
            for (var P = 0; P < T.length; P++) {
                var H = M;
                var A = S ? [] : [M];
                var e = S ? [] : [E];
                for (var O = 0; O < T[0].length; O++) {
                    if (isNaN(T[P][O])) {
                        if (!S) {
                            A.push(H - F);
                            e.push(E)
                        }
                        if (S && this.lineType == "spline") {
                            this.addArea(this.drawLine(N, A, e, false, false, U[P], this.lineThickness), V[P])
                        } else {
                            this.addArea(this.drawShape(N, A, e, this.width, this.height, U[P], U[P], I[P]), V[P])
                        }
                        A = S ? [] : [H + F];
                        e = S ? [] : [E]
                    } else {
                        var C = (T[P][O] - L) * D;
                        A.push(H);
                        if (this.areaIsCumulative) {
                            e.push(R[O] - C);
                            R[O] -= C
                        } else {
                            e.push(E - C)
                        }
                    }
                    H += F
                }
                if (!S) {
                    A.push(M + B);
                    e.push(E)
                }
                G.push([A, e])
            }
        } else {
            for (var P = 0; P < T[0].length; P++) {
                R[P] = M
            }
            for (var P = 0; P < T.length; P++) {
                var H = E;
                var A = S ? [] : [M];
                var e = S ? [] : [E];
                for (var O = 0; O < T[0].length; O++) {
                    if (isNaN(T[P][O])) {
                        if (!S) {
                            A.push(M);
                            e.push(H - F)
                        }
                        if (S && this.lineType == "spline") {
                            this.addArea(this.drawLine(N, A, e, false, false, U[P], this.lineThickness), V[P])
                        } else {
                            this.addArea(this.drawShape(N, A, e, this.width, this.height, U[P], U[P], I[P]), V[P])
                        }
                        A = S ? [] : [M];
                        e = S ? [] : [H + F]
                    } else {
                        var C = (T[P][O] - L) * D;
                        e.push(H);
                        if (this.areaIsCumulative) {
                            A.push(R[O] + C);
                            R[O] += C
                        } else {
                            A.push(M + C)
                        }
                    }
                    H += F
                }
                if (!S) {
                    A.push(M);
                    e.push(E + Q)
                }
                G.push([A, e])
            }
        }
        while (K >= 0) {
            var b = G.pop();
            if (S && this.lineType == "spline") {
                this.addArea(this.drawLine(N, b[0], b[1], false, false, U[K], this.lineThickness), V[K])
            } else {
                this.addArea(this.drawShape(N, b[0], b[1], this.width, this.height, U[K], U[K], I[K]), V[K])
            }
            K--
        }
    };
    this.drawBoxPlot = function(K, F, x, g, B, n, E, D, L, C, N) {
        var e = function(a) {
            return D == "vertical" ? x - ((a - E) * n) : F + ((a - E) * n)
        };
        var M = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
        var y = this.variableSeparationFactor / 2;
        var I = g / 2;
        var J = g / this.boxPlotOutliersRatio;
        if (D == "vertical") {
            for (var H = 0; H < K.length; H++) {
                var A = F + I;
                var k = [];
                for (var G = 0; G < 5; G++) {
                    k.push(e(K[H][G]))
                }
                this.addArea(this.rectangle(F + y, k[2], g - this.variableSeparationFactor, k[3] - k[2], L[H], L[H], C[H], false, false, true), N[H]);
                this.drawLine("line", F + y, k[4], F + (g - y), k[4], M, false, "butt", false, false, true);
                this.errorBar(A, k[2], A, k[0], -I, M);
                this.errorBar(A, k[3], A, k[1], -I, M);
                if (K[H][5]) {
                    for (var G = 0; G < K[H][5].length; G++) {
                        this.drawShape("sphere", A, e(K[H][5][G]), J, J, L[H], M, C[H], false, false, true)
                    }
                }
                F += B
            }
        } else {
            for (var H = 0; H < K.length; H++) {
                var A = x + I;
                var k = [];
                for (var G = 0; G < 5; G++) {
                    k.push(e(K[H][G]))
                }
                this.addArea(this.rectangle(k[2], x + y, k[3] - k[2], g - this.variableSeparationFactor, L[H], L[H], C[H], false, false, true), N[H]);
                this.drawLine("line", k[4], x + y, k[4], x + (g - y), M, false, "butt", false, false, true);
                this.errorBar(k[2], A, k[0], A, I, M);
                this.errorBar(k[3], A, k[1], A, I, M);
                if (K[H][5]) {
                    for (var G = 0; G < K[H][5].length; G++) {
                        this.drawShape("sphere", e(K[H][5][G]), A, J, J, L[H], M, C[H], false, false, true)
                    }
                }
                x += B
            }
        }
    };
    this.drawCandlestickPlot = function(G, B, q, f, F, n, A, x, y, H, J) {
        var e = function(a) {
            return y == "vertical" ? q - ((a - A) * n) : B + ((a - A) * n)
        };
        var I = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
        var E = f / 2;
        if (y == "vertical") {
            for (var D = 0; D < G.length; D++) {
                var s = B + E;
                var k = [];
                for (var C = 0; C < G[D].length; C++) {
                    k.push(e(G[D][C]))
                }
                if (x) {
                    if (k[0] > k[1]) {
                        this.addArea(this.rectangle(B, k[0], f, k[1] - k[0], false, H, "open", false, false, true), J[D]);
                        this.drawLine("line", s, k[1], s, k[2], H, false, "butt", false, false, true);
                        this.drawLine("line", s, k[3], s, k[0], H, false, "butt", false, false, true)
                    } else {
                        this.addArea(this.rectangle(B, k[0], f, k[1] - k[0], H, H, "closed", false, false, true), J[D]);
                        this.drawLine("line", s, k[3], s, k[1], H, false, "butt", false, false, true);
                        this.drawLine("line", s, k[0], s, k[2], H, false, "butt", false, false, true)
                    }
                } else {
                    this.addArea(this.rectangle(B, k[0], f, q - k[0], H, H, "closed", false, false, true), J[D])
                }
                B += F
            }
        } else {
            for (var D = 0; D < G.length; D++) {
                var s = q + E;
                var k = [];
                for (var C = 0; C < G[D].length; C++) {
                    k.push(e(G[D][C]))
                }
                if (x) {
                    if (k[1] > k[0]) {
                        this.addArea(this.rectangle(k[0], q, k[1] - k[0], f, false, H, "open", false, false, true), J[D]);
                        this.drawLine("line", k[1], s, k[2], s, H, false, "butt", false, false, true);
                        this.drawLine("line", k[3], s, k[0], s, H, false, "butt", false, false, true)
                    } else {
                        this.addArea(this.rectangle(k[0], q, k[1] - k[0], f, H, H, "closed", false, false, true), J[D]);
                        this.drawLine("line", k[3], s, k[1], s, H, false, "butt", false, false, true);
                        this.drawLine("line", k[0], s, k[2], s, H, false, "butt", false, false, true)
                    }
                } else {
                    this.addArea(this.rectangle(B, q, k[0] - B, f, H, H, "closed", false, false, true), J[D])
                }
                q += F
            }
        }
    };
    this.drawDotPlot = function(R, Q, J, C, y, N, E, B, I, D, G, S, K, F, P, U) {
        var A, r;
        var x = this.jitter ? Math.ceil(Math.log(this.varIndices.length * 5) / Math.LN10) : 1;
        var O = this.jitter ? P / x : 0;
        var T = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
        if (G == "vertical") {
            if (this.jitter) {
                J -= P / 2
            }
            for (var M = 0; M < R.length; M++) {
                var H = 0;
                for (var L = 0; L < R[M].length; L++) {
                    A = C - ((R[M][L] - I) * B);
                    if (!isNaN(A)) {
                        this.addArea(this.drawShape(F[M][L], J + H, A, D[M][L], D[M][L], S[M][L], T, K[M][L], false, false, true), U[M][L]);
                        if (Q[M] && !isNaN(Q[M])) {
                            r = (Q[M] / 2) * B;
                            this.errorBar(J + H, A, J + H, A + r, -N, S[M][L]);
                            this.errorBar(J + H, A, J + H, A - r, -N, S[M][L])
                        }
                        H = this.jitter && (L + 1) % (x + 1) ? H + O : 0
                    }
                }
                J += E
            }
        } else {
            if (this.jitter) {
                C -= P / 2
            }
            for (var M = 0; M < R.length; M++) {
                var H = 0;
                for (var L = 0; L < R[M].length; L++) {
                    A = J + ((R[M][L] - I) * B);
                    if (!isNaN(A)) {
                        this.addArea(this.drawShape(F[M][L], A, C + H, D[M][L], D[M][L], S[M][L], T, K[M][L], false, false, true), U[M][L]);
                        if (Q[M] && !isNaN(Q[M])) {
                            r = (Q[M] / 2) * B;
                            this.errorBar(A, C + H, A + r, C + H, N, S[M][L]);
                            this.errorBar(A, C + H, A - r, C + H, N, S[M][L])
                        }
                        H = this.jitter && (L + 1) % (x + 1) ? H + O : 0
                    }
                }
                C += E
            }
        }
    };
    this.drawHeatmap = function(u, k, D, B, q, j, A, s, z, r) {
        var g = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
        var b = this.graphType == "Network" ? false : true;
        for (var m = 0; m < u.length; m++) {
            var C = u[m];
            var y = !isNaN(C) ? this.getHeatmapColor(j, A, C) : this.missingDataColor;
            g = s ? y : g;
            if (this.shapeByShape) {
                this.addArea(this.drawShape(this.shapeByShape, k + (B / 2), D + (q / 2), B / 2, q / 2, y, g, "closed", false, false, b), z[m], r)
            } else {
                this.addArea(this.rectangleHM(k, D, B, q, y, g, "closed", false, false, b), z[m], r)
            } if (this.showDataValues) {
                this.drawText(C, (k + B) - 2, (D + q) - 2, this.overlayFont, this.foreground, "right", "bottom")
            }
            k += B
        }
    };
    this.drawTreemap = function(h, b, n, j, k) {
        var g = this;
        var m = function(d) {
            g.addArea(g.rectangleHM(d.coords.left + b, d.coords.top + n, d.coords.width, d.coords.height, d.color, false, "closed"), d.index);
            if (d.label) {
                var a = g.measureText(d.label, g.smpLabelFont);
                if (a + g.margin < d.coords.width) {
                    g.drawText(d.label, d.coords.left + b + 2, d.coords.top + n, g.smpLabelFont, this.foreground, "left", "top")
                } else {
                    if (a + g.margin < d.coords.height) {
                        g.drawText(d.label, d.coords.left + b, d.coords.top + n + 2, g.smpLabelFont, this.foreground, "right", "top", -Math.PI / 2)
                    }
                }
            }
        };
        var f = function(d) {
            for (var a = 0; a < d.length; a++) {
                if (d[a].children) {
                    f(d[a].children)
                } else {
                    m(d[a])
                }
            }
        };
        for (var e = 0; e < h.length; e++) {
            if (h[e].children) {
                f(h[e].children)
            } else {
                m(h[e])
            }
        }
    }
};
CanvasXpress.prototype.init3dUtils = function() {
    this.set3DRotation = function() {
        var a;
        var d = 0;
        var b = 0;
        if (this.graphType == "Network") {
            d = this.maxRotate != null ? this.maxRotate : 360;
            b = this.minRotate != null ? this.minRotate : 360
        } else {
            if (this.graphType == "Scatter3D" || this.is3DPlot) {
                d = this.maxRotate != null ? this.maxRotate : 90;
                b = this.minRotate != null ? this.minRotate : 0
            }
        } if (this.xRotate > d) {
            this.xRotate = d
        }
        if (this.xRotate < 0) {
            this.xRotate = b
        }
        if (this.yRotate > d) {
            this.yRotate = d
        }
        if (this.yRotate < 0) {
            this.yRotate = b
        }
        if (this.zRotate > d) {
            this.zRotate = d
        }
        if (this.zRotate < 0) {
            this.zRotate = b
        }
        if (this.xRotate > 0) {
            a = 180 / this.xRotate;
            this.ry = Math.PI / a
        } else {
            this.ry = 0
        } if (this.yRotate > 0) {
            a = 180 / this.yRotate;
            this.rx = Math.PI / a
        } else {
            this.rx = 0
        } if (this.zRotate > 0) {
            a = 180 / this.zRotate;
            this.rz = Math.PI / a
        } else {
            this.rz = 0
        }
    };
    this.set3DParams = function() {
        this.perspective = this.x * 1.5;
        this.lenX = this.x / 4 * this.zoom * this.x3DRatio;
        this.lenY = this.x / 4 * this.zoom * this.y3DRatio;
        this.lenZ = this.x / 4 * this.zoom * this.z3DRatio;
        if (this.padX == null || !this.padX) {
            this.padX = this.x / 2
        }
        if (this.padY == null || !this.padY) {
            this.padY = this.y / 2
        }
        if (this.padZ == null || !this.padZ) {
            this.padZ = this.y / 2
        }
    };
    this.get3DTransfrom = function(f, g, h) {
        var e, d, b;
        var a = [];
        d = g;
        b = h;
        g = d * Math.cos(this.rx) - b * Math.sin(this.rx);
        h = d * Math.sin(this.rx) + b * Math.cos(this.rx);
        e = f;
        b = h;
        f = b * Math.sin(this.ry) + e * Math.cos(this.ry);
        h = b * Math.cos(this.ry) - e * Math.sin(this.ry);
        e = f;
        d = g;
        f = e * Math.cos(this.rz) - d * Math.sin(this.rz);
        g = e * Math.sin(this.rz) + d * Math.cos(this.rz);
        f = f * (this.perspective / (h + this.perspective));
        g = g * (this.perspective / (h + this.perspective));
        h = h * (this.perspective / (h + this.perspective));
        a.push(f + this.padX);
        a.push(g + this.padY);
        a.push(h + this.padZ);
        return a
    };
    this.backfaceCulling = function(s) {
        var y = [];
        var w = [];
        var u = [];
        var r = [];
        var q = [];
        var p = [];
        for (var o = 0; o < s.length; o++) {
            var k = s[o][1][0] - s[o][0][0];
            var x = s[o][1][1] - s[o][0][1];
            var n = s[o][1][2] - s[o][0][2];
            var j = s[o][2][0] - s[o][0][0];
            var v = s[o][2][1] - s[o][0][1];
            var m = s[o][2][2] - s[o][0][2];
            var h = s[o][3][0] - s[o][0][0];
            var t = s[o][3][1] - s[o][0][1];
            var l = s[o][3][2] - s[o][0][2];
            y[o] = x * m - v * n;
            w[o] = j * n - k * m;
            u[o] = k * v - j * x;
            r[o] = t * m - v * l;
            q[o] = j * l - h * m;
            p[o] = h * v - j * t
        }
        return [y, w, u, r, q, p]
    }
};
CanvasXpress.prototype.initLegendUtils = function() {
    this.drawDecorationData = function() {
        var ad = this.marginLeft + this.offsetX + this.left;
        var S = this.marginTop + this.offsetY + this.top;
        var ak = this.data.d;
        if (this.showDecorations && ak) {
            if (ak.nlfit) {
                var ah, E, aj;
                var n = this.varIndices;
                var B, a;
                for (var ag = 0; ag < ak.nlfit.length; ag++) {
                    var L = [];
                    var K = [];
                    var o = ag % this.colors.length;
                    var ac = this.transformValue(this.yAxisTransform, ak.nlfit[ag].param[0]);
                    var Z = this.transformValue(this.yAxisTransform, ak.nlfit[ag].param[1]);
                    var V = ak.nlfit[ag].param[2];
                    var T = ak.nlfit[ag].param[3];
                    var M = this.xAxisIndices.length == 1 ? this.xAxisIndices[0] : this.xAxisIndices[ag];
                    var N = this.getDataForSmpGrpAtIndex(M);
                    if (this.xAxisTransform == "percentile") {
                        ah = this.range(N);
                        aj = ah[0];
                        E = ah[1]
                    }
                    n.sort(function(i, d) {
                        return N[i] - N[d]
                    });
                    o = ak.nlfit[ag].color ? ak.nlfit[ag].color : this.colors[o];
                    for (var af = 0; af < n.length; af++) {
                        var u = n[af];
                        var Q = this.getDataAtPos(u, M);
                        var P;
                        var w = [];
                        if (Q > 0) {
                            if (af > 0) {
                                var b = n[af - 1];
                                var O = this.getDataAtPos(b, M);
                                if (O > 0) {
                                    var e = (Q - O) / this.functionIntervals;
                                    for (var ae = 0; ae < this.functionIntervals; ae++) {
                                        w.push(O);
                                        O += e
                                    }
                                }
                            } else {
                                w = [Q]
                            }
                            for (var ae = 0; ae < w.length; ae++) {
                                if (ak.nlfit[ag].type == "reg") {
                                    P = ac + ((Z - ac) / (1 + V / (Math.pow(w[ae], T))))
                                } else {
                                    P = ac + ((Z - ac) / (1 + (Math.pow((w[ae] / V), T))))
                                } if (this.xAxisTransform) {
                                    w[ae] = this.xAxisTransform == "percentile" ? this.percentile(aj, E, w[ae]) : this.transformValue(this.xAxisTransform, w[ae])
                                }
                                B = ad + ((w[ae] - this.xAxisMin) * this.xAxisUnit);
                                a = (S + this.y) - ((P - this.yAxisMin) * this.yAxisUnit);
                                L.push(B);
                                K.push(a)
                            }
                        }
                    }
                    if (L.length > 0) {
                        this.drawShape("path", L, K, false, false, o, o, "open");
                        if (ak.nlfit[ag].type == "reg") {
                            P = ac + ((Z - ac) / (1 + V / (Math.pow(V, T))))
                        } else {
                            P = ac + ((Z - ac) / (1 + (Math.pow((V / V), T))))
                        } if (this.xAxisTransform) {
                            V = this.xAxisTransform == "percentile" ? this.percentile(aj, E, V) : this.transformValue(this.xAxisTransform, V)
                        }
                        B = ad + ((V - this.xAxisMin) * this.xAxisUnit);
                        a = (S + this.y) - ((P - this.yAxisMin) * this.yAxisUnit);
                        this.drawLine("dottedLine", ad, a, B, a, o);
                        this.drawLine("dottedLine", B, a, B, (S + this.y), o)
                    }
                }
            }
            if (ak.line) {
                for (var ag = 0; ag < ak.line.length; ag++) {
                    if (ak.line[ag].x || ak.line[ag].y) {
                        var o = ak.line[ag].color ? ak.line[ag].color : this.colors[ag % this.colors.length];
                        var an = ak.line[ag].type ? ak.line[ag].type : "line";
                        var Q = ak.line[ag].x ? ak.line[ag].x : false;
                        var P = ak.line[ag].y ? ak.line[ag].y : false;
                        var B, a, z, ao;
                        if (Q) {
                            B = ad + ((Q - this.xAxisMin) * this.xAxisUnit);
                            a = S;
                            z = B;
                            ao = a + this.y;
                            this.drawLine(an, B, a, z, ao, o)
                        }
                        if (P) {
                            B = ad;
                            a = S + this.y - ((P - this.yAxisMin) * this.yAxisUnit);
                            z = B + this.x;
                            ao = a;
                            this.drawLine(an, B, a, z, ao, o)
                        }
                    }
                }
            }
            if (ak.lines) {
                for (var ag = 0; ag < ak.lines.length; ag++) {
                    var B, a, z, ao;
                    var al = true;
                    var an = ak.lines[ag].type || "line";
                    var I = ak.lines[ag].color;
                    var R = ak.lines[ag].value || 0;
                    var W = ak.lines[ag].label || false;
                    if (this.graphOrientation == "vertical") {
                        B = this.marginLeft + this.offsetX + this.left;
                        z = B + this.x;
                        a = this.marginTop + this.offsetY + this.top + this.y - ((R - this.xAxisMin) * this.xAxisUnit);
                        ao = a;
                        al = a <= this.marginTop + this.offsetY + this.top + this.y && a >= this.marginTop + this.offsetY + this.top ? true : false
                    } else {
                        B = this.marginLeft + this.offsetX + this.left + ((R - this.xAxisMin) * this.xAxisUnit);
                        z = B;
                        a = this.marginTop + this.offsetY + this.top;
                        ao = a + this.y;
                        al = B <= this.marginLeft + this.offsetX + this.left + this.x && this.marginLeft + this.offsetX + this.left ? true : false
                    } if (al) {
                        if (W) {
                            if (this.graphOrientation == "vertical") {
                                this.drawText(W, z - this.margin, ao - this.margin, this.decorationFont, this.decorationColor, "right", "bottom")
                            } else {
                                this.drawText(W, z + this.margin, ao - this.margin, this.decorationFont, this.decorationColor, "left", "bottom")
                            }
                        }
                        this.drawLine(an, B, a, z, ao, I)
                    }
                }
            }
            if (ak.reg) {
                for (var ag = 0; ag < ak.reg.length; ag++) {
                    if (ak.reg[ag].slope && ak.reg[ag].intercept) {
                        var o = ag % this.colors.length;
                        var an = ak.reg[ag].type ? ak.reg[ag].type : "line";
                        var D = ak.reg[ag].slope;
                        var Y = ak.reg[ag].intercept;
                        var h = ak.reg[ag].cor;
                        var B = ak.reg[ag].start ? ak.reg[ag].start : this.xAxisMin;
                        var a = (D * B) + Y;
                        var z = ak.reg[ag].end ? ak.reg[ag].end : this.xAxisMax;
                        var ao = (D * z) + Y;
                        B = ad + (B * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                        a = (S + this.y) - (a * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        z = ad + (z * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                        ao = (S + this.y) - (ao * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        o = ak.reg[ag].color ? ak.reg[ag].color : this.colors[o];
                        this.drawLine(an, B, a, z, ao, o, false, false, false, false, true)
                    }
                }
            }
            if (ak.nor) {
                for (var ag = 0; ag < ak.nor.length; ag++) {
                    if (ak.nor[ag].mu && ak.nor[ag].sigma) {
                        var ab = [];
                        var X = [];
                        var J = [];
                        var B, a;
                        var o = ag % this.colors.length;
                        var p = ak.nor[ag].mu;
                        var g = ak.nor[ag].sigma;
                        var G = ak.nor[ag].start ? ak.nor[ag].start : ak.nor[ag].yAxis ? this.yAxisMin : this.xAxisMin;
                        var C = ak.nor[ag].end ? ak.nor[ag].end : ak.nor[ag].yAxis ? this.yAxisMax : this.xAxisMax;
                        var m = 120;
                        if (G < p && p < C) {
                            var O, A, F, ai;
                            var e = (p - G) / m;
                            var am = g * g;
                            var U = am * 2;
                            var H = 1 / Math.sqrt(2 * Math.PI * am);
                            if (ak.nor[ag].yAxis) {
                                F = ak.nor[ag].max ? ak.nor[ag].max * this.xAxisUnit : this.x - (this.x * this.axisExtension);
                                ai = F / H;
                                O = G;
                                for (var af = 0; af < m - 1; af++) {
                                    A = (H * Math.pow(Math.E, -Math.pow(O - p, 2) / am));
                                    J.push([O, A]);
                                    B = ad + (A * ai);
                                    a = (S + this.y) - (O * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                                    ab.push(B);
                                    X.push(a);
                                    O += e
                                }
                                e = (C - p) / m;
                                O = p;
                                for (var af = 0; af < m; af++) {
                                    A = (H * Math.pow(Math.E, -Math.pow(O - p, 2) / am));
                                    J.push([O, A]);
                                    B = ad + (A * ai);
                                    a = (S + this.y) - (O * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                                    ab.push(B);
                                    X.push(a);
                                    O += e
                                }
                                o = ak.nor[ag].color ? ak.nor[ag].color : this.colors[o];
                                this.drawShape("path", ab, X, false, false, o, o, "open")
                            } else {
                                F = ak.nor[ag].max ? ak.nor[ag].max * this.yAxisUnit : this.y - (this.y * this.axisExtension);
                                ai = F / H;
                                O = G;
                                for (var af = 0; af < m - 1; af++) {
                                    A = (H * Math.pow(Math.E, -Math.pow(O - p, 2) / am));
                                    J.push([O, A]);
                                    B = ad + (O * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                                    a = (S + this.y) - (A * ai);
                                    ab.push(B);
                                    X.push(a);
                                    O += e
                                }
                                e = (C - p) / m;
                                O = p;
                                for (var af = 0; af < m; af++) {
                                    A = (H * Math.pow(Math.E, -Math.pow(O - p, 2) / am));
                                    J.push([O, A]);
                                    B = ad + (O * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                                    a = (S + this.y) - (A * ai);
                                    ab.push(B);
                                    X.push(a);
                                    O += e
                                }
                                o = ak.nor[ag].color ? ak.nor[ag].color : this.colors[o];
                                this.drawShape("path", ab, X, false, false, o, o, "open")
                            }
                        }
                    }
                }
            }
            if (ak.area) {
                for (var ag = 0; ag < ak.area.length; ag++) {
                    if (ak.area[ag].type && ak.area[ag].x && ak.area[ag].y && ak.area[ag].width && ak.area[ag].height) {
                        if (this.isValidShape(ak.area[ag].type)) {
                            var B = ad + (ak.area[ag].x * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                            var a = (S + this.y) - (ak.area[ag].y * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                            var o = ak.area[ag].color ? ak.area[ag].color : this.colors[ag % this.colors.length];
                            var f = ak.area[ag].width * this.xAxisUnit;
                            var aa = ak.area[ag].height * this.yAxisUnit;
                            this.drawShape(ak.area[ag].type, B, a, f, aa, o, ak.area[ag].outline, ak.area[ag].pattern, ak.area[ag].rotate)
                        }
                    }
                }
            }
            if (ak.kaplanMeyer) {
                var B, a, z, ao, v, s, r, q, o;
                for (var ag = 0; ag < ak.kaplanMeyer.length; ag++) {
                    o = ak.kaplanMeyer[ag].color;
                    B = ad;
                    a = (S + this.y) - (this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                    z = ad + (ak.kaplanMeyer[ag].data.times[0] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                    ao = (S + this.y) - (ak.kaplanMeyer[ag].data.data[0][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                    s = (S + this.y) - (ak.kaplanMeyer[ag].data.data[0][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                    q = (S + this.y) - (ak.kaplanMeyer[ag].data.data[0][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                    this.drawLine("line", B, a, z, a, o);
                    this.drawLine("line", z, a, z, ao, o);
                    if (this.showDecorationsKaplanMeyerConfidence) {
                        this.drawLine("dottedLine", B, a, z, a, o, 0.5);
                        this.drawLine("dottedLine", z, a, z, s, o, 0.5);
                        this.drawLine("dottedLine", B, a, z, a, o, 0.5);
                        this.drawLine("dottedLine", z, a, z, q, o, 0.5)
                    }
                    for (var af = 1; af < ak.kaplanMeyer[ag].data.times.length; af++) {
                        B = ad + (ak.kaplanMeyer[ag].data.times[af - 1] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                        a = (S + this.y) - (ak.kaplanMeyer[ag].data.data[af - 1][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        v = (S + this.y) - (ak.kaplanMeyer[ag].data.data[af - 1][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        r = (S + this.y) - (ak.kaplanMeyer[ag].data.data[af - 1][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        z = ad + (ak.kaplanMeyer[ag].data.times[af] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                        ao = (S + this.y) - (ak.kaplanMeyer[ag].data.data[af][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        s = (S + this.y) - (ak.kaplanMeyer[ag].data.data[af][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        q = (S + this.y) - (ak.kaplanMeyer[ag].data.data[af][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        this.drawLine("line", B, a, z, a, o);
                        this.drawLine("line", z, a, z, ao, o);
                        if (this.showDecorationsKaplanMeyerConfidence) {
                            this.drawLine("dottedLine", B, v, z, v, o, 0.5);
                            this.drawLine("dottedLine", z, v, z, s, o, 0.5);
                            this.drawLine("dottedLine", B, r, z, r, o, 0.5);
                            this.drawLine("dottedLine", z, r, z, q, o, 0.5)
                        }
                    }
                }
            }
        }
    };
    this.setDecorationLegendDimension = function() {
        this.legendDecorationWidth = 0;
        this.legendDecorationHeight = 0;
        var g = this.data.d;
        if (this.showDecorations && g) {
            var l = this.getFontPt(this.decorationFont);
            var k = 0;
            var h = 0;
            var k = 0;
            var b = 0;
            if (g.nlfit) {
                var a = this.measureText(sprintf("%90s", "X"), this.decorationFont) + (this.margin * 5);
                var j = 0;
                for (var f = 0; f < g.nlfit.length; f++) {
                    var e = this.measureText(g.nlfit[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                k = this.margin + j + this.margin + a + this.margin;
                this.legendDecorationHeight = (g.nlfit.length * l * 2) + l + this.margin
            }
            if (g.line) {
                var j = 0;
                for (var f = 0; f < g.line.length; f++) {
                    var e = this.measureText(g.line[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                b = this.margin + j + this.margin;
                this.legendDecorationHeight += (g.line.length * l * 2) + this.margin
            }
            if (g.reg) {
                var a = this.measureText(sprintf("%45s", "X"), this.decorationFont) + (this.margin * 2);
                var j = 0;
                for (var f = 0; f < g.reg.length; f++) {
                    var e = this.measureText(g.reg[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                h = this.margin + j + this.margin + a + this.margin;
                this.legendDecorationHeight += (g.reg.length * l * 2) + l + this.margin
            }
            if (g.nor) {
                var a = this.measureText(sprintf("%30s", "X"), this.decorationFont) + (this.margin * 1);
                var j = 0;
                for (var f = 0; f < g.nor.length; f++) {
                    var e = this.measureText(g.nor[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                k = this.margin + j + this.margin + a + this.margin;
                this.legendDecorationHeight += (g.nor.length * l * 2) + l + this.margin
            }
            if (g.area) {
                var j = 0;
                for (var f = 0; f < g.area.length; f++) {
                    var e = this.measureText(g.area[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                b = this.margin + j + this.margin;
                this.legendDecorationHeight += (g.area.length * l * 2) + this.margin
            }
            if (g.kaplanMeyer) {
                var j = 0;
                for (var f = 0; f < g.kaplanMeyer.length; f++) {
                    var e = this.measureText(g.kaplanMeyer[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                b = this.margin + j + this.margin;
                this.legendDecorationHeight += (g.kaplanMeyer.length * l * 2) + this.margin
            }
            this.legendDecorationWidth = Math.max(Math.max(Math.max(k, h), k), b)
        }
    };
    this.drawDecorationLegend = function() {
        var f = this.marginLeft + this.offsetX + this.left;
        var q = this.marginTop + this.offsetY + this.top;
        var m = this.data.d;
        if (this.showDecorations && m) {
            var r = this.getFontPt(this.decorationFont);
            var e = this.measureText(sprintf("%15s", "X"), this.decorationFont);
            var a, p, n, o;
            if (this.decorationsPosition == "right") {
                p = q + (r / 2) + ((this.y - this.legendDecorationHeight) / 2)
            } else {
                p = (q + this.y + this.bottom) - this.legendDecorationHeight
            } if (m.nlfit) {
                o = (this.margin * 6) + (6 * e);
                if (this.decorationsPosition == "right") {
                    n = (f + this.x + this.right + e) - o
                } else {
                    n = f + ((this.x - this.legendDecorationWidth) / 2) + (this.legendDecorationWidth - o) + e
                }
                a = n;
                this.drawText("Min", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("Max", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("EC50", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("Slope", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("p-Val", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("F-Chg", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                p += r + r;
                for (var k = 0; k < m.nlfit.length; k++) {
                    var g = k % this.colors.length;
                    g = m.nlfit[k].color ? m.nlfit[k].color : this.colors[g];
                    a = (n + this.margin) - e;
                    if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                        a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                    }
                    this.drawText(m.nlfit[k].label, a, p, this.decorationFont, g, "right", "middle");
                    a = n;
                    for (var h = 0; h < 6; h++) {
                        var b = m.nlfit[k].param[h];
                        if (h < 2) {
                            b = this.transformValue(this.yAxisTransform, b)
                        } else {
                            if (h == 2) {
                                b = this.transformValue(this.xAxisTransform, b)
                            }
                        }
                        this.drawText(this.formatNumber(b), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                        a += e + this.margin
                    }
                    p += r + r
                }
            }
            if (m.line) {
                for (var k = 0; k < m.line.length; k++) {
                    if (m.line[k].label) {
                        if (this.decorationsPosition == "right") {
                            a = f + this.x + this.margin
                        } else {
                            a = f + ((this.x - this.legendDecorationWidth) / 2) + this.margin
                        }
                        for (var k = 0; k < m.line.length; k++) {
                            var g = m.line[k].color ? m.line[k].color : this.colors[k % this.colors.length];
                            if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                                a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                            }
                            this.drawText(m.line[k].label, a, p, this.decorationFont, g, "left", "middle");
                            p += r + r
                        }
                    }
                }
            }
            if (m.reg) {
                o = (this.margin * 3) + (3 * e);
                if (this.decorationsPosition == "right") {
                    n = (f + this.x + this.right + e) - o
                } else {
                    n = f + ((this.x - this.legendDecorationWidth) / 2) + (this.legendDecorationWidth - o) + e
                }
                a = n;
                this.drawText("Slope", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("Int", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("Cor", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                p += r + r;
                for (var k = 0; k < m.reg.length; k++) {
                    var g = k % this.colors.length;
                    g = m.reg[k].color ? m.reg[k].color : this.colors[g];
                    a = (n + this.margin) - e;
                    if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                        a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                    }
                    this.drawText(m.reg[k].label, a, p, this.decorationFont, g, "right", "middle");
                    a = n;
                    this.drawText(this.formatNumber(m.reg[k].slope), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                    a += e + this.margin;
                    this.drawText(this.formatNumber(m.reg[k].intercept), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                    a += e + this.margin;
                    this.drawText(this.formatNumber(m.reg[k].cor), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                    a += e + this.margin;
                    p += r + r
                }
            }
            if (m.nor) {
                o = (this.margin * 2) + (2 * e);
                if (this.decorationsPosition == "right") {
                    n = (f + this.x + this.right + e) - o
                } else {
                    n = f + ((this.x - this.legendDecorationWidth) / 2) + (this.legendDecorationWidth - o) + e
                }
                a = n;
                this.drawText("Mu", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("Sigma", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                p += r + r;
                for (var k = 0; k < m.nor.length; k++) {
                    var g = k % this.colors.length;
                    g = m.nor[k].color ? m.nor[k].color : this.colors[g];
                    a = (n + this.margin) - e;
                    if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                        a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                    }
                    this.drawText(m.nor[k].label, a, p, this.decorationFont, g, "right", "middle");
                    a = n;
                    this.drawText(this.formatNumber(m.nor[k].mu), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                    a += e + this.margin;
                    this.drawText(this.formatNumber(m.nor[k].sigma), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                    a += e + this.margin;
                    p += r + r
                }
            }
            if (m.area) {
                for (var k = 0; k < m.area.length; k++) {
                    if (m.area[k].label) {
                        if (this.decorationsPosition == "right") {
                            a = f + this.x + this.margin
                        } else {
                            a = f + ((this.x - this.legendDecorationWidth) / 2) + this.margin
                        }
                        var g = m.area[k].color ? m.area[k].color : this.colors[k % this.colors.length];
                        if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                            a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                        }
                        this.drawText(m.area[k].label, a, p, this.decorationFont, g, "left", "middle");
                        p += r + r
                    }
                }
            }
            if (m.kaplanMeyer) {
                for (var k = 0; k < m.kaplanMeyer.length; k++) {
                    if (m.kaplanMeyer[k].label) {
                        if (this.decorationsPosition == "right") {
                            a = f + this.x + this.margin
                        } else {
                            a = f + ((this.x - this.legendDecorationWidth) / 2) + this.margin
                        }
                        var g = m.kaplanMeyer[k].color ? m.kaplanMeyer[k].color : this.colors[k % this.colors.length];
                        if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                            a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                        }
                        this.drawText(m.kaplanMeyer[k].label, a, p, this.decorationFont, g, "left", "middle");
                        p += r + r
                    }
                }
            }
        }
    };
    this.setLegendFont = function() {
        if (this.autoScaleFont) {
            if (this.layoutComb) {
                this.legendFont = (parseInt(Math.max(this.minTextSize, this.legendFontSize - Math.min(this.layoutRows, this.layoutCols)) * this.legendScaleFontFactor))
            } else {
                var a = this.graphType == "Circular" ? 1.3 : 1;
                this.legendFont = (parseInt(this.legendFontSize * this.legendScaleFontFactor / a))
            }
            this.legendFont = this.legendFontStyle + " " + this.legendFont + "Pt " + this.fontName
        } else {
            this.legendFont = this.legendFontStyle + " " + parseInt(this.legendFontSize) + "Pt " + this.fontName
        }
    };
    this.setSampleLegendDimension = function() {
        this.legendSampleWidth = 0;
        this.legendSampleHeight = 0;
        if (this.xAxisIndices.length != this.yAxisIndices.length || this.xAxisIndices.length > 1) {
            var e = this.getFontPt(this.legendFont);
            var b = 0;
            if (this.xAxisIndices.length == this.yAxisIndices.length && this.xAxisIndices.length > 1) {
                for (var d = 0; d < this.xAxisIndices.length; d++) {
                    var a = this.measureText(this.shortenText(this.xAxis[d], this.maxSmpStringLen) + " vs " + this.shortenText(this.yAxis[d], this.maxSmpStringLen), this.legendFont);
                    b = Math.max(a, b)
                }
            } else {
                if (this.xAxisIndices.length > this.yAxisIndices.length) {
                    b = this.measureText(this.shortenText(this.getMaxText(this.xAxis), this.maxSmpStringLen) + " vs " + this.shortenText(this.yAxis[0], this.maxSmpStringLen), this.legendFont)
                } else {
                    if (this.yAxisIndices.length > this.xAxisIndices.length) {
                        b = this.measureText(this.shortenText(this.getMaxText(this.yAxis), this.maxSmpStringLen) + " vs " + this.shortenText(this.xAxis[0], this.maxSmpStringLen), this.legendFont)
                    }
                }
            }
            this.legendSampleWidth = (e - 1) + b + (this.margin * 3);
            this.legendSampleHeight = (Math.max(this.xAxisIndices.length, this.yAxisIndices.length) * (e + this.margin)) + this.margin
        }
    };
    this.drawSampleLegend = function(b, l) {
        var k = b;
        var e = l;
        var q = this.getFontPt(this.legendFont);
        var p = (q - 1) / 2;
        l += this.margin + p;
        if (this.legendBox) {
            this.disableGradientTransparencyShadow();
            this.rectangle(k, e, this.legendSampleWidth, this.legendSampleHeight, this.legendBackgroundColor, this.legendBoxColor);
            this.enableGradientTransparencyShadow()
        }
        var n = Math.max(this.xAxisIndices.length, this.yAxisIndices.length);
        for (var g = 0; g < n; g++) {
            var d = g % this.colors.length;
            var o = 0;
            var h = this.xAxisIndices.length == this.yAxisIndices.length ? this.yAxis[g] : this.xAxisIndices.length > this.yAxisIndices.length ? this.yAxis[this.yAxisCurrent] : this.yAxis[g];
            var j = this.xAxisIndices.length == this.yAxisIndices.length ? this.xAxis[g] : this.xAxisIndices.length > this.yAxisIndices.length ? this.xAxis[g] : this.xAxis[this.xAxisCurrent];
            var m = this.shortenText(h, this.maxSmpStringLen) + " vs " + this.shortenText(j, this.maxSmpStringLen);
            var f = b + p + this.margin;
            var a = l + p + this.margin;
            if (this.colorBy) {
                this.drawShape(this.shapes[o], f, l, q - 1, q - 1, this.background, this.colors[d], "open")
            } else {
                this.drawShape(this.shapes[o], f, l, q - 1, q - 1, this.colors[d], this.foreground, "closed")
            }
            this.drawText(m, f + p + this.margin, l, this.legendFont, this.legendColor, "left", "middle");
            l += q + this.margin
        }
        if (this.legendBox) {
            this.disableGradientTransparencyShadow();
            this.rectangle(k, e, this.legendSampleWidth, this.legendSampleHeight, false, this.legendBoxColor, "open");
            this.enableGradientTransparencyShadow()
        }
        this.addArea(["rect", k, e, k + this.legendSampleWidth, e + this.legendSampleHeight], [-1], "-legend-sample")
    };
    this.setVariableLegendDimension = function() {
        this.legendVariableWidth = 0;
        this.legendVariableHeight = 0;
        if ((this.colorBy && this.colorBy == "variable") || (this.shapeBy && this.shapeBy == "variable") || (this.sizeBy && this.sizeBy == "variable")) {
            var a = this.sizeBy && this.sizeBy == "variable" ? Math.max(this.sizes[this.varIndices.length - 1], this.getFontPt(this.legendFont)) : this.getFontPt(this.legendFont);
            var b = this.shortenText(this.maxVarNameStr, this.maxVarStringLen);
            this.legendVariableWidth = (a - 1) + this.measureText(b, this.legendFont) + (this.margin * 3);
            this.legendVariableHeight = (this.varIndices.length * (a + this.margin)) + this.margin
        }
    };
    this.drawVariableLegend = function(d, m) {
        if ((this.colorBy && this.colorBy == "variable") || (this.shapeBy && this.shapeBy == "variable") || (this.sizeBy && this.sizeBy == "variable")) {
            var k = d;
            var f = m;
            var q = this.getFontPt(this.legendFont);
            var l = this.sizeBy && this.sizeBy == "variable" ? Math.max(this.sizes[this.varIndices.length - 1], q) : q;
            m += this.margin + (l / 2);
            if (this.legendBox && this.legendBackgroundColor) {
                this.disableGradientTransparencyShadow();
                this.rectangle(k, f, this.legendVariableWidth, this.legendVariableHeight, this.legendBackgroundColor, this.legendBoxColor);
                this.enableGradientTransparencyShadow()
            }
            for (var h = 0; h < this.varIndices.length; h++) {
                var n = this.varIndices[h];
                var e = this.graphType == "Circular" || (this.colorBy && this.colorBy == "variable") ? h % this.colors.length : 0;
                var p = this.shapeBy && this.shapeBy == "variable" ? h % this.shapes.length : 0;
                var b = this.sizeBy && this.sizeBy == "variable" ? this.sizes[h % this.sizes.length] : l;
                var o = l / 2;
                var g = d + o + this.margin;
                var a = m + o + this.margin;
                var j = this.shortenText(this.data.y.vars[n], this.maxVarStringLen);
                if (this.colorBy && this.colorBy != "variable") {
                    this.drawShape(this.shapes[p], g, m, b, b, this.background, this.foreground, "open")
                } else {
                    this.drawShape(this.shapes[p], g, m, b, b, this.colors[e], this.foreground, "closed")
                }
                this.drawText(j, g + o + this.margin, m, this.legendFont, this.legendColor, "left", "middle");
                m += l + this.margin
            }
            if (this.legendBox) {
                this.disableGradientTransparencyShadow();
                this.rectangle(k, f, this.legendVariableWidth, this.legendVariableHeight, false, this.legendBoxColor, "open");
                this.enableGradientTransparencyShadow()
            }
            this.addArea(["rect", k, f, k + this.legendVariableWidth, f + this.legendVariableHeight], [-1], "-legend-variable")
        }
    };
    this.setColorLegendIndicatorDimensions = function() {
        if (this.colorBy || this.outlineBy) {
            var a = this.heatmapType.split("-");
            if (this.heatmapType.split("-").length > 1) {
                this.legendColorIndicatorWidth = parseInt(2 * 256 * this.indicatorWidth / this.indicatorBins) + (this.margin * 4) + 1
            } else {
                this.legendColorIndicatorWidth = parseInt(1 * 256 * this.indicatorWidth / this.indicatorBins) + (this.margin * 4) + 1
            }
            this.legendColorIndicatorHeight = this.indicatorHeight + (this.margin * 3) + this.getFontPt(this.legendFont);
            this.legendColorIndicatorHeight += this.getFontPt(this.legendFont) + this.margin
        }
    };
    this.getHeatmapColor = function(e, d, f) {
        var b = Math.abs(e);
        e += b;
        d += b;
        f += b;
        var a = ((f - e) * this.heatmapColors.length / (d - e)).toFixed() - 1;
        return this.heatmapColors[Math.max(0, Math.min(this.heatmapColors.length - 1, a))]
    };
    this.drawColorIndicator = function(d, n, f, l, h, b) {
        if (this.colorBy || this.outlineBy || b) {
            var k = d;
            var e = n;
            var a = this.indicatorHeight;
            var m = this.indicatorHeight;
            if (this.indicatorsPosition == "bottom") {
                for (var g = 0; g < this.heatmapColors.length; g++) {
                    var j = this.transparency != null ? this.addColorTransparency(this.heatmapColors[g], this.transparency) : this.heatmapColors[g];
                    this.drawLine("line", d, n, d, n + m, j, this.indicatorWidth + 0.5);
                    d += this.indicatorWidth
                }
                d = k - (this.indicatorWidth / 2);
                n += m + this.margin;
                this.drawText(sprintf("%." + h + "f", f), d, n, this.legendFont, this.legendColor, "center", "top");
                d += (this.heatmapColors.length * this.indicatorWidth / 2) - (this.indicatorWidth / 2);
                if (this.heatmapColors.length >= 10) {
                    this.drawText(sprintf("%." + h + "f", (f + l) / 2), d, n, this.legendFont, this.legendColor, "center", "top")
                }
                if (!b) {
                    this.drawText(this.colorBy || this.outlineBy, d, n + this.margin + this.getFontPt(this.legendFont), this.legendFont, this.legendColor, "center", "top")
                }
                d += (this.heatmapColors.length * this.indicatorWidth / 2) - (this.indicatorWidth / 2);
                this.drawText(sprintf("%." + h + "f", l), d, n, this.legendFont, this.legendColor, "center", "top");
                this.addArea(["rect", k - (this.margin * 2), e - this.margin, d + (this.margin * 2), n + this.getFontPt(this.legendFont) + this.margin], [-1], "-legend-indicator-color")
            } else {
                for (var g = 0; g < this.heatmapColors.length; g++) {
                    var j = this.transparency != null ? this.addColorTransparency(this.heatmapColors[g], this.transparency) : this.heatmapColors[g];
                    this.drawLine("line", d, n, d + a, n, j, this.indicatorWidth + 0.5);
                    n -= this.indicatorWidth
                }
                d += a + this.margin;
                n = e - (this.indicatorWidth / 2);
                this.drawText(sprintf("%." + h + "f", f), d, n, this.legendFont, this.legendColor, "center", "top", -Math.PI / 2);
                n -= (this.heatmapColors.length * this.indicatorWidth / 2) - (this.indicatorWidth / 2);
                if (this.heatmapColors.length >= 10) {
                    this.drawText(sprintf("%." + h + "f", (f + l) / 2), d, n, this.legendFont, this.legendColor, "center", "top", -Math.PI / 2)
                }
                if (!b) {
                    this.drawText(this.colorBy || this.outlineBy, d + this.margin + this.getFontPt(this.legendFont), n, this.legendFont, this.legendColor, "center", "top", -Math.PI / 2)
                }
                n -= (this.heatmapColors.length * this.indicatorWidth / 2) - (this.indicatorWidth / 2);
                this.drawText(sprintf("%." + h + "f", l), d, n, this.legendFont, this.legendColor, "center", "top", -Math.PI / 2);
                this.addArea(["rect", k - this.margin, n - (this.margin * 2), d + this.margin + this.getFontPt(this.legendFont), e + (this.margin * 2)], [-1], "-legend-indicator-color")
            }
        }
    };
    this.setShapeLegendIndicatorDimensions = function() {
        if (this.shapeBy) {
            this.legendShapeIndicatorWidth = (10 * (this.indicatorHeight + this.margin)) + (this.margin * 2);
            this.legendShapeIndicatorHeight = this.indicatorHeight + (this.margin * 3) + this.getFontPt(this.legendFont);
            this.legendShapeIndicatorHeight += this.getFontPt(this.legendFont) + this.margin
        }
    };
    this.drawShapeIndicator = function(b, n, f, m, j) {
        if (this.shapeBy) {
            var l = b;
            var d = n;
            var k = this.indicatorHeight / 2;
            var e = b;
            var a = n;
            if (this.indicatorsPosition == "bottom") {
                for (var g = 0; g < 10; g++) {
                    this.drawShape("pie" + g, e, a + this.margin, this.indicatorHeight, this.indicatorHeight, this.background, this.foreground, "open");
                    e += this.indicatorHeight + k
                }
                b = l;
                n += this.indicatorHeight + this.margin;
                this.drawText(sprintf("%." + j + "f", f), b, n, this.legendFont, this.legendColor, "center", "top");
                b += this.indicatorHeight * 7;
                this.drawText(sprintf("%." + j + "f", (f + m) / 2), b, n, this.legendFont, this.legendColor, "center", "top");
                this.drawText(this.shapeBy || shapeBy, b, n + this.margin + this.getFontPt(this.legendFont), this.legendFont, this.legendColor, "center", "top");
                b += this.indicatorHeight * 7;
                this.drawText(sprintf("%." + j + "f", m), b, n, this.legendFont, this.legendColor, "center", "top");
                this.addArea(["rect", l - (this.margin * 2), d - this.margin, b + (this.margin * 2), n + this.getFontPt(this.legendFont) + this.margin], [-1], "-legend-indicator-shape")
            } else {
                for (var g = 0; g < 10; g++) {
                    this.drawShape("pie" + g, e + this.margin, a, this.indicatorHeight, this.indicatorHeight, this.background, this.foreground, "open");
                    a -= this.indicatorHeight + k
                }
                b += this.indicatorHeight + this.margin;
                n = d;
                this.drawText(sprintf("%." + j + "f", f), b, n, this.legendFont, this.legendColor, "center", "top", -Math.PI / 2);
                n -= this.indicatorHeight * 7;
                if (this.heatmapColors.length >= 10) {
                    this.drawText(sprintf("%." + j + "f", (f + m) / 2), b, n, this.legendFont, this.legendColor, "center", "top", -Math.PI / 2)
                }
                this.drawText(this.shapeBy || shapeBy, b + this.margin + this.getFontPt(this.legendFont), n, this.legendFont, this.legendColor, "center", "top", -Math.PI / 2);
                n -= this.indicatorHeight * 7;
                this.drawText(sprintf("%." + j + "f", m), b, n, this.legendFont, this.legendColor, "center", "top", -Math.PI / 2);
                this.addArea(["rect", l - this.margin, n - (this.margin * 2), b + this.margin + this.getFontPt(this.legendFont), d + (this.margin * 2)], [-1], "-legend-indicator-shape")
            }
        }
    };
    this.setSizeLegendIndicatorDimensions = function() {
        if (this.sizeBy) {
            var a = 0;
            var d = this.indicatorHeight / 2;
            for (var b = 0; b < 10; b++) {
                a += this.sizes[b] + d
            }
            this.legendSizeIndicatorWidth = (a - (this.sizes[0] + this.sizes[9])) + (this.margin * 4);
            this.legendSizeIndicatorHeight = this.sizes[9] + (this.margin * 3) + this.getFontPt(this.legendFont);
            this.legendSizeIndicatorHeight += this.getFontPt(this.legendFont) + this.margin
        }
    };
    this.drawSizeIndicator = function(e, q, j, p, l) {
        if (this.sizeBy) {
            var o = e;
            var f = q;
            var m = this.indicatorHeight / 2;
            var r = this.sizes[9];
            var g = e;
            var a = q;
            var n = e;
            var d = q;
            if (this.indicatorsPosition == "bottom") {
                for (var k = 0; k < 10; k++) {
                    var b = this.sizes[k];
                    this.drawShape("sphere", g, a + (r / 2), b, b, this.background, this.foreground, "open");
                    g += b + m;
                    if (k < 4) {
                        n += b + m
                    } else {
                        if (k == 5) {
                            n += (b + m) / 2
                        }
                    }
                }
                q += r + this.margin;
                this.drawText(sprintf("%." + l + "f", j), o, q, this.legendFont, this.legendColor, "center", "top");
                this.drawText(sprintf("%." + l + "f", (j + p) / 2), n, q, this.legendFont, this.legendColor, "center", "top");
                this.drawText(this.sizeBy, o + (this.legendSizeIndicatorWidth / 2), q + this.margin + this.getFontPt(this.legendFont), this.legendFont, this.legendColor, "center", "top");
                this.drawText(sprintf("%." + l + "f", p), g - (r + m), q, this.legendFont, this.legendColor, "center", "top");
                this.addArea(["rect", o - (this.margin * 2), f - this.margin, (g - r) + (this.margin * 2), q + this.getFontPt(this.legendFont) + this.margin], [-1], "-legend-indicator-size")
            } else {
                for (var k = 0; k < 10; k++) {
                    var b = this.sizes[k];
                    this.drawShape("sphere", g + (r / 2), a, b, b, this.background, this.foreground, "open");
                    a -= (b + m);
                    if (k < 4) {
                        d -= (b + m)
                    } else {
                        if (k == 5) {
                            d -= ((b + m) / 2)
                        }
                    }
                }
                e += r + this.margin;
                this.drawText(sprintf("%." + l + "f", j), e, q, this.legendFont, this.legendColor, "center", "top", -Math.PI / 2);
                this.drawText(sprintf("%." + l + "f", (j + p) / 2), e, d, this.legendFont, this.legendColor, "center", "top", -Math.PI / 2);
                this.drawText(this.sizeBy, e + this.margin + this.getFontPt(this.legendFont), f - (this.legendSizeIndicatorWidth / 2), this.legendFont, this.legendColor, "center", "top", -Math.PI / 2);
                this.drawText(sprintf("%." + l + "f", p), e, a + (r + m), this.legendFont, this.legendColor, "center", "top", -Math.PI / 2);
                this.addArea(["rect", o - this.margin, (a + (r + m)) - (this.margin * 2), e + this.margin + this.getFontPt(this.legendFont), f + (this.margin * 2)], [-1], "-legend-indicator-size")
            }
        }
    };
    this.setDataColorShapeSizeIndicatorDimensions = function() {
        this.setColorLegendIndicatorDimensions();
        this.setShapeLegendIndicatorDimensions();
        this.setSizeLegendIndicatorDimensions()
    };
    this.getDiameterLegend = function() {
        return this.x >= 600 ? 10 : this.x >= 400 ? 8 : this.x >= 200 ? 6 : 4
    };
    this.setColorLegendDimensions = function(a) {
        this.legendColorWidth = 0;
        this.legendColorHeight = 0;
        if (this.colorBy || this.outlineBy) {
            var g, f;
            var j = this.getDiameterLegend();
            if (a) {
                g = this.colorBy || this.outlineBy;
                f = a
            } else {
                if (this.data.x && this.data.x.hasOwnProperty(this.colorBy)) {
                    g = this.setMaxSmpStringAnnt(this.colorBy);
                    f = this.legendColorsMax
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.colorBy)) {
                        g = this.setMaxVarStringAnnt(this.colorBy);
                        f = this.setMaxVarStringLabel(this.colorBy)
                    } else {
                        g = 0;
                        f = 0
                    }
                }
            }
            var b = this.measureText(g, this.legendFont);
            var e = this.measureText(f, this.legendFont) + j + this.margin;
            this.legendColorWidth = Math.max(b, e) + (this.margin * 2);
            var i = this.getFontPt(this.legendFont);
            var h = Math.max(j, i);
            this.legendColorHeight = (this.legendColorsN * (h + this.margin)) + i + (this.margin * 3)
        }
    };
    this.drawColorLegend = function(e, f) {
        if ((this.outlineBy && this.isMultidimensionalHeatmap) || (this.colorBy && ((this.data.x && this.data.x.hasOwnProperty(this.colorBy)) || (this.data.z && this.data.z.hasOwnProperty(this.colorBy))))) {
            var i = this.getDiameterLegend();
            var g = this.getFontPt(this.legendFont);
            var j = g / 2;
            var h = f + this.margin + j;
            var a = Math.max(i, g);
            this.disableGradientTransparencyShadow();
            if (this.legendBackgroundColor) {
                this.rectangle(e, f, this.legendColorWidth, this.legendColorHeight, this.legendBackgroundColor, this.legendBoxColor)
            } else {
                this.rectangle(e, f, this.legendColorWidth, this.legendColorHeight, false, this.legendBoxColor, "open")
            }
            this.enableGradientTransparencyShadow();
            this.drawText(this.colorBy || this.outlineBy, e + (this.legendColorWidth / 2), h, this.legendFont, this.colorLegend, "center", "middle");
            h += j + this.margin;
            this.disableGradientTransparencyShadow();
            this.drawLine("line", e, h, e + this.legendColorWidth, h, this.legendBoxColor);
            this.enableGradientTransparencyShadow();
            h += this.margin + (a / 2);
            for (var b in this.legendColors) {
                if (this.outlineBy) {
                    this.drawShape("circle", e + this.margin + (i / 2), h, i, i, false, this.legendColors[b], "open", false, 2)
                } else {
                    this.drawShape("circle", e + this.margin + (i / 2), h, i, i, this.legendColors[b], this.foreground, "closed")
                }
                this.drawText(b, e + (this.margin * 2) + i, h, this.legendFont, this.colorLegend, "left", "middle");
                h += this.margin + a
            }
            this.addArea(["rect", e, f, e + this.legendColorWidth, f + this.legendColorHeight], [-1], "-legend-color")
        }
    };
    this.setShapeLegendDimensions = function(a) {
        this.legendShapeWidth = 0;
        this.legendShapeHeight = 0;
        if (this.shapeBy) {
            var g, f;
            var j = this.getDiameterLegend();
            if (a) {
                g = this.shapeBy;
                f = a
            } else {
                if (this.data.x && this.data.x.hasOwnProperty(this.shapeBy)) {
                    g = this.setMaxSmpStringAnnt(this.shapeBy);
                    f = this.legendShapesMax
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.shapeBy)) {
                        g = this.setMaxVarStringAnnt(this.shapeBy);
                        f = this.setMaxVarStringLabel(this.shapeBy)
                    } else {
                        g = 0;
                        f = 0
                    }
                }
            }
            var b = this.measureText(g, this.legendFont);
            var e = this.measureText(f, this.legendFont) + j + this.margin;
            this.legendShapeWidth = Math.max(b, e) + (this.margin * 2);
            var i = this.getFontPt(this.legendFont);
            var h = Math.max(j, i);
            this.legendShapeHeight = (this.legendShapesN * (h + this.margin)) + i + (this.margin * 3)
        }
    };
    this.drawShapeLegend = function(b, e) {
        if ((this.shapeBy && this.isMultidimensionalHeatmap) || (this.shapeBy && ((this.data.x && this.data.x.hasOwnProperty(this.shapeBy)) || (this.data.z && this.data.z.hasOwnProperty(this.shapeBy))))) {
            var i = this.getDiameterLegend();
            var f = this.getFontPt(this.legendFont);
            var j = f / 2;
            var h = e + this.margin + j;
            var a = Math.max(i, f);
            this.disableGradientTransparencyShadow();
            if (this.legendBackgroundColor) {
                this.rectangle(b, e, this.legendShapeWidth, this.legendShapeHeight, this.legendBackgroundColor, this.legendBoxColor)
            } else {
                this.rectangle(b, e, this.legendShapeWidth, this.legendShapeHeight, false, this.legendBoxColor, "open")
            }
            this.enableGradientTransparencyShadow();
            this.drawText(this.shapeBy, b + (this.legendShapeWidth / 2), h, this.legendFont, this.colorLegend, "center", "middle");
            h += j + this.margin;
            this.disableGradientTransparencyShadow();
            this.drawLine("line", b, h, b + this.legendShapeWidth, h, this.legendBoxColor);
            this.enableGradientTransparencyShadow();
            h += this.margin + (a / 2);
            for (var g in this.legendShapes) {
                this.drawShape(this.legendShapes[g], b + this.margin + (i / 2), h, i, i, this.background, this.foreground, "closed");
                this.drawText(g, b + (this.margin * 2) + i, h, this.legendFont, this.colorLegend, "left", "middle");
                h += this.margin + a
            }
            this.addArea(["rect", b, e, b + this.legendShapeWidth, e + this.legendShapeHeight], [-1], "-legend-shape")
        }
    };
    this.setSizeLegendDimensions = function(a) {
        this.legendSizeWidth = 0;
        this.legendSizeHeight = 0;
        if (this.sizeBy) {
            var g, f;
            var j = this.sizes[this.legendSizesN - 1];
            if (a) {
                g = this.sizeBy;
                f = a
            } else {
                if (this.data.x && this.data.x.hasOwnProperty(this.sizeBy)) {
                    g = this.setMaxSmpStringAnnt(this.sizeBy);
                    f = this.legendSizesMax
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.sizeBy)) {
                        g = this.setMaxVarStringAnnt(this.sizeBy);
                        f = this.setMaxVarStringLabel(this.sizeBy)
                    } else {
                        g = 0;
                        f = 0
                    }
                }
            }
            var b = this.measureText(g, this.legendFont);
            var e = this.measureText(f, this.legendFont) + j + this.margin;
            this.legendSizeWidth = Math.max(b, e) + (this.margin * 2);
            var i = this.getFontPt(this.legendFont);
            var h = Math.max(j, i);
            this.legendSizeHeight = (this.legendSizesN * (h + this.margin)) + i + (this.margin * 3)
        }
    };
    this.drawSizeLegend = function(e, f) {
        if ((this.sizeBy && this.isMultidimensionalHeatmap) || (this.sizeBy && ((this.data.x && this.data.x.hasOwnProperty(this.sizeBy)) || (this.data.z && this.data.z.hasOwnProperty(this.sizeBy))))) {
            var i = this.sizes[this.legendSizesN - 1];
            var g = this.getFontPt(this.legendFont);
            var j = g / 2;
            var h = f + this.margin + j;
            var a = Math.max(i, g);
            this.disableGradientTransparencyShadow();
            if (this.legendBackgroundColor) {
                this.rectangle(e, f, this.legendSizeWidth, this.legendSizeHeight, this.legendBackgroundColor, this.legendBoxColor)
            } else {
                this.rectangle(e, f, this.legendSizeWidth, this.legendSizeHeight, false, this.legendBoxColor, "open")
            }
            this.enableGradientTransparencyShadow();
            this.drawText(this.sizeBy, e + (this.legendSizeWidth / 2), h, this.legendFont, this.colorLegend, "center", "middle");
            h += j + this.margin;
            this.disableGradientTransparencyShadow();
            this.drawLine("line", e, h, e + this.legendSizeWidth, h, this.legendBoxColor);
            this.enableGradientTransparencyShadow();
            h += this.margin + (a / 2);
            for (var b in this.legendSizes) {
                this.drawShape("circle", e + this.margin + (i / 2), h, this.legendSizes[b], this.legendSizes[b], this.background, this.foreground, "closed");
                this.drawText(b, e + (this.margin * 2) + i, h, this.legendFont, this.colorLegend, "left", "middle");
                h += this.margin + a
            }
            this.addArea(["rect", e, f, e + this.legendSizeWidth, f + this.legendSizeHeight], [-1], "-legend-size")
        }
    };
    this.setDataColorShapeSizeDimensions = function() {
        this.setColorLegendDimensions();
        this.setShapeLegendDimensions();
        this.setSizeLegendDimensions()
    };
    this.setDataColor = function(e) {
        this.colorByType = false;
        if (e && this.isMultidimensionalHeatmap) {
            var m = 0;
            var a = {};
            this.dataColors = [];
            this.legendColors = {};
            this.legendColorsN = 0;
            if (this.isNumeric2DArray(e)) {
                var h = this.setRangeDataObject(e);
                for (var g = 0; g < this.varIndices.length; g++) {
                    for (var f = 0; f < this.smpIndices.length; f++) {
                        var b = e[this.varIndices[g]][this.smpIndices[f]];
                        var d = !isNaN(b) ? this.getHeatmapColor(h[0], h[1], b) : this.missingDataColor;
                        this.dataColors.push(d)
                    }
                }
                this.legendColorsN = -1;
                this.legendColorRange = h;
                this.legendColorDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], this.heatmapColors.length));
                this.setColorLegendIndicatorDimensions()
            } else {
                var l = 0;
                for (var g = 0; g < this.varIndices.length; g++) {
                    for (var f = 0; f < this.smpIndices.length; f++) {
                        var d = e[this.varIndices[g]][this.smpIndices[f]];
                        if (!a.hasOwnProperty(d)) {
                            var k = this.measureText(d, this.legendFont);
                            if (k > l) {
                                l = k;
                                this.legendColorsMax = d
                            }
                            a[d] = m % this.colors.length;
                            this.legendColors[d] = this.colors[a[d]];
                            m++
                        }
                        this.dataColors.push(this.colors[a[d]])
                    }
                }
                this.legendColorsN = m;
                this.setColorLegendDimensions(this.legendColorsMax)
            }
        } else {
            if (this.colorBy) {
                var m = 0;
                var a = {};
                this.dataColors = [];
                this.legendColors = {};
                this.legendColorsN = 0;
                if (this.data.x && this.data.x.hasOwnProperty(this.colorBy)) {
                    this.colorByType = "x";
                    var o = this.isGroupedData ? this.grpIndices : this.smpIndices;
                    if (this.isNumeric(this.data.x[this.colorBy], true)) {
                        var h = this.range(this.data.x[this.colorBy], true);
                        for (var g = 0; g < o.length; g++) {
                            var n = o[g];
                            if (this.isGroupedData && (this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData))) {
                                for (var f = 0; f < this.data.w.grps[n].length; f++) {
                                    var b = this.data.x[this.colorBy][this.data.w.grps[n][f]];
                                    var d = !isNaN(b) ? this.getHeatmapColor(h[0], h[1], b) : this.missingDataColor;
                                    this.dataColors.push(d)
                                }
                            } else {
                                var b = this.isGroupedData ? this.mean(this.getSmpAnnotations(this.colorBy, this.data.w.grps[g], false, true)) : this.data.x[this.colorBy][n];
                                var d = !isNaN(b) ? this.getHeatmapColor(h[0], h[1], b) : this.missingDataColor;
                                this.dataColors.push(d)
                            }
                        }
                        this.legendColorsN = -1;
                        this.legendColorRange = h;
                        this.legendColorDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], this.heatmapColors.length));
                        this.setColorLegendIndicatorDimensions()
                    } else {
                        var l = 0;
                        for (var g = 0; g < o.length; g++) {
                            var n = o[g];
                            if (this.isGroupedData && (this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData))) {
                                for (var f = 0; f < this.data.w.grps[n].length; f++) {
                                    var d = this.data.x[this.colorBy][this.data.w.grps[n][f]];
                                    if (!a.hasOwnProperty(d)) {
                                        var k = this.measureText(d, this.legendFont);
                                        if (k > l) {
                                            l = k;
                                            this.legendColorsMax = d
                                        }
                                        a[d] = m % this.colors.length;
                                        this.legendColors[d] = this.colors[a[d]];
                                        m++
                                    }
                                    this.dataColors.push(this.colors[a[d]])
                                }
                            } else {
                                var d = this.isGroupedData ? this.getSmpAnnotations(this.colorBy, this.data.w.grps[g], true) : this.data.x[this.colorBy][n];
                                if (!a.hasOwnProperty(d)) {
                                    var k = this.measureText(d, this.legendFont);
                                    if (k > l) {
                                        l = k;
                                        this.legendColorsMax = d
                                    }
                                    a[d] = m % this.colors.length;
                                    this.legendColors[d] = this.colors[a[d]];
                                    m++
                                }
                                this.dataColors.push(this.colors[a[d]])
                            }
                        }
                        this.legendColorsN = m;
                        this.setColorLegendDimensions()
                    }
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.colorBy)) {
                        this.colorByType = "z";
                        if (this.isNumeric(this.data.z[this.colorBy], false, true)) {
                            var h = this.range(this.data.z[this.colorBy], false, true);
                            for (var g = 0; g < this.varIndices.length; g++) {
                                var n = this.varIndices[g];
                                var b = this.data.z[this.colorBy][n];
                                if (!isNaN(b)) {
                                    this.dataColors.push(this.getHeatmapColor(h[0], h[1], b))
                                } else {
                                    this.dataColors.push(this.missingDataColor)
                                }
                            }
                            this.legendColorRange = h;
                            this.legendColorDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], this.heatmapColors.length));
                            this.setColorLegendIndicatorDimensions()
                        } else {
                            for (var g = 0; g < this.varIndices.length; g++) {
                                var n = this.varIndices[g];
                                var d = this.data.z[this.colorBy][n];
                                if (!a.hasOwnProperty(d)) {
                                    a[d] = m % this.colors.length;
                                    this.legendColors[d] = this.colors[a[d]];
                                    m++
                                }
                                this.dataColors.push(this.colors[a[d]])
                            }
                            this.legendColorsN = m;
                            this.setColorLegendDimensions()
                        }
                    } else {
                        if (this.getSampleIndices(this.colorBy) > -1) {
                            m = this.getSampleIndices(this.colorBy);
                            var h = this.getAxisRangeBySample(m);
                            if (!this.scatterType || this.scatterType != "function") {
                                for (var g = 0; g < this.varIndices.length; g++) {
                                    var n = this.varIndices[g];
                                    var b = this.getDataAtPos(n, m);
                                    if (!isNaN(b)) {
                                        this.dataColors.push(this.getHeatmapColor(h[0], h[1], b))
                                    } else {
                                        this.dataColors.push(this.missingDataColor)
                                    }
                                }
                            }
                            this.legendColorRange = h;
                            this.legendColorDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], this.heatmapColors.length));
                            this.setColorLegendIndicatorDimensions()
                        } else {
                            if (this.colorBy == "variable") {
                                for (var g = 0; g < this.varIndices.length; g++) {
                                    var d = g % this.colors.length;
                                    this.dataColors.push(this.colors[d])
                                }
                                this.legendColorsN = this.dataColors.length;
                                this.setVariableLegendDimension()
                            } else {
                                for (var g = 0; g < this.varIndices.length; g++) {
                                    this.dataColors.push(this.colors[0])
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.setDataShape = function(d) {
        this.shapeByType = false;
        if (d && this.isMultidimensionalHeatmap) {
            var m = 0;
            var a = {};
            var q = "square";
            this.dataShapes = [];
            this.legendShapes = {};
            this.legendShapesN = 0;
            if (this.isNumeric2DArray(d)) {
                var h = this.setRangeDataObject(d);
                for (var g = 0; g < this.varIndices.length; g++) {
                    for (var f = 0; f < this.smpIndices.length; f++) {
                        var b = d[this.varIndices[g]][this.smpIndices[f]];
                        if (!isNaN(b)) {
                            var e = this.percentile(h[0], h[1], b);
                            var p = parseInt(e / 10);
                            if (p > 0) {
                                p--
                            }
                            this.dataShapes.push("pie" + p)
                        } else {
                            this.dataShapes.push(q)
                        }
                    }
                }
                this.legendShapeRange = h;
                this.legendShapeDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], 10));
                this.setShapeLegendIndicatorDimensions()
            } else {
                var l = 0;
                for (var g = 0; g < this.varIndices.length; g++) {
                    for (var f = 0; f < this.smpIndices.length; f++) {
                        var p = d[this.varIndices[g]][this.smpIndices[f]];
                        if (!a.hasOwnProperty(p)) {
                            var k = this.measureText(p, this.legendFont);
                            if (k > l) {
                                l = k;
                                this.legendShapesMax = p
                            }
                            a[p] = m % this.shapes.length;
                            this.legendShapes[p] = this.shapes[a[p]];
                            m++
                        }
                        this.dataShapes.push(this.shapes[a[p]])
                    }
                }
                this.legendShapesN = m;
                this.setShapeLegendDimensions(this.legendShapesMax)
            }
        } else {
            if (this.shapeBy) {
                var m = 0;
                var a = {};
                var q = "square";
                this.dataShapes = [];
                this.legendShapes = {};
                this.legendShapesN = 0;
                if (this.data.x && this.data.x.hasOwnProperty(this.shapeBy)) {
                    this.shapeByType = "x";
                    var o = this.isGroupedData ? this.grpIndices : this.smpIndices;
                    if (this.isNumeric(this.data.x[this.shapeBy], true)) {
                        var h = this.range(this.data.x[this.shapeBy], true);
                        for (var g = 0; g < o.length; g++) {
                            var n = o[g];
                            if (this.isGroupedData) {
                                for (var f = 0; f < this.data.w.grps[n].length; f++) {
                                    var b = this.data.x[this.shapeBy][this.data.w.grps[n][f]];
                                    if (!isNaN(b)) {
                                        var e = this.percentile(h[0], h[1], b);
                                        var p = parseInt(e / 10);
                                        if (p > 0) {
                                            p--
                                        }
                                        this.dataShapes.push("pie" + p)
                                    } else {
                                        this.dataShapes.push(q)
                                    }
                                }
                            } else {
                                var b = this.data.x[this.shapeBy][n];
                                if (!isNaN(b)) {
                                    var e = this.percentile(h[0], h[1], b);
                                    var p = parseInt(e / 10);
                                    if (p > 0) {
                                        p--
                                    }
                                    this.dataShapes.push("pie" + p)
                                } else {
                                    this.dataShapes.push(q)
                                }
                            }
                        }
                        this.legendShapeRange = h;
                        this.legendShapeDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], 10));
                        this.setShapeLegendIndicatorDimensions()
                    } else {
                        var l = 0;
                        for (var g = 0; g < o.length; g++) {
                            var n = o[g];
                            if (this.isGroupedData) {
                                for (var f = 0; f < this.data.w.grps[n].length; f++) {
                                    var p = this.data.x[this.shapeBy][this.data.w.grps[n][f]];
                                    if (!a.hasOwnProperty(p)) {
                                        var k = this.measureText(p, this.legendFont);
                                        if (k > l) {
                                            l = k;
                                            this.legendShapesMax = p
                                        }
                                        a[p] = m % this.shapes.length;
                                        this.legendShapes[p] = this.shapes[a[p]];
                                        m++
                                    }
                                    this.dataShapes.push(this.shapes[a[p]])
                                }
                            } else {
                                var p = this.data.x[this.shapeBy][n];
                                if (!a.hasOwnProperty(p)) {
                                    var k = this.measureText(p, this.legendFont);
                                    if (k > l) {
                                        l = k;
                                        this.legendShapesMax = p
                                    }
                                    a[p] = m % this.shapes.length;
                                    this.legendShapes[p] = this.shapes[a[p]];
                                    m++
                                }
                                this.dataShapes.push(this.shapes[a[p]])
                            }
                        }
                        this.legendShapesN = m;
                        this.setShapeLegendDimensions()
                    }
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.shapeBy)) {
                        this.shapeByType = "z";
                        if (this.isNumeric(this.data.z[this.shapeBy], false, true)) {
                            var h = this.range(this.data.z[this.shapeBy], false, true);
                            for (var g = 0; g < this.varIndices.length; g++) {
                                var n = this.varIndices[g];
                                var b = this.data.z[this.shapeBy][n];
                                if (!isNaN(b)) {
                                    var e = this.percentile(h[0], h[1], b);
                                    var p = parseInt(e / 10);
                                    if (p > 0) {
                                        p--
                                    }
                                    this.dataShapes.push("pie" + p)
                                } else {
                                    this.dataShapes.push(q)
                                }
                            }
                            this.legendShapeRange = h;
                            this.legendShapeDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], 10));
                            this.setShapeLegendIndicatorDimensions()
                        } else {
                            for (var g = 0; g < this.varIndices.length; g++) {
                                var n = this.varIndices[g];
                                var p = this.data.z[this.shapeBy][n];
                                if (!a.hasOwnProperty(p)) {
                                    a[p] = m % this.shapes.length;
                                    this.legendShapes[p] = this.shapes[a[p]];
                                    m++
                                }
                                this.dataShapes.push(this.shapes[a[p]])
                            }
                            this.legendShapesN = m;
                            this.setShapeLegendDimensions()
                        }
                    } else {
                        if (this.getSampleIndices(this.shapeBy) > -1) {
                            m = this.getSampleIndices(this.shapeBy);
                            var h = this.getAxisRangeBySample(m);
                            for (var g = 0; g < this.varIndices.length; g++) {
                                var n = this.varIndices[g];
                                var b = this.getDataAtPos(n, m);
                                if (!isNaN(b)) {
                                    var e = this.percentile(h[0], h[1], b);
                                    var p = parseInt(e / 10);
                                    if (p > 0) {
                                        p--
                                    }
                                    this.dataShapes.push("pie" + p)
                                } else {
                                    this.dataShapes.push(q)
                                }
                            }
                            this.legendShapeRange = h;
                            this.legendShapeDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], 10));
                            this.setShapeLegendIndicatorDimensions()
                        } else {
                            if (this.shapeBy == "variable") {
                                for (var g = 0; g < this.varIndices.length; g++) {
                                    var p = g % this.shapes.length;
                                    this.dataShapes.push(this.shapes[p])
                                }
                                this.legendShapesN = this.dataShapes.length;
                                this.setVariableLegendDimension()
                            } else {
                                for (var g = 0; g < this.varIndices.length; g++) {
                                    this.dataShapes.push(this.shapes[0])
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.setDataSize = function(e) {
        this.sizeByType = false;
        if (e && this.isMultidimensionalHeatmap) {
            var n = 0;
            var b = {};
            this.dataSizes = [];
            this.legendSizes = {};
            this.legendSizesN = 0;
            if (this.isNumeric2DArray(e)) {
                var k = this.setRangeDataObject(e);
                for (var h = 0; h < this.varIndices.length; h++) {
                    for (var g = 0; g < this.smpIndices.length; g++) {
                        var d = e[this.varIndices[h]][this.smpIndices[g]];
                        if (!isNaN(d)) {
                            var f = this.percentile(k[0], k[1], d);
                            var a = parseInt(f / 10);
                            if (a > 0) {
                                a--
                            }
                            this.dataSizes.push(this.sizes[a])
                        } else {
                            this.dataSizes.push(0)
                        }
                    }
                }
                this.legendSizeRange = k;
                this.legendSizeDecs = this.getAxisDecimals(this.getAxisIncrements(k[0], k[1], 10));
                this.setSizeLegendIndicatorDimensions()
            } else {
                var m = 0;
                for (var h = 0; h < this.varIndices.length; h++) {
                    for (var g = 0; g < this.smpIndices.length; g++) {
                        var a = e[this.varIndices[h]][this.smpIndices[g]];
                        if (!b.hasOwnProperty(a)) {
                            var l = this.measureText(a, this.legendFont);
                            if (l > m) {
                                m = l;
                                this.legendSizesMax = a
                            }
                            b[a] = (n % this.sizes.length) + 3;
                            this.legendSizes[a] = this.sizes[b[a]];
                            n++
                        }
                        this.dataSizes.push(this.sizes[b[a]])
                    }
                }
                this.legendSizesN = n;
                this.setSizeLegendDimensions(this.legendSizesMax)
            }
        } else {
            if (this.sizeBy) {
                var n = 0;
                var b = {};
                this.dataSizes = [];
                this.legendSizes = {};
                this.legendSizesN = 0;
                if (this.data.x && this.data.x.hasOwnProperty(this.sizeBy)) {
                    this.sizeByType = "x";
                    var p = this.isGroupedData ? this.grpIndices : this.smpIndices;
                    if (this.isNumeric(this.data.x[this.sizeBy], true)) {
                        var k = this.range(this.data.x[this.sizeBy], true);
                        for (var h = 0; h < p.length; h++) {
                            var o = p[h];
                            if (this.isGroupedData) {
                                for (var g = 0; g < this.data.w.grps[o].length; g++) {
                                    var d = this.data.x[this.sizeBy][this.data.w.grps[o][g]];
                                    if (!isNaN(d)) {
                                        var f = this.percentile(k[0], k[1], d);
                                        var a = parseInt(f / 10);
                                        if (a > 0) {
                                            a--
                                        }
                                        this.dataSizes.push(this.sizes[a])
                                    } else {
                                        this.dataSizes.push(0)
                                    }
                                }
                            } else {
                                var d = this.data.x[this.sizeBy][o];
                                if (!isNaN(d)) {
                                    var f = this.percentile(k[0], k[1], d);
                                    var a = parseInt(f / 10);
                                    if (a > 0) {
                                        a--
                                    }
                                    this.dataSizes.push(this.sizes[a])
                                } else {
                                    this.dataSizes.push(0)
                                }
                            }
                        }
                        this.legendSizeRange = k;
                        this.legendSizeDecs = this.getAxisDecimals(this.getAxisIncrements(k[0], k[1], 10));
                        this.setSizeLegendIndicatorDimensions()
                    } else {
                        var m = 0;
                        for (var h = 0; h < p.length; h++) {
                            var o = p[h];
                            if (this.isGroupedData) {
                                for (var g = 0; g < this.data.w.grps[o].length; g++) {
                                    var a = this.data.x[this.sizeBy][this.data.w.grps[o][g]];
                                    if (!b.hasOwnProperty(a)) {
                                        var l = this.measureText(a, this.legendFont);
                                        if (l > m) {
                                            m = l;
                                            this.legendSizesMax = a
                                        }
                                        b[a] = (n % this.sizes.length) + 3;
                                        this.legendSizes[a] = this.sizes[b[a]];
                                        n++
                                    }
                                    this.dataSizes.push(this.sizes[b[a]])
                                }
                            } else {
                                var a = this.isGroupedData ? this.getSmpAnnotations(this.sizeBy, this.data.w.grps[h], true) : this.data.x[this.sizeBy][o];
                                if (!b.hasOwnProperty(a)) {
                                    var l = this.measureText(a, this.legendFont);
                                    if (l > m) {
                                        m = l;
                                        this.legendSizesMax = a
                                    }
                                    b[a] = (n % this.sizes.length) + 3;
                                    this.legendSizes[a] = this.sizes[b[a]];
                                    n++
                                }
                                this.dataSizes.push(this.sizes[b[a]])
                            }
                        }
                        this.legendSizesN = n;
                        this.setSizeLegendDimensions()
                    }
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.sizeBy)) {
                        this.sizeByType = "z";
                        if (this.isNumeric(this.data.z[this.sizeBy], false, true)) {
                            var k = this.range(this.data.z[this.sizeBy], false, true);
                            for (var h = 0; h < this.varIndices.length; h++) {
                                var o = this.varIndices[h];
                                var d = this.data.z[this.sizeBy][o];
                                if (!isNaN(d)) {
                                    var f = this.percentile(k[0], k[1], d);
                                    var a = parseInt(f / 10);
                                    if (a > 0) {
                                        a--
                                    }
                                    this.dataSizes.push(this.sizes[a])
                                } else {
                                    this.dataSizes.push(0)
                                }
                            }
                            this.legendSizeRange = k;
                            this.legendSizeDecs = this.getAxisDecimals(this.getAxisIncrements(k[0], k[1], 10));
                            this.setSizeLegendIndicatorDimensions()
                        } else {
                            for (var h = 0; h < this.varIndices.length; h++) {
                                var o = this.varIndices[h];
                                var a = this.data.z[this.sizeBy][o];
                                if (!b.hasOwnProperty(a)) {
                                    b[a] = n % this.sizes.length;
                                    this.legendSizes[a] = this.sizes[b[a]];
                                    n++
                                }
                                this.dataSizes.push(this.sizes[b[a]])
                            }
                            this.legendSizesN = n;
                            this.setSizeLegendDimensions()
                        }
                    } else {
                        if (this.getSampleIndices(this.sizeBy) > -1) {
                            n = this.getSampleIndices(this.sizeBy);
                            var k = this.getAxisRangeBySample(n);
                            for (var h = 0; h < this.varIndices.length; h++) {
                                var o = this.varIndices[h];
                                var d = this.getDataAtPos(o, n);
                                if (!isNaN(d)) {
                                    var f = this.percentile(k[0], k[1], d);
                                    var a = parseInt(f / 10);
                                    if (a > 0) {
                                        a--
                                    }
                                    this.dataSizes.push(this.sizes[a])
                                } else {
                                    this.dataSizes.push(0)
                                }
                            }
                            this.legendSizeRange = k;
                            this.legendSizeDecs = this.getAxisDecimals(this.getAxisIncrements(k[0], k[1], 10));
                            this.setSizeLegendIndicatorDimensions()
                        } else {
                            if (this.sizeBy == "variable") {
                                for (var h = 0; h < this.varIndices.length; h++) {
                                    var a = h % this.sizes.length;
                                    this.dataSizes.push(this.sizes[a])
                                }
                                this.legendSizesN = this.dataSizes.length;
                                this.setVariableLegendDimension()
                            } else {
                                for (var h = 0; h < this.varIndices.length; h++) {
                                    this.dataSizes.push(this.scatterPointSize)
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.setDataColorShapeSize = function() {
        this.resetLegends();
        this.setLegendFont();
        if (this.isMultidimensionalHeatmap) {
            if (this.outlineByData && this.data.y[this.outlineByData]) {
                this.setDataColor(this.data.y[this.outlineByData])
            }
            if (this.shapeByData && this.data.y[this.shapeByData]) {
                this.setDataShape(this.data.y[this.shapeByData])
            }
            if (this.sizeByData && this.data.y[this.sizeByData]) {
                this.setDataSize(this.data.y[this.sizeByData])
            }
        } else {
            this.setDataColor();
            this.setDataShape();
            this.setDataSize()
        } if (!this.scatterPlotMatrix && (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2d")) {
            this.setSampleLegendDimension()
        }
    };
    this.resetLegends = function() {
        var a = ["Color", "Shape", "Size"];
        for (var d = 0; d < a.length; d++) {
            this["legend" + a[d] + "IndicatorWidth"] = 0;
            this["legend" + a[d] + "IndicatorHeight"] = 0;
            this["data" + a[d] + "s"] = [];
            this["legend" + a[d] + "s"] = {};
            this["legend" + a[d] + "s"] = 0
        }
        var b = this.scatterPlotMatrix ? ["Color", "Shape", "Size", "Variable"] : ["Color", "Shape", "Size", "Variable", "Sample"];
        for (var d = 0; d < b.length; d++) {
            this["legend" + b[d] + "Width"] = 0;
            this["legend" + b[d] + "Height"] = 0
        }
    };
    this.setLegendDimensions = function() {
        this.legendLayout = [];
        var a = this.margin;
        var m = this.margin;
        if (this.showIndicators) {
            var g = ["Color", "Shape", "Size"];
            for (var d = 0; d < g.length; d++) {
                var k = this["legend" + g[d] + "IndicatorWidth"];
                var e = this["legend" + g[d] + "IndicatorHeight"];
                if (k) {
                    if (this.indicatorsPosition == "bottom") {
                        m += this.margin + e
                    } else {
                        a += this.margin + e
                    }
                }
            }
        }
        var b = 0;
        var l = 0;
        var j = 0;
        if (this.showLegend) {
            var f = this.scatterPlotMatrix ? ["Color", "Shape", "Size", "Variable"] : ["Color", "Shape", "Size", "Variable", "Sample"];
            for (var d = 0; d < f.length; d++) {
                var k = this["legend" + f[d] + "Width"];
                var e = this["legend" + f[d] + "Height"];
                if (k > 0) {
                    if (this.legendPosition == "right") {
                        if (l + this.margin + e > this.height) {
                            a += this.margin + k;
                            b = k;
                            l = e;
                            j++;
                            this.legendLayout[j] = [f[d]]
                        } else {
                            if (k > b) {
                                a += (k - b);
                                b = k
                            }
                            l += e;
                            if (!this.legendLayout[j]) {
                                this.legendLayout[j] = []
                            }
                            this.legendLayout[j].push(f[d])
                        }
                    } else {
                        if (b + this.margin + k > this.width) {
                            m += this.margin + e;
                            b = k;
                            l = e;
                            j++;
                            this.legendLayout[d] = [f[d]]
                        } else {
                            if (e > l) {
                                m += (e - l);
                                l = e
                            }
                            b += k;
                            if (!this.legendLayout[j]) {
                                this.legendLayout[j] = []
                            }
                            this.legendLayout[j].push(f[d])
                        }
                    }
                }
            }
        }
        this.legendWidth = a + this.margin;
        this.legendHeight = m + this.margin
    };
    this.getXYLegendCoords = function(p, a, r) {
        var o, f, n, k;
        var m = 0;
        var d = 0;
        var q = -1;
        var g = -1;
        if (this.legendLayout) {
            for (var e = 0; e < this.legendLayout.length; e++) {
                o = 0;
                f = 0;
                for (var b = 0; b < this.legendLayout[e].length; b++) {
                    if (this.legendLayout[e][b] == p) {
                        g = b
                    }
                    o += this["legend" + this.legendLayout[e][b] + "Width"] + this.margin;
                    f += this["legend" + this.legendLayout[e][b] + "Height"] + this.margin;
                    m = Math.max(m, o);
                    d = Math.max(d, f)
                }
                if (g > -1) {
                    q = e;
                    break
                }
            }
            if (this.legendPosition == "right") {
                r = g == 0 && this.scatterPlotMatrix ? this.marginTop + this.layoutTop : g == 0 ? this.marginTop + this.offsetY + this.top : r;
                n = a;
                k = g == 0 && this.scatterPlotMatrix ? (this.height - d) / 2 : g == 0 ? this.marginTop + this.offsetY + this.top + ((this.y - d) / 2) : r;
                a = g == this.legendLayout[q].length - 1 ? a + m : a;
                r = k + this["legend" + this.legendLayout[q][g] + "Height"] + this.margin
            } else {
                a = g == 0 && this.scatterPlotMatrix ? this.marginLeft + this.layoutLeft : g == 0 ? this.marginLeft + this.offsetX + this.left : a;
                n = g == 0 && this.scatterPlotMatrix ? (this.width - m) / 2 : g == 0 ? this.marginLeft + this.offsetX + this.left + ((this.x - m) / 2) + this.margin : a + this.margin;
                k = r;
                a = n + this["legend" + this.legendLayout[q][g] + "Width"] + this.margin;
                r = g == this.legendLayout[q].length - 1 ? r + d : r
            }
        }
        return [n, k, a, r]
    };
    this.drawScatterLegend = function(e, s) {
        var d = this.scatterPlotMatrix ? this.width - (this.marginRight + this.layoutRight) : this.marginLeft + this.offsetX + this.left + this.x;
        var o = this.scatterPlotMatrix ? this.height - (this.marginBottom + this.layoutBottom) : this.marginTop + this.offsetY + this.top + this.y;
        if (e) {
            d += e
        }
        if (s) {
            o += s
        }
        if (this.showIndicators) {
            var r, k;
            var a, q;
            if (!this.scatterPlotMatrix && (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D")) {
                d += (this.margin * 2);
                o += this.get2DXAxisHeight() + this.margin;
                if (this.graphType == "ScatterBubble2D" && this.zAxisShow) {
                    d += this.getFontPt(this.axisTitleFont) + (this.margin * 2)
                }
            } else {
                d += (this.margin * 1);
                o += (this.margin * 1)
            }
            var n = ["Color", "Shape", "Size"];
            for (var g = 0; g < n.length; g++) {
                r = this["legend" + n[g] + "IndicatorWidth"];
                k = this["legend" + n[g] + "IndicatorHeight"];
                if (r) {
                    var b = "draw" + n[g] + "Indicator";
                    var j = this["legend" + n[g] + "Range"];
                    var f = this["legend" + n[g] + "Decs"];
                    if (this.indicatorsPosition == "bottom") {
                        a = this.scatterPlotMatrix ? (this.width - r) / 2 : this.marginLeft + this.offsetX + this.left + ((this.x - r) / 2);
                        q = o;
                        this[b](a, q, j[0], j[1], f);
                        o += k + this.margin
                    } else {
                        a = d;
                        q = this.scatterPlotMatrix ? (this.height - k) / 2 : this.marginTop + this.offsetY + this.top + (this.y - ((this.y - r) / 2));
                        this[b](a, q, j[0], j[1], f);
                        d += k + this.margin
                    }
                }
            }
        }
        if (this.showLegend) {
            var m = this.scatterPlotMatrix ? ["Color", "Shape", "Size", "Variable"] : ["Color", "Shape", "Size", "Variable", "Sample"];
            for (var g = 0; g < m.length; g++) {
                r = this["legend" + m[g] + "Width"];
                k = this["legend" + m[g] + "Height"];
                if (r > 0) {
                    var b = "draw" + m[g] + "Legend";
                    var p = this.getXYLegendCoords(m[g], d, o);
                    this[b](p[0], p[1]);
                    if (this.legendPosition == "right") {
                        o = p[3] + this.margin
                    } else {
                        d = p[2] + this.margin
                    }
                }
            }
        }
    }
};
CanvasXpress.prototype.initApi = function() {
    this.getValidGraphTypes = function() {
        return this.validGraphTypes
    };
    this.setHeatmapScheme = function() {
        this.initializeAttributes()
    };
    this.hasIndicator = function() {
        if (this.graphType.match(/Scatter/) || this.graphType == "Bar") {
            return true
        } else {
            return false
        }
    };
    this.hasLegend = function() {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Correlation" && this.graphType != "Heatmap") {
            return true
        } else {
            return false
        }
    };
    this.hasLegendProperties = function() {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Correlation" && this.graphType != "Heatmap" && this.graphType != "Pie") {
            return true
        } else {
            return false
        }
    };
    this.hasData = function() {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn") {
            return true
        } else {
            return false
        }
    };
    this.hasDataSamples = function() {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && !this.graphType.match(/Scatter/)) {
            if (this.graphType == "Correlation" && this.correlationAxis != "samples") {
                return false
            }
            return true
        } else {
            return false
        }
    };
    this.hasDataGroups = function() {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && !this.graphType.match(/Scatter/)) {
            if (this.graphType == "Correlation" && this.correlationAxis != "samples") {
                return false
            }
            if (this.data.x) {
                return true
            } else {
                return false
            }
        } else {
            return false
        }
    };
    this.hasDataVariables = function() {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn") {
            if (this.graphType == "Correlation" && this.correlationAxis != "variables") {
                return false
            }
            return true
        } else {
            return false
        }
    };
    this.hasDataProperties = function() {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Heatmap" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation") {
            return true
        } else {
            return false
        }
    };
    this.hasOrientation = function() {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && this.graphType != "Circular" && !this.graphType.match(/Scatter/)) {
            return true
        } else {
            return false
        }
    };
    this.hasOverlays = function() {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && !this.graphType.match(/Scatter/)) {
            return true
        } else {
            return false
        }
    };
    this.hasDendrograms = function() {
        if (this.graphType != "Heatmap" && (this.data.t.smps || this.data.t.vars)) {
            return true
        } else {
            return false
        }
    };
    this.hasDecorations = function() {
        return this.data.d && (this.data.d.nlfit || this.data.d.line || this.data.d.reg || this.data.d.nor || this.data.d.area) ? true : false
    };
    this.isSegregable = function() {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && !this.graphType.match(/Scatter/)) {
            return true
        } else {
            return false
        }
    };
    this.getLineTypes = function() {
        var f = ["line"];
        var d = ["", "dashed", "dotted", "bezierY", "bezierX", "curved"];
        var a = ["arrow", "arrowHead", "arrowTail", "arrowHeadSquareTail", "arrowTailSquareHead", "square", "squareHead", "squareTail", "squareHeadArrowTail", "squareTailArrowHead"];
        for (var e = 0; e < a.length; e++) {
            f.push(a[e] + "Line")
        }
        for (var e = 1; e < d.length; e++) {
            for (var b = 0; b < a.length; b++) {
                f.push(d[e] + this.capitalize(a[b]) + "Line")
            }
        }
        return f
    };
    this.isValidShape = function(b) {
        for (var a = 0; a < this.shapes.length; a++) {
            if (this.shapes[a] == b) {
                return true
            }
        }
        return false
    };
    this.isCompatibleGraphType = function(b, a) {
        if (b.match(/^Bar$|^Line$|Boxplot|Dotplot/)) {
            return a.match(/^Bar$|^Line$|Boxplot|Dotplot/) ? true : false
        } else {
            return false
        }
    };
    this.modifyHighlights = function(d, b, e) {
        var a = e ? "highlightVar" : "highlightSmp";
        this.modifyObjectArray(d, b, a)
    };
    this.getHighlights = function(b) {
        var a = b ? this.highlightVar : this.highlightSmp;
        return this.getObjectArray(a)
    };
    this.modifySmpOverlays = function(b, a) {
        this.modifyObjectArray(b, a, "smpOverlays")
    };
    this.modifyVarOverlays = function(b, a) {
        this.modifyObjectArray(b, a, "varOverlays")
    };
    this.getSmpOverlays = function() {
        return this.getObjectArray(this.smpOverlays)
    };
    this.getVarOverlays = function() {
        return this.getObjectArray(this.varOverlays)
    };
    this.getXData = function() {
        var b = [];
        if (this.data.x) {
            for (var a in this.data.x) {
                b.push(a)
            }
        }
        return b
    };
    this.getZData = function() {
        var b = [];
        if (this.data.z) {
            for (var a in this.data.z) {
                b.push(a)
            }
        }
        return b
    };
    this.getXZData = function() {
        return this.graphType.match(/Scatter/) ? this.getZData() : this.getXData()
    };
    this.getSamplesAsArray = function() {
        var e = this.getSamples();
        var b = [];
        for (var d = 0; d < e.length; d++) {
            b.push(e[d].name)
        }
        return b
    };
    this.getVariablesAsArray = function() {
        var e = this.getVariables();
        var b = [];
        for (var d = 0; d < e.length; d++) {
            b.push(e[d].name)
        }
        return b
    };
    this.getNodeData = function(a) {
        return this.getNetworkData("nodes", a)
    };
    this.getEdgeData = function(a) {
        return this.getNetworkData("edges", a)
    };
    this.getSampleData = function(a) {
        if (!this.samplesData) {
            this.samplesData = {
                smps: {
                    o: this.getObjectArray(this.data.y.smps),
                    t: "string"
                }
            };
            if (this.data.x) {
                for (att in this.data.x) {
                    this.samplesData[att] = {
                        o: this.getObjectArray(this.getUniqueKeys(this.data.x[att])),
                        t: this.isNumeric(this.data.x[att]) ? "numeric" : "string"
                    }
                }
            }
        }
        return a ? this.samplesData : this.getKeys(this.samplesData)
    };
    this.getVariableData = function(a) {
        if (!this.variablesData) {
            this.variablesData = {
                vars: {
                    o: this.getObjectArray(this.data.y.vars),
                    t: "string"
                }
            };
            if (this.data.z) {
                for (att in this.data.z) {
                    this.variablesData[att] = {
                        o: this.getObjectArray(this.getUniqueKeys(this.data.z[att])),
                        t: this.isNumeric(this.data.z[att]) ? "numeric" : "string"
                    }
                }
            }
        }
        return a ? this.variablesData : this.getKeys(this.variableData)
    };
    this.getNetworkData = function(e, a) {
        if (this.graphType == "Network" && !this[e + "Data"]) {
            this[e + "Data"] = {};
            var g = this.skipConfigurableProperties ? this.getObjectArray(this[e.replace("s", "") + "ConfigurableProperties"]) : {};
            for (var d = 0; d < this.data[e].length; d++) {
                var f = this.data[e][d];
                for (var b in f) {
                    if (!g[b]) {
                        if (typeof(f[b]) != "object") {
                            if (this[e + "Data"].hasOwnProperty(b)) {
                                if (this[e + "Data"][b]["o"].hasOwnProperty(f[b])) {
                                    this[e + "Data"][b]["o"][f[b]]++
                                } else {
                                    this[e + "Data"][b]["o"][f[b]] = 1
                                } if (isNaN(f[b])) {
                                    this[e + "Data"][b]["t"] = "string"
                                }
                            } else {
                                this[e + "Data"][b] = {
                                    o: {},
                                    t: isNaN(f[b]) ? "string" : "numeric"
                                };
                                this[e + "Data"][b]["o"][f[b]] = 1
                            }
                        } else {
                            if (f[b] && f[b].constructor == (new Date).constructor) {}
                        }
                    }
                }
                if (this[e + "Properties"].length > 0) {
                    this.getAdditionalData(f, this[e + "Data"], this[e + "Properties"])
                }
            }
        }
        if (this.graphType == "Network") {
            return a ? this[e + "Data"] : this.getKeys(this[e + "Data"])
        } else {
            return false
        }
    };
    this.getFeatureData = function(b) {
        if (!this.featuresData) {
            this.featuresData = {};
            var k = this.skipConfigurableProperties ? this.getObjectArray(this.featureConfigurableProperties) : {};
            for (var g = 0; g < this.data.tracks.length; g++) {
                var a = this.data.tracks[g];
                var h = a.data;
                for (var e = 0; e < h.length; e++) {
                    var f = h[e];
                    for (var d in f) {
                        if (!k[d]) {
                            if (typeof(f[d]) != "object") {
                                if (this.featuresData.hasOwnProperty(d)) {
                                    if (this.featuresData[d]["o"].hasOwnProperty(f[d])) {
                                        this.featuresData[d]["o"][f[d]]++
                                    } else {
                                        this.featuresData[d]["o"][f[d]] = 1
                                    } if (isNaN(f[d])) {
                                        this.featuresData[d]["t"] = "string"
                                    }
                                } else {
                                    this.featuresData[d] = {
                                        o: {},
                                        t: isNaN(f[d]) ? "string" : "numeric"
                                    };
                                    this.featuresData[d]["o"][f[d]] = 1
                                }
                            } else {
                                if (f[d].constructor == (new Date).constructor) {}
                            }
                        }
                    }
                }
                if (this.featuresProperties.length > 0) {
                    this.getAdditionalData(h, this.featuresData, this.featuresProperties)
                }
            }
        }
        return b ? this.featuresData : this.getKeys(this.featuresData)
    };
    this.getAdditionalData = function(e, f, k) {
        for (var g = 0; g < k.length; g++) {
            var b = e;
            var l = false;
            if (k[g].length > 0) {
                for (var d = 0; d < k[g].length; d++) {
                    var a = k[g][d];
                    if (b[a]) {
                        b = b[a]
                    } else {
                        l = true;
                        break
                    }
                }
                if (!l) {
                    for (var h in b) {
                        if (typeof(b[h]) != "object") {
                            if (f.hasOwnProperty(h)) {
                                if (f[h]["o"].hasOwnProperty(b[h])) {
                                    f[h]["o"][b[h]]++
                                } else {
                                    f[h]["o"][b[h]] = 1
                                } if (isNaN(b[h])) {
                                    f[h]["t"] = "string"
                                }
                            } else {
                                f[h] = {
                                    o: {},
                                    t: isNaN(b[h]) ? "string" : "numeric",
                                    r: g
                                };
                                f[h]["o"][b[h]] = 1
                            }
                        } else {
                            if (b[h].constructor == (new Date).constructor) {}
                        }
                    }
                }
            }
        }
    };
    this.getOperators = function() {
        return ["", "like", "not like", ">", ">=", "<", "<=", "==", "null", "not null"]
    };
    this.resetFilters = function(e, d) {
        var a = [];
        if (!e) {
            a = ["filterSmpBy", "filterVarBy", "filterNodeBy", "filterEdgeBy", "filterFeatureBy"]
        } else {
            a = [e]
        }
        for (var b = 0; b < a.length; b++) {
            c = a[b];
            if (c == "filterSmpBy") {
                this.resetSmpFilters(d)
            } else {
                if (c == "filterVarBy") {
                    this.resetVarFilters(d)
                } else {
                    if (c == "filterNodeBy") {
                        this.resetNodeFilters(d)
                    } else {
                        if (c == "filterEdgeBy") {
                            this.resetEdgeFilters(d)
                        } else {
                            if (c == "filterFeatureBy") {
                                this.resetFeatureFilters(d)
                            }
                        }
                    }
                }
            }
        }
    };
    this.zoonIn = function(a) {
        this.handleWheelEvent(a, 1)
    };
    this.zoonOut = function(a) {
        this.handleWheelEvent(a, -1)
    };
    this.clusterSamples = function() {
        this.clusterAxis = "samples";
        this.showSmpDendrogram = true;
        if (!this.data.t) {
            this.data.t = {}
        }
        this.data.t.smps = this.cluster();
        this.draw()
    };
    this.clusterVariables = function() {
        this.clusterAxis = "variables";
        this.showVarDendrogram = true;
        if (!this.data.t) {
            this.data.t = {}
        }
        this.data.t.vars = this.cluster();
        this.draw()
    };
    this.kmeansSamples = function() {
        this.clusterAxis = "samples";
        this.showOverlays = true;
        if (!this.data.x) {
            this.data.x = {}
        }
        this.data.x["k-Means"] = this.kmeans();
        if (!this.isInArray("k-Means", this.smpOverlays)) {
            this.smpOverlays.push("k-Means")
        }
        this.draw()
    };
    this.kmeansVariables = function() {
        this.clusterAxis = "variables";
        this.showOverlays = true;
        if (!this.data.z) {
            this.data.z = {}
        }
        this.data.z["k-Means"] = this.kmeans();
        if (!this.isInArray("k-Means", this.varOverlays)) {
            this.varOverlays.push("k-Means")
        }
        this.draw()
    };
    this.setFunctions = function() {
        this.functions.push("clusterSamples");
        this.functions.push("clusterVariables");
        this.functions.push("transpose");
        this.functions.push("transform");
        this.functions.push("sortSamplesByCategory");
        this.functions.push("sortSamplesByVariable");
        this.functions.push("sortVariablesByCategory");
        this.functions.push("sortVariablesBySample");
        this.functions.push("hideUnhideSmps");
        this.functions.push("hideUnhideVars");
        this.functions.push("desegregateSamples");
        this.functions.push("segregateSamples");
        this.functions.push("groupSamples");
        this.functions.push("ungroupSamples");
        this.functions.push("desegregateVariables");
        this.functions.push("segregateVariables");
        this.functions.push("kmeansSamples");
        this.functions.push("kmeansVariables");
        this.functions.push("showCodeDiv");
        this.functions.push("hideCodeDiv");
        this.functions.push("showInfoDiv");
        this.functions.push("hideInfoDiv");
        this.functions.push("updateCodeDiv");
        this.functions.push("createHistogram");
        this.functions.push("removeHistogram");
        this.functions.push("addRegressionLine");
        this.functions.push("addNormalDistributionLine");
        this.functions.push("recalculateLayout");
        this.functions.push("setSkin");
        this.functions.push("createRandomData");
        this.functions.push("draw");
        this.functions.push("reset");
        this.functions.push("print");
        this.functions.push("saveRemoteParameters")
    };
    this.initializeApi = function() {
        this.setFunctions()
    };
    this.initializeApi()
};
CanvasXpress.prototype.initUtils = function() {
    this.initDimensions();
    this.initGeneralUtils();
    this.initPlotUtils();
    this.initConfigUtils();
    this.initLegendUtils();
    this.init3dUtils();
    this.initApi()
};
CanvasXpress.prototype.initLayout = function() {
    this.isValidLayout = function() {
        var a = this.layout.split(/X/i);
        if (this.adjustAspectRatio && !this.plotByVariable) {
            if (a.length == 2) {
                this.layoutRows = a[0];
                this.layoutCols = a[1]
            } else {
                this.layoutRows = 1;
                this.layoutCols = 1;
                this.layoutValid = false
            } if (!this.graphType.match(/Scatter/) && this.layoutComb && this.data.l && (this.data.l.vars || this.data.l.smps) && this.data.l.weight && this.data.l.type) {
                this.data.l.comp = [];
                if (this.data.l.vars && this.data.l.smps) {
                    var f = 0;
                    for (var d = 0; d < this.data.l.smps.length; d++) {
                        for (var b = 0; b < this.data.l.vars.length; b++) {
                            this.data.l.comp[f] = [this.getVariableIndices(this.data.l.vars[b]), this.getSampleIndices(this.data.l.smps[d])];
                            f++
                        }
                    }
                    this.layoutRows = this.data.l.smps.length;
                    this.layoutCols = this.data.l.vars.length
                } else {
                    if (this.data.l.vars) {
                        for (var d = 0; d < this.data.l.vars.length; d++) {
                            this.data.l.comp[d] = this.getVariableIndices(this.data.l.vars[d])
                        }
                    } else {
                        for (var d = 0; d < this.data.l.smps.length; d++) {
                            this.data.l.comp[d] = this.getSampleIndices(this.data.l.smps[d])
                        }
                    } if (this.graphType != "Pie") {
                        if (this.graphOrientation == "vertical") {
                            this.layoutRows = this.data.l.comp.length
                        } else {
                            this.layoutCols = this.data.l.comp.length
                        }
                    }
                }
                this.layoutValid = true;
                this.layoutAdjust = true
            } else {
                if (this.layoutComb && this.data.l && this.data.l.smps && this.data.l.weight && this.data.l.type) {
                    this.data.l.comp = [];
                    var e = this.getVariableIndices(this.data.y.vars);
                    for (var d = 0; d < this.data.l.type.length; d++) {
                        this.data.l.comp[d] = e
                    }
                    this.layoutValid = true
                } else {
                    if (this.data.l && this.data.l.comp) {
                        if (this.data.l.comp.length <= (this.layoutRows * this.layoutCols)) {
                            this.layoutValid = true
                        } else {
                            this.layoutValid = false
                        }
                    } else {
                        this.layoutValid = false
                    }
                }
            }
        } else {
            this.layoutRows = 1;
            this.layoutCols = 1;
            this.layoutValid = false
        }
    };
    this.setLayout = function(a) {};
    this.addLayoutResizer = function(b) {
        var a = 0;
        if (this.resizerType && this.resizerPosition == b) {
            a += this.resizerWidth + (this.margin * 2);
            if (this.resizerType == "samples") {
                a += 14 + this.margin
            }
        }
        return a
    };
    this.getLayoutResizerDimensions = function() {
        if (this.resizerType) {
            var u, j, e, d;
            var f = this.data.l.comp.length - 1;
            var k = this.resizerWidth;
            var z = this.resizerWidth;
            var B = this.marginTop + this.layoutTop;
            var c = this.marginRight + this.layoutRight;
            var q = this.marginBottom + this.layoutBottom;
            var g = this.marginLeft + this.layoutLeft;
            var A = this.getAxesVals(0);
            var s = 0;
            var m = 0;
            switch (this.resizerPosition) {
                case "right":
                    u = "xAxis";
                    j = "y";
                    e = "v";
                    d = "r";
                    B += this["subGraphTop" + 0];
                    g = this.resizerType == "samples" ? this.width - ((this.margin * 2) + this.resizerWidth + 14) : this.width - (this.margin + this.resizerWidth);
                    k = this.height - (B + q + this["subGraphBottom" + f]);
                    break;
                case "left":
                    u = "xAxis";
                    j = "y";
                    e = "v";
                    d = "l";
                    B += this["subGraphTop" + 0];
                    g = this.resizerType == "samples" && this.graphOrientation == "horizontal" ? (this.margin * 2) : this.margin;
                    k = this.height - (B + q + this["subGraphBottom" + f]);
                    break;
                case "top":
                    u = "xAxis";
                    j = "x";
                    e = "h";
                    d = "t";
                    B = this.resizerType == "samples" ? (this.margin * 2) + 14 : this.margin;
                    g += this["subGraphLeft" + 0];
                    z = this.width - (g + c + this["subGraphRight" + f]);
                    m += this.resizerWidth;
                    break;
                case "bottom":
                    u = "xAxis";
                    j = "x";
                    e = "h";
                    d = "b";
                    B = this.resizerType == "samples" && this.graphOrientation == "vertical" ? this.height - ((this.margin * 2) + this.resizerWidth + 14) : this.width - (this.margin + this.resizerWidth);
                    g += this["subGraphLeft" + 0];
                    z = this.width - (g + c + this["subGraphRight" + f]);
                    m += this.resizerWidth;
                    break
            }
            if (e == "v") {
                return ([u, g + s, g + s + z, B + m, B + m + k, j, e, d, A, g + 14, B, z, k])
            } else {
                return ([u, g + s, g + s + z, B + m, B + m + k, j, e, d, A, g, B, z, k])
            }
        }
    };
    this.drawLayoutResizer = function() {
        if (this.resizerType) {
            var a = this.getLayoutResizerDimensions();
            this.showAxesResizer(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], "", 0, 0, 0);
            this.drawAxesResizerBackgroundData(a[9], a[10], a[11], a[12]);
            this.drawAxesResizerMasks()
        }
    };
    this.getLayoutMaxLegend = function() {
        if (this.data.l.vars) {
            var a = 0;
            if (this.data.l.comp) {
                for (var b = 0; b < this.data.l.comp.length; b++) {
                    a = Math.max(a, this.data.l.comp[b].length)
                }
            }
            return a
        } else {
            return this.varIndices.length
        }
    };
    this.setLayoutLeft = function() {
        var a = 0;
        if (this.graphOrientation != "vertical" && this.segregateSamplesBy && this.segregateVariablesBy) {
            this.set1DVarSmpLabelFont();
            a = this.fontSize + (this.margin * 4) + this.measureText(this.maxSmpNameStr, this.smpLabelFont) + this.getSmpOverlaysLength()
        } else {
            if (this.graphOrientation != "vertical" && this.segregateVariablesBy) {
                this.set1DVarSmpLabelFont();
                a = (this.margin * 2) + this.measureText(this.maxSmpNameStr, this.smpLabelFont) + this.getSmpOverlaysLength()
            } else {
                if ((this.segregateSamplesBy || this.segregateVariablesBy) && this.graphOrientation == "vertical") {
                    a = this.fontSize + (this.margin * 2)
                } else {
                    if (this.graphType == "Candlestick" && this.graphOrientation != "vertical") {
                        this.setTimeAxis();
                        this.set1DVarSmpLabelFont();
                        a = this.getSampleLabelLength() + this.getSmpOverlaysLength()
                    } else {
                        if (this.graphType == "Pie") {
                            a = (this.margin * 2) + this.measureText("XX", this.smpLabelFont)
                        }
                    }
                }
            }
        }
        return a + this.addLayoutResizer("left")
    };
    this.setLayoutRight = function() {
        var a = 0;
        if (this.graphType == "Pie" && this.showLegend && this.legendPosition == "right") {
            var b = this.getPieLegendDimensions();
            a = b[0]
        } else {
            if (this.graphType.match(/Scatter/) && (this.showLegend || this.showIndicators)) {
                if (this.xAxis && this.yAxis) {
                    this.setDataColorShapeSize()
                }
                this.setLegendDimensions();
                a = this.legendWidth
            }
        }
        return a + this.addLayoutResizer("right")
    };
    this.setLayoutTop = function() {
        var a = 0;
        if (((this.segregateSamplesBy || this.segregateVariablesBy) && this.graphOrientation != "vertical") || (this.segregateSamplesBy && this.segregateVariablesBy) || (this.graphType == "Pie")) {
            a = this.fontSize + (this.margin * 2)
        }
        return a + this.addLayoutResizer("top")
    };
    this.setLayoutBottom = function() {
        var a = 0;
        if (this.graphType == "Pie" && this.showLegend && this.legendPosition == "bottom") {
            var c = this.getPieLegendDimensions();
            a = c[1]
        } else {
            if (this.segregateSamplesBy && this.segregateVariablesBy) {
                a = this.getLegendHeight()
            } else {
                if (this.segregateVariablesBy && this.graphOrientation == "vertical") {
                    this.set1DVarSmpLabelFont();
                    a = (this.margin * 2) + this.measureText(this.maxSmpNameStr, this.smpLabelFont) + this.getSmpOverlaysLength()
                } else {
                    if (this.graphType == "Candlestick" && this.graphOrientation == "vertical") {
                        this.setTimeAxis();
                        this.set1DVarSmpLabelFont();
                        a = this.getSampleLabelLength() + this.getSmpOverlaysLength()
                    } else {
                        if (this.graphType.match(/Scatter/) && (this.showLegend || this.showIndicators)) {
                            if (this.xAxis && this.yAxis) {
                                this.setDataColorShapeSize()
                            }
                            this.setLegendDimensions();
                            a = this.legendHeight
                        }
                    }
                }
            }
        }
        return a + this.addLayoutResizer("bottom")
    };
    this.drawLayoutSampleOverlays = function(b) {
        var a = this.smpIndices;
        this.smpIndices = b;
        this.set1DVarSmpLabelFont();
        this.smpIndices = a;
        this.showSampleNames = true;
        this.showOverlays = true;
        this.draw1DYLayout()
    };
    this.drawLayoutVariableLegend = function() {
        this.showLegend = true;
        if (this.graphType == "Pie") {
            this.drawPieLegend()
        } else {
            this.draw1DLegend()
        }
        this.showLegend = false
    };
    this.setLayoutDimensions = function() {
        this.offsetX = 0;
        this.offsetY = 0;
        this.layoutLeft = this.setLayoutLeft();
        this.layoutRight = this.setLayoutRight();
        this.layoutTop = this.setLayoutTop();
        this.layoutBottom = this.setLayoutBottom()
    };
    this.drawLabelsLayout = function() {
        var q = 0;
        var p = 0;
        var o = 0;
        var f = 0;
        var k = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
        var d = this.height - (this.marginTop + this.layoutTop + this.layoutBottom + this.marginBottom);
        if (this.resizerType) {
            if (this.resizerPosition == "top") {
                p = this.resizerType == "samples" ? (this.margin * 2) + this.resizerWidth + 14 : this.margin + this.resizerWidth;
                f = p
            } else {
                if (this.resizerPosition == "left") {
                    q = this.resizerType == "samples" ? (this.margin * 2) + this.resizerWidth + 14 : this.margin + this.resizerWidth;
                    o = q
                }
            }
        }
        if (this.segregateSamplesBy && this.segregateVariablesBy) {
            p += this.fontSize + (this.margin * 4);
            q = this.marginLeft + this.layoutLeft;
            for (var s = 0; s < this.data.l.vars.length; s++) {
                var l = s * this.data.l.smps.length;
                var r = k * this["subGraphWeight" + l][0];
                q += (r / 2);
                this.drawText(this.data.l.name[l][0], q, p, this.font, this.foreground, "center", "middle");
                q += (r / 2)
            }
            q = o + this.fontSize + (this.margin * 4);
            p = this.marginTop + this.layoutTop;
            for (var l = 0; l < this.data.l.smps.length; l++) {
                var m = d * this["subGraphWeight" + l][1];
                p += (m / 2);
                this.drawText(this.data.l.name[l][1], q, p, this.font, this.foreground, "center", "middle", -Math.PI / 2);
                p += (m / 2)
            }
        } else {
            if ((this.segregateSamplesBy || this.segregateVariablesBy) && this.graphOrientation == "vertical" && this.data.l.name) {
                q += this.fontSize + (this.margin * 4);
                p += this.marginTop + this.layoutTop;
                for (var l = 0; l < this.data.l.name.length; l++) {
                    var m = d * this["subGraphWeight" + l];
                    p += (m / 2);
                    this.drawText(this.data.l.name[l], q, p, this.font, this.foreground, "center", "middle", -Math.PI / 2);
                    p += (m / 2)
                }
            } else {
                if ((this.segregateSamplesBy || this.segregateVariablesBy) && this.graphOrientation == "horizontal" && this.data.l.name) {
                    p += this.fontSize + (this.margin * 4);
                    q += this.marginLeft + this.layoutLeft;
                    for (var l = 0; l < this.data.l.name.length; l++) {
                        var r = k * this["subGraphWeight" + l];
                        q += (r / 2);
                        this.drawText(this.data.l.name[l], q, p, this.font, this.foreground, "center", "middle");
                        q += (r / 2)
                    }
                } else {
                    if (this.graphType == "Pie" && (this.showPieGrid || this.showPieSampleLabel)) {
                        var m, r;
                        var n = 0;
                        var t = this.getFontPt(this.font);
                        var b = this.marginTop + this.layoutTop;
                        var e = this.marginLeft + this.layoutLeft;
                        var a = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
                        for (var l = 0; l < this.layoutRows; l++) {
                            m = d * this["subGraphWeight" + n][1];
                            q = (this.marginLeft + this.layoutLeft) - this.margin;
                            b += m;
                            if (this.showPieGrid) {
                                this.drawText(a[l], q, (b + (t / 2)) - (m / 2), this.font, this.foreground, "right", "middle")
                            }
                            for (var g = 0; g < this.layoutCols; g++) {
                                if (this.xAxis.length <= n) {
                                    break
                                }
                                r = k * this["subGraphWeight" + n][0];
                                e += r;
                                p = (this.marginTop + this.layoutTop) - this.margin;
                                if (l == 0) {
                                    if (this.showPieGrid) {
                                        this.drawText(g + 1, (e + (t / 2)) - (r / 2), p, this.font, this.foreground, "center", "bottom")
                                    }
                                }
                                if (this.showPieSampleLabel) {
                                    this.drawText(this.xAxis[n], e - (r / 1.1), b - (m / 5), this.legendFont, this.foreground, "center", "middle")
                                }
                                n++
                            }
                            e = this.marginLeft + this.layoutLeft
                        }
                    }
                }
            }
        }
    };
    this.setLayoutGraphAttributes = function() {
        var g = 0;
        for (var d = 0; d < this.layoutRows; d++) {
            for (var b = 0; b < this.layoutCols; b++) {
                var e = "subGraphType" + g;
                if (!this[e]) {
                    if (this.data.l.type && this.data.l.type[g]) {
                        this[e] = this.data.l.type[g]
                    } else {
                        this[e] = this.graphType
                    }
                }
                var f = "subSummaryType" + g;
                if (this[e] == "Boxplot" || this.summaryType == "iqr") {
                    this[f] = "iqr"
                } else {
                    if (this.summaryType == "median") {
                        this[f] = "median"
                    } else {
                        if (this.summaryType == "sum") {
                            this[f] = "sum"
                        } else {
                            if (this[e] == "Correlation") {
                                this[f] = "cor"
                            } else {
                                if (this[e] == "Candlestick") {
                                    if ((this.graphOrientation == "vertical" && d > 0) || (this.graphOrientation == "horizontal" && b == 0)) {
                                        this[f] = "volume"
                                    } else {
                                        this[f] = "candle"
                                    }
                                } else {
                                    this[f] = "mean"
                                }
                            }
                        }
                    }
                }
                var a = "subTransformType" + g;
                if (!this[a]) {
                    if (this.data.l.transform && this.data.l.transform[g]) {
                        this[a] = this.data.l.transform[g]
                    } else {
                        this[a] = this.subTransformType
                    }
                }
                g++
            }
        }
    };
    this.setLayoutWeights = function() {
        if (this.data.l.weight) {
            var d = 0;
            var e = 0;
            var a;
            var b;
            if (this.scatterPlotMatrix) {
                for (var c = 0; c < this.layoutRows; c++) {
                    a = "subGraphWeight" + c;
                    b = this[a] ? this[a] : this.data.l.weight[c];
                    d += b
                }
                for (var c = 0; c < this.data.l.weight.length; c++) {
                    a = "subGraphWeight" + c;
                    b = this[a] ? this[a] : this.data.l.weight[c];
                    this.data.l.weight[c] = b / d;
                    this[a] = this.data.l.weight[c]
                }
            } else {
                if (this.data.l.vars && this.data.l.smps) {
                    for (var c = 0; c < this.data.l.weight.length; c++) {
                        a = "subGraphWeight" + c;
                        b = this[a] ? this[a] : this.data.l.weight[c];
                        d += b[0];
                        e += b[1]
                    }
                    for (var c = 0; c < this.data.l.weight.length; c++) {
                        a = "subGraphWeight" + c;
                        b = this[a] ? this[a] : this.data.l.weight[c];
                        this.data.l.weight[c][0] = b[0] / d * this.data.l.smps.length;
                        this.data.l.weight[c][1] = b[1] / e * this.data.l.vars.length;
                        this[a] = this.data.l.weight[c]
                    }
                } else {
                    if (this.graphType == "Pie") {
                        for (var c = 0; c < this.data.l.comp.length; c++) {
                            a = "subGraphWeight" + c;
                            this[a] = this.data.l.weight[c]
                        }
                    } else {
                        for (var c = 0; c < this.data.l.weight.length; c++) {
                            a = "subGraphWeight" + c;
                            b = this[a] ? this[a] : this.data.l.weight[c];
                            d += b
                        }
                        for (var c = 0; c < this.data.l.weight.length; c++) {
                            a = "subGraphWeight" + c;
                            b = this[a] ? this[a] : this.data.l.weight[c];
                            this.data.l.weight[c] = b / d;
                            this[a] = this.data.l.weight[c]
                        }
                    }
                }
            }
        } else {
            if (this.data.l.comp) {
                this.data.l.weight = [];
                for (var c = 0; c < this.data.l.comp.length; c++) {
                    a = "subGraphWeight" + c;
                    this.data.l.weight[c] = this.data.l.comp.length;
                    this[a] = this.data.l.weight[c]
                }
            } else {
                alert("Wuz going on dude? This aint't gonna work!")
            }
        }
    };
    this.setMinimumLayoutAxisFonts = function() {
        var h = 0;
        var e = Number.MAX_VALUE;
        for (var d = 0; d < this.layoutRows; d++) {
            for (var b = 0; b < this.layoutCols; b++) {
                var g, f, a;
                if (this.data.l.desc && this.data.l.desc[h]) {
                    g = this.data.l.desc[h]
                } else {
                    g = "NA"
                }
                a = this.graphOrientation == "vertical" ? this.height * this["subGraphWeight" + h] : this.width * this["subGraphWeight" + h];
                this.setAxisFont(g, a);
                f = this.getFontPt(this.axisTitleFont);
                if (f < e) {
                    e = f;
                    this.minLayoutAxis = e;
                    this.minLayoutAxisTitle = g
                }
                h++
            }
        }
    };
    this.getLayoutSummaryTypes = function() {
        var g = 0;
        var a = {};
        var e = [];
        for (var d = 0; d < this.layoutRows; d++) {
            for (var b = 0; b < this.layoutCols; b++) {
                var f = "subSummaryType" + g;
                if (!a.hasOwnProperty(this[f])) {
                    e.push(this[f]);
                    a[this[f]] = true
                }
                g++
            }
        }
        return e
    };
    this.validateLayoutSummaryGrouping = function() {
        if (this.isGroupedData) {
            var b = this.getLayoutSummaryTypes();
            for (var a = 0; a < b.length; a++) {
                if (!this.isValidPlotData(b[a])) {
                    this.groupSamples(this.groupingFactors, b);
                    break
                }
            }
        }
    };
    this.resetLayout = function() {
        delete(this.data.l);
        delete(this.layoutParams);
        this.offsetX = 0;
        this.offsetY = 0;
        this.layoutValidN = false;
        this.layoutValidR = false;
        this.layoutValidC = false;
        this.layoutComb = false;
        this.layout = "1X1"
    };
    this.drawLayoutCompartments = function(h) {
        var a = [];
        var A = 0;
        var t = 0;
        var y = this.varIndices;
        var v = this.smpIndices;
        var s = this.showSampleNames;
        var p = this.showOverlays;
        var l = this.showLegend;
        var x = this.showIndicators;
        var d = this.getObjectArray(y);
        var g = this.getObjectArray(v);
        var D = false;
        var C = ["left", "right", "top", "bottom", "x", "y", "width", "height", "weight", "offsetX", "offsetY", "varIndices", "smpIndices", "grpIndices", "graphType", "summaryType", "transformType", "varIndicesStart", "smpIndicesStart", "minData", "maxData", "xAxisMin", "xAxisMax", "xAxis2Min", "xAxis2Max", "yAxisMin", "yAxisMax", "zAxisMin", "zAxisMax", "xAxisAbsMin", "xAxisAbsMax", "xAxis2AbsMin", "xAxis2AbsMax", "yAxisAbsMin", "yAxisAbsMax", "zAxisAbsMin", "zAxisAbsMax", "xAxisUnit", "xAxis2Unit", "yAxisUnit", "zAxisUnit", "setMin", "setMax", "setMin2", "setMax2", "setMinX", "setMaxX", "setMinY", "setMaxY", "setMinZ", "setMaxZ"];
        var o = ["graphType", "transformType", "varIndicesStart", "smpIndicesStart", "setMin", "setMax", "setMin2", "setMax2", "setMinX", "setMaxX", "setMinY", "setMaxY", "setMinZ", "setMaxZ"];
        var r;
        if (this.layoutComb) {
            if (!this.graphType.match(/Scatter/)) {
                this.layoutMaxVarLegend = this.getLayoutMaxLegend()
            }
            if (this.graphType.match(/Scatter/)) {
                this.xAxis = this.data.y.smps;
                this.yAxis = this.data.y.smps;
                this.initAxes(true)
            } else {
                this.initAxes(false, true)
            }
            this.setLayoutDimensions();
            var E = this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight;
            var f = this.marginTop + this.layoutTop + this.layoutBottom + this.marginBottom;
            if (this.graphType.match(/Scatter/)) {
                this.draw2DLegend()
            }
            if (this.layoutParams && this.layoutValidN > -1) {
                r = this.layoutParams;
                if (r[this.layoutValidN]) {
                    for (var z = 0; z < C.length; z++) {
                        r[this.layoutValidN][C[z]] = this[C[z]]
                    }
                }
            }
            this.offsetX = this.layoutLeft;
            this.offsetY = this.layoutTop;
            this.layoutMaxVarLegendLabel = this.data.l.vars ? this.maxVarNameStr : this.maxSmpNameStr;
            this.layoutParams = [];
            if (!this.graphType.match(/Scatter/)) {
                if (this.data.l.vars && this.data.l.smps) {
                    this.layoutRows = this.data.l.smps.length;
                    this.layoutCols = this.data.l.vars.length;
                    this.layoutMaxSamples = this.smpIndices.length * this.layoutCols / this.layoutRows;
                    this.legendPosition = "bottom"
                } else {
                    A = Math.max(this.layoutRows, this.layoutCols);
                    if (this.graphType != "Pie") {
                        if (this.graphOrientation == "vertical") {
                            this.layoutRows = A;
                            this.layoutCols = 1;
                            this.legendPosition = "right"
                        } else {
                            this.layoutRows = 1;
                            this.layoutCols = A;
                            this.legendPosition = "bottom"
                        }
                    }
                }
            }
            this.setLayoutWeights();
            this.setMinimumLayoutAxisFonts();
            this.setLayoutGraphAttributes();
            this.validateLayoutSummaryGrouping();
            var B = 0;
            for (var z = 0; z < this.layoutRows; z++) {
                var e = false;
                for (var w = 0; w < this.layoutCols; w++) {
                    this.layoutCurrent = B;
                    if (this.graphType == "Pie") {
                        if (this.data.l.smps.length <= B) {
                            break
                        }
                    }
                    if (r) {
                        for (var u = 0; u < o.length; u++) {
                            this[o[u]] = r[B][o[u]]
                        }
                    }
                    this.weight = this["subGraphWeight" + B];
                    this.graphType = this["subGraphType" + B];
                    this.summaryType = this["subSummaryType" + B];
                    this.transformType = this["subTransformType" + B];
                    if (this["subTransformType" + B]) {
                        this.isTransformedData = true
                    }
                    if (this.data.l.log && this.data.l.log[B]) {
                        this.isLogData = this.data.l.log[B]
                    }
                    if (this.graphType.match(/Scatter/)) {
                        if (this.data.l.smps[B].xAxis && this.data.l.smps[B].yAxis) {
                            this.xAxis = this.data.l.smps[B].xAxis;
                            this.yAxis = this.data.l.smps[B].yAxis;
                            this.xAxisIndices = this.getSampleIndices(this.xAxis);
                            this.yAxisIndices = this.getSampleIndices(this.yAxis)
                        } else {
                            this.xAxis = false;
                            this.yAxis = false;
                            this.xAxisIndices = false;
                            this.yAxisIndices = false
                        }
                        this.layoutWidth = (this.width - E) * this["subGraphWeight" + B];
                        this.layoutHeight = (this.height - f) * this["subGraphWeight" + B];
                        this.varIndices = this.data.l.comp[B];
                        if (this.graphType.match(/Scatter/) && this.layoutAdjust && this.xAxis && this.yAxis) {
                            this.initAxes(true);
                            this.layoutAxis = 3
                        } else {
                            if (this.graphType.match(/Scatter/)) {
                                this.layoutAxis = w == 0 ? 2 : 0;
                                this.layoutAxis = z == this.layoutRows && this.layoutAxis ? 3 : z == this.layoutRows ? 1 : 0
                            }
                        }
                        this.showLegend = false;
                        this.showIndicators = false
                    } else {
                        if (this.data.l.vars && this.data.l.smps) {
                            D = this.graphOrientation == "vertical" ? true : false;
                            this.showLegend = false
                        } else {
                            if (this.graphType == "Pie") {
                                D = false;
                                this.showLegend = false
                            } else {
                                D = this.data.l.smps ? true : false
                            }
                        }
                        this.showSampleNames = D;
                        this.showOverlays = D;
                        this.xAxisTitle = this.data.l.desc && this.data.l.desc[B] ? this.data.l.desc[B] : false;
                        if (this.data.l.vars && this.data.l.smps) {
                            this.layoutHeight = (this.height - f) * this["subGraphWeight" + B][1];
                            this.layoutWidth = (this.width - E) * this["subGraphWeight" + B][0];
                            a = [];
                            for (var u = 0; u < this.data.l.comp[B][0].length; u++) {
                                if (d.hasOwnProperty(this.data.l.comp[B][0][u])) {
                                    a.push(this.data.l.comp[B][0][u])
                                }
                            }
                            this.varIndices = a;
                            a = [];
                            for (var u = 0; u < this.data.l.comp[B][1].length; u++) {
                                if (g.hasOwnProperty(this.data.l.comp[B][1][u])) {
                                    a.push(this.data.l.comp[B][1][u])
                                }
                            }
                            this.smpIndices = a
                        } else {
                            if (this.graphType == "Pie") {
                                this.layoutWidth = (this.width - E) * this["subGraphWeight" + B][0];
                                this.layoutHeight = (this.height - f) * this["subGraphWeight" + B][1]
                            } else {
                                if (this.graphOrientation == "vertical") {
                                    this.layoutHeight = (this.height - f) * this["subGraphWeight" + B];
                                    this.layoutWidth = this.width - E
                                } else {
                                    this.layoutWidth = (this.width - E) * this["subGraphWeight" + B];
                                    this.layoutHeight = this.height - f
                                }
                            }
                            a = [];
                            if (this.data.l.vars) {
                                for (var u = 0; u < this.data.l.comp[B].length; u++) {
                                    if (d.hasOwnProperty(this.data.l.comp[B][u])) {
                                        a.push(this.data.l.comp[B][u])
                                    }
                                }
                                this.varIndices = a
                            } else {
                                for (var u = 0; u < this.data.l.comp[B].length; u++) {
                                    if (g.hasOwnProperty(this.data.l.comp[B][u])) {
                                        a.push(this.data.l.comp[B][u])
                                    }
                                }
                                this.smpIndices = a
                            }
                        } if (this.layoutAdjust) {
                            this.layoutAxis = 3;
                            if (this.varIndices.length > 0 && this.smpIndices.length > 0) {
                                this.initAxes(true)
                            }
                        }
                    } if (this.varIndices.length > 0 && this.smpIndices.length > 0) {
                        h.call(this)
                    }
                    this["subGraphTop" + B] = this.top;
                    this["subGraphBottom" + B] = this.bottom;
                    this["subGraphRight" + B] = this.right;
                    this["subGraphLeft" + B] = this.left;
                    this["subGraphX" + B] = this.x;
                    this["subGraphY" + B] = this.y;
                    var n = ["rect", this.marginLeft + this.offsetX + this.left, this.marginTop + this.offsetY + this.top, this.marginLeft + this.offsetX + this.left + this.x, this.marginTop + this.offsetY + this.top + this.y];
                    if (this.graphType.match(/Scatter/)) {
                        if (z == w) {
                            var q = this.scaleTextToFont(this.maxSmpNameStr, this.maxTextSize, (this.width - E) * 0.8 / this.layoutCols);
                            this.drawText(this.data.y.smps[z], this.marginLeft + this.offsetX + this.left + (this.x / 2), this.marginTop + this.offsetY + this.top + (this.y / 2), q, this.foreground, "center", "middle")
                        }
                    } else {
                        if (!D) {
                            if (this.data.l.vars && this.data.l.smps) {
                                if (this.varIndices.length > 0 && this.smpIndices.length > 0) {
                                    if (this.graphOrientation != "vertical" && (B % this.data.l.vars.length == 0 || !e)) {
                                        e = true;
                                        this.drawLayoutSampleOverlays(v)
                                    }
                                    if (B >= this.data.l.vars.length * (this.data.l.smps.length - 1)) {
                                        this.drawLayoutVariableLegend()
                                    }
                                }
                            } else {
                                if (this.graphType != "Pie") {
                                    if ((this.graphOrientation == "vertical" && (B + 1) == A) || (this.graphOrientation != "vertical" && B == 0)) {
                                        this.drawLayoutSampleOverlays(v)
                                    }
                                } else {
                                    if (this.graphType == "Pie" && B == 0) {
                                        if (l) {
                                            this.drawLayoutVariableLegend()
                                        }
                                    }
                                }
                            }
                        } else {
                            if (this.data.l.vars && this.data.l.smps) {
                                if (B >= this.data.l.vars.length * (this.data.l.smps.length - 1)) {
                                    this.drawLayoutVariableLegend()
                                }
                            }
                        }
                    }
                    var b = {};
                    for (var u = 0; u < C.length; u++) {
                        b[C[u]] = this[C[u]]
                    }
                    b.width = this.layoutWidth;
                    b.height = this.layoutHeight;
                    b.subGraphType = this.graphType;
                    b.subSummaryType = this.SummaryType;
                    b.subTransformType = this.transformType;
                    this.layoutParams.push(b);
                    if (this.graphType.match(/Scatter/) || (this.data.l.vars && this.data.l.smps)) {
                        this.offsetX += this.layoutWidth
                    } else {
                        if (this.graphOrientation == "vertical") {
                            this.offsetY += this.layoutHeight
                        } else {
                            this.offsetX += this.layoutWidth
                        }
                    }
                    B++
                }
                if (this.graphType.match(/Scatter|Pie/) || (this.data.l.vars && this.data.l.smps)) {
                    this.offsetX = this.layoutLeft;
                    this.offsetY += this.layoutHeight
                }
            }
            this.drawLabelsLayout();
            this.drawLayoutResizer();
            this.varIndices = y;
            this.smpIndices = v;
            this.showSampleNames = s;
            this.showOverlays = p;
            this.showLegend = l;
            this.showIndicators = x
        }
    };
    this.initializeLayout = function() {
        this.isValidLayout()
    };
    this.initializeLayout()
};
CanvasXpress.prototype.initViewport = function(a) {
    this.setViewport = function() {
        var d = this.$("container-" + this.target);
        var q = this.toolbarPermanent && this.canvas.height > 400 ? 20 : this.toolbarPermanent && this.canvas.height <= 400 ? 13 : 0;
        if (!d) {
            var y = this.$(this.target);
            y.className = "CanvasXpress";
            var d = this.$cX("div", {
                id: "container-" + this.target,
                className: "CanvasXpressContainer"
            });
            if (a) {
                d.style.display = "none"
            }
            var k = this.$cX("div", {
                id: "north-container-" + this.target,
                className: "CanvasXpressContainer"
            }, {
                width: (y.width + 14) + "px",
                height: (q + 7) + "px",
                clear: "left"
            });
            var g = this.$cX("div", {
                id: "north-handler-" + this.target,
                className: "CanvasXpressHandler",
                state: "open",
                open: "url('" + this.imageDir + "tbottom.png')",
                close: "url('" + this.imageDir + "ttop.png')",
                skipWidth: true
            }, {
                width: (y.width + 14) + "px",
                height: "7px",
                display: "none",
                backgroundImage: "url('" + this.imageDir + "ttop.png')"
            });
            var z = this.$cX("div", {
                id: "north-wrapper-" + this.target,
                className: "CanvasXpressWrapper"
            }, {
                width: (y.width + 14) + "px",
                height: q + "px"
            });
            var C = this.$cX("div", {
                id: "middle-container-" + this.target,
                className: "CanvasXpressContainer"
            }, {
                width: (y.width + 14) + "px",
                height: y.height + "px",
                clear: "left"
            });
            if (this.isIE && this.useFlashIE && this.browserVersion < 9) {
                C.style.zIndex = -1
            }
            var l = this.$cX("div", {
                id: "west-container-" + this.target,
                className: "CanvasXpressContainer"
            }, {
                width: "7px",
                height: y.height + "px"
            });
            var j = this.$cX("div", {
                id: "west-handler-" + this.target,
                className: "CanvasXpressHandler",
                state: "open",
                open: "url('" + this.imageDir + "tright.png')",
                close: "url('" + this.imageDir + "tleft.png')",
                skipHeight: true
            }, {
                width: "7px",
                height: y.height + "px",
                display: "none",
                backgroundImage: "url('" + this.imageDir + "tleft.png')"
            });
            var B = this.$cX("div", {
                id: "west-wrapper-" + this.target,
                className: "CanvasXpressWrapper"
            }, {
                width: "0px",
                height: y.height + "px"
            });
            var e = this.$cX("div", {
                id: "center-wrapper-" + this.target,
                className: "CanvasXpressWrapper"
            });
            var h = this.$cX("div", {
                id: "east-container-" + this.target,
                className: "CanvasXpressContainer"
            }, {
                width: "7px",
                height: y.height + "px"
            });
            var f = this.$cX("div", {
                id: "east-handler-" + this.target,
                className: "CanvasXpressHandler",
                state: "open",
                open: "url('" + this.imageDir + "tright.png')",
                close: "url('" + this.imageDir + "tleft.png')",
                skipHeight: true
            }, {
                width: "7px",
                height: y.height + "px",
                display: "none",
                backgroundImage: "url('" + this.imageDir + "tleft.png')"
            });
            var x = this.$cX("div", {
                id: "east-wrapper-" + this.target,
                className: "CanvasXpressWrapper"
            }, {
                width: "0px",
                height: y.height + "px"
            });
            var b = this.$cX("div", {
                id: "south-container-" + this.target,
                className: "CanvasXpressContainer"
            }, {
                width: (y.width + 14) + "px",
                height: "7px",
                clear: "left"
            });
            var A = this.$cX("div", {
                id: "south-handler-" + this.target,
                className: "CanvasXpressHandler",
                open: "url('" + this.imageDir + "tbottom.png')",
                close: "url('" + this.imageDir + "ttop.png')",
                skipWidth: true
            }, {
                width: (y.width + 14) + "px",
                height: "7px",
                display: "none",
                backgroundImage: "url('" + this.imageDir + "ttop.png')"
            });
            var r = this.$cX("div", {
                id: "south-wrapper-" + this.target,
                className: "CanvasXpressWrapper",
                state: "open"
            }, {
                width: (y.width + 14) + "px",
                height: "0px"
            });
            k.appendChild(g);
            k.appendChild(z);
            l.appendChild(B);
            l.appendChild(j);
            h.appendChild(f);
            h.appendChild(x);
            b.appendChild(A);
            b.appendChild(r);
            C.appendChild(l);
            C.appendChild(e);
            C.appendChild(h);
            d.appendChild(k);
            d.appendChild(C);
            d.appendChild(b);
            if (this.isVideo) {
                var m = this.$(this.target + "-cX-Video");
                if (!m) {
                    m = this.$cX("video", {
                        id: this.target + "-cX-Video",
                        autoplay: false,
                        controls: this.videoControls,
                        loop: this.videoLoop,
                        preload: this.videoPreload,
                        poster: this.videoPoster,
                        dataSet: this.videoData,
                        width: this.canvas.width,
                        height: this.canvas.height,
                        className: this.videoClassName
                    });
                    var n = [];
                    var u = this.backgroundVideo;
                    if (u && !(u.propertyIsEnumerable("length")) && typeof u === "object" && typeof u.length === "number") {
                        n = u
                    } else {
                        n.push(this.backgroundVideo)
                    }
                    for (var w = 0; w < n.length; w++) {
                        var p = this.$cX("source", {
                            src: n[w],
                            type: n[w].match(/mp4$/) ? "video/mp4" : n[w].match(/webm$/) ? "video/webm" : "video/ogv"
                        });
                        m.appendChild(p)
                    }
                }
                y.parentNode.insertBefore(d, y);
                e.appendChild(y.parentNode.appendChild(y));
                y.parentNode.insertBefore(m, y)
            } else {
                y.parentNode.insertBefore(d, y);
                e.appendChild(y.parentNode.appendChild(y))
            }
            this.addRemoveViewportListeners("addEvtListener")
        }
    };
    this.addRemoveViewportListeners = function(b) {
        this.addRemoveEvtListener(b, this.$("north-handler-" + this.target), "click", this.clickViewport, false);
        this.addRemoveEvtListener(b, this.$("west-handler-" + this.target), "click", this.clickViewport, false);
        this.addRemoveEvtListener(b, this.$("east-handler-" + this.target), "click", this.clickViewport, false);
        this.addRemoveEvtListener(b, this.$("south-handler-" + this.target), "click", this.clickViewport, false)
    };
    this.clickViewport = function(b) {
        return function(n, d) {
            if (!n) {
                n = window.event
            }
            if (!d) {
                d = b.getTargetEvent(n)
            }
            var q, l;
            var g = d.parentNode;
            var j = d.nextSibling || d.previousSibling;
            var f = b.$(this.remoteParentId + "-canvasXpressRemoteWindow");
            var c = b.$("west-handler-" + b.target);
            var k = b.$("north-container-" + b.target);
            var o = b.$("south-container-" + b.target);
            var p = b.$("middle-container-" + b.target);
            var m = b.$("east-container-" + b.target);
            var i = b.$("west-container-" + b.target);
            if (g && j && c && k && o && p && m && i) {
                if (d.state == "closed") {
                    d.state = "open";
                    d.style.backgroundImage = d.close;
                    if (f) {
                        q = d.lastRemoteWidth;
                        l = d.lastRemoteHeight + 7;
                        b.resizeMove(f, 0, 0, d.lastRemoteWidth, d.lastRemoteHeight)
                    }
                    if (d.id.match(/north|south/)) {
                        b.resizeMove(g, 0, 0, d.lastWidth, d.lastHeight + 7);
                        b.resizeMove(j, 0, 0, d.lastWidth, d.lastHeight)
                    } else {
                        b.resizeMove(p, 0, 0, d.lastWidth + p.clientWidth, b.canvas.height);
                        b.resizeMove(g, 0, 0, d.lastWidth + 7, b.canvas.height);
                        b.resizeMove(j, 0, 0, d.lastWidth, b.canvas.height)
                    }
                    setTimeout(function() {
                        j.style.overflow = "visible"
                    }, 1000)
                } else {
                    j.style.overflow = "hidden";
                    d.state = "closed";
                    d.lastLeft = parseInt(j.style.left);
                    d.lastTop = parseInt(j.style.top);
                    d.lastWidth = parseInt(j.style.width);
                    d.lastHeight = parseInt(j.style.height);
                    d.lastRemoteWidth = f ? parseInt(f.clientWidth) : 0;
                    d.lastRemoteHeight = f ? parseInt(f.clientHeight) : 0;
                    d.style.backgroundImage = d.open;
                    if (d.id.match(/north|south/)) {
                        q = parseInt(i.clientWidth) + b.canvas.width + parseInt(m.clientWidth);
                        l = b.canvas.height + 14;
                        if (f) {
                            b.resizeMove(f, 0, 0, q, l)
                        }
                        b.resizeMove(j, 0, 0, q, 0);
                        b.resizeMove(g, 0, 0, q, 7)
                    } else {
                        l = parseInt(k.clientHeight) + b.canvas.height + parseInt(o.clientHeight);
                        if (d.id.match(/west/)) {
                            q = Math.max(parseInt(o.clientHeight), parseInt(m.clientWidth) + b.canvas.width + 7);
                            if (f) {
                                b.resizeMove(f, 0, 0, q + 48, l + 54)
                            }
                            b.resizeMove(j, 0, 0, 0, b.canvas.height);
                            b.resizeMove(g, 0, 0, 7, b.canvas.height);
                            b.resizeMove(p, 0, 0, parseInt(m.clientWidth) + b.canvas.width + 7, b.canvas.height)
                        } else {
                            q = Math.max(parseInt(o.clientHeight), parseInt(i.clientWidth) + b.canvas.width + 7);
                            if (f) {
                                b.resizeMove(f, 0, 0, q + 48, l + 54)
                            }
                            b.resizeMove(j, 0, 0, 0, b.canvas.height);
                            b.resizeMove(g, 0, 0, 7, b.canvas.height);
                            b.resizeMove(p, 0, 0, parseInt(i.clientWidth) + b.canvas.width + 7, b.canvas.height)
                        }
                    }
                } if (f) {
                    setTimeout(function() {
                        b.resizeExtContainer(q + 48, l + 54)
                    }, 500)
                }
            }
            return false
        }
    }(this);
    this.resizeViewportNorth = function() {
        var e = this.$("west-container-" + this.target);
        var c = this.$("east-container-" + this.target);
        var g = this.$("north-container-" + this.target);
        var d = this.$("north-handler-" + this.target);
        var b = this.$("north-wrapper-" + this.target);
        var f = this.toolbarPermanent && this.canvas.height > 400 ? "20px" : this.toolbarPermanent && this.canvas.height <= 400 ? "13px" : 0;
        if (e && c && g && d && b) {
            if (d.style.display == "block" && d.state == "open") {
                g.style.width = (parseInt(e.style.width) + this.canvas.width + parseInt(c.style.width)) + "px";
                b.style.width = (parseInt(e.style.width) + this.canvas.width + parseInt(c.style.width)) + "px"
            } else {
                g.style.width = (parseInt(e.style.width) + this.canvas.width + parseInt(c.style.width)) + "px";
                b.style.width = (parseInt(e.style.width) + this.canvas.width + parseInt(c.style.width)) + "px";
                g.style.height = (f + 7) + "px";
                b.style.height = f + "px"
            }
            d.style.left = parseInt(e.style.width) + "px";
            d.style.width = this.canvas.width + "px"
        }
    };
    this.resizeViewportWest = function() {
        var f = this.$(this.target + "-cX-Configurator");
        var d = this.$("west-container-" + this.target);
        var b = this.$("west-handler-" + this.target);
        var e = this.$("west-wrapper-" + this.target);
        if (d && b && e) {
            if (b.style.display == "block" && b.state == "open") {
                d.style.width = (this.configuratorWidth + 7 + 22) + "px";
                e.style.width = (this.configuratorWidth + 22) + "px";
                d.style.height = this.canvas.height + "px";
                e.style.height = this.canvas.height + "px"
            } else {
                d.style.width = "7px";
                e.style.width = "0px"
            }
            d.style.height = this.canvas.height + "px";
            b.style.height = this.canvas.height + "px";
            e.style.height = this.canvas.height + "px"
        }
    };
    this.resizeViewportEast = function() {
        var d = this.$(this.target + "-cX-DataFilter");
        var b = this.$("east-container-" + this.target);
        var e = this.$("east-handler-" + this.target);
        var c = this.$("east-wrapper-" + this.target);
        if (b && e && c) {
            if (e.style.display == "block" && e.state == "open") {
                b.style.width = (this.dataFilterWidth + 7 + 6) + "px";
                c.style.width = (this.dataFilterWidth + 6) + "px";
                b.style.height = this.canvas.height + "px";
                c.style.height = this.canvas.height + "px"
            } else {
                b.style.width = "7px";
                c.style.width = "0px"
            }
            b.style.height = this.canvas.height + "px";
            e.style.height = this.canvas.height + "px";
            c.style.height = this.canvas.height + "px"
        }
    };
    this.resizeViewportSouth = function(e) {
        var h = this.$(this.target + "-cX-DataTable");
        var b = this.$("west-handler-" + this.target);
        var c = this.$("west-container-" + this.target);
        var g = this.$("east-container-" + this.target);
        var j = this.$("south-container-" + this.target);
        var f = this.$("south-handler-" + this.target);
        var l = this.$("south-wrapper-" + this.target);
        if (h && b && c && g && j && f && l) {
            var i = b && b.style.display == "none" ? 7 : 0;
            if ((f.style.display == "block" && f.state == "open") || e) {
                j.style.height = (parseInt(h.style.height) + 7 + 2) + "px";
                l.style.height = (parseInt(h.style.height) + 2) + "px";
                j.style.width = (parseInt(h.style.width) + 2 + i) + "px";
                l.style.width = j.style.width
            } else {
                j.style.width = (parseInt(c.style.width) + this.canvas.width + parseInt(g.style.width)) + "px";
                l.style.width = (parseInt(c.style.width) + this.canvas.width + parseInt(g.style.width)) + "px";
                j.style.height = "7px";
                l.style.height = "0px"
            }
            f.style.left = parseInt(c.style.width) + "px";
            f.style.width = this.canvas.width + "px"
        }
    };
    this.resizeViewport = function(j) {
        if (j) {
            var b = this.getTargetEvent(j);
            if (b.className == "CanvasXpressHandler") {
                return
            }
            if (this.Ext) {
                for (var d = 0; d < CanvasXpress.references.length; d++) {
                    CanvasXpress.references[d].resizeViewport()
                }
            }
            if (b.className && b.className.match(/x-tab-strip-text/)) {
                return
            }
        }
        var h = this.$("middle-container-" + this.target);
        var c = this.$("east-container-" + this.target);
        var g = this.$("west-container-" + this.target);
        if (h && c && g) {
            this.resizeViewportWest();
            this.resizeViewportEast();
            this.resizeViewportNorth();
            this.resizeViewportSouth();
            var f = (parseInt(g.style.width) + this.canvas.width + parseInt(c.style.width) + 1);
            h.style.width = (f + 2) + "px";
            h.style.height = (this.canvas.height + 2) + "px"
        }
    };
    this.hideViewport = function() {
        if (this.configuratorLastState && this.configuratorLastState == "docked") {
            var b = this.$("west-handler-" + this.target);
            if (b && b.state == "open") {
                this.clickViewport(false, b)
            }
        }
        if (this.dataFilterLastState && this.dataFilterLastState == "docked") {
            var d = this.$("east-handler-" + this.target);
            if (d && d.state == "open") {
                this.clickViewport(false, d)
            }
        }
        if (this.dataTableLastState && this.dataTableLastState == "docked") {
            var c = this.$("south-handler-" + this.target);
            if (c && c.state == "open") {
                this.clickViewport(false, c)
            }
        }
    };
    this.resetViewportOverflow = function(c) {
        if (c) {
            var b = this.$(c + "-wrapper-" + this.target);
            if (b) {
                b.style.overflow = "visible"
            }
        }
    };
    this.initializeViewport = function() {
        this.setViewport()
    };
    this.initializeViewport()
};
CanvasXpress.prototype.initMenuLinks = function() {
    this.addLinkDiv = function() {
        if (this.$(this.target + "-cX-Link")) {
            this.resetLinkDiv();
            return
        }
        var b = this.$cX("div", {
            id: this.target + "-cX-Link",
            className: "CanvasXpressLink"
        }, {
            zIndex: 10002,
            display: "none"
        });
        var a = this.$cX("ul", {
            id: this.target + "-cX-Link-Content",
            className: "CanvasXpressList"
        });
        var c = this.$("north-wrapper-" + this.target);
        if (c) {
            b.appendChild(a);
            c.appendChild(b)
        }
    };
    this.showLinkDiv = function(J, b, D) {
        var K = this.$(this.target + "-cX-Link-Content");
        var k = this.$("west-container-" + this.target);
        var M = false;
        if (K) {
            this.resetLinkDiv();
            var L = this.adjustedCoordinates(J);
            if (L) {
                var h = L.x + k.offsetWidth;
                var f = L.y;
                for (var H = 0; H < b.length; H++) {
                    var o = b[H].url;
                    var C = b[H].name;
                    var r = b[H].title;
                    var E = b[H].icon;
                    var v = b[H].source;
                    var B = b[H].params;
                    if (o) {
                        M = true
                    } else {
                        if (v && this.data.links && this.data.links[v]) {
                            o = this.data.links[v].url;
                            M = true;
                            if (B) {
                                for (var G in B) {
                                    o = o.replace("$" + G + "$", B[G])
                                }
                            }
                        }
                    }
                    var F = this.$cX("li", {
                        className: "CanvasXpressListItem"
                    });
                    var c = r ? r : this.data.links && v && this.data.links[v] && this.data.links[v].title ? this.data.links[v].title : "";
                    var N = this.$cX("a", {
                        className: "CanvasXpressListItemA",
                        href: o,
                        alt: c,
                        title: c,
                        target: "_blank"
                    });
                    var I = this.$cX("img", {
                        className: "CanvasXpressListIcon",
                        src: E ? E : this.data.links && v && this.data.links[v] && this.data.links[v].icon ? this.data.links[v].icon : this.getPixelImage()
                    });
                    var A = this.$cX("span", {
                        className: "CanvasXpressListItemText",
                        innerHTML: C ? C : this.data.links && v && this.data.links[v] && this.data.links[v].name ? this.data.links[v].name : H
                    });
                    N.appendChild(I);
                    N.appendChild(A);
                    F.appendChild(N);
                    this.addRemoveLinkListeners("addEvtListener", F);
                    K.appendChild(F)
                }
                K.parentNode.style.left = h + "px";
                K.parentNode.style.top = f + "px";
                K.parentNode.style.display = M ? "block" : "none"
            }
        }
    };
    this.addRemoveLinkListeners = function(b, a) {
        if (a) {
            this.addRemoveEvtListener(b, a, "click", this.clickLink, false);
            this.addRemoveEvtListener(b, a, "mouseover", this.mouseoverLink, false);
            this.addRemoveEvtListener(b, a, "mouseout", this.mouseoutLink, false)
        }
    };
    this.clickLink = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.resetLinkDiv();
            return false
        }
    }(this);
    this.mouseoverLink = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            var b = a.getMenuItemComp(c);
            b[0].className = "CanvasXpressListItemActive";
            b[1].className = "CanvasXpressListItemAActive";
            return false
        }
    }(this);
    this.mouseoutLink = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            var b = a.getMenuItemComp(c);
            b[0].className = "CanvasXpressListItem";
            b[1].className = "CanvasXpressListItemA";
            return false
        }
    }(this);
    this.resetLinkDiv = function() {
        var a = this.$(this.target + "-cX-Link-Content");
        if (a && a.childNodes) {
            while (a.childNodes.length > 0) {
                this.addRemoveLinkListeners("removeEvtListener", a.childNodes[0]);
                a.removeChild(a.childNodes[0])
            }
            a.parentNode.style.display = "none"
        }
    };
    this.addMenu = function(n, b, o, k, r, q, j) {
        if (this.disableMenu) {
            return
        }
        var c;
        var g;
        var s = this.$("north-wrapper-" + this.target);
        var f = this.$("west-container-" + this.target);
        this.resetLinkDiv();
        if (s && f) {
            if (b) {
                id = this.newId("-cX-Menu-");
                c = this.$cX("div", {
                    id: id,
                    className: "CanvasXpressMenu",
                    par: o
                }, {
                    left: "0px",
                    top: "0px",
                    zIndex: this.menuIndex++,
                    display: "none"
                })
            } else {
                this.removeMenus();
                if (k) {
                    b = k;
                    r += f.offsetWidth
                } else {
                    b = this.setMenu();
                    var a = this.getTargetEvent(n);
                    var v = this.adjustedCoordinates(n, a);
                    r = v.x + f.offsetWidth;
                    q = v.y
                }
                id = this.newId("-cX-Menu-");
                c = this.$cX("div", {
                    id: id,
                    className: "CanvasXpressMenu"
                }, {
                    left: r + "px",
                    top: q + "px",
                    zIndex: this.menuIndex++
                })
            }
            var t = this.$cX("ul", {
                id: this.newId("-cX-List-"),
                className: "CanvasXpressList",
                header: j
            });
            c.appendChild(t);
            s.appendChild(c);
            var p = 15;
            var d = b.length > p ? p : b.length;
            if (b.length > p) {
                t.rawMenu = b;
                t.rawMenuIndex = 0;
                this.addMenuItemScroller(t, "Top")
            }
            for (var g = 0; g < d; g++) {
                if (b[g][0] == "-") {
                    this.addMenuItemSep(t)
                } else {
                    this.addMenuItem(b[g], t)
                }
            }
            if (b.length > p) {
                this.addMenuItemScroller(t, "Bottom")
            }
        }
        return id
    };
    this.pageMenuItem = function(e, f) {
        var g, i, a, h;
        var d = e.childNodes.length - 2;
        if (f == "Top" && e.rawMenuIndex > 0) {
            g = e.childNodes[e.childNodes.length - 2];
            i = e.rawMenu[e.rawMenuIndex - 1];
            a = e.childNodes[1];
            h = true;
            e.rawMenuIndex--
        } else {
            if (f == "Bottom" && e.rawMenu.length > (e.rawMenuIndex + d)) {
                g = e.childNodes[1];
                i = e.rawMenu[e.rawMenuIndex + d];
                a = e.childNodes[e.childNodes.length - 1];
                h = true;
                e.rawMenuIndex++
            }
        } if (h) {
            this.addRemoveItemListeners("removeEvtListener", g);
            g.parentNode.removeChild(g);
            if (i[0] == "-") {
                this.addMenuItemSep(e, a)
            } else {
                this.addMenuItem(i, e, a)
            }
        }
    };
    this.addMenuItemSep = function(d, a) {
        var c = this.$cX("li", {
            id: this.newId("-cX-List-Item-Sep-"),
            className: "CanvasXpressListItemSep"
        });
        var e = this.$cX("span", {
            id: this.newId("-cX-List-Item-Text-Sep-"),
            className: "CanvasXpressListItemTextSep",
            innerHTML: "&nbsp;"
        });
        c.appendChild(e);
        if (a) {
            a.parentNode.insertBefore(c, a)
        } else {
            d.appendChild(c)
        }
    };
    this.addMenuItemScroller = function(b, c) {
        var a = this.$cX("li", {
            id: this.newId("-cX-List-Item-Scroll-" + c),
            className: "CanvasXpressListItemScroll" + c
        });
        var d = this.$cX("span", {
            id: this.newId("-cX-List-Item-Text-Scroll-" + c),
            className: "CanvasXpressListItemTextScroll" + c,
            innerHTML: "&nbsp;"
        });
        a.appendChild(d);
        b.appendChild(a);
        this.addRemoveItemListeners("addEvtListener", a)
    };
    this.addMenuItem = function(d, n, j) {
        var h = this.newId("-cX-List-Item-");
        var f = this.$cX("li", {
            id: h,
            className: "CanvasXpressListItem",
            click: d[2],
            params: d[3] || []
        });
        var k;
        if (d[5]) {
            var e = this.addMenu(false, d[5], h);
            k = this.$cX("a", {
                id: this.newId("-cX-List-Item-A-"),
                className: "CanvasXpressListItemAArrow",
                hidefocus: "true",
                unselectable: "on",
                href: "#",
                menu: e
            })
        } else {
            k = this.$cX("a", {
                id: this.newId("-cX-List-Item-A-"),
                className: "CanvasXpressListItemA",
                hidefocus: "true",
                unselectable: "on",
                href: "#"
            })
        }
        var g = this.$cX("img", {
            id: this.newId("-cX-List-Icon-"),
            className: "CanvasXpressListIcon",
            src: this.imageDir + (d[1] || "canvasXpress.gif")
        });
        var p = this.$cX("span", {
            id: this.newId("-cX-List-Item-Text-"),
            className: "CanvasXpressListItemText",
            innerHTML: d[0] || ""
        });
        var c = this.$cX("span", {
            className: "CanvasXpressListItemTextShort",
            innerHTML: d[4] || ""
        });
        k.appendChild(g);
        k.appendChild(p);
        k.appendChild(c);
        f.appendChild(k);
        if (j) {
            j.parentNode.insertBefore(f, j)
        } else {
            n.appendChild(f)
        }
        this.addRemoveItemListeners("addEvtListener", f)
    };
    this.addRemoveItemListeners = function(b, a) {
        if (!a) {
            return this.removeMenus()
        }
        this[b](a, "click", this.clickMenuItem, false);
        this[b](a, "mouseover", this.mouseoverMenuItem, false);
        this[b](a, "mouseout", this.mouseoutMenuItem, false);
        if (a.className.match(/Scroll/)) {
            this[b](a, "mousedown", this.mousedownMenuItem, false);
            this[b](a, "mouseup", this.mouseupMenuItem, false)
        }
    };
    this.clickMenuItem = function(a) {
        return function(g) {
            if (!g) {
                g = window.event
            }
            var f = a.getMenuItemComp(g);
            if (f[0].className.match(/Scroll/) || f[1].className.match(/Scroll/)) {
                var b = f[0].className.match(/Scroll/) ? f[0] : f[1];
                var c = b.parentNode;
                var j = b.className.match(/ScrollTop/) ? "Top" : "Bottom";
                a.pageMenuItem(c, j)
            } else {
                var h = [];
                if (f[0].params) {
                    for (var d = 0; d < f[0].params.length; d++) {
                        if (f[0].params[d] == "event") {
                            h.push(g)
                        } else {
                            if (f[0].params[d] == "component") {
                                h.push(f)
                            } else {
                                h.push(f[0].params[d])
                            }
                        }
                    }
                }
                a[f[0].click].apply(a, h);
                a.removeMenus()
            }
            a.cancelEvent();
            return false
        }
    }(this);
    this.mouseoverMenuItem = function(a) {
        return function(g) {
            if (!g) {
                g = window.event
            }
            var f = a.getMenuItemComp(g);
            if (f[0].className.match(/Scroll/) || f[1].className.match(/Scroll/)) {
                var i = f[0].className.match(/Scroll/) ? f[0] : f[1];
                i.className += "Active";
                return
            }
            f[0].className = "CanvasXpressListItemActive";
            if (a.subMenuOn && a.subMenuOn.par != f[0].id) {
                var b = a.$(a.subMenuOn.par);
                a.hideMenu([b, b.childNodes[0]], a.subMenuOn)
            }
            if (f[1].menu) {
                var b = a.$(f[1].menu);
                var h = f[0].parentNode.parentNode;
                b.style.left = (h.offsetLeft + h.offsetWidth - 5) + "px";
                b.style.top = (h.offsetTop + f[1].offsetTop) + "px";
                b.style.display = "block";
                f[1].className = "CanvasXpressListItemAArrowActive"
            } else {
                f[1].className = "CanvasXpressListItemAActive"
            }
        }
    }(this);
    this.mouseoutMenuItem = function(a) {
        return function(k) {
            if (!k) {
                k = window.event
            }
            if (a.fastScrollMenuOn) {
                a.fastScrollMenuOn = false;
                clearInterval(a.fastScrollMenu)
            }
            var g, c, b, u, s, r, o, n;
            var t = a.adjustedCoordinates(k);
            if (t) {
                var j = a.$("north-container-" + a.target);
                var i = a.$("west-container-" + a.target);
                t.x += i.offsetWidth;
                t.y += j.offsetHeight;
                var q = a.getMenuItemComp(k);
                if (q[1] && q[1].menu) {
                    var h = a.$(q[1].menu);
                    g = h.offsetLeft;
                    s = h.offsetTop;
                    c = g + h.offsetWidth;
                    r = s + h.offsetHeight;
                    if (t.x >= g && t.x <= c && t.y >= s && t.y <= r) {
                        a.subMenuOn = h;
                        return
                    }
                    a.hideMenu(q, h)
                } else {
                    var l = q[0].parentNode.parentNode;
                    var f = l.par ? a.$(l.par) : false;
                    g = l.offsetLeft + 3;
                    s = l.offsetTop + 3;
                    c = g + l.offsetWidth - 6;
                    r = s + l.offsetHeight - 6;
                    if (f && (t.x <= g || t.x >= c || t.y <= s || t.y >= r)) {
                        a.hideMenu([f, f.childNodes[0]], l)
                    }
                    a.hideMenu(q, h)
                }
            }
        }
    }(this);
    this.mousedownMenuItem = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.fastScrollMenuOn = true;
            a.fastScrollMenu = setInterval(function() {
                a.clickMenuItem(b)
            }, 100);
            return false
        }
    }(this);
    this.mouseupMenuItem = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            if (a.fastScrollMenuOn) {
                a.fastScrollMenuOn = false;
                clearInterval(a.fastScrollMenu)
            }
        }
    }(this);
    this.getMenuItemComp = function(d) {
        var c = this.getTargetEvent(d);
        var b;
        if (c.tagName.match(/img|span/i)) {
            b = c.parentNode;
            c = b.parentNode
        } else {
            if (c.tagName.match(/a/i)) {
                b = c;
                c = b.parentNode
            } else {
                b = c.getElementsByTagName("a")[0]
            }
        }
        return [c, b]
    };
    this.hideMenu = function(a, b) {
        if (a) {
            if (a[0].className.match(/Scroll/) || a[1].className.match(/Scroll/)) {
                var d = a[0].className.match(/Scroll/) ? a[0] : a[1];
                d.className = d.className.replace("Active", "")
            } else {
                if (a[1] && a[1].menu) {
                    a[1].className = "CanvasXpressListItemAArrow"
                } else {
                    a[1].className = "CanvasXpressListItemA"
                }
                a[0].className = "CanvasXpressListItem"
            }
        }
        if (b) {
            b.style.display = "none"
        }
        this.subMenuOn = false
    };
    this.removeMenus = function(k) {
        var f = [];
        if (this.skipHeaderMouseout) {
            this.skipHeaderMouseout.className = "CanvasXpressTableCellHead";
            this.skipHeaderMouseout.firstChild.firstChild.className = "CanvasXpressTableCellHead";
            this.skipHeaderMouseout = false
        }
        if (!k) {
            var c = this.$("north-wrapper-" + this.target);
            if (c) {
                var h = c.getElementsByTagName("div");
                for (var g = 0; g < h.length; g++) {
                    if (h[g].className == "CanvasXpressMenu") {
                        f.unshift(this.$(h[g].id))
                    }
                }
            }
            this.menuIndex = 10000
        } else {
            f.push(this.$(this.target + "-cX-Menu-" + k))
        } if (f.length > 0) {
            for (var g = 0; g < f.length; g++) {
                var a = f[g];
                var b = a.getElementsByTagName("li");
                for (var e = 0; e < b.length; e++) {
                    if (b[e].className != "CanvasXpressListItemSep") {
                        this.addRemoveItemListeners("removeEvtListener", b[e])
                    }
                }
                a.parentNode.removeChild(a)
            }
        }
    };
    this.setMenu = function() {
        this.menu = {};
        var c = ["Bar", "Line", "Area", "AreaLine", "BarLine", "Boxplot", "Dotplot", "Heatmap", "Treemap", "Stacked", "StackedLine", "StackedPercent", "StackedPercentLine", "Candlestick", "Pie", "Correlation", "Circular", "Scatter2D", "ScatterBubble2D", "Scatter3D", "Scatter2D", "Venn", "Network", "Genome"];
        for (var d = 0; d < c.length; d++) {
            this.menu[this.validGraphTypes[d]] = []
        }
        if (this.graphType == "Network") {
            var b = [];
            b.push(["Clockwise", "rotate_clockwise.png", "arrowMove", [34]]);
            b.push(["Clockwise - Animate", "rotate_clockwise_cont.png", "arrowMove", [39, true]]);
            b.push(["Anticlockwise", "rotate_anticlockwise.png", "arrowMove", [33]]);
            b.push(["Anticlockwise - Animate", "rotate_anticlockwise_cont.png", "arrowMove", [37, true]]);
            var g = [];
            g.push(["Top", "align_top.png", "alignDistributeSelectedNodes", [false, 84]]);
            g.push(["Right", "align_right.png", "alignDistributeSelectedNodes", [false, 82]]);
            g.push(["Bottom", "align_bottom.png", "alignDistributeSelectedNodes", [false, 66]]);
            g.push(["Left", "align_left.png", "alignDistributeSelectedNodes", [false, 76]]);
            var e = [];
            e.push(["Vertically", "distribute_vertical.png", "alignDistributeSelectedNodes", [false, 86]]);
            e.push(["Horozontally", "distribute_horizontal.png", "alignDistributeSelectedNodes", [false, 72]]);
            var f = [];
            f.push(["Send to back", "move_back.png", "orderNodes", ["sendNodeToBack"]]);
            f.push(["Send backward", "move_backwards.png", "orderNodes", ["sendNodeBackward"]]);
            f.push(["Bring to front", "move_front.png", "orderNodes", ["bringNodeToFront"]]);
            f.push(["Bring forward", "move_forwards.png", "orderNodes", ["bringNodeForward"]]);
            if (this.isSelectNodes) {
                this.menu.Network.push(["Align", "align_bottom.png", false, false, false, g]);
                this.menu.Network.push(["Distribute", "distribute_vertical.png", false, false, false, e]);
                this.menu.Network.push(["Rotate", "rotate_anticlockwise.png", false, false, false, b]);
                this.menu.Network.push(["Order", "move_front.png", false, false, false, f]);
                this.menu.Network.push(["-"]);
                this.menu.Network.push(["Show conections", "connections.png", "showHideSelectedDataPoint", [false, 36], "Ctrl + Home"]);
                this.menu.Network.push(["-"]);
                this.menu.Network.push(["Show hidden nodes", "show_selected.png", "showHideSelectedDataPoint", [false, 45], "Ctrl + Insert"]);
                this.menu.Network.push(["Hide nodes", "hide_selected.png", "showHideSelectedDataPoint", [false, 46], "Ctrl + Delete"]);
                this.menu.Network.push(["-"]);
                this.menu.Network.push(["Undo", "undo.png", "alignDistributeSelectedNodes", [false, 90], "Ctrl + z"]);
                this.menu.Network.push(["Redo", "redo.png", "alignDistributeSelectedNodes", [false, 90, true], "Ctrl + y"]);
                this.menu.Network.push(["-"])
            } else {
                this.menu.Network.push(["Rotate", "rotate_anticlockwise.png", false, false, false, b])
            }
        }
        for (var d = 0; d < c.length; d++) {
            this.menu[this.validGraphTypes[d]].push(["Reset", "refresh.png", "masterReset", [], "ESC"]);
            this.menu[this.validGraphTypes[d]].push(["Print", "camera.png", "print", [], "Ctrl + P"]);
            if (this.remoteService) {
                var a = [];
                a.push(["Overwrite data", "disk.png", "save", ["event", "update"]]);
                a.push(["Save data as", "save-as.png", "save", ["event", "save"]]);
                a.push(["Delete data", "delete-saved.png", "save", ["event", "delete"]]);
                a.push(["Recover data", "recover.png", "save", ["event", "recover"]]);
                this.menu[this.validGraphTypes[d]].push(["Server save", "disk.png", false, false, false, a])
            }
        }
        return this.menu[this.graphType]
    };
    this.resetMenuLinks = function() {
        this.resetLinkDiv();
        this.removeMenus()
    };
    this.initializeMenuLinks = function() {
        if (!this.disableEvents) {
            this.addLinkDiv()
        }
    };
    this.initializeMenuLinks()
};
CanvasXpress.prototype.initToolbarTooltip = function() {
    this.addToolbarDiv = function() {
        if (this.$(this.target + "-cX-Toolbar")) {
            return
        }
        var s = this.canvas.height >= 500 ? "16px" : this.canvas.height >= 400 ? "12px" : this.canvas.height >= 300 ? "10px" : "8px";
        var j = this.$cX("div", {
            id: this.target + "-cX-Toolbar"
        }, {
            position: "absolute",
            overflow: this.toolbarPermanent ? "visible" : "hidden",
            width: this.width + "px",
            height: "0px",
            left: 7 + "px",
            top: this.toolbarPermanent ? "0px" : "12px",
            zIndex: 9000
        });
        var b = this.$cX("img", {
            src: this.getPixelImage() + "?" + new Date().getDayYear() + ":" + this.userId
        });
        var l = this.$cX("img", {
            id: this.target + "-cX-ToolbarHelp",
            className: "CanvasXpressToolbarImage",
            src: this.imageDir + "help1.png",
            alt: "Help",
            title: "Help"
        }, {
            width: s,
            height: s
        });
        var g = this.$cX("img", {
            id: this.target + "-cX-ToolbarCode",
            className: "CanvasXpressToolbarImage",
            src: this.imageDir + "purple_code.png",
            alt: "Show Code",
            title: "Show Code"
        }, {
            width: s,
            height: s
        });
        var e = this.$cX("img", {
            id: this.target + "-cX-ToolbarSave",
            className: "CanvasXpressToolbarImage",
            src: this.imageDir + "camera.png",
            alt: "Save as png",
            title: "Save as png"
        }, {
            width: s,
            height: s
        });
        var r = this.$cX("img", {
            id: this.target + "-cX-ToolbarLayout",
            className: "CanvasXpressToolbarImage",
            src: this.appLayout ? this.imageDir + "configure_hide.png" : this.isLayoutConfigurator ? this.imageDir + "configure_show.png" : this.imageDir + "configure_simple_show.png",
            alt: this.appLayout ? "Basic layout" : "Application layout",
            title: this.appLayout ? "Basic layout" : "Application layout"
        }, {
            width: s,
            height: s,
            display: this.disableDataFilters || this.disableDataTable || this.disableConfigurator ? "none" : "block"
        });
        var m = this.$cX("img", {
            id: this.target + "-cX-ToolbarFilter",
            className: "CanvasXpressToolbarImage",
            src: this.imageDir + "funnel.png",
            alt: "Filter data",
            title: "Filter data"
        }, {
            width: s,
            height: s,
            display: this.disableDataFilters ? "none" : "block"
        });
        var o = this.$cX("img", {
            id: this.target + "-cX-ToolbarData",
            className: "CanvasXpressToolbarImage",
            src: this.imageDir + "table.png",
            alt: "Show data",
            title: "Show data"
        }, {
            width: s,
            height: s,
            display: this.disableDataTable ? "none" : "block"
        });
        if (this.isVML || this.disableConfigurator || (this.isIE && this.browserVersion < 9)) {
            o.style.marginRight = "4px"
        }
        var t = this.$cX("img", {
            id: this.target + "-cX-ToolbarConfigurator",
            className: "CanvasXpressToolbarImage",
            src: this.imageDir + "cog.png",
            alt: "Configure plot",
            title: "Configure plot"
        }, {
            width: s,
            height: s,
            marginRight: "4px",
            display: this.isVML || this.disableConfigurator || (this.isIE && this.browserVersion < 9) ? "none" : "block"
        });
        var u = this.$cX("div", {
            id: this.target + "-cX-ToolbarHelpDescription",
            className: "CanvasXpressToolbarHelp draggable"
        }, {
            cursor: "move",
            display: "none",
            padding: "10px",
            position: "absolute"
        });
        var k = this.$cX("img", {
            id: this.target + "-cX-ToolbarHelpClose",
            className: "CanvasXpressToolbarHelp",
            src: this.imageDir + "cancel1.png",
            alt: "Close",
            title: "Close"
        });
        u.appendChild(document.createTextNode("Help"));
        u.appendChild(k);
        u.appendChild(this.$cX("br"));
        this.addHelp(u);
        j.appendChild(b);
        j.appendChild(t);
        j.appendChild(o);
        j.appendChild(m);
        j.appendChild(r);
        j.appendChild(e);
        j.appendChild(g);
        j.appendChild(l);
        j.appendChild(u);
        var u = this.$("north-wrapper-" + this.target);
        if (u) {
            u.appendChild(j);
            this.addRemoveToolbarListeners("addEvtListener")
        }
    };
    this.addRemoveToolbarListeners = function(a) {
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-ToolbarHelp"), "click", this.clickHelp, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-ToolbarCode"), "click", this.clickShowCode, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-ToolbarSave"), "click", this.print, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-ToolbarLayout"), "click", this.clickLayout, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-ToolbarFilter"), "click", this.clickDataFilters, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-ToolbarData"), "click", this.clickDataTable, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-ToolbarConfigurator"), "click", this.clickGraphConfigurator, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-ToolbarHelpClose"), "click", this.closeHelp, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-ToolbarHelpDescription"), "mousedown", this.registerMousemove, false)
    };
    this.clickHelp = function(a) {
        return function(f) {
            if (!f) {
                f = window.event
            }
            var c = a.$(a.target + "-cX-Toolbar");
            var d = a.$(a.target + "-cX-ToolbarHelpDescription");
            if (c && d) {
                c.style.overflow = "visible";
                d.style.display = "block";
                d.style.left = ((f.layerX || f.x) - 400) + "px";
                d.style.top = (f.layerY || f.y) + "px"
            }
            return false
        }
    }(this);
    this.clickShowCode = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.showCodeDiv();
            return false
        }
    }(this);
    this.closeHelp = function(a) {
        return function(f) {
            if (!f) {
                f = window.event
            }
            var c = a.$(a.target + "-cX-Toolbar");
            var d = a.$(a.target + "-cX-ToolbarHelpDescription");
            if (c && d) {
                d.style.display = "none";
                setTimeout(function() {
                    c.style.overflow = a.toolbarPermanent ? "visible" : "hidden"
                }, 300)
            }
            return false
        }
    }(this);
    this.clickLayout = function(a) {
        return function(i) {
            if (!i) {
                i = window.event
            }
            var j = function() {
                a.showDataFilter();
                if (!a.dataFilterLastState || (a.dataFilterLastState && a.dataFilterLastState != "docked")) {
                    a.moveDataFilter();
                    if (!a.activeAccordion) {
                        setTimeout(function() {
                            if (a.graphType == "Genome") {
                                a.activateAccordion(false, a.$(a.target + "-cX-DataFilterGenomeHeader"))
                            } else {
                                if (a.graphType == "Network") {
                                    a.activateAccordion(false, a.$(a.target + "-cX-DataFilterNodeHeader"))
                                } else {
                                    a.activateAccordion(false, a.$(a.target + "-cX-DataFilterVariableHeader"))
                                }
                            }
                        }, 500)
                    }
                }
            };
            var f = function() {
                a.updateDataTable();
                if (!a.dataTableLastState || (a.dataTableLastState && a.dataTableLastState != "docked")) {
                    a.moveDataTableDiv("dock")
                }
                setTimeout(function() {
                    var e = a.$("middle-container-" + a.target);
                    a.dataTableTarget = a.$(a.target + "-cX-DataTable");
                    a.updateDataTableResizerDiv(false, parseInt(e.style.width) - 9, parseInt(a.dataTableTarget.style.height));
                    a.endDataTableResizerDiv();
                    a.hideToolbar()
                }, 500)
            };
            var c = i.target || i.srcElement;
            a.appLayout = a.appLayout ? false : true;
            c.src = a.appLayout ? a.imageDir + "configure_hide.png" : a.imageDir + "configure_show.png";
            c.alt = a.appLayout ? "Basic layout" : "Application layout";
            c.title = a.appLayout ? "Basic layout" : "Application layout";
            if (a.resizeHeightOnLayout) {
                a.setDataTableDimensions()
            }
            var b = a.isLayoutConfigurator ? a.configuratorWidth + a.dataFilterWidth + 36 : a.dataFilterWidth + 18;
            var d = a.dataTableRowsHeight + 53;
            if (a.appLayout) {
                if (a.resizeWidthOnLayout && a.width - b >= b * 1.3) {
                    if (a.resizeHeightOnLayout && a.height - d >= d * 1.3) {
                        a.setDimensions(a.width - b, a.height - d);
                        a.resizeWidthOnLayoutActive = true;
                        a.resizeHeightOnLayoutActive = true
                    } else {
                        a.setDimensions(a.width - b, a.height);
                        a.resizeWidthOnLayoutActive = true
                    }
                    a.resizeViewport()
                } else {
                    if (a.resizeHeightOnLayout && a.height - d >= d * 1.3) {
                        a.setDimensions(a.width, a.height - d);
                        a.resizeHeightOnLayoutActive = true;
                        a.resizeViewport()
                    }
                }
                var g = a.isLayoutConfigurator ? 500 : 1;
                if (a.isLayoutConfigurator) {
                    a.addConfigurator();
                    a.selectConfig(false, true);
                    if (!a.configuratorLastState || (a.configuratorLastState && a.configuratorLastState != "docked")) {
                        a.clickDockUndockConfigurator()
                    }
                }
                a.dataFilterHeight = a.canvas.height - (a.graphType == "Genome" ? 60 : 81);
                setTimeout(function() {
                    j();
                    setTimeout(function() {
                        f()
                    }, 500)
                }, g)
            } else {
                if (a.isLayoutConfigurator) {
                    a.closeConfigurator()
                }
                setTimeout(function() {
                    if (a.activeAccordion) {
                        a.activateAccordion(false, a.activeAccordion.previousSibling)
                    }
                    a.hideDataFilter();
                    setTimeout(function() {
                        a.hideTable();
                        a.hideToolbar();
                        setTimeout(function() {
                            if (a.resizeWidthOnLayoutActive) {
                                if (a.resizeHeightOnLayoutActive) {
                                    a.setDimensions(a.width + b, a.height + d)
                                } else {
                                    a.setDimensions(a.width + b, a.height)
                                }
                            } else {
                                if (a.resizeHeightOnLayoutActive) {
                                    a.setDimensions(a.width, a.height + d)
                                }
                            }
                            a.resizeWidthOnLayoutActive = false;
                            a.resizeHeightOnLayoutActive = false
                        }, 500)
                    }, 500)
                }, 500)
            }
            return false
        }
    }(this);
    this.clickDataTable = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.updateDataTable();
            return false
        }
    }(this);
    this.clickDataFilters = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.showDataFilter();
            return false
        }
    }(this);
    this.clickGraphConfigurator = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.addConfigurator();
            return false
        }
    }(this);
    this.addHelp = function(m) {
        var j = this.$cX("div", false, {
            width: "400px"
        });
        j.appendChild(this.$cX("br"));
        var y = this.$cX("img", {
            src: this.imageDir + "help1.png"
        });
        j.appendChild(y);
        j.appendChild(document.createTextNode(" Show this help"));
        j.appendChild(this.$cX("br"));
        var r = this.$cX("img", {
            src: this.imageDir + "camera.png"
        });
        j.appendChild(r);
        j.appendChild(document.createTextNode(" Save"));
        j.appendChild(this.$cX("br"));
        var i = this.$cX("p", {
            className: "CanvasXpressToolbarHelp",
            innerHTML: "Save the image as a 'png' file (in this toolbar) or save the data as an excel file (in the data table widget)."
        });
        j.appendChild(i);
        var A = this.$cX("img", {
            src: this.imageDir + "funnel.png"
        });
        j.appendChild(A);
        j.appendChild(document.createTextNode(" Filters"));
        j.appendChild(this.$cX("br"));
        var D = this.$cX("p", {
            className: "CanvasXpressToolbarHelp",
            innerHTML: "Widget used to filter the data and metadata. Metadata will be automatically assigned as text, numeric or date."
        });
        j.appendChild(D);
        var A = this.$cX("img", {
            src: this.imageDir + "table.png"
        });
        j.appendChild(A);
        j.appendChild(document.createTextNode(" Show data"));
        j.appendChild(this.$cX("br"));
        var b = this.$cX("p", {
            className: "CanvasXpressToolbarHelp",
            innerHTML: "Show the data used for this visualization in an HTML table."
        });
        j.appendChild(b);
        var y = this.$cX("img", {
            src: this.imageDir + "cog.png"
        });
        j.appendChild(y);
        j.appendChild(document.createTextNode(" Show the configurator"));
        j.appendChild(this.$cX("br"));
        var g = this.$cX("p", {
            className: "CanvasXpressToolbarHelp",
            innerHTML: "This widget allows you to customize this graph. You may enter the name of the property you wish to customize in the text box (which filters as you type) or browse through a number of categories.<br>You will find a short description for the property you select along with its category and links to other relevant properties.<br>You will also see the current value for the seleced property along with a link to an additional widget to help you specifying the new value."
        });
        j.appendChild(g);
        var C = this.$cX("img", {
            src: this.imageDir + "lightbulb.png"
        });
        j.appendChild(C);
        j.appendChild(document.createTextNode(" Show or hide advanced customizations"));
        j.appendChild(this.$cX("br"));
        var f = this.$cX("p", {
            className: "CanvasXpressToolbarHelp",
            innerHTML: "Displayed in the configurator widget."
        });
        j.appendChild(f);
        var q = this.$cX("img", {
            src: this.imageDir + "find.png"
        });
        j.appendChild(q);
        j.appendChild(document.createTextNode(" Search by customizable categories"));
        j.appendChild(this.$cX("br"));
        var e = this.$cX("p", {
            className: "CanvasXpressToolbarHelp",
            innerHTML: "Displayed in the configurator widget to facilitate searching for customizable property."
        });
        j.appendChild(e);
        var v = this.$cX("img", {
            src: this.imageDir + "pin.png"
        });
        j.appendChild(v);
        j.appendChild(document.createTextNode(" Dock widget to the side"));
        j.appendChild(this.$cX("br"));
        var o = this.$cX("img", {
            src: this.imageDir + "unpin.png"
        });
        j.appendChild(o);
        j.appendChild(document.createTextNode(" Undock widget from the side"));
        j.appendChild(this.$cX("br"));
        var t = this.$cX("img", {
            src: this.imageDir + "purple_code.png"
        });
        j.appendChild(t);
        j.appendChild(document.createTextNode(" Show visualization code"));
        j.appendChild(this.$cX("br"));
        var B = this.$cX("img", {
            src: this.imageDir + "cancel1.png"
        });
        j.appendChild(B);
        j.appendChild(document.createTextNode(" Close widget"));
        j.appendChild(this.$cX("br"));
        j.appendChild(this.$cX("br"));
        var l = this.$cX("a", {
            href: "http://canvasxpress.org",
            target: "_blank",
            innerHTML: "canvasXpress"
        });
        j.appendChild(document.createTextNode("Additional documentation at "));
        j.appendChild(l);
        j.appendChild(this.$cX("br"));
        m.appendChild(j)
    };
    this.showToolbar = function(e) {
        if (!this.toolbarPermanent) {
            var a = this.$(this.target + "-cX-Toolbar");
            var d = this.$("west-container-" + this.target);
            if (a && parseInt(a.style.height) == 0 && d) {
                var c = this;
                var b = parseInt(d.style.width);
                this.resizeMove(a, 0, 12, this.width + b, 20, 250);
                if (e) {
                    setTimeout(function() {
                        c.hideToolbar()
                    }, 5000)
                }
            }
        }
    };
    this.hideToolbar = function() {
        if (!this.toolbarPermanent) {
            var a = this.$(this.target + "-cX-Toolbar");
            var c = this.$("west-container-" + this.target);
            if (a && parseInt(a.style.height) == 20 && c) {
                var b = parseInt(c.style.width);
                this.resizeMove(a, 0, 12, this.width + b, 0)
            }
        }
    };
    this.isToolbar = function(c) {
        if (!c) {
            c = window.event
        }
        var b = this.adjustedCoordinates(c);
        if (b) {
            var a = b.x;
            var d = b.y;
            if (d > 0 && d < 24 && a > 0 && a < this.width) {
                this.showToolbar()
            } else {
                if (d > 24 && d < this.height && a > 0 && a < this.width) {
                    this.hideToolbar()
                }
            }
        }
    };
    this.addTooltipDiv = function(l, k, j) {
        var a = 0;
        var b = this.target + "-cX-TooltipDiv" + a;
        var o = this.$(this.target + "-cX-Info");
        if (o && o.style.display != "none") {
            k = parseInt(o.style.left);
            j = parseInt(o.style.top)
        }
        var f = this.$(b);
        while (f) {
            a++;
            b = this.target + "-cX-TooltipDiv" + a;
            f = this.$(b)
        }
        var g = this.$cX("div", {
            id: b,
            className: "CanvasXpressTooltip draggable"
        }, {
            left: k + "px",
            top: j + "px",
            zIndex: 29010
        });
        var h = this.$cX("img", {
            id: b + "Close",
            className: "CanvasXpressTooltip",
            src: this.imageDir + "cancel1.png",
            alt: "Close",
            title: "Close"
        });
        var m = this.$cX("div", {
            id: b + "HTML",
            innerHTML: l || ""
        }, {
            clear: "both"
        });
        g.appendChild(h);
        g.appendChild(m);
        document.body.appendChild(g);
        this.resetInfoSpan();
        return g
    };
    this.addRemoveTooltipDivsListeners = function(a, b) {
        this.addRemoveEvtListener(a, b, "mousedown", this.registerMousemove, false);
        this.addRemoveEvtListener(a, b, "touchstart", this.registerMousemove, false);
        this.addRemoveEvtListener(a, b.firstChild, "click", this.closeTooltipDiv, false)
    };
    this.closeTooltipDiv = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            var b = c.target || c.srcElement;
            if (b) {
                var f = b.parentNode;
                a.addRemoveTooltipDivsListeners("removeEvtListener", f);
                f.parentNode.removeChild(f)
            }
            return false
        }
    }(this);
    this.showTooltipDiv = function(c, g) {
        var b = this.adjustedCoordinates(c);
        if (b) {
            var a = b.x;
            var h = c ? b.y : b.y + 25;
            var f = this.addTooltipDiv(g, a, h);
            this.addRemoveTooltipDivsListeners("addEvtListener", f)
        }
    };
    this.resetTooltipDivs = function() {
        var c = 0;
        var a = this.target + "-cX-TooltipDiv" + c;
        var b = this.$(a);
        while (b) {
            this.addRemoveTooltipDivsListeners("removeEvtListener", b);
            b.parentNode.removeChild(b);
            c++;
            a = this.target + "-cX-TooltipDiv" + c;
            b = this.$(a)
        }
    };
    this.addInfoSpan = function() {
        if (this.$(this.target + "-cX-Info")) {
            this.resetInfoSpan();
            return
        }
        var a = this.$cX("span", {
            id: this.target + "-cX-Info",
            className: "CanvasXpressTooltip"
        }, {
            display: "none",
            zIndex: 29010
        });
        document.body.appendChild(a)
    };
    this.resetInfoSpan = function(d, c) {
        var b = this.$(this.target + "-cX-Info");
        if (b) {
            var a = new Date().getTime() - this.infoStartTime;
            if (a > this.infoTimeIn || c) {
                b.style.left = "0px";
                b.style.top = "0px";
                b.style.display = "none";
                b.innerHTML = ""
            }
        }
    };
    this.showInfoSpan = function(c, j) {
        if (this.draggingOn || this.remoteUpdating) {
            return
        }
        var l = new Date().getTime() - this.infoStartTime;
        var m = this.$(this.target + "-cX-Info");
        if (m && j && j != "" && l > this.infoTimeIn) {
            var k = this.adjustedCoordinates(c, m);
            if (k) {
                var f = k.x;
                var d = c ? k.y : k.y + 25;
                if (!isNaN(j)) {
                    j = j.toString()
                }
                if (j.match(/\w/)) {
                    m.innerHTML = j;
                    m.style.left = (f + 10) + "px";
                    m.style.top = (d - 20) + "px";
                    m.style.display = "inline";
                    m.style.zIndex = parseInt(m.style.zIndex);
                    var i = parseInt(m.clientWidth);
                    var a = parseInt(m.clientHeight);
                    if (i < window.innerWidth && i > (window.innerWidth + window.pageXOffset) - f && (i + 20) < (f - window.pageXOffset)) {
                        m.style.left = (f - (i + 20)) + "px";
                        m.style.left = (f - (parseInt(m.clientWidth) + 20)) + "px"
                    }
                    if (a < window.innerHeight && a > (window.innerHeight + window.pageYOffset) - d && (a - 15) < (d - window.pageYOffset)) {
                        m.style.top = (d - (a - 15)) + "px";
                        m.style.top = (d - (parseInt(m.clientHeight) - 15)) + "px"
                    }
                    this.infoStartTime = new Date().getTime();
                    var b = this;
                    var g = function() {
                        this.update = function() {
                            var h = new Date().getTime();
                            if (h - b.infoStartTime > b.infoTimeOut) {
                                b.resetInfoSpan();
                                clearInterval(e)
                            }
                        };
                        var e = setInterval(this.update, 100)
                    };
                    g.call()
                }
            }
        }
    };
    this.initializeToolbarTooltip = function() {
        if (!this.disableEvents) {
            if (!this.disableToolbar) {
                this.addToolbarDiv()
            }
            this.addInfoSpan()
        }
    };
    this.initializeToolbarTooltip()
};
CanvasXpress.prototype.initConfigurator = function() {
    this.addConfigurator = function(a) {
        return function(af, E, N, M) {
            if (!af) {
                af = window.event
            }
            var ah = a.$(a.target + "-cX-Configurator");
            if (ah) {
                if (a.activeTarget) {
                    a.activeTarget.style.zIndex = 10000
                }
                a.activeTarget = ah;
                a.activeTarget.style.zIndex = 10001;
                if (a.configuratorLastState && a.configuratorLastState == "docked") {
                    var h = a.$("west-handler-" + a.target);
                    a.clickViewport(af, h);
                    return
                }
            }
            var G = "Search property or function";
            if (a.isVML || a.disableConfigurator || (this.isIE && this.browserVersion < 9)) {
                return
            }
            a.configuringOn = true;
            if (E) {
                if (a.isArray(E)) {
                    E = E[0]
                }
                if (a.graphType == "Network") {
                    a.configuringNetwork = E;
                    if (a.data.nodes.length > E) {
                        G = "Configure " + (a.data.nodes[E].label || a.data.nodes[E].name || a.data.nodes[E].id)
                    } else {
                        var A = a.data.edges[E - a.data.nodes.length];
                        var J = a.data.nodes[a.data.nodeIndices[A.id1]];
                        var I = a.data.nodes[a.data.nodeIndices[A.id2]];
                        G = "Configure " + (J.label || J.name || J.id) + " - " + (I.label || J.name || I.id)
                    }
                } else {
                    if (a.graphType == "Genome") {
                        a.configuringGenome = E;
                        G = "Configure track " + E
                    }
                }
            }
            var C = N != null && M != null ? {
                x: N,
                y: M
            } : a.adjustedCoordinates(af);
            if (C) {
                N = a.applicationLook || a.configuratorLastState == "docked" ? 0 : C.x;
                M = a.applicationLook || a.configuratorLastState == "docked" ? 0 : C.y;
                var ah = a.$cX("div", {
                    id: a.target + "-cX-Configurator",
                    className: a.applicationLook ? "CanvasXpressConfigurator fixed" : "CanvasXpressConfigurator draggable"
                }, {
                    cursor: "move",
                    left: N + "px",
                    top: M + "px",
                    padding: "10px",
                    position: "absolute",
                    zIndex: 10001
                });
                var ab = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorKeyText"
                }, {
                    display: "block",
                    marginBottom: "5px",
                    width: a.configuratorWidth + "px"
                });
                var ac = a.$cX("span", {
                    id: a.target + "-cX-ConfiguratorKeyTextSpan",
                    className: "CanvasXpressConfigurator",
                    innerHTML: G
                });
                var B = a.$cX("img", {
                    id: a.target + "-cX-ConfiguratorKeyAdvanced",
                    className: "CanvasXpressConfigurator",
                    src: a.showAdvancedConfiguration ? a.imageDir + "lightbulb.png" : a.imageDir + "lightbulb_off.png",
                    alt: a.showAdvancedConfiguration ? "Show basic configuaration properties" : "Show advanced configuaration properties",
                    title: a.showAdvancedConfiguration ? "Show basic configuaration properties" : "Show advanced configuaration properties"
                });
                var ad = a.$cX("img", {
                    id: a.target + "-cX-ConfiguratorKeySearch",
                    className: "CanvasXpressConfigurator",
                    src: a.imageDir + "find.png",
                    alt: "Browse properties by category",
                    title: "Browse properties by category"
                });
                var D = a.$cX("img", {
                    id: a.target + "-cX-ConfiguratorKeyDock",
                    className: "CanvasXpressConfigurator",
                    src: a.applicationLook ? a.imageDir + "unpin.png" : a.imageDir + "pin.png",
                    alt: a.applicationLook ? "Undock" : "Dock",
                    title: a.applicationLook ? "Undock" : "Dock",
                    state: a.applicationLook ? "docked" : "free"
                });
                var Z = a.$cX("img", {
                    id: a.target + "-cX-ConfiguratorKeyClose",
                    className: "CanvasXpressConfigurator",
                    src: a.imageDir + "cancel1.png",
                    alt: "Close",
                    title: "Close"
                });
                var aa = a.$cX("input", {
                    id: a.target + "-cX-ConfiguratorKey",
                    className: "CanvasXpressConfigurator",
                    type: "text"
                }, {
                    display: "block",
                    width: a.configuratorWidth + "px"
                });
                var Y = a.$cX("select", {
                    id: a.target + "-cX-ConfiguratorCategories",
                    className: "CanvasXpressConfigurator",
                    size: 5
                }, {
                    display: "none",
                    width: a.configuratorWidth + "px"
                });
                var S = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorSugestionsText",
                    innerHTML: "Select property"
                }, {
                    display: "none",
                    margin: "5px 0px 5px 0px",
                    width: a.configuratorWidth + "px"
                });
                var R = a.$cX("select", {
                    id: a.target + "-cX-ConfiguratorSugestions",
                    className: "CanvasXpressConfigurator",
                    size: a.mobileApp ? 5 : 10
                }, {
                    display: "none",
                    width: a.configuratorWidth + "px"
                });
                var ag = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorSugestionsDescription"
                }, {
                    display: "none",
                    margin: "5px 0px 5px 0px",
                    width: a.configuratorWidth + "px",
                    minHeight: "56px",
                    overflow: "auto"
                });
                var P = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorValueText",
                    innerHTML: "Current value"
                }, {
                    display: "none",
                    margin: "5px 0px 5px 0px",
                    width: a.configuratorWidth + "px"
                });
                var aj = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorSeeAlso"
                }, {
                    display: "none",
                    width: a.configuratorWidth + "px",
                    minHeight: "20px",
                    overflow: "auto"
                });
                var O = a.$cX("input", {
                    id: a.target + "-cX-ConfiguratorValue",
                    className: "CanvasXpressConfigurator",
                    type: "text"
                }, {
                    display: "none",
                    width: a.configuratorWidth + "px"
                });
                var F = a.$cX("input", {
                    id: a.target + "-cX-ConfiguratorApply",
                    value: "Apply",
                    type: "button"
                }, {
                    display: "none",
                    cssFloat: "left",
                    borderRadius: "5px",
                    top: "4px",
                    position: "relative",
                    width: (a.configuratorWidth / 2) + "px"
                });
                var ai = a.$cX("input", {
                    id: a.target + "-cX-ConfiguratorButton",
                    value: "Draw",
                    type: "button"
                }, {
                    display: "none",
                    cssFloat: "left",
                    borderRadius: "5px",
                    top: "4px",
                    position: "relative",
                    width: (a.configuratorWidth / 2) + "px"
                });
                var T = a.$cX("img", {
                    id: a.target + "-cX-ConfiguratorOptionsClose",
                    className: "CanvasXpressConfigurator",
                    src: a.imageDir + "cancel1.png",
                    alt: "Close",
                    title: "Close"
                });
                var L = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorOptions",
                    className: "CanvasXpressConfigurator draggable"
                }, {
                    cursor: "move",
                    display: "none",
                    padding: "10px",
                    position: "absolute"
                });
                var V = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorColorCurrent",
                    className: "CanvasXpressConfiguratorColor"
                }, {
                    width: "181px",
                    height: "16px",
                    cssFloat: "left",
                    cursor: "default"
                });
                var U = a.$cX("img", {
                    id: a.target + "-cX-ConfiguratorColorClose",
                    className: "CanvasXpressConfigurator",
                    src: a.imageDir + "cancel1.png",
                    alt: "Close",
                    title: "Close"
                });
                var X = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorColor",
                    className: "CanvasXpressConfigurator draggable"
                }, {
                    width: "204px",
                    cursor: "move",
                    display: "none",
                    padding: "10px",
                    position: "absolute"
                });
                var H = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorFilter",
                    className: "CanvasXpressConfiguratorFilter draggable",
                    innerHTML: 'Build filter ("+" to set "-" to remove)'
                }, {
                    cursor: "move",
                    display: "none",
                    padding: "10px",
                    position: "absolute"
                });
                var K = a.$cX("img", {
                    id: a.target + "-cX-ConfiguratorFilterClose",
                    className: "CanvasXpressConfigurator",
                    src: a.imageDir + "cancel1.png",
                    alt: "Close",
                    title: "Close"
                });
                var Q = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorExample",
                    className: "CanvasXpressConfiguratorExample draggable"
                }, {
                    width: (a.configuratorExamplesSize + 35) + "px",
                    maxHeight: (a.configuratorExamplesSize) + "px",
                    cursor: "move",
                    display: "none",
                    padding: "10px",
                    position: "absolute",
                    overflow: "hidden",
                    paddingBottom: "35px"
                });
                var ae = a.$cX("span", {
                    id: a.target + "-cX-ConfiguratorExampleSpan",
                    className: "CanvasXpressConfiguratorExample",
                    innerHTML: ""
                });
                var w = a.$cX("img", {
                    id: a.target + "-cX-ConfiguratorExampleClose",
                    className: "CanvasXpressConfigurator",
                    src: a.imageDir + "cancel1.png",
                    alt: "Close",
                    title: "Close"
                });
                var t = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorExampleContent",
                    className: "CanvasXpressConfiguratorExampleContent",
                }, {
                    maxWidth: (a.configuratorExamplesSize + 35) + "px",
                    maxHeight: (a.configuratorExamplesSize) + "px",
                    overflow: "auto"
                });
                ab.appendChild(ac);
                ab.appendChild(Z);
                ab.appendChild(D);
                ab.appendChild(B);
                ab.appendChild(ad);
                L.appendChild(document.createTextNode("Select option ..."));
                L.appendChild(T);
                L.appendChild(a.$cX("br"));
                X.appendChild(V);
                X.appendChild(U);
                X.appendChild(a.$cX("br"));
                H.appendChild(K);
                H.appendChild(a.$cX("br"));
                Q.appendChild(ae);
                Q.appendChild(w);
                Q.appendChild(a.$cX("br"));
                Q.appendChild(t);
                ah.appendChild(ab);
                ah.appendChild(aa);
                ah.appendChild(Y);
                ah.appendChild(S);
                ah.appendChild(R);
                ah.appendChild(ag);
                ah.appendChild(aj);
                ah.appendChild(P);
                ah.appendChild(O);
                ah.appendChild(F);
                ah.appendChild(ai);
                ah.appendChild(L);
                ah.appendChild(X);
                ah.appendChild(H);
                ah.appendChild(Q);
                var W = a.$("west-wrapper-" + a.target);
                if (W) {
                    W.appendChild(ah);
                    if (a.activeTarget) {
                        a.activeTarget.style.zIndex = 10000
                    }
                    a.activeTarget = ah;
                    a.addRemoveConfiguratorListeners("addEvtListener");
                    if (a.configuringNetwork || a.configuringGenome) {
                        a.selectConfig(false, true)
                    }
                    setTimeout(function() {
                        aa.focus()
                    }, 300)
                }
            }
        }
    }(this);
    this.addRemoveConfiguratorListeners = function(g) {
        var B = this.$(this.target + "-cX-Configurator");
        var v = this.$(this.target + "-cX-ConfiguratorCategories");
        var h = this.$(this.target + "-cX-ConfiguratorSugestions");
        var a = this.$(this.target + "-cX-ConfiguratorApply");
        var C = this.$(this.target + "-cX-ConfiguratorButton");
        var w = this.$(this.target + "-cX-ConfiguratorKeyClose");
        var D = this.$(this.target + "-cX-ConfiguratorKeyDock");
        var A = this.$(this.target + "-cX-ConfiguratorKeyAdvanced");
        var y = this.$(this.target + "-cX-ConfiguratorKeySearch");
        var d = this.$(this.target + "-cX-ConfiguratorOptions");
        var j = this.$(this.target + "-cX-ConfiguratorOptionsClose");
        var u = this.$(this.target + "-cX-ConfiguratorColor");
        var r = this.$(this.target + "-cX-ConfiguratorColorClose");
        var e = this.$(this.target + "-cX-ConfiguratorFilter");
        var o = this.$(this.target + "-cX-ConfiguratorFilterClose");
        var x = this.$(this.target + "-cX-ConfiguratorExample");
        var k = this.$(this.target + "-cX-ConfiguratorExampleClose");
        if (B && v && h && C && a && w && D && A && y && d && j && u && r && e && o && x && k) {
            this[g](B, "mousedown", this.registerMousemove, false);
            this[g](v, "change", this.changeCategory, false);
            this[g](v, "click", this.changeCategory, false);
            this[g](h, "change", this.clickSuggestions, false);
            this[g](h, "click", this.clickSuggestions, false);
            this[g](a, "click", this.clickApplyConfigurator, false);
            this[g](C, "click", this.clickConfigurator, false);
            this[g](y, "click", this.clickSearch, false);
            this[g](A, "click", this.clickAdvanced, false);
            this[g](D, "click", this.clickDockUndockConfigurator, false);
            this[g](w, "click", this.closeConfigurator, false);
            this[g](d, "mousedown", this.registerMousemove, false);
            this[g](j, "click", this.closePropertyOptions, false);
            this[g](u, "mousedown", this.registerMousemove, false);
            this[g](r, "click", this.closePropertyColor, false);
            this[g](e, "mousedown", this.registerMousemove, false);
            this[g](o, "click", this.closePropertyFilter, false);
            this[g](x, "mousedown", this.registerMousemove, false);
            this[g](k, "click", this.closePropertyExample, false)
        }
    };
    this.getConfigurableProperties = function() {
        if (this.configuringNetwork) {
            if (this.data.nodes.length > this.configuringNetwork) {
                return this.getNodeConfigurableProperties(this.configuringNetwork)
            } else {
                return this.getEdgeConfigurableProperties(this.configuringNetwork - this.data.nodes.length)
            }
        } else {
            if (this.configuringGenome) {
                if (!isNaN(this.configuringGenome) || this.configuringGenome.match(/:/)) {
                    return this.featureConfigurableProperties
                } else {
                    if (this.configuringGenome.match(/track/)) {
                        return this.trackConfigurableProperties
                    } else {
                        this.configuringGenome = false
                    }
                }
            }
        }
        var d = [];
        for (var c in CanvasXpress.doc.P) {
            if (!CanvasXpress.doc.P[c].Z) {
                var a = CanvasXpress.doc.P[c].M;
                var b = CanvasXpress.doc.P[c].U;
                if (CanvasXpress.doc.M[a].U) {
                    if (CanvasXpress.doc.M[a].U.hasOwnProperty(this.graphType)) {
                        if (this.showAdvancedConfiguration) {
                            d.push(c)
                        } else {
                            if (!CanvasXpress.doc.P[c].A) {
                                d.push(c)
                            }
                        }
                    }
                } else {
                    if (this.showAdvancedConfiguration) {
                        if (b) {
                            if (b.hasOwnProperty(this.graphType)) {
                                d.push(c)
                            }
                        } else {
                            d.push(c)
                        }
                    } else {
                        if (!CanvasXpress.doc.P[c].A) {
                            if (b) {
                                if (b.hasOwnProperty(this.graphType)) {
                                    d.push(c)
                                } else {
                                    d.push(c)
                                }
                            }
                        }
                    }
                }
            }
        }
        return d
    };
    this.getConfigurableObjectDoc = function(a) {
        if (this.configuringNetwork) {
            if (this.data.nodes.length > this.configuringNetwork) {
                return CanvasXpress.doc.N[a] ? CanvasXpress.doc.N[a] : false
            } else {
                return CanvasXpress.doc.E[a] ? CanvasXpress.doc.E[a] : false
            }
        } else {
            if (this.configuringGenome) {
                if (!isNaN(this.configuringGenome) || this.configuringGenome.match(/:/)) {
                    return CanvasXpress.doc.F[a] ? CanvasXpress.doc.F[a] : false
                } else {
                    if (this.configuringGenome.match(/track/)) {
                        return CanvasXpress.doc.G[a] ? CanvasXpress.doc.G[a] : false
                    } else {
                        this.configuringGenome = false;
                        return CanvasXpress.doc.P[a] ? CanvasXpress.doc.P[a] : false
                    }
                }
            } else {
                return CanvasXpress.doc.P[a] ? CanvasXpress.doc.P[a] : false
            }
        }
    };
    this.selectConfig = function(D, F) {
        var z = this.$(this.target + "-cX-ConfiguratorKey");
        var q = this.$(this.target + "-cX-ConfiguratorSugestionsText");
        var n = this.$(this.target + "-cX-ConfiguratorSugestions");
        var E = this.$(this.target + "-cX-ConfiguratorSugestionsDescription");
        var l = this.$(this.target + "-cX-ConfiguratorValueText");
        var H = this.$(this.target + "-cX-ConfiguratorSeeAlso");
        var j = this.$(this.target + "-cX-ConfiguratorValue");
        var f = this.$(this.target + "-cX-ConfiguratorApply");
        var G = this.$(this.target + "-cX-ConfiguratorButton");
        var B = this.$(this.target + "-cX-ConfiguratorValueHREF");
        var m = document.activeElement;
        var y = this.getConfigurableProperties();
        var w = [];
        if (this.getKeyCode(D) == 13) {
            this.resetOptionColorFiltersExamples();
            if (this.editingDescriptionOn) {
                this.submitEditPropertyDescription()
            } else {
                if (n && j && j.value) {
                    var g = false;
                    for (var A = 0; A < y.length; A++) {
                        if (n.value == y[A]) {
                            g = true;
                            break
                        }
                    }
                    if (g) {
                        this.clickConfigurator(D, n, j)
                    } else {
                        this.resetConfigurator()
                    }
                }
            }
        } else {
            if (m.id.match(/canvasXpressConfiguratorFilterValue/)) {
                return
            } else {
                if (z && m.id == z.id || F) {
                    this.resetOptionColorFiltersExamples();
                    this.resetEditPropertyDescription();
                    for (var A = 0; A < y.length; A++) {
                        if (y[A].toLowerCase().indexOf(z.value.toLowerCase()) >= 0) {
                            w.push(y[A])
                        }
                    }
                    if (w.length > 0 && q && n && E && l && H && j && G && f) {
                        this.resetSugestions();
                        if (!this.configuringNetwork && !this.configuringGenome) {
                            w.sort(function(d, c) {
                                return CanvasXpress.doc.P[d].M > CanvasXpress.doc.P[c].M ? 1 : CanvasXpress.doc.P[c].M > CanvasXpress.doc.P[d].M ? -1 : d > c ? 1 : c > d ? -1 : 0
                            });
                            for (var A = 0; A < w.length; A++) {
                                var y = this.$cX("option", {
                                    text: CanvasXpress.doc.P[w[A]].M ? CanvasXpress.doc.P[w[A]].M + " : " + w[A] : "NA : " + w[A],
                                    value: w[A]
                                });
                                try {
                                    n.add(y, null)
                                } catch (C) {
                                    n.add(y)
                                }
                            }
                        } else {
                            w.sort();
                            for (var A = 0; A < w.length; A++) {
                                var y = this.$cX("option", {
                                    text: w[A],
                                    value: w[A]
                                });
                                try {
                                    n.add(y, null)
                                } catch (C) {
                                    n.add(y)
                                }
                            }
                        }
                        n.options[0].selected = true;
                        this.setConfiguratorPropertyValue(n, E, l, H, j);
                        q.innerHTML = "Select property (" + w.length + ")";
                        q.style.display = "block";
                        n.style.display = "block";
                        E.style.display = "block";
                        l.style.display = "block";
                        H.style.display = "block";
                        j.style.display = "block";
                        G.style.display = "block";
                        f.style.display = "block"
                    } else {
                        z.value = z.value.slice(0, z.value.length - 1)
                    }
                } else {
                    if (j && m.id == j.id) {
                        this.resetOptionColorFiltersExamples();
                        this.resetEditPropertyDescription();
                        if (B && B.innerHTML == "color") {
                            B.style.color = j.value ? this.rgbToHex(this.validateColor(j.value.replace(/[\'\"]/g, ""))) : this.foreground
                        }
                    } else {
                        if (this.remoteService) {
                            this.resetOptionColorFiltersExamples();
                            this.selectDataSet(D)
                        }
                    }
                }
            }
        }
        return false
    };
    this.clickSearch = function(a) {
        return function(G) {
            if (!G) {
                G = window.event
            }
            a.configuringNetwork = false;
            a.configuringGenome = false;
            a.resetEditOptionColorFiltersExamples();
            var E = a.$(a.target + "-cX-ConfiguratorKeyTextSpan");
            var C = a.$(a.target + "-cX-ConfiguratorKey");
            var A = a.$(a.target + "-cX-ConfiguratorCategories");
            var w = a.$(a.target + "-cX-ConfiguratorSugestionsText");
            var t = a.$(a.target + "-cX-ConfiguratorSugestions");
            var H = a.$(a.target + "-cX-ConfiguratorSugestionsDescription");
            var q = a.$(a.target + "-cX-ConfiguratorValueText");
            var J = a.$(a.target + "-cX-ConfiguratorSeeAlso");
            var p = a.$(a.target + "-cX-ConfiguratorValue");
            var I = a.$(a.target + "-cX-ConfiguratorButton");
            var c = a.$(a.target + "-cX-ConfiguratorApply");
            var f = a.$(a.target + "-cX-ConfiguratorOptions");
            var y = a.$(a.target + "-cX-ConfiguratorColor");
            var h = a.$(a.target + "-cX-ConfiguratorFilter");
            var B = a.getKeys(CanvasXpress.doc.M).sort();
            var j = [];
            if (C && C.style.display == "none") {
                if (E) {
                    E.innerText = "Search property or function"
                }
                if (A) {
                    A.style.display = "none"
                }
                C.value = "";
                C.style.display = "block"
            } else {
                if (E) {
                    for (var D = 0; D < B.length; D++) {
                        if (CanvasXpress.doc.M[B[D]].U) {
                            if (CanvasXpress.doc.M[B[D]].U.hasOwnProperty(a.graphType)) {
                                if (a.showAdvancedConfiguration) {
                                    j.push(B[D])
                                } else {
                                    if (CanvasXpress.doc.M[B[D]].B) {
                                        j.push(B[D])
                                    }
                                }
                            }
                        } else {
                            if (a.showAdvancedConfiguration) {
                                j.push(B[D])
                            } else {
                                if (CanvasXpress.doc.M[B[D]].B) {
                                    j.push(B[D])
                                }
                            }
                        }
                        E.innerText = "Select category (" + j.length + ")"
                    }
                }
                if (C) {
                    C.style.display = "none"
                }
                if (A) {
                    a.resetCategories();
                    for (var D = 0; D < j.length; D++) {
                        var x = a.$cX("option", {
                            text: j[D],
                            value: j[D]
                        });
                        try {
                            A.add(x, null)
                        } catch (F) {
                            A.add(x)
                        }
                    }
                    A.style.display = "block"
                }
            } if (w && t && H && q && J && p && I && c && f && y && h) {
                w.style.display = "none";
                t.style.display = "none";
                H.style.display = "none";
                q.style.display = "none";
                J.style.display = "none";
                p.style.display = "none";
                I.style.display = "none";
                c.style.display = "none";
                f.style.display = "none";
                y.style.dysplay = "none";
                h.style.dysplay = "none"
            }
            return false
        }
    }(this);
    this.clickDockUndockConfigurator = function(a) {
        return function(m, f) {
            if (!m) {
                m = window.event
            }
            var p = a.$(a.target + "-cX-Configurator");
            var n = a.$(a.target + "-cX-ConfiguratorKeyDock");
            var q = a.$(a.target + "-cX-ConfiguratorButton");
            var t = a.$(a.target + "-cX-ConfiguratorApply");
            var s = a.$("middle-container-" + a.target);
            var j = a.$("west-container-" + a.target);
            var g = a.$("west-handler-" + a.target);
            var l = a.$("east-container-" + a.target);
            if (p && n && s && j && g && l) {
                if (n.state == "free" && !f) {
                    var o = (parseInt(p.style.padding) * 2) + 2;
                    var k = p.clientHeight - o;
                    a.configuringOn = "docked";
                    a.resizeViewportWest();
                    p.className = "CanvasXpressConfigurator fixed";
                    p.style.cursor = "default";
                    n.src = a.imageDir + "unpin.png";
                    n.alt = "Undock";
                    n.title = "Undock";
                    n.state = "docked";
                    a.configuratorLastState = "docked";
                    s.style.width = p.clientWidth + 7 + a.canvas.width + l.clientWidth + 2;
                    a.resizeMove(j, 0, 0, p.clientWidth + 7, a.canvas.height, 500, null);
                    a.resizeMove(p, 0, 0, a.configuratorWidth, a.canvas.height - o, 500, null);
                    q.style.left = ((a.configuratorWidth / 2) + 10) + "px";
                    t.style.left = "10px";
                    q.style.position = "absolute";
                    t.style.position = "absolute";
                    g.style.display = "block";
                    setTimeout(function() {
                        a.resizeViewportWest();
                        q.style.top = (a.canvas.height - (o + 10)) + "px";
                        t.style.top = (a.canvas.height - (o + 10)) + "px";
                        q.style.position = "absolute";
                        t.style.position = "absolute"
                    }, 500)
                } else {
                    a.configuringOn = "free";
                    p.className = "CanvasXpressConfigurator draggable";
                    p.style.cursor = "move";
                    q.style.left = "0px";
                    t.style.left = "0px";
                    q.style.top = "4px";
                    t.style.top = "4px";
                    q.style.position = "relative";
                    t.style.position = "relative";
                    n.src = a.imageDir + "pin.png";
                    n.alt = "Dock";
                    n.title = "Dock";
                    n.state = "free";
                    a.configuratorLastState = "free";
                    a.resizeMove(j, 0, 0, 7, a.canvas.height, 500, function() {
                        s.style.width = 7 + a.canvas.width + l.clientWidth
                    });
                    a.resizeViewportWest();
                    g.style.display = "none";
                    setTimeout(function() {
                        p.style.height = ""
                    }, 500)
                }
            }
            return false
        }
    }(this);
    this.clickAdvanced = function(a) {
        return function(d) {
            if (!d) {
                d = window.event
            }
            var b = a.$(a.target + "-cX-ConfiguratorKey");
            var c = a.$(a.target + "-cX-ConfiguratorKeyAdvanced");
            if (c) {
                if (a.showAdvancedConfiguration) {
                    a.showAdvancedConfiguration = false;
                    c.src = a.imageDir + "lightbulb_off.png";
                    c.alt = "Show advanced configuaration properties";
                    c.title = "Show advanced configuaration properties"
                } else {
                    a.showAdvancedConfiguration = true;
                    c.src = a.imageDir + "lightbulb.png";
                    c.alt = "Show basic configuaration properties";
                    c.title = "Show basic configuaration properties"
                } if (b && b.style.display == "none") {
                    b.value = "";
                    b.style.display = "block";
                    a.clickSearch()
                } else {
                    a.resetEditOptionColorFiltersExamples();
                    a.resetEditPropertyDescription();
                    a.resetPropertySeeAlsoLinks();
                    a.selectConfig(false, true)
                }
            }
            return false
        }
    }(this);
    this.closeConfigurator = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.resetViewportOverflow("west");
            a.clickDockUndockConfigurator(b, true);
            a.resetConfigurator();
            return false
        }
    }(this);
    this.changeCategory = function(a) {
        return function(F, C) {
            if (!F) {
                F = window.event
            }
            a.resetEditOptionColorFiltersExamples();
            var B = a.$(a.target + "-cX-ConfiguratorCategories");
            var t = a.$(a.target + "-cX-ConfiguratorSugestionsText");
            var q = a.$(a.target + "-cX-ConfiguratorSugestions");
            var G = a.$(a.target + "-cX-ConfiguratorSugestionsDescription");
            var l = a.$(a.target + "-cX-ConfiguratorValueText");
            var I = a.$(a.target + "-cX-ConfiguratorSeeAlso");
            var k = a.$(a.target + "-cX-ConfiguratorValue");
            var c = a.$(a.target + "-cX-ConfiguratorApply");
            var H = a.$(a.target + "-cX-ConfiguratorButton");
            var f = a.$(a.target + "-cX-ConfiguratorOptions");
            var A = a.$(a.target + "-cX-ConfiguratorColor");
            var g = a.$(a.target + "-cX-ConfiguratorFilter");
            var h = CanvasXpress.doc.M;
            if (B && B.value && t && q && G && l && I && k && H && f && A && g) {
                var w = a.showAdvancedConfiguration ? h[B.value].P.sort() : h[B.value].B.sort();
                a.resetSugestions();
                for (var D = 0; D < w.length; D++) {
                    var y = a.$cX("option", {
                        text: w[D],
                        value: w[D]
                    });
                    try {
                        q.add(y, null)
                    } catch (E) {
                        q.add(y)
                    }
                }
                q.options[C || 0].selected = true;
                t.innerHTML = "Select property (" + w.length + ")";
                a.setConfiguratorPropertyValue(q, G, l, I, k);
                t.style.display = "block";
                q.style.display = "block";
                G.style.display = "block";
                l.style.display = "block";
                I.style.display = "block";
                k.style.display = "block";
                c.style.display = "block";
                H.style.display = "block";
                f.style.display = "none";
                A.style.display = "none";
                g.style.display = "none"
            }
            return false
        }
    }(this);
    this.resetCategories = function() {
        var a = this.$(this.target + "-cX-ConfiguratorCategories");
        if (a) {
            if (a.hasChildNodes()) {
                while (a.childNodes.length >= 1) {
                    a.removeChild(a.firstChild)
                }
            }
            a.style.display = "none"
        }
    };
    this.clickSuggestions = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.resetEditOptionColorFiltersExamples();
            a.setConfiguratorPropertyValue();
            return false
        }
    }(this);
    this.setConfiguratorPropertyValue = function(l, e, j, g, h) {
        if (!l) {
            l = this.$(this.target + "-cX-ConfiguratorSugestions")
        }
        if (!e) {
            e = this.$(this.target + "-cX-ConfiguratorSugestionsDescription")
        }
        if (!j) {
            j = this.$(this.target + "-cX-ConfiguratorValueText")
        }
        if (!g) {
            g = this.$(this.target + "-cX-ConfiguratorSeeAlso")
        }
        if (!h) {
            h = this.$(this.target + "-cX-ConfiguratorValue")
        }
        var k;
        var f = this.$(this.target + "-cX-ConfiguratorOptions");
        var c = this.getConfigurableObjectDoc(l.value);
        h.value = "";
        h.style.readonly = false;
        if (this.configuringNetwork) {
            if (typeof(this[l.value]) == "function") {
                h.style.disabled = "disabled";
                h.style.readonly = false
            } else {
                if (this.configuringNetwork < this.data.nodes.length) {
                    k = this.data.nodes[this.configuringNetwork][l.value]
                } else {
                    k = this.data.edges[this.configuringNetwork - this.data.nodes.length][l.value]
                }
            }
        } else {
            if (this.configuringGenome) {
                var b = this.subtracksInfo;
                if (!isNaN(this.configuringGenome)) {
                    k = this.data.tracks[b[this.configuringGenome].track].data[b[this.configuringGenome].index][l.value]
                } else {
                    if (this.configuringGenome.match(/:/)) {
                        k = parseInt(this.configuringGenome.split(":")[1]);
                        k = this.data.tracks[b[k].track].data[b[k].index][l.value]
                    } else {
                        k = parseInt(this.configuringGenome.replace("track-", ""));
                        k = this.data.tracks[b[k].track][l.value]
                    }
                }
            } else {
                if (typeof(this[l.value]) == "function") {
                    j.innerHTML = "Current&nbsp;value&nbsp;[&nbsp;<i>function</i>&nbsp;]&nbsp;" + this[l.value].length + "&nbsp;parameter(s)";
                    if (this[l.value].length == 0) {
                        h.style.disabled = "disabled";
                        h.style.readonly = false
                    }
                } else {
                    k = this[l.value]
                }
            }
        }
        h.value = k ? JSON.stringify(k) : "";
        this.addPropertyDescription(e, c, l.value);
        this.addPropertySeeAlsoLinks(g, c);
        this.addPropertyOptions(j, f, c, l.value, k);
        if (this.showConfiguratorExamplesOnSelect) {
            this.resetPropertyExample();
            this.clickExamplePropertyDescription(false, l.value)
        }
    };
    this.resetSugestions = function() {
        var a = this.$(this.target + "-cX-ConfiguratorSugestions");
        if (a) {
            if (a.hasChildNodes()) {
                while (a.childNodes.length >= 1) {
                    a.removeChild(a.firstChild)
                }
            }
            a.style.display = "none"
        }
    };
    this.addPropertyDescription = function(r, g, f) {
        var t = g && g.C ? g.C : "";
        var j = g && g.M ? g.M : "";
        var v = g && g.H ? true : false;
        this.resetPropertyDescription(r);
        var n = this.$cX("img", {
            id: this.target + "-cX-ConfiguratorSugestionsDescriptionEdit",
            src: this.imageDir + "pencil.png",
            alt: "Edit description",
            title: "Edit description"
        }, {
            cursor: "default",
            margin: "2px",
            width: "10px",
            height: "10px"
        });
        var a = this.$cX("i", {
            innerHTML: f
        });
        var w = this.$cX("span", {
            id: this.target + "-cX-ConfiguratorSugestionsDescriptionEditSpan",
            className: "CanvasXpressConfigurator",
            prop: f,
            innerHTML: " : " + t
        });
        var k = this.$cX("i", {
            innerHTML: j
        });
        var l = this.$cX("a", {
            id: this.target + "-cX-ConfiguratorSugestionsDescriptionExample",
            href: "javascript:void(0)",
            alt: "Show examples",
            title: "Show examples"
        });
        var u = this.$cX("span", false, {
            className: "CanvasXpressConfigurator"
        });
        l.appendChild(a);
        u.appendChild(document.createTextNode("Description [ "));
        u.appendChild(k);
        u.appendChild(document.createTextNode(" ]"));
        r.appendChild(u);
        r.appendChild(this.$cX("br"));
        r.appendChild(v ? l : a);
        r.appendChild(w);
        r.appendChild(n);
        this.addEvtListener(l, "click", this.clickExamplePropertyDescription, false);
        this.addEvtListener(n, "click", this.clickEditPropertyDescription, false)
    };
    this.resetPropertyDescription = function(f, b, a) {
        if (!f) {
            f = this.$(this.target + "-cX-ConfiguratorSugestionsDescription")
        }
        if (!b) {
            b = this.$(this.target + "-cX-ConfiguratorSugestionsDescriptionEdit")
        }
        if (f && b) {
            this.removeEvtListener(b, "click", this.clickEditPropertyDescription, false);
            if (!a) {
                a = this.$(this.target + "-cX-ConfiguratorSugestionsDescriptionExample")
            }
            if (a) {
                this.removeEvtListener(a, "click", this.clickExamplePropertyDescription, false)
            }
            while (f.childNodes.length > 0) {
                var g = f.childNodes[0];
                f.removeChild(g)
            }
        }
    };
    this.getExamplesDocObject = function(l, z) {
        var c = [];
        if (l) {
            var n = this.getConfigurableObjectDoc(l);
            var e = n.U ? this.getKeys(n.U) : CanvasXpress.doc.M[n.M]["U"] ? this.getKeys(CanvasXpress.doc.M[n.M]["U"]) : ["Bar"];
            for (var t = 0; t < n.H.length; t++) {
                if (n.H[t].match(/\*/)) {
                    var a = [];
                    var r = n.H[t] == "{*}" ? {} : JSON.parse(String(n.H[t].replace("*,", "")));
                    var h = r.data ? this.getDataSet(r.data) : false;
                    var y = r.skipExample ? this.getObjectArray(r.skipExample) : {};
                    var b = r.functions ? r.functions : false;
                    var g = r.conditional ? r.conditional : false;
                    if (h) {
                        delete(r.data)
                    }
                    if (y) {
                        delete(r.skipExample)
                    }
                    if (b) {
                        delete(r.functions)
                    }
                    if (g) {
                        delete(r.conditional)
                    }
                    if (n.T == "option") {
                        a = n.O
                    } else {
                        if (n.T == "boolean") {
                            a = [true, false]
                        } else {
                            if (n.T == "color") {
                                a = ["rgb(255,125,51)", "rgb(51,255,125)", "rgb(125,51,255)"];
                                a.unshift(n.D)
                            } else {
                                if (n.T == "float") {
                                    a = n.D == "null" ? [null, 0.5] : [parseFloat(n.D), Math.max(parseFloat(n.D) * 1.5, 1)]
                                } else {
                                    if (n.T == "integer") {
                                        a = n.D == 0 ? [0, 1] : [parseInt(n.D), parseInt((parseInt(n.D) * 1.5) + 0.5)]
                                    }
                                }
                            }
                        }
                    }
                    for (var s = 0; s < a.length; s++) {
                        if (y.hasOwnProperty(a[s])) {
                            continue
                        }
                        var m = (z ? l : this.target) + "-cX-ConfiguratorExample-" + l + "-" + String(a[s]).replace(/\s/m, "-") + "-" + t;
                        var v = this.cloneObject(r);
                        v[l] = a[s];
                        if (v[l] == "false") {
                            v[l] = false
                        } else {
                            if (v[l] == "true") {
                                v[l] = true
                            } else {
                                if (v[l] == "null") {
                                    v[l] = null
                                }
                            }
                        } if (!v.graphType) {
                            v.graphType = e[0]
                        }
                        if (g) {
                            for (var k in g) {
                                v[k] = g[k][s % g[k].length]
                            }
                        }
                        if (b && s == 0) {
                            c.push([m, h, v, b])
                        } else {
                            c.push([m, h, v])
                        }
                    }
                } else {
                    var s = JSON.parse(String(n.H[t]));
                    var x = s.data ? this.getDataSet(s.data) : false;
                    var w = s.functions ? s.functions : false;
                    if (x) {
                        delete(s.data)
                    }
                    if (w) {
                        delete(s.functions)
                    }
                    var m = (z ? l : this.target) + "-cX-ConfiguratorExample-" + l + "-" + t;
                    if (!s.graphType) {
                        s.graphType = e[0]
                    }
                    if (w) {
                        c.push([m, x, s, w])
                    } else {
                        c.push([m, x, s])
                    }
                }
            }
        }
        return c
    };
    this.clickExamplePropertyDescription = function(a) {
        return function(u, n, y) {
            a.resetPropertyExample();
            var t = y ? a.$(n + "-cX-API-Example") : a.$(a.target + "-cX-ConfiguratorExample");
            var d = y ? a.$(n + "-cX-API-ExampleSpan") : a.$(a.target + "-cX-ConfiguratorExampleSpan");
            var m = y ? a.$(n + "-cX-API-ExampleContent") : a.$(a.target + "-cX-ConfiguratorExampleContent");
            if (t && d && m) {
                t.style.display = "block";
                if (!n) {
                    n = this.firstChild.innerHTML
                }
                var f = a.getExamplesDocObject(n);
                d.innerHTML = n;
                for (var r = 0; r < f.length; r++) {
                    var o = f[r][0];
                    var l = f[r][1];
                    var s = f[r][2];
                    var g = f[r][3];
                    var w = a.$cX("canvas", {
                        id: o,
                        width: y ? 500 : a.configuratorExamplesSize,
                        height: y ? 500 : a.configuratorExamplesSize,
                    });
                    m.appendChild(w);
                    var h = new CanvasXpress(o, l, s);
                    if (g) {
                        for (var q = 0; q < g.length; q++) {
                            if (g[q].match(/:/)) {
                                var b = g[q].split(":");
                                h[b.shift()].apply(h, b)
                            } else {
                                h[g[q]]()
                            }
                        }
                    }
                }
                if (!y) {
                    if (a.alignConfiguratorExamples || a.configuratorLastState == "docked") {
                        var k = a.$(a.target + "-cX-Configurator");
                        t.style.left = k.offsetWidth + "px";
                        t.style.top = "-1px";
                        t.style.height = (k.clientHeight - 45) + "px";
                        m.style.maxHeight = (k.clientHeight - 45) + "px";
                        a.removeClass(t, "draggable")
                    } else {
                        var x = a.adjustedCoordinates(u, t);
                        t.style.left = x.x + "px";
                        t.style.top = x.y + "px";
                        delete(t.style.height);
                        m.style.Maxheight = "500px";
                        a.addClass(t, "draggable")
                    }
                }
            }
        }
    }(this);
    this.clickEditPropertyDescription = function(a) {
        return function(h) {
            if (!h) {
                h = window.event
            }
            a.resetPropertyColor();
            a.resetPropertyFilter();
            a.resetPropertyExample();
            var f = a.$(a.target + "-cX-Configurator");
            var g = a.$(a.target + "-cX-ConfiguratorSugestions");
            var u = a.$(a.target + "-cX-ConfiguratorSugestionsDescriptionEditSpan");
            var m = a.$(a.target + "-cX-ConfiguratorOptions");
            if (f && g && u && m) {
                m.style.display = "none";
                var t = a.adjustedCoordinates(h, g);
                if (t) {
                    a.editingDescriptionOn = true;
                    var r = t.x;
                    var o = t.y;
                    var j = a.$cX("div", {
                        id: a.target + "-cX-ConfiguratorEditForm",
                        className: "CanvasXpressConfigurator draggable"
                    }, {
                        cursor: "move",
                        left: r + "px",
                        top: o + "px",
                        padding: "10px",
                        position: "absolute",
                        width: (a.configuratorWidth * 0.8) + "px"
                    });
                    var l = a.$cX("img", {
                        id: a.target + "-cX-ConfiguratorEditFormClose",
                        className: "CanvasXpressConfigurator",
                        src: a.imageDir + "cancel1.png",
                        alt: "Close",
                        title: "Close"
                    });
                    var q = a.$cX("textarea", {
                        id: a.target + "-cX-ConfiguratorEditFormValue",
                        className: "CanvasXpressConfigurator",
                        value: u.prop + u.innerHTML,
                        rows: 10
                    }, {
                        width: "100%",
                        maxWidth: (a.configuratorWidth * 0.8) + "px"
                    });
                    var n = a.$cX("input", {
                        id: a.target + "-cX-ConfiguratorEditFormButton",
                        value: "Submit",
                        type: "button"
                    }, {
                        width: "100%",
                        borderRadius: "5px",
                        maxWidth: (a.configuratorWidth * 0.8) + "px"
                    });
                    j.appendChild(document.createTextNode("Editing " + g.value));
                    j.appendChild(l);
                    j.appendChild(a.$cX("br"));
                    j.appendChild(q);
                    j.appendChild(n);
                    a.addEvtListener(l, "click", a.closeEditPropertyDescription, false);
                    a.addEvtListener(n, "click", a.submitEditPropertyDescription, false);
                    f.appendChild(j)
                }
            }
        }
    }(this);
    this.submitEditPropertyDescription = function(a) {
        return function(f) {
            if (!f) {
                f = window.event
            }
            var c = a.$(a.target + "-cX-ConfiguratorSugestions");
            var b = a.$(a.target + "-cX-ConfiguratorEditFormValue");
            var d = a.$(a.target + "-cX-ConfiguratorSugestionsDescriptionEditSpan");
            if (c && b && d) {
                b.value = b.value.replace(/\n/g, "");
                CanvasXpress.doc.P[c.value].C = b.value;
                d.innerHTML = b.value;
                alert("New description for:\n - " + c.value + " -\nwas submitted and may apppear\nin new versions of CanvasXpress\nThank you for your contribution")
            }
            a.resetEditPropertyDescription()
        }
    }(this);
    this.closeEditPropertyDescription = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.resetEditPropertyDescription()
        }
    }(this);
    this.resetEditPropertyDescription = function() {
        var e = this.$(this.target + "-cX-ConfiguratorEditForm");
        var f = this.$(this.target + "-cX-ConfiguratorEditFormClose");
        var a = this.$(this.target + "-cX-ConfiguratorEditFormButton");
        if (e && f && a) {
            this.addEvtListener(f, "click", this.closeEditPropertyDescription, false);
            this.addEvtListener(a, "click", this.submitEditPropertyDescription, false);
            e.parentNode.removeChild(e)
        }
        this.editingDescriptionOn = false
    };
    this.addPropertySeeAlsoLinks = function(e, g) {
        this.resetPropertySeeAlsoLinks(e);
        var d = this.$cX("span", false, {
            className: "CanvasXpressConfigurator"
        });
        d.appendChild(document.createTextNode("See Also: "));
        e.appendChild(d);
        if (g && g.S) {
            for (var f = 0; f < g.S.length; f++) {
                var h = this.$cX("a", {
                    href: "javascript:void(0)",
                    innerHTML: g.S[f]
                });
                this.addEvtListener(h, "click", this.clickPropertySeeAlsoLinks, false);
                e.appendChild(h);
                if (f < g.S.length - 1) {
                    e.appendChild(document.createTextNode(", "))
                }
            }
        }
    };
    this.clickPropertySeeAlsoLinks = function(a) {
        return function(h) {
            if (!h) {
                h = window.event
            }
            var f = a.$(a.target + "-cX-ConfiguratorKey");
            var b = a.$(a.target + "-cX-ConfiguratorCategories");
            var g = a.$(a.target + "-cX-ConfiguratorSugestions");
            var c = h.target || h.srcElement;
            if (b && b.style.display == "block") {
                var l = CanvasXpress.doc.P[c.innerHTML];
                var j = CanvasXpress.doc.M[l.M].P.sort();
                b.value = l.M;
                for (i = 0; i < j.length; i++) {
                    if (j[i] == c.innerHTML) {
                        a.changeCategory(h, i);
                        return false
                    }
                }
                a.changeCategory(h)
            } else {
                if (f) {
                    f.value = c.innerHTML;
                    a.selectConfig(h, true)
                }
            }
            return false
        }
    }(this);
    this.resetPropertySeeAlsoLinks = function(b) {
        if (!b) {
            b = this.$(this.target + "-cX-ConfiguratorSeeAlso")
        }
        if (b && b.childNodes) {
            while (b.childNodes.length > 0) {
                var d = b.childNodes[0];
                if (d.nodeName.toLowerCase() == "a") {
                    this.removeEvtListener(d, "click", this.clickPropertySeeAlsoLinks, false)
                }
                b.removeChild(d)
            }
        }
    };
    this.addPropertyOptions = function(w, p, f, g, s) {
        this.resetPropertyOptions(w, p);
        var q = this.$cX("span", false, {
            className: "CanvasXpressConfigurator"
        });
        var l = this.$cX("i");
        q.appendChild(document.createTextNode("Current value"));
        if (f && f.T && (f.T == "option" || f.T == "array" || f.T == "boolean")) {
            var x = this.$cX("div", {
                id: this.target + "-cX-ConfiguratorOptionsContainer",
                className: "CanvasXpressConfiguratorOptions"
            });
            var r = this.$cX("a", {
                href: "javascript:void(0)",
                innerHTML: f.T,
                alt: "Modify property",
                title: "Modify property"
            });
            this.addEvtListener(r, "click", this.clickPropertyOptions, false);
            q.appendChild(document.createTextNode(" ["));
            l.appendChild(r);
            q.appendChild(document.createTextNode(" "));
            q.appendChild(l);
            q.appendChild(document.createTextNode(" ]"));
            if (f.T == "array") {
                var n = f.X ? this[f.X]() : f.O ? f.O : [];
                var m = this.getObjectArray(s);
                if (n.length > 0) {
                    for (var h = 0; h < n.length; h++) {
                        var g = this.$cX("input", {
                            type: "checkbox",
                            value: n[h],
                            checked: m.hasOwnProperty(n[h]) ? true : false
                        }, {
                            marginLeft: "0px"
                        });
                        this.addEvtListener(g, "change", this.updatePropertyValue, false);
                        x.appendChild(document.createTextNode((h + 1) + ". "));
                        x.appendChild(g);
                        x.appendChild(document.createTextNode(n[h]));
                        x.appendChild(this.$cX("br"))
                    }
                } else {
                    x.appendChild(this.$cX("br"));
                    x.appendChild(document.createTextNode("This array is user defined"));
                    x.appendChild(this.$cX("br"))
                }
            } else {
                var n = f.T == "boolean" ? ["true", "false"] : f.X ? this[f.X]() : f.O ? f.O : [];
                if (f.X && f.O) {
                    n = n.concat(f.O)
                }
                for (var h = 0; h < n.length; h++) {
                    var g = this.$cX("a", {
                        href: "javascript:void(0)",
                        innerHTML: n[h],
                        alt: "Modify property",
                        title: "Modify property"
                    }, {
                        padding: "2px"
                    });
                    this.addEvtListener(g, "click", this.updatePropertyValue, false);
                    x.appendChild(document.createTextNode((h + 1) + ". "));
                    x.appendChild(g);
                    x.appendChild(this.$cX("br"))
                }
            }
            p.appendChild(x)
        } else {
            if (f && f.T) {
                q.appendChild(document.createTextNode(" ["));
                if (f.T == "color") {
                    var n;
                    if (this.configuringNetwork) {
                        if (this.configuringNetwork < this.data.nodes.length) {
                            n = this.data.nodes[this.configuringNetwork][g]
                        } else {
                            n = this.data.edges[this.configuringNetwork - this.data.nodes.length][g]
                        }
                    } else {
                        if (this.configuringGenome) {
                            var e = this.subtracksInfo;
                            if (!isNaN(this.configuringGenome)) {
                                n = this.data.tracks[e[this.configuringGenome].track].data[e[this.configuringGenome].index]
                            } else {
                                if (this.configuringGenome.match(/:/)) {
                                    n = parseInt(this.configuringGenome.split(":")[1]);
                                    n = this.data.tracks[e[n].track].data[e[n].index]
                                } else {
                                    n = parseInt(this.configuringGenome.replace("track-", ""));
                                    n = this.data.tracks[e[n].track]
                                }
                            }
                        } else {
                            n = this[g]
                        }
                    }
                    var r = this.$cX("a", {
                        id: this.target + "-cX-ConfiguratorValueHREF",
                        href: "javascript:void(0)",
                        innerHTML: f.T,
                        alt: "Modify color",
                        title: "Modify color"
                    }, {
                        color: n ? this.rgbToHex(this.validateColor(n)) : this.foreground
                    });
                    this.addEvtListener(r, "click", this.addPropertyColor, false);
                    l.appendChild(r)
                } else {
                    if (f && f.T == "filter") {
                        var r = this.$cX("a", {
                            id: this.target + "-cX-ConfiguratorValueFilter",
                            href: "javascript:void(0)",
                            innerHTML: f.T,
                            name: g
                        });
                        r.opts = f.X ? this[f.X]() : f.O ? f.O : [];
                        r.opts.unshift("");
                        this.addEvtListener(r, "click", this.addPropertyFilter, false);
                        l.appendChild(r)
                    } else {
                        l.appendChild(document.createTextNode(f.T))
                    }
                }
                q.appendChild(document.createTextNode(" "));
                q.appendChild(l);
                q.appendChild(document.createTextNode(" ]"))
            }
        }
        w.appendChild(q)
    };
    this.clickPropertyOptions = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.resetEditPropertyDescription();
            var c = a.$(a.target + "-cX-ConfiguratorOptions");
            if (c) {
                c.style.display = "block";
                c.style.left = b.layerX + "px";
                c.style.top = b.layerY + "px"
            }
            return false
        }
    }(this);
    this.closePropertyOptions = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.handleHideDiv(a.target + "-cX-ConfiguratorOptions")
        }
    }(this);
    this.resetPropertyOptions = function(a, e, b) {
        if (!a) {
            a = this.$(this.target + "-cX-ConfiguratorValueText")
        }
        if (!e) {
            e = this.$(this.target + "-cX-ConfiguratorOptions")
        }
        if (a && a.childNodes && !b) {
            while (a.childNodes.length > 0) {
                var f = a.childNodes[0];
                if (f.nodeName.toLowerCase() == "a") {
                    this.removeEvtListener(f, "click", this.clickPropertyOptions, false)
                }
                a.removeChild(f)
            }
        }
        if (e) {
            var d = this.$(this.target + "-cX-ConfiguratorOptionsContainer");
            if (d) {
                while (d.childNodes.length > 0) {
                    var f = d.childNodes[0];
                    if (f.nodeName.toLowerCase() == "a") {
                        this.removeEvtListener(f, "click", this.updatePropertyValue, false)
                    } else {
                        if (f.nodeName.toLowerCase() == "input" && f.type == "checkbox") {
                            this.removeEvtListener(f, "change", this.updatePropertyValue, false)
                        }
                    }
                    d.removeChild(f)
                }
                e.removeChild(d)
            }
            e.style.display = "none"
        }
    };
    this.addPropertyFilter = function(a) {
        return function(d) {
            if (!d) {
                d = window.event
            }
            a.resetEditPropertyDescription();
            var b = d.target || d.srcElement;
            var c = a.$(a.target + "-cX-ConfiguratorFilter");
            a.addAllPropertyFilters(b.name, b.opts);
            c.style.display = "block";
            c.opts = b.opts;
            c.style.left = d.layerX + "px";
            c.style.top = d.layerY + "px"
        }
    }(this);
    this.addAllPropertyFilters = function(c, d) {
        var b = this.$(this.target + "-cX-ConfiguratorFilter");
        for (var a = 0; a < this[c].length; a++) {
            this.insertPropertyFilterRow(b, a, c, d)
        }
        this.insertPropertyFilterRow(b, this[c].length, c, d)
    };
    this.insertPropertyFilterRow = function(F, B, r, y) {
        if (!F) {
            F = this.$(this.target + "-cX-ConfiguratorFilter")
        }
        if (F) {
            var e = this.configuratorWidth * 0.25;
            var G = this.$cX("div", {
                id: this.target + "-cX-ConfiguratorFilterContainer" + B
            }, {
                width: (this.configuratorWidth * 1.05) + "px"
            });
            var q = this.$cX("select", {
                id: this.target + "-cX-ConfiguratorFilterSelect" + B,
                className: "CanvasXpressConfiguratorFilter",
                param: r,
                idx: B
            }, {
                marginRight: "2px",
                marginLeft: "1px",
                width: e + "px"
            });
            if (!y) {
                y = F.opts
            }
            y.sort();
            for (var A = 0; A < y.length; A++) {
                var d = this.$cX("option", {
                    text: y[A],
                    value: y[A]
                });
                try {
                    q.add(d, null)
                } catch (E) {
                    q.add(d)
                }
                if (this[r][B] && y[A] == this[r][B]) {
                    d.selected = true
                }
            }
            this.addEvtListener(q, "change", this.unsetPropertyFilterRow, false);
            var t = this.$cX("select", {
                id: this.target + "-cX-ConfiguratorFilterOp" + B,
                className: "CanvasXpressConfiguratorFilter",
                param: r,
                idx: B
            }, {
                marginRight: "2px",
                width: e + "px"
            });
            var x = this.getOperators();
            for (var A = 0; A < x.length; A++) {
                var d = this.$cX("option", {
                    text: x[A],
                    value: x[A]
                });
                try {
                    t.add(d, null)
                } catch (E) {
                    t.add(d)
                }
                if (this[r + "Op"][B] && x[A] == this[r + "Op"][B]) {
                    d.selected = true
                }
            }
            this.addEvtListener(t, "change", this.unsetPropertyFilterRow, false);
            var I = this.$cX("img", {
                src: this.imageDir + "case_sensitive.png"
            }, {
                width: "10px"
            });
            var H = this.$cX("input", {
                id: this.target + "-cX-ConfiguratorFilterCase" + B,
                type: "checkbox",
                param: r,
                idx: B,
                alt: "Check for case sensitive",
                title: "Check for case sensitive"
            }, {
                width: "10px"
            });
            if (this[r + "Case"][B]) {
                H.checked = true
            }
            this.addEvtListener(H, "change", this.unsetPropertyFilterRow, false);
            var n = this.$cX("input", {
                id: this.target + "-cX-ConfiguratorFilterValue" + B,
                param: r,
                idx: B,
                type: "text"
            }, {
                width: e + "px"
            });
            if (this[r + "Value"][B]) {
                n.value = this[r + "Value"][B]
            }
            this.addEvtListener(n, "change", this.unsetPropertyFilterRow, false);
            var u = this.$cX("img", {
                id: this.target + "-cX-ConfiguratorFilterMinus" + B,
                src: this.imageDir + "minus.png",
                alt: "Remove Filter",
                title: "Remove Filter",
                param: r,
                idx: B
            }, {
                padding: "9px 2px 2px 2px",
                cssFloat: "left",
                cursor: "default",
                width: "10px"
            });
            this.addEvtListener(u, "click", this.removePropertyFilterRow, false);
            var e = this.$cX("img", {
                id: this.target + "-cX-ConfiguratorFilterPlus" + B,
                src: this.imageDir + "add1.png",
                alt: "Set Filter",
                title: "Set Filter",
                param: r,
                idx: B
            }, {
                padding: "7px 2px 2px 2px",
                cssFloat: "right",
                cursor: "default",
                width: "10px"
            });
            this.addEvtListener(e, "click", this.addPropertyFilterRow, false);
            var D = this.$cX("img", {
                id: this.target + "-cX-ConfiguratorFilterCheck" + B,
                src: this.imageDir + "accept.png",
                alt: "Filter added",
                title: "Filter added"
            }, {
                padding: "7px 2px 2px 2px",
                cssFloat: "right",
                cursor: "default",
                width: "10px",
                display: this[r][B] ? "block" : "none"
            });
            var C = this.$cX("div", {
                id: this.target + "-cX-ConfiguratorFilterCheckEmpty" + B
            }, {
                cssFloat: "right",
                cursor: "default",
                width: "10px",
                display: this[r][B] ? "none" : "block"
            });
            G.appendChild(u);
            G.appendChild(q);
            G.appendChild(t);
            G.appendChild(I);
            G.appendChild(H);
            G.appendChild(n);
            G.appendChild(C);
            G.appendChild(D);
            G.appendChild(e);
            F.appendChild(G)
        }
    };
    this.addPropertyFilterRow = function(a) {
        return function(q) {
            if (!q) {
                q = window.event
            }
            var b = q.target || q.srcElement;
            var d = b.parentNode;
            var r = b.param;
            var l = b.idx;
            var t = a.$(a.target + "-cX-ConfiguratorValue");
            var n = a.$(a.target + "-cX-ConfiguratorFilterCheck" + l);
            var m = a.$(a.target + "-cX-ConfiguratorFilterCheckEmpty" + l);
            if (d && r && l != null && t && n && m) {
                var j = d.childNodes[1].value;
                var f = d.childNodes[2].value;
                var s = d.childNodes[4].checked;
                var u = d.childNodes[5].value;
                if (j != "" && ((f != "" && u != "") || f.match("null"))) {
                    if (a[r].length > 0 && a[r][l] != null) {
                        a[r][l] = j;
                        a[r + "Op"][l] = f;
                        a[r + "Value"][l] = u;
                        a[r + "Case"][l] = s
                    } else {
                        a[r].push(j);
                        a[r + "Op"].push(f);
                        a[r + "Value"].push(u);
                        a[r + "Case"].push(s);
                        a.insertPropertyFilterRow(false, l + 1, r)
                    }
                    t.value = '["' + a[r].join('", "') + '"]';
                    n.style.display = "block";
                    m.style.display = "none"
                }
            }
        }
    }(this);
    this.removePropertyFilterRow = function(a) {
        return function(k) {
            if (!k) {
                k = window.event
            }
            var d = k.target || k.srcElement;
            var j = d.parentNode;
            var h = j.parentNode;
            var l = d.param;
            var f = d.idx;
            var b = a.$(a.target + "-cX-ConfiguratorValue");
            if (j && l && f != null && b) {
                a.resetFilters(l, f);
                a.resetPropertyFilter(true);
                a.addAllPropertyFilters(l, h.opts);
                b.value = a[l].length > 0 ? '["' + a[l].join('", "') + '"]' : "[]"
            }
        }
    }(this);
    this.unsetPropertyFilterRow = function(a) {
        return function(m) {
            if (!m) {
                m = window.event
            }
            var p = [];
            var b = m.target || m.srcElement;
            var n = b.param;
            var f = b.idx;
            if (n && f != null) {
                if (a[n].length > 0 && a[n][f]) {
                    a[n][f] = false;
                    a[n + "Op"][f] = false;
                    a[n + "Value"][f] = false;
                    a[n + "Case"][f] = false;
                    for (var d = 0; d < a[n].length; d++) {
                        if (d != f) {
                            p.push(a[n][d])
                        }
                    }
                    var l = a.$(a.target + "-cX-ConfiguratorFilterCheck" + f);
                    var k = a.$(a.target + "-cX-ConfiguratorFilterCheckEmpty" + f);
                    var o = a.$(a.target + "-cX-ConfiguratorValue");
                    if (l && k && o) {
                        l.style.display = "none";
                        k.style.display = "block";
                        o.value = p.length > 0 ? '["' + p.join('", "') + '"]' : "[]"
                    }
                }
            }
        }
    }(this);
    this.closePropertyFilter = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.handleHideDiv(a.target + "-cX-ConfiguratorFilter");
            a.resetPropertyFilter()
        }
    }(this);
    this.closePropertyExample = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.handleHideDiv(a.target + "-cX-ConfiguratorExample");
            a.resetPropertyExample()
        }
    }(this);
    this.resetPropertyFilter = function(a) {
        var b = this.$(this.target + "-cX-ConfiguratorFilter");
        if (b) {
            if (b && b.childNodes) {
                while (b.childNodes.length > 3) {
                    var c = b.childNodes[3];
                    this.removeEvtListener(c.childNodes[0], "click", this.removePropertyFilterRow, false);
                    this.removeEvtListener(c.childNodes[1], "change", this.unsetPropertyFilterRow, false);
                    this.removeEvtListener(c.childNodes[2], "change", this.unsetPropertyFilterRow, false);
                    this.removeEvtListener(c.childNodes[4], "change", this.unsetPropertyFilterRow, false);
                    this.removeEvtListener(c.childNodes[5], "change", this.unsetPropertyFilterRow, false);
                    this.removeEvtListener(c.childNodes[8], "click", this.addPropertyFilterRow, false);
                    b.removeChild(b.childNodes[3])
                }
            }
            if (!a) {
                b.style.display = "none"
            }
        }
    };
    this.resetPropertyExample = function(a) {
        var b = this.$(this.target + "-cX-ConfiguratorExample");
        if (b) {
            var c = b.getElementsByTagName("canvas");
            while (c.length > 0) {
                this.destroy(c[0].id)
            }
            if (!a) {
                b.style.display = "none"
            }
        }
    };
    this.addPropertyColor = function(a) {
        return function(j) {
            if (!j) {
                j = window.event
            }
            a.resetEditPropertyDescription();
            var d = a.$(a.target + "-cX-ConfiguratorColor");
            var t = a.$(a.target + "-cX-ConfiguratorValue");
            if (d && t) {
                var g = t.value ? a.rgbToHex(a.validateColor(t.value.replace(/[\'\"]/g, ""))) : a.foreground;
                a.colorRGBfromString(g);
                var r = Math.round(a.colorHSV[0] / 6 * 180);
                var q = Math.round((1 - a.colorHSV[1]) * 100);
                var m = Math.round((1 - a.colorHSV[2]) * 100);
                var l = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorColorContainer"
                }, {
                    width: "210px",
                    height: "101px",
                    marginTop: "7px"
                });
                var b = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorColorPalette",
                    className: "CanvasXpressConfiguratorColor"
                }, {
                    position: "relative",
                    left: "0px",
                    top: "0px",
                    width: "181px",
                    height: "101px",
                    backgroundImage: "url('" + a.imageDir + "color.png')",
                    backgroundRepeat: "no-repeat",
                    cursor: "crosshair"
                });
                var o = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorColorPaletteCurrent"
                }, {
                    position: "relative",
                    left: (r - 7) + "px",
                    top: (q - 7) + "px",
                    width: "195px",
                    height: "115px",
                    cursor: "crosshair",
                    backgroundImage: "url('" + a.imageDir + "cross.gif')",
                    backgroundRepeat: "no-repeat"
                });
                b.appendChild(o);
                var w = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorColorSaturation",
                    className: "CanvasXpressConfiguratorColor"
                }, {
                    position: "relative",
                    left: "188px",
                    top: "-102px",
                    width: "15px",
                    height: "100px",
                    border: "1px solid " + a.skinBorderColor,
                    cursor: "crosshair"
                });
                for (var f = 0; f < 100; f += 4) {
                    var u = a.$cX("div", false, {
                        height: "4px",
                        position: "relative",
                        left: "0px",
                        cursor: "crosshair"
                    });
                    w.appendChild(u)
                }
                var k = a.$cX("div", {
                    id: a.target + "-cX-ConfiguratorColorSaturationCurrent"
                }, {
                    position: "relative",
                    left: "0px",
                    top: (m - 108) + "px",
                    width: "29px",
                    height: "115px",
                    cursor: "crosshair",
                    backgroundImage: "url('" + a.imageDir + "cross.gif')",
                    backgroundRepeat: "no-repeat",
                    overflow: "hidden"
                });
                w.appendChild(k);
                l.appendChild(b);
                l.appendChild(w);
                d.appendChild(l);
                a.colorizeSaturationColorDiv();
                a.addEvtListener(b, "mousedown", a.registerPalette, false);
                a.addEvtListener(w, "mousedown", a.registerSaturation, false);
                d.style.display = "block";
                d.style.left = j.layerX + "px";
                d.style.top = j.layerY + "px"
            }
            return false
        }
    }(this);
    this.registerPalette = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.changingColorOn = "palette";
            if (a.colorHSV[2] == 0) {
                a.colorFromHsv(null, null, 1);
                var c = a.$(a.target + "-cX-ConfiguratorColorSaturationCurrent");
                if (c) {
                    c.style.top = "-108px"
                }
            }
            a.updateColorValue(b);
            a.colorizeSaturationColorDiv();
            return false
        }
    }(this);
    this.registerSaturation = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.changingColorOn = "saturation";
            a.updateColorValue(b);
            return false
        }
    }(this);
    this.updateColorValue = function(g) {
        if (this.changingColorOn) {
            if (this.changingColorOn == "palette") {
                var f = this.$(this.target + "-cX-ConfiguratorColorPalette");
                var b = this.$(this.target + "-cX-ConfiguratorColorPaletteCurrent");
                if (f && b) {
                    var d = this.adjustedCoordinates(g, f);
                    if (d) {
                        var a = Math.min(Math.max(0, d.x), 181);
                        var j = Math.min(Math.max(0, d.y), 101);
                        b.style.left = (a - 7) + "px";
                        b.style.top = (j - 7) + "px";
                        this.colorFromHsv(a * 6 / 180, 1 - j / 100, null);
                        this.colorizeSaturationColorDiv()
                    }
                }
            } else {
                var c = this.$(this.target + "-cX-ConfiguratorColorSaturation");
                var h = this.$(this.target + "-cX-ConfiguratorColorSaturationCurrent");
                if (c && h) {
                    var d = this.adjustedCoordinates(g, c);
                    if (d) {
                        var j = Math.min(Math.max(0, d.y), 101);
                        h.style.top = (j - 108) + "px";
                        this.colorFromHsv(null, null, 1 - j / 100)
                    }
                }
            }
        }
    };
    this.colorFromHsv = function(c, b, a) {
        if (c != null) {
            this.colorHSV[0] = Math.min(Math.max(0, c), 6)
        }
        if (b != null) {
            this.colorHSV[1] = Math.min(Math.max(0, b), 1)
        }
        if (a != null) {
            this.colorHSV[2] = Math.min(Math.max(0, a), 1)
        }
        this.colorRGB = this.hsvFromRgb(this.colorHSV[0], this.colorHSV[1], this.colorHSV[2]);
        this.colorizeCurrentColorDiv()
    };
    this.hsvFromRgb = function(e, d, b) {
        if (e == null) {
            return [b, b, b]
        }
        var c = Math.floor(e);
        var g = c % 2 ? e - c : 1 - (e - c);
        var a = b * (1 - d);
        var j = b * (1 - d * g);
        switch (c) {
            case 0:
                return [b, j, a];
            case 1:
                return [j, b, a];
            case 2:
                return [a, b, j];
            case 3:
                return [a, j, b];
            case 4:
                return [j, a, b];
            case 5:
                return [b, a, j];
            case 6:
        }
    };
    this.colorFromRgb = function(e, d, a) {
        if (this.colorRGB) {
            if (e != null) {
                this.colorRGB[0] = Math.min(Math.max(0, e), 1)
            }
            if (d != null) {
                this.colorRGB[1] = Math.min(Math.max(0, d), 1)
            }
            if (a != null) {
                this.colorRGB[2] = Math.min(Math.max(0, a), 1)
            }
            var c = this.rgbFromHsv(this.colorRGB[0], this.colorRGB[1], this.colorRGB[2]);
            if (c[0] != null) {
                this.colorHSV[0] = c[0]
            }
            if (c[2] != 0) {
                this.colorHSV[1] = c[1]
            }
            this.colorHSV[2] = c[2];
            this.colorizeCurrentColorDiv()
        }
    };
    this.rgbFromHsv = function(j, f, c) {
        var k = Math.min(Math.min(j, f), c);
        var d = Math.max(Math.max(j, f), c);
        var a = d - k;
        if (a == 0) {
            return [null, 0, d]
        } else {
            var e = j == k ? 3 + (c - f) / a : (f == k ? 5 + (j - c) / a : 1 + (f - j) / a);
            return [e == 6 ? 0 : e, a / d, d]
        }
    };
    this.colorRGBToString = function() {
        if (this.colorRGB) {
            return (256 | Math.round(255 * this.colorRGB[0])).toString(16).substr(1) + (256 | Math.round(255 * this.colorRGB[1])).toString(16).substr(1) + (256 | Math.round(255 * this.colorRGB[2])).toString(16).substr(1)
        }
    };
    this.colorRGBfromString = function(b) {
        var a = b.match(/^\W*([0-9A-F]{3}([0-9A-F]{3})?)\W*$/i);
        if (!a) {
            return false
        } else {
            if (a[1].length === 6) {
                this.colorFromRgb(parseInt(a[1].substr(0, 2), 16) / 255, parseInt(a[1].substr(2, 2), 16) / 255, parseInt(a[1].substr(4, 2), 16) / 255)
            } else {
                this.colorFromRgb(parseInt(a[1].charAt(0) + a[1].charAt(0), 16) / 255, parseInt(a[1].charAt(1) + a[1].charAt(1), 16) / 255, parseInt(a[1].charAt(2) + a[1].charAt(2), 16) / 255)
            }
            return true
        }
    };
    this.colorizeCurrentColorDiv = function() {
        var f = this.$(this.target + "-cX-ConfiguratorColorCurrent");
        var a = this.$(this.target + "-cX-ConfiguratorValue");
        var d = this.$(this.target + "-cX-ConfiguratorValueHREF");
        if (f && a && d) {
            var e = this.colorRGBToString();
            var b = this.hexToRgb("#" + e);
            f.style.backgroundColor = "#" + e;
            f.innerHTML = "&nbsp;&nbsp;" + b;
            a.value = '"' + b + '"';
            d.style.color = "#" + e
        }
    };
    this.colorizeSaturationColorDiv = function() {
        var b = function(m, k, c, j, h) {
            return "rgb(" + (m * (1 - j / h) * 100) + "%," + (k * (1 - j / h) * 100) + "%," + (c * (1 - j / h) * 100) + "%)"
        };
        var e = this.$(this.target + "-cX-ConfiguratorColorSaturation");
        if (e && this.colorHSV) {
            var f = e.childNodes;
            var a = this.hsvFromRgb(this.colorHSV[0], this.colorHSV[1], 1);
            if (a) {
                for (var d = 0; d < f.length - 1; d++) {
                    f[d].style.backgroundColor = b(a[0], a[1], a[2], d, f.length - 1)
                }
            }
        }
    };
    this.endColorChange = function(a) {
        this.changingColorOn = false
    };
    this.closePropertyColor = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.handleHideDiv(a.target + "-cX-ConfiguratorColor");
            a.resetPropertyColor()
        }
    }(this);
    this.resetPropertyColor = function() {
        var c = this.$(this.target + "-cX-ConfiguratorColor");
        var b = this.$(this.target + "-cX-ConfiguratorColorPalette");
        var a = this.$(this.target + "-cX-ConfiguratorColorSaturation");
        if (c && b && a) {
            if (c && c.childNodes) {
                while (c.childNodes.length > 3) {
                    c.removeChild(c.childNodes[3])
                }
                this.removeEvtListener(b, "mousedown", this.registerPalette, false);
                this.removeEvtListener(a, "mousedown", this.registerSaturation, false)
            }
            c.style.display = "none"
        }
    };
    this.updatePropertyValue = function(a) {
        return function(h) {
            if (!h) {
                h = window.event
            }
            a.resetEditPropertyDescription();
            var f = a.$(a.target + "-cX-ConfiguratorValue");
            var j = a.$(a.target + "-cX-ConfiguratorOptions");
            var d = h.target || h.srcElement;
            if (d.nodeName.toLowerCase() == "input") {
                var b = [];
                for (var g = 0; g < d.parentNode.childNodes.length; g++) {
                    var k = d.parentNode.childNodes[g];
                    if (k.checked) {
                        b.push(k.value)
                    }
                }
                f.value = b.length > 0 ? '["' + b.join('", "') + '"]' : "[]"
            } else {
                if (f && j) {
                    if (d.innerHTML == "true") {
                        f.value = d.innerHTML
                    } else {
                        if (d.innerHTML == "false") {
                            f.value = d.innerHTML
                        } else {
                            if (d.innerHTML == "null") {
                                f.value = d.innerHTML
                            } else {
                                f.value = '"' + d.innerHTML + '"'
                            }
                        }
                    }
                    j.style.display = "none"
                }
            }
            return false
        }
    }(this);
    this.clickApplyConfigurator = function(a) {
        return function(b) {
            return a.clickConfigurator(b, false, false, true)
        }
    }(this);
    this.clickConfigurator = function(a) {
        return function(g, m, l, j) {
            if (!g) {
                g = window.event
            }
            if (!m) {
                m = a.$(a.target + "-cX-ConfiguratorSugestions")
            }
            if (!l) {
                l = a.$(a.target + "-cX-ConfiguratorValue")
            }
            if (m && l) {
                var k = a.getConfigurableObjectDoc(m.value);
                if (l.value) {
                    var b = JSON.parse(l.value);
                    if (k.T == "color" && !a.validateColor(b)) {
                        alert('"' + b + '" is NOT a valid color');
                        return false
                    }
                }
                if (a.configuringNetwork) {
                    if (a.configuringNetwork < a.data.nodes.length) {
                        if (typeof(a[m.value]) == "function") {
                            a[m.value](a.data.nodes[a.configuringNetwork])
                        } else {
                            a.data.nodes[a.configuringNetwork][m.value] = JSON.parse(l.value)
                        }
                    } else {
                        if (typeof(a[m.value]) == "function") {
                            a[m.value](a.data.edges[a.configuringNetwork - a.data.nodes.length])
                        } else {
                            a.data.edges[a.configuringNetwork - a.data.nodes.length][m.value] = JSON.parse(l.value)
                        }
                    }
                } else {
                    if (a.configuringGenome) {
                        var c = a.subtracksInfo;
                        if (!isNaN(a.configuringGenome)) {
                            a.data.tracks[c[a.configuringGenome].track].data[c[a.configuringGenome].index][m.value] = JSON.parse(l.value)
                        } else {
                            if (a.configuringGenome.match(/:/)) {
                                var h = parseInt(a.configuringGenome.split(":")[1]);
                                a.data.tracks[c[h].track].data[c[h].index][m.value] = JSON.parse(l.value)
                            } else {
                                var h = parseInt(a.configuringGenome.replace("track-", ""));
                                a.data.tracks[h][m.value] = JSON.parse(l.value)
                            }
                        }
                    } else {
                        if (typeof(a[m.value]) == "function") {
                            if (a[m.value].length > 0 && l && l.value) {
                                var j = JSON.parse(l.value);
                                a[m.value](j)
                            } else {
                                a[m.value]()
                            }
                            a.resetConfigurator();
                            return false
                        } else {
                            a[m.value] = JSON.parse(l.value);
                            a.userConfig[m.value] = a[m.value]
                        }
                    }
                } if (!j) {
                    a.resetConfigurator()
                }
                var d = m.value.match(/filter(.+)By/);
                if (d) {
                    a.reset();
                    a.filterData()
                }
                a.resetPropertyExample();
                a.draw()
            }
            return false
        }
    }(this);
    this.handleHideDiv = function(a) {
        var b = this.$(a);
        if (b) {
            b.style.display = "none"
        }
        return false
    };
    this.resetOptionColorFiltersExamples = function() {
        this.resetPropertyOptions(false, false, true);
        this.resetPropertyColor();
        this.resetPropertyFilter();
        this.resetPropertyExample()
    };
    this.resetEditOptionColorFiltersExamples = function() {
        this.resetEditPropertyDescription();
        this.resetPropertyOptions(false, false, true);
        this.resetPropertyFilter();
        this.resetPropertyExample()
    };
    this.resetConfigurator = function() {
        if (this.configuringOn && this.configuringOn != "docked") {
            this.resetEditOptionColorFiltersExamples();
            this.resetPropertyDescription();
            this.resetPropertySeeAlsoLinks();
            this.editingDescriptionOn = false;
            this.configuratorLastState = false;
            this.configuringOn = false;
            this.configuringNetwork = false;
            this.configuringGenome = false;
            this.addRemoveConfiguratorListeners("removeEvtListener");
            this.removeTarget(this.target + "-cX-Configurator")
        }
    }
};
CanvasXpress.prototype.initAcknowlegments = function() {
    this.addAcknowledgmentDiv = function() {
        if (this.$(this.target + "canvasXpressAcknowledgmentDiv")) {
            this.setAcknowledgmentVisibility();
            return
        }
        var f = document.createElement("div");
        f.id = this.target + "canvasXpressAcknowledgmentDiv";
        f.style.display = this.acknowledgment ? "block" : "none";
        f.style.width = this.width + "px";
        f.style.cssFloat = "left";
        f.style.position = "relative";
        f.style.zIndex = 9999;
        this.setAcknowledgmentPosition(f);
        var c = document.createElement("img");
        c.src = this.imageDir + this.acknowledgmentIcon;
        c.style.margin = "2px";
        c.alt = "Graphs powered by canvasXpress";
        c.title = "Graphs powered by canvasXpress";
        c.style.cssFloat = "right";
        var b = document.createElement("a");
        b.href = "http://canvasxpress.org";
        b.target = "_blank";
        b.style.cssFloat = "right";
        b.appendChild(c);
        f.appendChild(b);
        var e = this.$("south-wrapper-" + this.target);
        if (e) {
            e.appendChild(f)
        }
    };
    this.resizeAcknowledgmentDiv = function() {
        var b = this.$(this.target + "canvasXpressAcknowledgmentDiv");
        if (b) {
            b.style.width = this.width + "px"
        }
    };
    this.setAcknowledgmentVisibility = function() {
        var b = this.$(this.target + "canvasXpressAcknowledgmentDiv");
        if (b) {
            b.style.display = this.acknowledgment ? "block" : "none";
            this.setAcknowledgmentPosition(b)
        }
    };
    this.setAcknowledgmentPosition = function(b) {
        if (b) {
            if (this.acknowledgmentIconPosition == "inside") {
                b.style.top = this.citation ? (((this.citationFontSize * this.citationScaleFontFactor) + 36) * -1) + "px" : "-31px";
                b.style.right = "3px"
            } else {
                b.style.top = "0px";
                b.style.right = "0px"
            }
        }
    };
    this.addAcknowledgmentDiv()
};
CanvasXpress.prototype.initCodeInfo = function() {
    this.addInfoCodeDiv = function() {
        if (this.$(this.target + "-cX-Code")) {
            return
        }
        var g = this.$cX("div", {
            id: this.target + "-cX-Info",
            className: "CanvasXpressInfo"
        }, {
            display: "none"
        });
        var h = this.$cX("div", {
            id: this.target + "-cX-Code",
            className: "CanvasXpressCode draggable"
        }, {
            left: "50px",
            top: "-200px",
            display: "none"
        });
        var j = this.$cX("img", {
            id: this.target + "-cX-CodeCloseImage",
            className: "CanvasXpressCode",
            src: this.imageDir + "cancel1.png",
            alt: "Close Code",
            title: "Close Code"
        });
        var f = this.$cX("img", {
            id: this.target + "-cX-CodePrettyImage",
            className: "CanvasXpressCode",
            src: this.imageDir + "blue_code.png",
            alt: "Pretty Code",
            title: "Pretty Code"
        });
        var e = this.$cX("img", {
            id: this.target + "-cX-CodeCompactImage",
            className: "CanvasXpressCode",
            src: this.imageDir + "green_code.png",
            alt: "Compact Code",
            title: "Compact Code"
        });
        var d = this.$cX("img", {
            id: this.target + "-cX-CodeTabImage",
            className: "CanvasXpressCode",
            src: this.imageDir + "yellow_code.png",
            alt: "Tab Code",
            title: "Tab Code"
        });
        var b = this.$cX("img", {
            id: this.target + "-cX-CodeParamsImage",
            className: "CanvasXpressCode",
            src: this.imageDir + "red_code.png",
            alt: "Params Code",
            title: "Params Code"
        });
        var g = this.$cX("div", {
            id: this.target + "-cX-CodeContainer",
            className: "CanvasXpressCodeContainer"
        });
        var a = this.$("north-wrapper-" + this.target);
        var k = this.$("south-wrapper-" + this.target);
        if (a) {
            a.appendChild(g)
        }
        if (k) {
            h.appendChild(j);
            h.appendChild(f);
            h.appendChild(e);
            h.appendChild(d);
            h.appendChild(b);
            h.appendChild(g);
            k.appendChild(h);
            this.addRemoveCodeListeners("addEvtListener")
        }
    };
    this.addRemoveCodeListeners = function(a) {
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-Code"), "mousedown", this.registerMousemove, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeCloseImage"), "click", this.clickCode, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodePrettyImage"), "click", this.clickChangeCode, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeCompactImage"), "click", this.clickChangeCode, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeTabImage"), "click", this.clickChangeCode, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeParamsImage"), "click", this.clickChangeCode, false)
    };
    this.clickCode = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.hideCodeDiv();
            return false
        }
    }(this);
    this.clickChangeCode = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            var b = a.getTargetEvent(c);
            switch (b.id) {
                case a.target + "-cX-CodePrettyImage":
                    a.codeType = "pretty";
                    break;
                case a.target + "-cX-CodeCompactImage":
                    a.codeType = "compact";
                    break;
                case a.target + "-cX-CodeTabImage":
                    a.codeType = "tab";
                    break;
                case a.target + "-cX-CodeParamsImage":
                    a.codeType = "params";
                    break;
                default:
                    break
            }
            a.updateCodeDiv();
            return false
        }
    }(this);
    this.clearCodeDiv = function() {
        var b = this.$(this.target + "-cX-Code");
        var a = this.$(this.target + "-cX-CodeContent");
        if (b && a) {
            a.parentNode.removeChild(a);
            b.style.display = "none"
        }
    };
    this.updateCodeDiv = function(i) {
        var j = this.$(this.target + "-cX-Code");
        var d = this.$(this.target + "-cX-CodeContainer");
        var g = this.cloneObject(this.data);
        var e = this.codeType == "pretty" ? this.prettyJSON(g) : this.codeType == "params" ? "{\n  ...\n}" : JSON.stringify(g);
        var f = this.codeType == "pretty" || this.codeType == "params" ? this.prettyJSON(this.userConfig) : JSON.stringify(this.userConfig);
        if (j && d) {
            this.clearCodeDiv();
            var a = this.codeType == "tab" || this.codeType == "compact" ? "span" : "pre";
            var b = this.codeType == "tab" ? "canvasID\t" + e + "\t" + f + "\n" : 'new CanvasXpress("canvasID", ' + e + ", " + f + ")\n";
            d.appendChild(this.$cX(a, {
                id: this.target + "-cX-CodeContent",
                className: "CanvasXpressCodeContent",
                innerHTML: b
            }));
            j.style.display = "block";
            if (i) {
                j.style.zIndex = i
            }
        }
    };
    this.updateInfoDiv = function(a) {
        var b = this.$(this.target + "-cX-Info");
        if (b && a) {
            b.innerHTML = a
        }
    };
    this.showDiv = function(a) {
        var b = this.$(this.target + "-cX-" + a);
        if (b) {
            b.style.display = "block"
        }
    };
    this.hideDiv = function(a) {
        var b = this.$(this.target + "-cX-" + a);
        if (b) {
            b.style.display = "none"
        }
    };
    this.showCodeDiv = function() {
        this.updateCodeDiv();
        this.showDiv("Code")
    };
    this.hideCodeDiv = function() {
        this.hideDiv("Code")
    };
    this.showInfoDiv = function() {
        this.showDiv("Info")
    };
    this.hideInfoDiv = function() {
        this.hideDiv("Info")
    };
    this.initializeCodeInfo = function() {
        this.addInfoCodeDiv()
    };
    this.initializeCodeInfo()
};
CanvasXpress.prototype.initDataFilter = function() {
    this.addDataFilterDiv = function() {
        if (this.$(this.target + "-cX-DataFilter")) {
            return
        }
        var j = this.dataFilterLastX != null ? parseInt(this.dataFilterLastX) : -this.canvas.width * 0.5;
        var h = this.dataFilterLastY != null ? parseInt(this.dataFilterLastY) : this.canvas.height * 0.5;
        var u = this.graphType == "Genome" ? 60 : 81;
        this.dataFilterHeight = this.canvas.height - u;
        this.activeAccordion = null;
        var B = this.$cX("div", {
            id: this.target + "-cX-DataFilter",
            className: this.applicationLook ? "CanvasXpressDataFilter fixed" : "CanvasXpressDataFilter draggable-container"
        }, {
            top: h + "px",
            left: j + "px",
            display: "none",
            zIndex: 10000
        });
        var o = this.$cX("div", {
            id: this.target + "-cX-DataFilterToolbar",
            className: this.applicationLook ? "CanvasXpressDataFilterToolbar fixed" : "CanvasXpressDataFilterToolbar draggable"
        }, {
            width: this.dataFilterWidth + "px"
        });
        var b = this.$cX("span", {
            innerHTML: "Filters",
            className: "CanvasXpressDataFilterToolbarText"
        });
        var s = this.$cX("img", {
            id: this.target + "-cX-DataFilterKeyFlash",
            className: "CanvasXpressDataFilterToolbarImage",
            src: this.filterFlashingOn ? this.imageDir + "lightbulb.png" : this.imageDir + "lightbulb_off.png",
            alt: this.filterFlashingOn ? "Turn off Flashing" : "Turn on Flashing",
            title: this.filterFlashingOn ? "Turn off Flashing" : "Turn on Flashing"
        }, {
            display: this.graphType == "Network" ? "block" : "none"
        });
        if (this.isIE) {
            s.style.marginTop = "-10px"
        }
        var g = this.$cX("img", {
            id: this.target + "-cX-DataFilterKeyReset",
            className: "CanvasXpressDataFilterToolbarImage",
            src: this.imageDir + "funnel_cross.png",
            alt: "Reset filters",
            title: "Reset filters"
        });
        if (this.isIE) {
            g.style.marginTop = "-10px"
        }
        var v = this.$cX("img", {
            id: this.target + "-cX-DataFilterKeyDock",
            className: "CanvasXpressDataFilterToolbarImage",
            src: this.applicationLook ? this.imageDir + "unpin.png" : this.imageDir + "pin.png",
            alt: this.applicationLook ? "Undock" : "Dock",
            title: this.applicationLook ? "Undock" : "Dock",
            state: this.applicationLook ? "docked" : "free"
        });
        if (this.isIE) {
            v.style.marginTop = "-10px"
        }
        var x = this.$cX("img", {
            id: this.target + "-cX-DataFilterKeyClose",
            className: "CanvasXpressDataFilterToolbarImage",
            src: this.imageDir + "cancel1.png",
            alt: "Close",
            title: "Close"
        });
        if (this.isIE) {
            x.style.marginTop = "-10px"
        }
        var C = this.$cX("div", {
            id: this.target + "-cX-DataFilterContainer",
            className: "CanvasXpressDataFilterContainer"
        }, {
            width: this.dataFilterWidth + "px"
        });
        var m = this.$cX("div", {
            id: this.target + "-cX-DataFilterVariableHeader",
            className: "CanvasXpressDataFilterHead"
        }, {
            width: this.dataFilterWidth + "px",
            display: this.graphType.match(/Genome|Network/) ? "none" : "block"
        });
        var r = this.$cX("div", {
            id: this.target + "-cX-DataFilterVariableContent",
            className: "CanvasXpressDataFilterContent"
        }, {
            width: this.dataFilterWidth + "px",
            height: "0px",
            display: "none"
        });
        var e = this.$cX("span", {
            innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variables",
            className: "CanvasXpressDataFilterText"
        });
        var k = this.$cX("div", {
            id: this.target + "-cX-DataFilterSampleHeader",
            className: "CanvasXpressDataFilterHead"
        }, {
            width: this.dataFilterWidth + "px",
            display: this.graphType.match(/Genome|Network/) ? "none" : "block"
        });
        var q = this.$cX("div", {
            id: this.target + "-cX-DataFilterSampleContent",
            className: "CanvasXpressDataFilterContent"
        }, {
            width: this.dataFilterWidth + "px",
            height: "0px",
            display: "none"
        });
        var c = this.$cX("span", {
            innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Samples",
            className: "CanvasXpressDataFilterText"
        });
        var y = this.$cX("div", {
            id: this.target + "-cX-DataFilterNodeHeader",
            className: "CanvasXpressDataFilterHead"
        }, {
            width: this.dataFilterWidth + "px",
            display: this.graphType == "Network" ? "block" : "none"
        });
        var A = this.$cX("div", {
            id: this.target + "-cX-DataFilterNodeContent",
            className: "CanvasXpressDataFilterContent"
        }, {
            width: this.dataFilterWidth + "px",
            height: "0px",
            display: "none"
        });
        var n = this.$cX("span", {
            innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nodes",
            className: "CanvasXpressDataFilterText"
        });
        var t = this.$cX("div", {
            id: this.target + "-cX-DataFilterEdgeHeader",
            className: "CanvasXpressDataFilterHead"
        }, {
            width: this.dataFilterWidth + "px",
            display: this.graphType == "Network" ? "block" : "none"
        });
        var z = this.$cX("div", {
            id: this.target + "-cX-DataFilterEdgeContent",
            className: "CanvasXpressDataFilterContent"
        }, {
            width: this.dataFilterWidth + "px",
            height: "0px",
            display: "none"
        });
        var i = this.$cX("span", {
            innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edges",
            className: "CanvasXpressDataFilterText"
        });
        var f = this.$cX("div", {
            id: this.target + "-cX-DataFilterGenomeHeader",
            className: "CanvasXpressDataFilterHead"
        }, {
            width: this.dataFilterWidth + "px",
            display: this.graphType == "Genome" ? "block" : "none"
        });
        var l = this.$cX("div", {
            id: this.target + "-cX-DataFilterGenomeContent",
            className: "CanvasXpressDataFilterContent"
        }, {
            width: this.dataFilterWidth + "px",
            height: "0px",
            display: "none"
        });
        var a = this.$cX("span", {
            innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Features",
            className: "CanvasXpressDataFilterText"
        });
        o.appendChild(b);
        o.appendChild(x);
        o.appendChild(v);
        o.appendChild(g);
        o.appendChild(s);
        m.appendChild(e);
        k.appendChild(c);
        y.appendChild(n);
        t.appendChild(i);
        f.appendChild(a);
        C.appendChild(m);
        C.appendChild(r);
        C.appendChild(k);
        C.appendChild(q);
        C.appendChild(y);
        C.appendChild(A);
        C.appendChild(t);
        C.appendChild(z);
        C.appendChild(f);
        C.appendChild(l);
        B.appendChild(o);
        B.appendChild(C);
        var p = this.$("east-wrapper-" + this.target);
        if (p) {
            p.appendChild(B);
            this.addRemoveDataFilterListeners("addEvtListener")
        }
    };
    this.addRemoveDataFilterListeners = function(k) {
        var e = this.$(this.target + "-cX-DataFilterToolbar");
        var a = this.$(this.target + "-cX-DataFilterKeyFlash");
        var g = this.$(this.target + "-cX-DataFilterKeyReset");
        var b = this.$(this.target + "-cX-DataFilterKeyDock");
        var c = this.$(this.target + "-cX-DataFilterKeyClose");
        var h = this.$(this.target + "-cX-DataFilterVariableHeader");
        var i = this.$(this.target + "-cX-DataFilterSampleHeader");
        var d = this.$(this.target + "-cX-DataFilterNodeHeader");
        var f = this.$(this.target + "-cX-DataFilterEdgeHeader");
        var j = this.$(this.target + "-cX-DataFilterGenomeHeader");
        if (e && a && g && b && c && h && i && d && f && j) {
            this[k](e, "mousedown", this.registerMousemove, false);
            this[k](a, "click", this.flashDataFilter, false);
            this[k](g, "click", this.resetDataFilter, false);
            this[k](b, "click", this.dockUndockDataFilter, false);
            this[k](c, "click", this.hideDataFilter, false);
            this[k](h, "click", this.activateAccordion, false);
            this[k](i, "click", this.activateAccordion, false);
            this[k](d, "click", this.activateAccordion, false);
            this[k](f, "click", this.activateAccordion, false);
            this[k](j, "click", this.activateAccordion, false)
        }
    };
    this.flashDataFilter = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            var b = a.getTargetEvent(c);
            if (a.filterFlashingOn) {
                a.filterFlashingOn = false;
                b.src = a.imageDir + "lightbulb_off.png";
                b.alt = "Turn on Flashing";
                b.title = "Turn on Flashing"
            } else {
                a.filterFlashingOn = true;
                b.src = a.imageDir + "lightbulb.png";
                b.alt = "Turn off Flashing";
                b.title = "Turn off Flashing"
            }
            return false
        }
    }(this);
    this.activateAccordion = function(a) {
        return function(f, b) {
            if (!f) {
                f = window.event
            }
            var d = a;
            if (!b) {
                b = a.getTargetEvent(f)
            }
            if (b) {
                if (b.tagName.toLowerCase() == "span") {
                    b = b.parentNode
                }
                b.className = "CanvasXpressDataFilterHeadActive";
                b.firstChild.className = "CanvasXpressDataFilterTextActive";
                var c = b.nextSibling;
                if (c) {
                    setTimeout(function() {
                        if (d.activeAccordion && c.id == d.activeAccordion.id) {
                            c = false
                        }
                        d.transitionAccordion(new Date().getTime(), 250, c, d.activeAccordion);
                        if (d.activeAccordion) {
                            var e = d.activeAccordion.previousSibling;
                            e.className = "CanvasXpressDataFilterHead";
                            e.firstChild.className = "CanvasXpressDataFilterText"
                        }
                        d.activeAccordion = c
                    }, 33)
                }
            }
            return false
        }
    }(this);
    this.resizeDataFilterForScroller = function(p) {
        var l = this.$(this.target + "-cX-DataFilter");
        var c = this.$(this.target + "-cX-DataFilterToolbar");
        var q = this.$(this.target + "-cX-DataFilterContainer");
        var h = this.$(this.target + "-cX-DataFilterVariableHeader");
        var n = this.$(this.target + "-cX-DataFilterVariableContent");
        var j = this.$(this.target + "-cX-DataFilterSampleHeader");
        var o = this.$(this.target + "-cX-DataFilterSampleContent");
        var b = this.$(this.target + "-cX-DataFilterNodeHeader");
        var g = this.$(this.target + "-cX-DataFilterNodeContent");
        var f = this.$(this.target + "-cX-DataFilterEdgeHeader");
        var k = this.$(this.target + "-cX-DataFilterEdgeContent");
        var m = this.$(this.target + "-cX-DataFilterGenomeHeader");
        var a = this.$(this.target + "-cX-DataFilterGenomeContent");
        if (l && c && q && h && n && j && o && b && g && f && k && m && a) {
            this.dataFilterScroller == p ? true : false;
            var e = [l, c, q, h, n, j, o, b, g, f, k, m, a];
            for (var d = 0; d < e.length; d++) {
                if (p) {
                    e[d].style.width = (parseInt(e[d].style.width) + 18) + "px"
                } else {
                    e[d].style.width = (parseInt(e[d].style.width) - 18) + "px"
                }
            }
        }
    };
    this.moveDataFilter = function(i) {
        var q, g;
        var p = this.$(this.target + "-cX-DataFilter");
        var d = this.$(this.target + "-cX-DataFilterToolbar");
        var f = this.$(this.target + "-cX-DataFilterKeyDock");
        var a = this.$(this.remoteParentId + "-canvasXpressRemoteWindow");
        var e = this.$("north-container-" + this.target);
        var n = this.$("south-container-" + this.target);
        var b = this.$("west-container-" + this.target);
        var o = this.$("middle-container-" + this.target);
        var k = this.$("east-container-" + this.target);
        var c = this.$("east-handler-" + this.target);
        var m = this.$("east-wrapper-" + this.target);
        var j = this;
        if (p && d && f && e && n && b && o && k && c && m) {
            var l = (d.clientWidth - this.dataFilterWidth) + 2;
            g = parseInt(e.clientHeight) + this.canvas.height + parseInt(n.clientHeight);
            if (f.state == "free" && !i) {
                d.className = "CanvasXpressDataFilterToolbar fixed";
                f.src = this.imageDir + "unpin.png";
                f.alt = "Undock";
                f.title = "Undock";
                f.state = "docked";
                this.dataFilterLastState = "docked";
                this.dataFilterLastX = p.style.left;
                this.dataFilterLastY = p.style.top;
                c.style.display = "block";
                var q = parseInt(b.style.width) + this.canvas.width + d.clientWidth + 7 + 2;
                if (a) {
                    this.resizeMove(a, 0, 0, Math.max(q, parseInt(n.clientWidth)) + 48, g + 54)
                }
                this.resizeMove(o, 0, 0, q, this.canvas.height);
                this.resizeMove(k, 0, 0, this.dataFilterWidth + l + 7, this.canvas.height);
                this.resizeMove(m, 0, 0, this.dataFilterWidth + l, this.canvas.height);
                this.resizeMove(p, 0, 0, this.dataFilterWidth, this.canvas.height)
            } else {
                d.className = "CanvasXpressDataFilterToolbar draggable";
                f.src = this.imageDir + "pin.png";
                f.alt = "Dock";
                f.title = "Dock";
                f.state = "free";
                this.dataFilterLastState = "free";
                if (i) {
                    delete(this.dataFilterLastState);
                    this.dataFilterLastX = null;
                    this.dataFilterLastY = null;
                    this.fade(p, 500, function() {
                        j.resetFade(p);
                        p.style.display = "none";
                        p.style.width = j.dataFilterWidth + "px";
                        p.style.height = j.canvas.height + "px"
                    })
                }
                c.style.display = "none";
                q = parseInt(b.style.width) + this.canvas.width;
                if (a) {
                    this.resizeMove(a, 0, 0, Math.max(q + 7, parseInt(n.clientWidth)) + 48, g + 54)
                }
                this.resizeMove(o, 0, 0, q + 7, this.canvas.height);
                this.resizeMove(k, 0, 0, 7, this.canvas.height);
                this.resizeMove(m, 0, 0, 0, this.canvas.height);
                if (!i) {
                    this.resizeMove(p, 0, 0, 0, this.canvas.height)
                }
            } if (a) {
                setTimeout(function() {
                    j.resizeExtContainer(Math.max(q + 7, parseInt(n.clientWidth)) + 48, g + 54)
                }, 500)
            }
        }
    };
    this.updateDataFilter = function() {
        var h = this;
        var a = function(n, k, p, i, m) {
            var l = {
                min: ">=",
                max: "<=",
                like: "like"
            };
            h[n].push(m != null ? i + ":::" + m : i);
            h[n + "Op"].push(l[p]);
            h[n + "Case"].push(false);
            if (p == "like") {
                h[n + "Value"].push("^" + h.toDoFilter[k][i][p].join("$|^") + "$")
            } else {
                h[n + "Value"].push(h.toDoFilter[k][i][p])
            }
        };
        if (this.filteringStringOn || this.filteringNumericOn) {
            this.resetFilters();
            var j = false;
            for (var f in this.toDoFilter) {
                for (var b in this.toDoFilter[f]) {
                    for (var g in this.toDoFilter[f][b]) {
                        var c = this.toDoFilter[f][b]["ref"];
                        if (g != "ref") {
                            if (f == "sample") {
                                a("filterSmpBy", f, g, b, c)
                            } else {
                                if (f == "variable") {
                                    a("filterVarBy", f, g, b, c)
                                } else {
                                    if (f == "node") {
                                        a("filterNodeBy", f, g, b, c)
                                    } else {
                                        if (f == "edge") {
                                            a("filterEdgeBy", f, g, b, c)
                                        } else {
                                            if (f == "feature") {
                                                a("filterFeatureBy", f, g, b, c)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.reset();
            this.filterData();
            if (this.graphType == "Network" && this.filterFlashingOn) {
                var d = [];
                for (var e = 0; e < this.data.nodes.length; e++) {
                    if (!this.data.nodes[e].hide) {
                        d.push(this.data.nodes[e].id)
                    }
                }
                this.flashNode(d, false, 5)
            } else {
                this.draw()
            }
        }
    };
    this.showDataFilter = function(a) {
        return function(d) {
            if (!d) {
                d = window.event
            }
            var g = a.$(a.target + "-cX-DataFilter");
            if (g) {
                if (a.dataFilterLastState && a.dataFilterLastState == "docked") {
                    var f = a.$("east-handler-" + a.target);
                    a.clickViewport(d, f)
                }
                if (g.style.left == "0px" && g.style.top == "0px") {
                    var b = a.$("west-container-" + a.target);
                    var c = a.$("middle-container-" + a.target);
                    if (b && c) {
                        c.style.width = (parseInt(b.clientWidth) + a.canvas.width + a.dataFilterWidth + 7) + "px"
                    }
                }
                if (a.activeTarget) {
                    a.activeTarget.style.zIndex = 10000
                }
                a.activeTarget = g;
                g.style.display = "block";
                a.loadDataFilter();
                g.style.zIndex = 10001
            }
            return false
        }
    }(this);
    this.removeGenericDataFilterListenersOrReset = function(x) {
        var w = [];
        var u = [];
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Area":
            case "AreaLine":
            case "Dotplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Boxplot":
            case "Correlation":
            case "Pie":
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Scatter3D":
            case "Candlestick":
            case "Circular":
                var h = this.$(this.target + "-cX-DataFilterSampleContent");
                var k = this.$(this.target + "-cX-DataFilterVariableContent");
                if (h && k) {
                    w.push(h, k);
                    u.push(this.getSampleData(true));
                    u.push(this.getVariableData(true))
                }
                break;
            case "Venn":
                return;
            case "Network":
                var r = this.$(this.target + "-cX-DataFilterNodeContent");
                var n = this.$(this.target + "-cX-DataFilterEdgeContent");
                if (r && n) {
                    w.push(r, n);
                    u.push(this.getNodeData(true));
                    u.push(this.getEdgeData(true))
                }
                break;
            case "Genome":
                var f = this.$(this.target + "-cX-DataFilterGenomeContent");
                if (f) {
                    w.push(f);
                    u.push(this.getFeatureData(true))
                }
                break
        }
        for (var s = 0; s < u.length; s++) {
            var e = w[s];
            var l = u[s];
            var z = this.getKeys(l);
            z.sort();
            for (var p = 0; p < z.length; p++) {
                var y = l[z[p]]["t"];
                var v = z[p].replace(/\W/g, "_");
                if (y == "string") {
                    var a = this.$(this.target + ":" + v + ":cX-DataFilterInput");
                    var o = this.$(this.target + ":" + v + ":cX-DataFilterScroll");
                    if (o && a) {
                        if (x) {
                            a.value = "";
                            this.resetSelectStringFilter(o)
                        } else {
                            this.addRemoveNumericDataFilterListeners("removeEvtListener", o)
                        }
                    }
                } else {
                    var m = this.$(this.target + ":" + v + ":cX-DataFilterMin");
                    var g = this.$(this.target + ":" + v + ":cX-DataFilterMinLabel");
                    var b = this.$(this.target + ":" + v + ":cX-DataFilterRange");
                    var q = this.$(this.target + ":" + v + ":cX-DataFilterMax");
                    var t = this.$(this.target + ":" + v + ":cX-DataFilterMaxLabel");
                    if (m && g && b && q && t) {
                        if (x) {
                            m.style.left = "0px";
                            g.innerHTML = this.bestFormatNumber(b.min, b.decis);
                            b.style.left = "0px";
                            b.style.width = (this.dataFilterWidth - 42) + "px";
                            q.style.left = "0px";
                            t.innerHTML = this.bestFormatNumber(b.max, b.decis)
                        } else {
                            this.addRemoveNumericDataFilterListeners("removeEvtListener", m, q)
                        }
                    }
                }
            }
        }
    };
    this.loadDataFilter = function() {
        if (!this.toDoFilter) {
            this.toDoFilter = {}
        }
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Area":
            case "AreaLine":
            case "Dotplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Boxplot":
            case "Correlation":
            case "Pie":
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Scatter3D":
            case "Candlestick":
            case "Circular":
                return this.loadDataFilterSmpVar();
            case "Venn":
                return;
            case "Network":
                return this.loadDataFilterNetwork();
            case "Genome":
                return this.loadDataFilterGenome()
        }
    };
    this.loadDataFilterGeneric = function(d, a, h) {
        var f = this.getKeys(h);
        f.sort();
        if (!a.loaded) {
            a.loaded = {}
        }
        for (var b = 0; b < f.length; b++) {
            var g = this.getKeys(h[f[b]]["o"]);
            var c = h[f[b]]["t"];
            var e = h[f[b]]["r"];
            if (c == "string") {
                if (!a.loaded[f[b]]) {
                    a.appendChild(this.createStringFilter(d, f[b], g, e));
                    a.loaded[f[b]] = true
                }
            } else {
                if (!a.loaded[f[b]]) {
                    a.appendChild(this.createNumericFilter(d, f[b], g, e));
                    a.loaded[f[b]] = true
                }
            }
        }
    };
    this.loadDataFilterSmpVar = function() {
        var b = this.$(this.target + "-cX-DataFilterSampleContent");
        var a = this.$(this.target + "-cX-DataFilterVariableContent");
        if (b && a) {
            this.loadDataFilterGeneric("sample", b, this.getSampleData(true));
            this.loadDataFilterGeneric("variable", a, this.getVariableData(true))
        }
    };
    this.loadDataFilterNetwork = function() {
        var b = this.$(this.target + "-cX-DataFilterNodeContent");
        var a = this.$(this.target + "-cX-DataFilterEdgeContent");
        if (b && a) {
            this.loadDataFilterGeneric("node", b, this.getNodeData(true));
            this.loadDataFilterGeneric("edge", a, this.getEdgeData(true))
        }
    };
    this.loadDataFilterGenome = function() {
        var a = this.$(this.target + "-cX-DataFilterGenomeContent");
        if (a) {
            this.loadDataFilterGeneric("feature", a, this.getFeatureData(true))
        }
    };
    this.createNumericFilter = function(x, i, w, c) {
        var j = function(d) {
            var b = 1000000;
            return (((d * b) - (parseInt(d) * b)) / b).toString().replace(/\./, "").length - 1
        };
        w.sort(function(e, d) {
            return e - d
        });
        var m = i.replace(/\W/g, "_");
        var n = this.$cX("div", {
            id: this.target + ":" + m + ":cX-DataFilterContainer",
            className: "CanvasXpressDataFilterContainerHoverable"
        });
        var h = this.$cX("div", {
            innerHTML: i
        }, {
            width: (this.dataFilterWidth - 12) + "px",
            margin: "5px"
        });
        var a = this.$cX("div", false, {
            width: (this.dataFilterWidth - 12) + "px",
            height: "14px",
            margin: "2px"
        });
        var y = this.$cX("div", {
            id: this.target + ":" + m + ":cX-DataFilterRange",
            className: "CanvasXpressDataFilterContainerRange",
            min: parseFloat(w[0]),
            max: parseFloat(w[w.length - 1]),
            range: w[w.length - 1] - w[0],
            units: (w[w.length - 1] - w[0]) / (this.dataFilterWidth - 42),
            decis: j(w[w.length - 1] - w[0]),
            filter: x,
            ref: c,
            uvalue: i
        }, {
            width: (this.dataFilterWidth - 42) + "px"
        });
        var g = this.$cX("div", {
            id: this.target + ":" + m + ":cX-DataFilterMinLabel",
            innerHTML: this.bestFormatNumber(w[0], y.decis)
        }, {
            marginLeft: "2px",
            cssFloat: "left"
        });
        var u = this.$cX("div", {
            id: this.target + ":" + m + ":cX-DataFilterMaxLabel",
            innerHTML: this.bestFormatNumber(w[w.length - 1], y.decis)
        }, {
            marginRight: "2px",
            cssFloat: "right"
        });
        var p = this.$cX("div", {
            className: "CanvasXpressDataFilterContainerNumeric"
        }, {
            width: (this.dataFilterWidth - 14) + "px"
        });
        var f = this.$cX("div", {
            id: this.target + ":" + m + ":cX-DataFilterMin",
            className: "CanvasXpressDataFilterContainerMin"
        }, {
            left: "0px"
        });
        var o = this.$cX("div", {
            id: this.target + ":" + m + ":cX-DataFilterMax",
            className: "CanvasXpressDataFilterContainerMax"
        }, {
            left: "0px"
        });
        a.appendChild(g);
        a.appendChild(u);
        p.appendChild(f);
        p.appendChild(y);
        p.appendChild(o);
        n.appendChild(h);
        n.appendChild(a);
        n.appendChild(p);
        this.addRemoveNumericDataFilterListeners("addEvtListener", f, o);
        return n
    };
    this.addRemoveNumericDataFilterListeners = function(c, b, a) {
        if (c && b && a) {
            this[c](b, "mousedown", this.mousedownNumericFilter, false);
            this[c](a, "mousedown", this.mousedownNumericFilter, false)
        }
    };
    this.mousedownNumericFilter = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            var b = a.getTargetEvent(c);
            if (b) {
                a.filteringNumericOn = b;
                a.xMouseDown = c.clientX;
                a.yMouseDown = c.clientY
            }
            return false
        }
    }(this);
    this.updateNumericFilter = function(m) {
        if (this.filteringNumericOn) {
            this.cancelEvent(m);
            var c = this.filteringNumericOn;
            var d, j, p, b, o, h;
            if (c.id.match(/cX-DataFilterMin/)) {
                d = true;
                j = c.id;
                p = c.id.replace("cX-DataFilterMin", "cX-DataFilterMax");
                b = c.id.replace("cX-DataFilterMin", "cX-DataFilterRange");
                o = c.id.replace("cX-DataFilterMin", "cX-DataFilterMinLabel");
                h = c.id.replace("cX-DataFilterMin", "cX-DataFilterMaxLabel")
            } else {
                d = false;
                p = c.id;
                j = c.id.replace("cX-DataFilterMax", "cX-DataFilterMin");
                b = c.id.replace("cX-DataFilterMax", "cX-DataFilterRange");
                o = c.id.replace("cX-DataFilterMax", "cX-DataFilterMinLabel");
                h = c.id.replace("cX-DataFilterMax", "cX-DataFilterMaxLabel")
            }
            j = this.$(j);
            p = this.$(p);
            b = this.$(b);
            o = this.$(o);
            h = this.$(h);
            if (j && p && b && o && h) {
                var r = m.clientX - this.xMouseDown;
                var q = this.dataFilterWidth - 42;
                var n = d ? parseInt(b.style.width) - r : parseInt(b.style.width) + r;
                var i = parseInt(j.style.left) + r;
                var l = this.absoluteCoordinates(j);
                var a = this.absoluteCoordinates(p);
                if (d) {
                    if (i > 0 && n > 0) {
                        this.xMouseDown = m.clientX;
                        i = Math.max(0, Math.min(q, i));
                        n = Math.max(0, Math.min(q, n))
                    } else {
                        if (i > 0) {
                            i -= r;
                            n = (a.x - l.x) - 14
                        } else {
                            n += i;
                            i = 0
                        }
                    }
                    var f = Math.min((b.units * i) + b.min, parseFloat(h.innerHTML));
                    j.style.left = i + "px";
                    b.style.left = i + "px";
                    b.style.width = n + "px";
                    p.style.left = i + "px";
                    o.innerHTML = this.bestFormatNumber(f, b.decis)
                } else {
                    var f = Math.max(Math.min((b.units * (i + n)) + b.min, b.max), parseFloat(o.innerHTML));
                    if (i + n <= q && n >= 0) {
                        this.xMouseDown = m.clientX;
                        i = Math.max(0, Math.min(q, i));
                        n = Math.max(0, Math.min(q - i, n))
                    } else {
                        if (i + n > q) {
                            i -= r;
                            n = q - i
                        }
                    }
                    b.style.width = n + "px";
                    h.innerHTML = this.bestFormatNumber(f, b.decis)
                }
                var g = b.uvalue;
                var k = b.filter;
                if (o.innerHTML != b.min.toString() || h.innerHTML != b.max.toString()) {
                    if (!this.toDoFilter[k]) {
                        this.toDoFilter[k] = {}
                    }
                    if (!this.toDoFilter[k][g]) {
                        this.toDoFilter[k][g] = {}
                    }
                    if (o.innerHTML != b.min.toString()) {
                        this.toDoFilter[k][g]["min"] = parseFloat(o.innerHTML)
                    }
                    if (h.innerHTML != b.max.toString()) {
                        this.toDoFilter[k][g]["max"] = parseFloat(h.innerHTML)
                    }
                    if (b.ref != null) {
                        this.toDoFilter[k][g]["ref"] = b.ref
                    }
                } else {
                    if (this.toDoFilter[k] && this.toDoFilter[k][g]) {
                        delete(this.toDoFilter[k][g])
                    }
                }
                this.updateDataFilter()
            }
        }
        return false
    };
    this.endNumericFilter = function(a) {
        if (this.filteringNumericOn) {
            this.filteringNumericOn = false
        }
    };
    this.createStringFilter = function(A, n, z, c) {
        z.sort();
        z.unshift("(All) " + z.length + " values");
        z.push("");
        var w = n.replace(/\W/g, "_");
        var x = this.$cX("div", {
            id: this.target + ":" + w + ":cX-DataFilterContainer",
            className: "CanvasXpressDataFilterContainerHoverable"
        });
        var h = this.$cX("div", {
            innerHTML: n
        }, {
            width: "98%",
            margin: "5px"
        });
        var u = this.$cX("input", {
            id: this.target + ":" + w + ":cX-DataFilterInput",
            type: "text"
        }, {
            cursor: "default",
            width: "98%",
            marginLeft: "3px"
        });
        var g = this.$cX("div", {
            id: this.target + ":" + w + ":cX-DataFilterMask",
            className: "CanvasXpressDataFilterContainerMask"
        }, {
            width: "96%",
            height: "80px"
        });
        var B = this.$cX("div", {
            id: this.target + ":" + w + ":cX-DataFilterScroll",
            filter: A,
            uvalue: n,
            values: z,
            selected: {
                0: true
            },
            ref: c,
            skey: w,
            last: 0
        }, {
            width: "96%",
            height: ((z.length + 1) * 16) + "px"
        });
        var f = this.$cX("div", {
            id: this.target + ":" + w + ":cX-DataFilterOptions"
        }, {
            width: "110%",
            margin: "2px",
            position: "relative"
        });
        for (var p = 0; p < Math.min(5, z.length); p++) {
            var b = z[p].length > 30 ? z[p].substr(0, 30) + " ..." : z[p];
            var y = this.$cX("div", {
                id: this.target + ":" + w + ":cX-DataFilterItem-" + p,
                className: p == 0 ? "CanvasXpressDataFilterContainerItemSelected" : "CanvasXpressDataFilterContainerItem",
                innerHTML: b,
                alt: z[p],
                title: z[p],
                index: p
            });
            f.appendChild(y)
        }
        B.appendChild(f);
        g.appendChild(B);
        x.appendChild(h);
        x.appendChild(u);
        x.appendChild(g);
        this.addRemoveStringDataFilterListeners("addEvtListener", g);
        return x
    };
    this.addRemoveStringDataFilterListeners = function(b, a) {
        if (b && a) {
            this[b](a, "scroll", this.scrollStringFilter, false);
            this[b](a, "mousedown", this.registerStringFilter, false);
            this[b](a, "mouseup", this.endStringFilter, false)
        }
    };
    this.scrollStringFilter = function(a) {
        return function(l, j) {
            if (!l) {
                l = window.event
            }
            if (!j) {
                j = this
            }
            var h = j.firstChild;
            var n = h.firstChild;
            var f = h.skey;
            var c = Math.max(0, Math.min(Math.floor(j.scrollTop / 16), h.values.length - 5));
            n.style.top = j.scrollTop + "px";
            for (var g = 0; g < Math.min(5, h.values.length); g++) {
                var m = a.$(a.target + ":" + f + ":cX-DataFilterItem-" + g);
                if (m) {
                    var j = h.values[c + g].length > 30 ? h.values[c + g].substr(0, 30) + " ..." : h.values[c + g];
                    m.className = h.selected[c + g] ? "CanvasXpressDataFilterContainerItemSelected" : "CanvasXpressDataFilterContainerItem";
                    m.innerHTML = j;
                    m.alt = h.values[c + g];
                    m.title = h.values[c + g];
                    m.index = c + g
                }
            }
            if (a.filteringStringOn) {
                a.updateSelectStringFilter(false, a.$(a.target + ":" + f + ":cX-DataFilterItem-4"), true)
            }
            return false
        }
    }(this);
    this.registerStringFilter = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            var b = a.getTargetEvent(c);
            if (!b.id.match(/cX-DataFilterMask/)) {
                a.$(b.parentNode.id.replace("cX-DataFilterOptions", "cX-DataFilterInput")).value = "";
                a.updateSelectStringFilter(false, b, c.shiftKey, c.ctrlKey);
                a.filteringStringOn = b
            }
            return false
        }
    }(this);
    this.endStringFilter = function(a) {
        return function(k, l) {
            if (!k) {
                k = window.event
            }
            if (!l && a.filteringStringOn) {
                l = a.filteringStringOn.parentNode.parentNode
            }
            if (!l) {
                return
            }
            var g = l.selected;
            var j = l.filter;
            var c = l.uvalue;
            var h = l.ref;
            var b = l.values;
            if (!g[0]) {
                if (!a.toDoFilter[j]) {
                    a.toDoFilter[j] = {}
                }
                if (!a.toDoFilter[j][c]) {
                    a.toDoFilter[j][c] = {
                        like: []
                    }
                }
                a.toDoFilter[j][c]["like"] = [];
                for (var d in g) {
                    a.toDoFilter[j][c]["like"].push(b[d])
                }
                if (h != null) {
                    a.toDoFilter[j][c]["ref"] = h
                }
            } else {
                if (a.toDoFilter[j] && a.toDoFilter[j][c]) {
                    delete(a.toDoFilter[j][c])
                }
            }
            a.filteringStringOn = true;
            a.updateDataFilter();
            a.filteringStringOn = false;
            return false
        }
    }(this);
    this.updateStringFilter = function(b) {
        var a = this.getTargetEvent(b);
        var c = this.filteringStringOn ? this.filteringStringOn.id.replace(/-\d$/, "") : "";
        if (a.id.match(c) && !b.ctrlKey) {
            this.updateSelectStringFilter(false, a, true)
        }
    };
    this.updateSelectStringFilter = function(A, C, g, a) {
        if (A) {
            var t = this.$(A);
            var d = this.$(A.replace("cX-DataFilterInput", "cX-DataFilterScroll"));
            if (t.value) {
                var j = 0;
                var c = d.firstChild;
                var w = c.childNodes[0].index;
                var r = null;
                var D = 0;
                d.selected = {};
                for (var m = 1; m < d.values.length - 1; m++) {
                    if (d.values[m].toLowerCase().match(t.value.toLowerCase())) {
                        if (!r) {
                            r = m;
                            D = m * 16
                        }
                        d.selected[m] = true;
                        j++
                    }
                }
                if (j + 2 == d.values.length) {
                    d.selected = {
                        0: true
                    };
                    r = 0
                }
                if (r != null) {
                    d.parentNode.scrollTop = D;
                    this.scrollStringFilter(false, d.parentNode)
                }
                this.endStringFilter(false, d)
            } else {
                this.resetSelectStringFilter(d);
                this.endStringFilter(false, d)
            }
        } else {
            if (C) {
                var y = C.index;
                var c = C.parentNode;
                var D = C.parentNode.parentNode;
                var k = D.last;
                var q = D.selected;
                var B = D.values;
                var w = c.childNodes[0].index;
                var j = 0;
                var u = a && D.selected[y];
                D.selected = {};
                if (!u) {
                    D.selected[y] = true
                }
                if (g) {
                    if (y > k) {
                        for (var m = k; m <= y; m++) {
                            D.selected[m] = true;
                            j++
                        }
                    } else {
                        for (var m = y; m <= k; m++) {
                            D.selected[m] = true;
                            j++
                        }
                    }
                } else {
                    if (a) {
                        if (!u) {
                            D.last = y
                        }
                        for (var m in q) {
                            if (m == y && u) {
                                continue
                            }
                            D.selected[m] = true;
                            j++
                        }
                    } else {
                        D.last = y
                    }
                } if (j > 0) {
                    delete(D.selected[0])
                }
                delete(D.selected[B.length - 1]);
                for (var m = 0; m < c.childNodes.length; m++) {
                    c.childNodes[m].className = D.selected[m + w] ? "CanvasXpressDataFilterContainerItemSelected" : "CanvasXpressDataFilterContainerItem"
                }
            }
        }
    };
    this.resetSelectStringFilter = function(a) {
        if (a) {
            a.selected = {
                0: true
            };
            var b = a.parentNode;
            b.scrollTop = 0;
            this.scrollStringFilter(false, b)
        }
    };
    this.hideDataFilter = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.moveDataFilter(true);
            return false
        }
    }(this);
    this.dockUndockDataFilter = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            var b = a.$(a.target + "-cX-DataFilter");
            if (b) {
                a.moveDataFilter()
            }
            return false
        }
    }(this);
    this.resizeDataFilter = function() {
        var a = this.graphType == "Genome" ? 60 : 81;
        this.dataFilterHeight = this.canvas.height - a;
        if (this.activeAccordion) {
            this.activeAccordion.style.height = this.dataFilterHeight + "px"
        }
    };
    this.resetDataFilter = function(a) {
        return function(d, g, b) {
            a.resetFilters();
            a.toDoFilter = {};
            a.reset();
            if (b) {
                var c = a.$(a.target + "-cX-DataFilter");
                if (c) {
                    a.removeGenericDataFilterListenersOrReset();
                    c.parentNode.removeChild(c);
                    a.addDataFilterDiv()
                }
            } else {
                a.removeGenericDataFilterListenersOrReset(true)
            } if (!g) {
                a.draw()
            }
            return false
        }
    }(this);
    this.initializeDataFilterEvents = function() {
        this.addDataFilterDiv()
    };
    this.initializeDataFilterEvents()
};
CanvasXpress.prototype.initDataTable = function() {
    this.addDataTableDiv = function(E, F) {
        if (this.$(this.target + "-cX-DataTable")) {
            return
        }
        var p = this;
        var O = function(n, d, b) {
            var o = p.$cX(d == 0 || b == 0 ? "th" : "td", {
                id: p.target + "-cX-DataTableCell." + d + "." + b,
                className: d == 0 || b == 0 ? "CanvasXpressTableCellHead" : "CanvasXpressTableCell"
            }, {
                width: p.colWidth + "px",
                height: p.rowHeight + "px"
            });
            n.appendChild(o)
        };
        if (!F) {
            this.setDataTableDimensions(E)
        }
        var C = 20;
        var f = 44;
        var m = this.dataTableLastX != null ? parseInt(this.dataTableLastX) : this.canvas.width * 0.1;
        var k = this.dataTableLastY != null ? parseInt(this.dataTableLastY) : -this.canvas.height * 0.9;
        var q = this.dataTableLastWidth || this.dataTableColsWidth + C;
        var G = this.dataTableLastHeight || this.dataTableRowsHeight + f;
        var v = ((this.colWidth + 8) * 3) + 6;
        var M = ((this.rowHeight + 4) * 3) + 8;
        var L = this.$cX("div", {
            id: this.target + "-cX-DataTable",
            className: "CanvasXpressDataTable draggable-container"
        }, {
            top: k + "px",
            left: m + "px",
            width: q + "px",
            height: G + "px",
            minWidth: (v + C) + "px",
            minHeight: (M + f + 20) + "px",
            zIndex: 10000,
            display: "none"
        });
        var l = this.$cX("div", {
            id: this.target + "-cX-DataTableToolbar",
            className: "CanvasXpressDataTableToolbar draggable"
        }, {
            width: q + "px",
            minWidth: (v + C) + "px"
        });
        var h = this.$cX("img", {
            id: this.target + "-cX-DataTableSaveImage",
            className: "CanvasXpressDataTableToolbarImage",
            src: this.imageDir + "disk.png",
            alt: "Save data",
            title: "Save data"
        });
        var c = this.$cX("img", {
            id: this.target + "-cX-DataTableTransposeImage",
            className: "CanvasXpressDataTableToolbarImage",
            src: this.imageDir + "transpose.png",
            alt: "Transpose data",
            title: "Transpose data"
        });
        var g = this.$cX("img", {
            id: this.target + "-cX-DataTableNetworkImage",
            className: "CanvasXpressDataTableToolbarImage",
            src: this.networkShowDataTable == "nodes" ? this.imageDir + "edges.png" : this.imageDir + "nodes.png",
            alt: this.networkShowDataTable == "nodes" ? "Show edge data" : "Show node data",
            title: this.networkShowDataTable == "nodes" ? "Show edge data" : "Show node data"
        }, {
            display: this.graphType == "Network" ? "block" : "none"
        });
        var x = this.$cX("img", {
            id: this.target + "-cX-DataTableDockImage",
            className: "CanvasXpressDataTableToolbarImage",
            src: this.dataTableLastState && this.dataTableLastState == "docked" ? this.imageDir + "unpin.png" : this.imageDir + "pin.png",
            alt: this.dataTableLastState && this.dataTableLastState == "docked" ? "Undock" : "Dock",
            title: this.dataTableLastState && this.dataTableLastState == "docked" ? "Undock" : "Dock"
        });
        var D = this.$cX("img", {
            id: this.target + "-cX-DataTableCloseImage",
            className: "CanvasXpressDataTableToolbarImage",
            src: this.imageDir + "cancel1.png",
            alt: "Close table",
            title: "Close table"
        });
        var H = this.$cX("div", {
            id: this.target + "-cX-DataTableContainer",
            className: "CanvasXpressDataTableContainer"
        }, {
            width: q + "px",
            height: (G - 20) + "px",
            minWidth: (v + C) + "px",
            minHeight: (M + f) + "px"
        });
        var a = this.$cX("div", {
            id: this.target + "-cX-DataTableTableMask",
            className: "CanvasXpressDataTableMask"
        }, {
            width: (q - C) + "px",
            height: (G - f) + "px",
            minWidth: v + "px",
            minHeight: (M + 20) + "px"
        });
        var A = this.$cX("table", {
            id: this.target + "-cX-DataTableTable",
            className: "CanvasXpressDataTable"
        });
        var N = this.$cX("tbody");
        for (var J = 0; J < this.maxRows; J++) {
            var B = this.$cX("tr");
            for (var I = 0; I < this.maxCols; I++) {
                O(B, J, I)
            }
            N.appendChild(B)
        }
        var z = this.$cX("div", {
            id: this.target + "-cX-DataTableVer",
            className: "CanvasXpressDataTableVertical"
        }, {
            height: (G - f) + "px",
            minHeight: (M + 20) + "px"
        });
        var e = this.$cX("img", {
            id: this.target + "-cX-DataTableVerImage",
            src: this.getPixelImage(),
            width: 1,
            height: this.dataTableTotalHeight
        });
        z.appendChild(e);
        var K = this.$cX("div", {
            id: this.target + "-cX-DataTableHor",
            className: "CanvasXpressDataTableHorizontal"
        }, {
            width: (q - C) + "px",
            minWidth: v + "px"
        });
        var y = this.$cX("img", {
            id: this.target + "-cX-DataTableHorImage",
            src: this.getPixelImage(),
            width: this.dataTableTotalWidth,
            height: 1
        });
        K.appendChild(y);
        var s = this.$cX("div", {
            id: this.target + "-cX-DataTableResizer",
            className: "CanvasXpressDataTableResizer resizable"
        });
        l.appendChild(D);
        l.appendChild(x);
        l.appendChild(c);
        l.appendChild(h);
        l.appendChild(g);
        A.appendChild(N);
        a.appendChild(A);
        H.appendChild(a);
        H.appendChild(z);
        H.appendChild(K);
        H.appendChild(s);
        L.appendChild(l);
        L.appendChild(H);
        var u = this.$("south-wrapper-" + this.target);
        if (u) {
            u.appendChild(L);
            this.addRemoveDataTableListeners("addEvtListener")
        }
    };
    this.addRemoveDataTableListeners = function(a, f) {
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableHor"), "scroll", this.scrollTable, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableVer"), "scroll", this.scrollTable, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableToolbar"), "mousedown", this.registerMousemove, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableSaveImage"), "click", this.saveTable, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableNetworkImage"), "click", this.networkUpdateTable, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableTransposeImage"), "click", this.transposeDataTable, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableDockImage"), "click", this.dockUndockTable, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCloseImage"), "click", this.hideTable, false);
        this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableResizer"), "mousedown", this.mousedownDataTableResizer, false);
        var e = f ? f[0] : this.maxRows;
        var g = f ? f[1] : this.maxCols;
        for (var d = 0; d < g; d++) {
            this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "click", this.clickDataTableHeader, false);
            this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mousemove", this.mousemoveDataTableHeader, false);
            this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mousedown", this.mousedownDataTableHeader, false);
            this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mouseover", this.mouseoverDataTableHeader, false);
            this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mouseout", this.mouseoutDataTableHeader, false)
        }
        for (var d = 0; d < e; d++) {
            this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + ".0"), "mouseover", this.mouseoverDataTableHeader, false);
            this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + ".0"), "mouseout", this.mouseoutDataTableHeader, false)
        }
        for (var d = 1; d < e; d++) {
            for (var b = 1; b < g; b++) {
                this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + "." + b), "mouseover", this.mouseoverDataTableCell, false);
                this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + "." + b), "mouseout", this.mouseoutDataTableCell, false);
                this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + "." + b), "click", this.clickDataTableCell, false)
            }
        }
    };
    this.scrollTable = function(a) {
        return function(g) {
            if (!g) {
                g = window.event
            }
            a.removeMenus();
            var j = a.$(a.target + "-cX-DataTable");
            var b = a.$(a.target + "-cX-DataTableVer");
            var f = a.$(a.target + "-cX-DataTableHor");
            if (j && b && f && !a.resizingDataTableOn) {
                var i = Math.ceil(f.scrollLeft / (f.scrollWidth / a.totalCols));
                var c = Math.ceil(b.scrollTop / (b.scrollHeight / a.totalRows));
                a.dataTableLastScrollLeft = f.scrollLeft;
                a.dataTableLastScrollTop = b.scrollTop;
                a.dataTableLastScrollWidth = f.scrollWidth;
                a.dataTableLastScrollHeight = b.scrollHeight;
                if (i != a.startCol || c != a.startRow) {
                    a.startCol = i;
                    a.startRow = c;
                    a.updateDataTable(false, false, false, true)
                }
            }
            return false
        }
    }(this);
    this.saveTable = function(a) {
        return function(g) {
            if (!g) {
                g = window.event
            }
            a.removeMenus();
            var b = a.maxCols;
            var f = a.maxRows;
            var c = a.startCol;
            var i = a.startRow;
            a.maxCols = a.totalCols;
            a.maxRows = a.totalRows;
            a.startCol = 0;
            a.startRow = 0;
            var h = a.updateDataTable(false, false, true);
            a.exportToExcel(h);
            a.maxCols = b;
            a.maxRows = f;
            a.startCol = c;
            a.startRow = i;
            return false
        }
    }(this);
    this.dockUndockTable = function(a) {
        return function(d) {
            if (!d) {
                d = window.event
            }
            a.removeMenus();
            var c = a.dataTableLastState && a.dataTableLastState == "docked" ? "undock" : "dock";
            var b = a.getTargetEvent(d);
            if (c == "dock") {
                b.src = a.imageDir + "unpin.png";
                b.alt = "Undock";
                b.title = "Undock"
            } else {
                b.src = a.imageDir + "pin.png";
                b.alt = "Dock";
                b.title = "Dock"
            }
            a.moveDataTableDiv(c);
            return false
        }
    }(this);
    this.transposeDataTable = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.removeMenus();
            a.startRow = 0;
            a.startCol = 0;
            a.dataTableTransposed = a.dataTableTransposed ? false : true;
            a.sortDataTableHead = false;
            a.updateDataTable(false, true, false, false, true);
            a.resizeDataTable();
            return false
        }
    }(this);
    this.minimizeTable = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.moveDataTableDiv("min");
            return false
        }
    }(this);
    this.maximizeTable = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.moveDataTableDiv("max");
            return false
        }
    }(this);
    this.hideTable = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.removeMenus();
            var c = a.$(a.target + "-cX-DataTable");
            if (c) {
                a.showDataTable = false;
                a.moveDataTableDiv("hide");
                setTimeout(function() {
                    a.hideUnhideDataTable(true);
                    a.resetFade(c);
                    a.resetDataTable(true)
                }, 500)
            }
            return false
        }
    }(this);
    this.networkUpdateTable = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            a.removeMenus();
            var b = a.getTargetEvent(c);
            a.networkShowDataTable = a.networkShowDataTable == "nodes" ? "edges" : "nodes";
            a.updateDataTable(false, true, false, true);
            return false
        }
    }(this);
    this.mousedownDataTableResizer = function(a) {
        return function(d) {
            if (!d) {
                d = window.event
            }
            a.removeMenus();
            var b = d.target || d.srcElement;
            if (a.hasClass(b, "resizable")) {
                var f = a.$(a.target + "-cX-DataTable");
                if (f) {
                    a.dataTableTarget = f;
                    a.xMouseDown = d.clientX;
                    a.yMouseDown = d.clientY;
                    a.dataTableWidth = parseInt(a.dataTableTarget.style.width);
                    a.dataTableHeight = parseInt(a.dataTableTarget.style.height);
                    a.resizingDataTableOn = true
                }
            }
            return false
        }
    }(this);
    this.mousemoveDataTableHeader = function(a) {
        return function(j) {
            if (!j) {
                j = window.event
            }
            var c = a.resizingDataTableColumnOn ? a.dataTableColumnTarget : a.getTargetEvent(j);
            var n = a.adjustedCoordinates(j, c);
            var l = a.$(a.target + "-cX-DataTableHorImage");
            if (n && l) {
                if (a.resizingDataTableColumnOn) {
                    var b = a.dataTableColumnTarget.id.split(".");
                    var g = parseInt(b[2]);
                    var k = n.x - a.xMouseDown;
                    var m = Math.max(a.colWidth, (a.dataTableColumnWidth[a.startCol + g] || a.colWidth) + k);
                    a.dataTableColumnTarget.firstChild.style.width = m + "px";
                    l.width += k;
                    for (var h = a.startRow; h < a.startRow + a.totalRows; h++) {
                        var d = a.$(a.target + "-cX-DataTableCell." + h + "." + g);
                        if (d) {
                            d.style.width = m + "px";
                            d.firstChild.style.width = m + "px"
                        }
                    }
                    a.dataTableColumnWidth[a.startCol + g] = m;
                    a.xMouseDown = n.x;
                    a.yMouseDown = n.y;
                    document.body.style.cursor = "ew-resize"
                } else {
                    var f = (c.offsetLeft + c.clientWidth) - n.x;
                    if (f < 5 && c.nodeName.toLowerCase() == "th") {
                        c.style.cursor = "ew-resize"
                    } else {
                        c.style.cursor = "default"
                    }
                }
            }
            return false
        }
    }(this);
    this.mousedownDataTableHeader = function(a) {
        return function(d) {
            if (!d) {
                d = window.event
            }
            var b = d.target || d.srcElement;
            var c = a.adjustedCoordinates(d, b);
            if (c) {
                var f = (b.offsetLeft + b.clientWidth) - c.x;
                if (f < 5 && b.nodeName.toLowerCase() == "th") {
                    a.dataTableColumnTarget = b;
                    a.xMouseDown = c.x;
                    a.yMouseDown = c.y;
                    a.resizingDataTableColumnOn = true;
                    document.body.style.cursor = "ew-resize"
                }
            }
            return false
        }
    }(this);
    this.clickDataTableHeader = function(a) {
        return function(l, f) {
            if (!l) {
                l = window.event
            }
            if (!f) {
                a.cancelEvent(l);
                f = a.getTargetEvent(l)
            }
            var b = a.target + "-cX-DataTableCell.0.0";
            if (f.tagName.match(/th/i)) {
                f = f.firstChild
            }
            if (f.tagName.match(/^a$/i)) {
                if (a.skipHeaderMouseout && a.skipHeaderMouseout.id == this.id) {
                    a.removeMenus();
                    return false
                }
                var o = a.maxCols;
                var w = a.maxRows;
                var j = a.startCol;
                var q = a.startRow;
                var u = a.dataTableColumnHide;
                a.maxCols = a.totalCols;
                a.maxRows = 0;
                a.startCol = 0;
                a.startRow = 0;
                a.dataTableColumnHide = {};
                var n = a.updateDataTable(false, false, true);
                a.maxCols = o;
                a.maxRows = w;
                a.startCol = j;
                a.startRow = q;
                a.dataTableColumnHide = u;
                var p = [];
                for (var k = 1; k < n[0].length; k++) {
                    p.push([n[0][k], a.dataTableColumnHide[n[0][k]] ? "unchecked.png" : "checked.png", "hideUnhideDataTableColumn", [n[0][k]]])
                }
                var h = [];
                h.push(["Sort Ascending", "sort_ascii_asc.png", "sortDataTableByColumn", ["asc", f.parentNode]]);
                h.push(["Sort Descending", "sort_ascii_desc.png", "sortDataTableByColumn", ["desc", f.parentNode]]);
                h.push(["-"]);
                h.push(["Columns", "table.png", false, false, false, p]);
                var g = a.absoluteCoordinates(f);
                var r = a.absoluteCoordinates(a.$(a.target + "-cX-DataTable"));
                var t = a.absoluteCoordinates(a.$(a.target));
                a.addMenu(l, false, false, h, (g.x - r.x) + (r.x - t.x), g.y - (t.y - 28), this);
                a.skipHeaderMouseout = this
            } else {
                if (f.className == "CanvasXpressTableCellSortDesc") {
                    f.className = "CanvasXpressTableCellSortAsc"
                } else {
                    f.className = "CanvasXpressTableCellSortDesc"
                } if (a.sortDataTableHead) {
                    if (a.sortDataTableHead.id != f.id) {
                        var v = a.$(a.sortDataTableHead.id);
                        if (v) {
                            if (f.parentNode.id == b) {
                                a.sortDataTableHead.id = a.target + "-cX-DataTableCellContent.0.0"
                            }
                            v.className = "CanvasXpressTableCell"
                        }
                    }
                }
                a.removeMenus();
                a.sortDataTableHead = f;
                a.sortDataTable()
            }
            return false
        }
    }(this);
    this.mouseoverDataTableHeader = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            this.className = "CanvasXpressTableCellHeadActive";
            this.firstChild.firstChild.className = "CanvasXpressTableCellHeadActive";
            return false
        }
    }(this);
    this.mouseoutDataTableHeader = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            if (a.skipHeaderMouseout && a.skipHeaderMouseout.id == this.id) {
                return false
            } else {
                this.className = "CanvasXpressTableCellHead";
                this.firstChild.firstChild.className = "CanvasXpressTableCellHead"
            }
            return false
        }
    }(this);
    this.mouseoverDataTableCell = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            this.className = "CanvasXpressTableCellActive";
            return false
        }
    }(this);
    this.mouseoutDataTableCell = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            this.className = "CanvasXpressTableCell";
            return false
        }
    }(this);
    this.clickDataTableCell = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.removeMenus();
            return false
        }
    }(this);
    this.hideUnhideDataTableColumn = function(a) {
        if (this.dataTableColumnHide[a]) {
            delete(this.dataTableColumnHide[a])
        } else {
            this.dataTableColumnHide[a] = true
        }
        this.updateDataTable(false, false, false, true)
    };
    this.sortDataTableByColumn = function(b, a) {
        if (b == "asc") {
            a.className = "CanvasXpressTableCellSortDesc"
        } else {
            a.className = "CanvasXpressTableCellSortAsc"
        }
        this.sortDataTableHead = a;
        this.clickDataTableHeader(false, a)
    };
    this.setDataTableDimensions = function(d, k) {
        var b = 0;
        var p = 0;
        var e = 0;
        var l = false;
        var j = function() {
            for (var a = 0; a < d.w.grps.length; a++) {
                e += d.w.grps[a].length
            }
            return e
        };
        if (!d) {
            d = this.data
        }
        if (!this.dataTableColumnHide) {
            this.dataTableColumnHide = {}
        }
        var s = 0;
        if (d.x) {
            for (var h in d.x) {
                if (!this.dataTableColumnHide[h]) {
                    s++
                }
            }
        }
        var m = 0;
        if (d.z) {
            for (var h in d.z) {
                if (!this.dataTableColumnHide[h]) {
                    m++
                }
            }
        }
        var w = this.getDataTableDimensions();
        if (w[0] != this.maxRows || w[1] != this.maxCols) {
            this.initialMaxRows = this.maxRows;
            this.initialMaxCols = this.maxCols
        }
        if (this.graphType == "Network") {
            var q = this.getAllNetworkAttributes(d);
            b = this.dataTableTransposed ? 1 + d[this.networkShowDataTable].length : 1 + q[1];
            p = this.dataTableTransposed ? 1 + q[1] : 1 + d[this.networkShowDataTable].length
        } else {
            if (this.graphType == "Genome") {
                b = 1;
                p = 1
            } else {
                if (this.graphType == "Venn") {
                    var u = this.getVennCompartments(d);
                    b = this.dataTableTransposed ? 1 + u[1] : 2;
                    p = this.dataTableTransposed ? 2 : 1 + u[1]
                } else {
                    if (this.graphType == "Correlation") {
                        b = this.correlationAxis == "samples" ? 1 + d.y.smps.length : 1 + d.y.vars.length;
                        p = b
                    } else {
                        if (this.graphType == "Candlestick") {
                            if (d.y) {
                                b = this.dataTableTransposed ? 1 + (d.y.smps.length * d.y.vars.length) : 6;
                                p = this.dataTableTransposed ? 6 : 1 + (d.y.smps.length * d.y.vars.length)
                            } else {
                                if (d.market) {
                                    b = this.dataTableTransposed ? 1 + (d.market.smps.length * d.market.vars.length) : 6;
                                    p = this.dataTableTransposed ? 6 : 1 + (d.market.smps.length * d.market.vars.length)
                                }
                            }
                        } else {
                            if (d.y && d.y.vars && d.y.smps) {
                                b = this.dataTableTransposed ? 1 + m + d.y.smps.length : 1 + s + d.y.vars.length;
                                p = this.dataTableTransposed ? 1 + s + d.y.vars.length : 1 + m + d.y.smps.length
                            } else {
                                if (d.w && d.w.vars && d.w.grps) {
                                    e = j();
                                    b = this.dataTableTransposed ? 1 + m + e : 1 + s + d.w.vars.length;
                                    p = this.dataTableTransposed ? 1 + s + d.w.vars.length : 1 + m + e
                                }
                            }
                        }
                    }
                }
            }
        } if (this.maxRows > b) {
            this.initialMaxRows = this.maxRows;
            this.maxRows = b
        }
        if (this.maxCols > p) {
            this.initialMaxCols = this.maxCols;
            this.maxCols = p
        }
        if (this.totalRows == null || this.totalCols == null) {
            this.totalRows = b;
            this.totalCols = p
        } else {
            if (k || b != this.totalRows || p != this.totalCols || w[0] != this.maxRows || w[1] != this.maxCols || w[2] != this.rowHeight || w[3] != this.colWidth) {
                this.totalRows = b;
                this.totalCols = p;
                l = true
            } else {
                this.totalRows = b;
                this.totalCols = p;
                if (this.showDataTable) {
                    this.hideUnhideDataTable()
                }
            }
        }
        this.dataTableTotalHeight = 10;
        for (var h = 0; h < this.totalRows; h++) {
            this.dataTableTotalHeight += this.setDataTableRowHeight(h)
        }
        this.dataTableTotalHeight += this.totalRows * 4;
        this.dataTableTotalWidth = 10;
        for (var h = 0; h < this.totalCols; h++) {
            this.dataTableTotalWidth += this.setDataTableColumnWidth(h)
        }
        this.dataTableTotalWidth += this.totalCols * 8;
        this.dataTableRowsHeight = 10;
        for (var h = this.startRow; h < this.startRow + this.maxRows; h++) {
            this.dataTableRowsHeight += this.setDataTableRowHeight(h)
        }
        this.dataTableRowsHeight += this.maxRows * 4;
        this.dataTableColsWidth = 10;
        for (var h = this.startCol; h < this.startCol + this.maxCols; h++) {
            this.dataTableColsWidth += this.setDataTableColumnWidth(h)
        }
        this.dataTableColsWidth += this.maxCols * 8;
        if (l) {
            this.resetDataTable(true, w)
        }
    };
    this.setDataTableColumnWidth = function(b, a) {
        if (!this.dataTableColumnWidth[b]) {
            this.dataTableColumnWidth[b] = this.colWidth
        } else {
            if (a) {
                this.dataTableColumnWidth[b] = Math.max(a, this.colWidth)
            }
        }
        return this.dataTableColumnWidth[b]
    };
    this.setDataTableRowHeight = function(a, b) {
        if (!this.dataTableRowHeight[a]) {
            this.dataTableRowHeight[a] = this.rowHeight
        } else {
            if (b) {
                this.dataTableRowHeight[a] = Math.max(b, this.rowHeight)
            }
        }
        return this.dataTableRowHeight[a]
    };
    this.getAllNetworkAttributes = function(c) {
        var b = this.getNetworkData(this.networkShowDataTable, true);
        var d = this.getKeys(b).length;
        return [b, d]
    };
    this.getVennCompartments = function(c) {
        var b = {};
        var d = 0;
        if (c.venn && c.venn.data) {
            for (var a in c.venn.data) {
                b[a] = 1;
                d++
            }
        }
        return [b, d]
    };
    this.getDataTableDimensions = function() {
        var f = 0;
        var i = 0;
        var e = 0;
        var b = 0;
        var d = this.$(this.target + "-cX-DataTableTable");
        var g = this.$(this.target + "-cX-DataTableCell.0.0");
        if (d) {
            var a = d.childNodes[0].rows;
            if (a) {
                f = a.length;
                i = a[0].cells.length;
                e = g && g.firstChild && g.firstChild.style ? parseInt(g.firstChild.style.height) : 0;
                b = g && g.firstChild && g.firstChild.style ? parseInt(g.firstChild.style.width) : 0
            }
        }
        return [f, i, e, b]
    };
    this.resetDataTable = function(b, a) {
        this.addRemoveDataTableListeners("removeEvtListener", a);
        this.removeTarget(this.target + "-cX-DataTable");
        this.addDataTableDiv(false, b)
    };
    this.hideUnhideDataTable = function(a) {
        if (this.initialMaxRows) {
            this.maxRows = this.initialMaxRows
        }
        if (this.initialMaxCols) {
            this.maxCols = this.initialMaxCols
        }
        var b = this.$(this.target + "-cX-DataTable");
        if (b) {
            if (a == true) {
                b.style.display = "none"
            } else {
                b.style.display = "block"
            }
        }
    };
    this.resizeDataTable = function() {
        var g = this.$(this.target + "-cX-DataTableContainer");
        var d = this.$(this.target + "-cX-DataTableVer");
        var f = this.$(this.target + "-cX-DataTableHor");
        if (g && d && f) {
            var b = 0;
            this.maxCols = 0;
            for (var e = this.startCol; e < this.totalCols; e++) {
                b += this.dataTableColumnWidth[e] + 8;
                if (parseInt(g.style.width) < b) {
                    this.maxCols++;
                    break
                } else {
                    this.maxCols++
                }
            }
            if (b < parseInt(g.style.width) && this.startCol > 0) {
                for (var e = this.startCol; e >= 0; e--) {
                    if (b + this.dataTableColumnWidth[e] + 8 < parseInt(g.style.width)) {
                        b += this.dataTableColumnWidth[e] + 8;
                        this.maxCols++;
                        this.startCol--
                    } else {
                        break
                    }
                }
            }
            if (parseInt(g.style.width) > this.dataTableTotalWidth) {
                this.maxCols = (this.totalCols - this.startCol)
            }
            this.maxCols = Math.max(3, Math.min(this.maxCols, (this.totalCols - this.startCol)));
            var a = 0;
            this.maxRows = 0;
            for (var e = this.startRow; e < this.totalRows; e++) {
                a += this.dataTableRowHeight[e] + 4;
                if (parseInt(g.style.height) < a) {
                    this.maxRows++;
                    break
                } else {
                    this.maxRows++
                }
            }
            if (a < parseInt(g.style.height) && this.startRow > 0) {
                for (var e = this.startRow; e >= 0; e--) {
                    if (a + this.dataTableRowHeight[e] + 4 < parseInt(g.style.height)) {
                        a += this.dataTableRowHeight[e] + 4;
                        this.maxRows++;
                        this.startRow--
                    } else {
                        break
                    }
                }
            }
            if (parseInt(g.style.height) > this.dataTableTotalHeight) {
                this.totalRows = (this.totalRows - this.startRow)
            }
            this.maxRows = Math.max(3, Math.min(this.maxRows, (this.totalRows - this.startRow)));
            this.updateDataTable(false, true, false, true);
            d = this.$(this.target + "-cX-DataTableVer");
            f = this.$(this.target + "-cX-DataTableHor");
            if (d && f) {
                if (!this.isIE) {
                    d.scrollHeight = this.dataTableLastScrollHeight
                }
                d.scrollTop = this.dataTableLastScrollTop ? this.dataTableLastScrollTop : d.scrollTop;
                if (!this.isIE) {
                    f.scrollWidth = this.dataTableLastScrollWidth
                }
                f.scrollLeft = this.dataTableLastScrollLeft ? this.dataTableLastScrollLeft : f.scrollLeft
            }
            if (this.dataTableLastState == "docked") {
                this.resizeViewportSouth(true)
            }
        }
    };
    this.sortDataTable = function() {
        this.sortDir = this.sortDataTableHead.className == "CanvasXpressTableCellSortDesc" ? "descending" : "ascending";
        var a = this.sortDataTableHead.innerText ? this.sortDataTableHead.innerText : this.sortDataTableHead.textContent;
        if (this.graphType == "Network") {
            if (this.dataTableTransposed) {
                if (this.sortDataTableHead.type == "cxb") {
                    this.sortDataTableHead.className = "CanvasXpressTableCell";
                    this.sortDataTableHead = false;
                    return
                } else {
                    this.sortNetworkIndices(a)
                }
            } else {
                this.sortDataTableHead.className = "CanvasXpressTableCell";
                this.sortDataTableHead = false;
                return
            }
        } else {
            if (this.graphType == "Genome") {
                this.sortDataTableHead.className = "CanvasXpressTableCell";
                this.sortDataTableHead = false;
                return
            } else {
                if (this.graphType == "Venn") {
                    this.sortDataTableHead.className = "CanvasXpressTableCell";
                    this.sortDataTableHead = false;
                    return
                } else {
                    if (this.graphType == "Correlation") {
                        if (this.correlationAxis == "samples") {
                            if (this.sortDataTableHead.type == "cxb") {
                                this.sortSamples()
                            } else {
                                this.sortSamples(false, false, a, "cor", true);
                                this.sortDataTableHead.className = "CanvasXpressTableCell";
                                this.sortDataTableHead = false
                            }
                        } else {
                            if (this.sortDataTableHead.type == "cxb") {
                                this.sortVariables()
                            } else {
                                this.sortVariables(false, false, a, "cor", true);
                                this.sortDataTableHead.className = "CanvasXpressTableCell";
                                this.sortDataTableHead = false
                            }
                        }
                    } else {
                        if (this.graphType == "Candlestick") {
                            this.sortDataTableHead.className = "CanvasXpressTableCell";
                            this.sortDataTableHead = false;
                            return
                        } else {
                            if (this.data.y.vars && this.data.y.smps) {
                                if (this.dataTableTransposed) {
                                    if (this.sortDataTableHead.type == "cxx") {
                                        this.sortSamplesByCategory([a])
                                    } else {
                                        if (this.sortDataTableHead.type == "cxv") {
                                            this.sortSamplesByVariable(a)
                                        } else {
                                            if (this.sortDataTableHead.type == "cxb") {
                                                this.sortSamples()
                                            }
                                        }
                                    }
                                } else {
                                    if (this.sortDataTableHead.type == "cxz") {
                                        this.sortVariablesByCategory([a])
                                    } else {
                                        if (this.sortDataTableHead.type == "cxs") {
                                            this.sortVariablesBySample(a)
                                        } else {
                                            if (this.sortDataTableHead.type == "cxb") {
                                                this.sortVariables()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        this.updateDataTable(false, true, false, false, true)
    };
    this.getDataClassAsArray = function(y, b, K, C, z, e) {
        var m = 0;
        var h = 0;
        var x = 0;
        var t = 0;
        var H = [];
        var I = [];
        var w = [];
        var u = [];
        var f = function(r, s, d, L) {
            if (s.hasOwnProperty(r)) {
                return s[r] != null ? s[r] : ""
            } else {
                if (d[0][r] && d[0][r].hasOwnProperty("r")) {
                    var v = d[0][r]["r"];
                    for (var l = 0; l < L[v].length; l++) {
                        var k = L[v][l];
                        if (s.hasOwnProperty(k)) {
                            s = s[k]
                        } else {
                            return ""
                        }
                    }
                    if (s.hasOwnProperty(r)) {
                        return s[r] != null ? s[r] : ""
                    }
                }
                return ""
            }
        };
        if (b == null) {
            b = 0
        }
        if (K == null) {
            K = 99
        }
        if (C == null) {
            C = 0
        }
        if (z == null) {
            z = 99
        }
        if (this.graphType == "Network") {
            var J = this.getAllNetworkAttributes(y);
            w.push("");
            u.push("cxb");
            if (this.dataTableTransposed) {
                for (var E in J[0]) {
                    if (h < K && t >= b && !this.dataTableColumnHide[E]) {
                        w.push(E);
                        u.push("cxx");
                        h++
                    }
                    t++
                }
                H.push(w);
                I.push(u);
                for (var E = 0; E < y[this.networkShowDataTable].length; E++) {
                    if (m < z && x >= C) {
                        h = 0;
                        t = 0;
                        w = [E + 1];
                        u = ["cxz"];
                        for (var D in J[0]) {
                            if (h < K && t >= b && !this.dataTableColumnHide[D]) {
                                var q = f(D, y[this.networkShowDataTable][E], J, this[this.networkShowDataTable + "Properties"]);
                                w.push(q);
                                u.push("cxy");
                                h++
                            }
                            t++
                        }
                        H.push(w);
                        I.push(u);
                        m++
                    }
                    x++
                }
            } else {
                for (var E = 0; E < y[this.networkShowDataTable].length; E++) {
                    if (h < K && t >= b && !this.dataTableColumnHide[E + 1]) {
                        w.push(E + 1);
                        u.push("cxz");
                        h++
                    }
                    t++
                }
                H.push(w);
                I.push(u);
                for (var E in J[0]) {
                    if (m < z && x >= C) {
                        h = 0;
                        t = 0;
                        w = [E];
                        u = ["cxx"];
                        for (var D = 0; D < y[this.networkShowDataTable].length; D++) {
                            if (h < K && t >= b && !this.dataTableColumnHide[E + 1]) {
                                var q = f(E, y[this.networkShowDataTable][D], J, this[this.networkShowDataTable + "Properties"]);
                                w.push(q);
                                u.push("cxy");
                                h++
                            }
                            t++
                        }
                        H.push(w);
                        I.push(u);
                        m++
                    }
                    x++
                }
            }
        } else {
            if (this.graphType == "Genome") {
                H = [
                    ["Not implemented"]
                ];
                I = [
                    ["cxb"]
                ]
            } else {
                if (this.graphType == "Venn") {
                    var q = this.getVennCompartments(y);
                    w.push("");
                    u.push("cxb");
                    if (this.dataTableTransposed) {
                        w.push("No");
                        u.push("cxz");
                        H.push(w);
                        I.push(u);
                        for (var E in q[0]) {
                            if (m < z && x >= C) {
                                h = 0;
                                t = 0;
                                w = [E];
                                u = ["cxx"];
                                if (h < K && t >= b) {
                                    w.push(y.venn.data[E]);
                                    u.push("cxy");
                                    h++
                                }
                                t++;
                                H.push(w);
                                I.push(u);
                                m++
                            }
                            x++
                        }
                    } else {
                        for (var E in q[0]) {
                            if (h < K && t >= b) {
                                w.push(E);
                                u.push("cxx");
                                h++
                            }
                            t++
                        }
                        H.push(w);
                        I.push(u);
                        if (m < z && x >= C) {
                            h = 0;
                            t = 0;
                            w = ["No"];
                            u = ["cxz"];
                            for (var E in q[0]) {
                                if (h < K && t >= b) {
                                    w.push(y.venn.data[E]);
                                    u.push("cxy");
                                    h++
                                }
                                t++
                            }
                            H.push(w);
                            I.push(u)
                        }
                    }
                } else {
                    if (this.graphType == "Correlation") {
                        var p = this.correlationAxis == "samples" ? y.y.smps : y.y.vars;
                        var g = this.correlationAxis == "samples" ? this.smpIndices : this.varIndices;
                        var n = this.correlationAxis == "samples" ? "cxs" : "cxv";
                        w.push("");
                        u.push("cxb");
                        for (var E = 0; E < p.length; E++) {
                            if (h < K && t >= b && !this.dataTableColumnHide[e ? p[g[E]] : p[E]]) {
                                w.push(e ? p[g[E]] : p[E]);
                                u.push(n);
                                h++
                            }
                            t++
                        }
                        H.push(w);
                        I.push(u);
                        for (var E = 0; E < p.length; E++) {
                            if (m < z && x >= C) {
                                h = 0;
                                t = 0;
                                w = [e ? p[g[E]] : p[E]];
                                u = [n];
                                for (var D = 0; D < p.length; D++) {
                                    if (h < K && t >= b && !this.dataTableColumnHide[e ? p[g[D]] : p[D]]) {
                                        if (y.y.cor) {
                                            w.push(e ? y.y.cor[g[E]][g[D]] : y.y.cor[E][D])
                                        } else {
                                            w.push(E == D ? 1 : y.y.data)
                                        }
                                        u.push("cxy");
                                        h++
                                    }
                                    t++
                                }
                                H.push(w);
                                I.push(u);
                                m++
                            }
                            x++
                        }
                    } else {
                        if (this.graphType == "Candlestick") {
                            var J = ["open", "low", "high", "close", "volume"];
                            w.push("");
                            u.push("cxb");
                            if (this.dataTableTransposed) {
                                for (var E = 0; E < y.y.vars.length; E++) {
                                    for (var D = 0; D < J.length; D++) {
                                        var A = y.y.vars.length > 1 ? y.y.vars[E] + ":" + J[D] : J[D];
                                        if (h < K && t >= b && !this.dataTableColumnHide[A]) {
                                            w.push(A);
                                            u.push("cxv");
                                            h++
                                        }
                                        t++
                                    }
                                }
                                H.push(w);
                                I.push(u);
                                for (var E = 0; E < y.y.smps.length; E++) {
                                    if (m < z && x >= C) {
                                        h = 0;
                                        t = 0;
                                        w = [y.y.smps[E]];
                                        u = ["cxs"];
                                        for (var D = 0; D < y.y.vars.length; D++) {
                                            for (var B = 0; B < J.length; B++) {
                                                var A = y.y.vars.length > 1 ? y.y.vars[D] + ":" + J[B] : J[B];
                                                if (h < K && t >= b && !this.dataTableColumnHide[A]) {
                                                    w.push(y.y[J[B]][D][E] != null ? y.y[J[B]][D][E] : y.y[J[B]][E]);
                                                    u.push("cxy");
                                                    h++
                                                }
                                                t++
                                            }
                                        }
                                        H.push(w);
                                        I.push(u);
                                        m++
                                    }
                                    x++
                                }
                            } else {
                                for (var E = 0; E < y.y.smps.length; E++) {
                                    if (h < K && t >= b && !this.dataTableColumnHide[y.y.smps[E]]) {
                                        w.push(y.y.smps[E]);
                                        u.push("cxs");
                                        h++
                                    }
                                    t++
                                }
                                H.push(w);
                                I.push(u);
                                for (var E = 0; E < y.y.vars.length; E++) {
                                    for (var D = 0; D < J.length; D++) {
                                        if (m < z && x >= C) {
                                            h = 0;
                                            t = 0;
                                            var A = y.y.vars.length > 1 ? y.y.vars[E] + ":" + J[D] : J[D];
                                            w = [A];
                                            u = ["cxv"];
                                            for (var B = 0; B < y.y.smps.length; B++) {
                                                if (h < K && t >= b && !this.dataTableColumnHide[y.y.smps[B]]) {
                                                    w.push(y.y[J[D]][E][B] != null ? y.y[J[D]][E][B] : y.y[J[D]][B]);
                                                    u.push("cxy");
                                                    h++
                                                }
                                                t++
                                            }
                                            H.push(w);
                                            I.push(u);
                                            m++
                                        }
                                        x++
                                    }
                                }
                            }
                        } else {
                            if (y.y.vars && y.y.smps) {
                                var G = e ? this.varIndices.length : y.y.vars.length;
                                var F = e ? this.smpIndices.length : y.y.smps.length;
                                w.push("");
                                u.push("cxb");
                                if (this.dataTableTransposed) {
                                    if (y.x) {
                                        for (var E in y.x) {
                                            if (h < K && t >= b && !this.dataTableColumnHide[E]) {
                                                w.push(E);
                                                u.push("cxx");
                                                h++
                                            }
                                            t++
                                        }
                                    }
                                    for (var E = 0; E < G; E++) {
                                        if (h < K && t >= b && !this.dataTableColumnHide[e ? y.y.vars[this.varIndices[E]] : y.y.vars[E]]) {
                                            w.push(e ? y.y.vars[this.varIndices[E]] : y.y.vars[E]);
                                            u.push("cxv");
                                            h++
                                        }
                                        t++
                                    }
                                    H.push(w);
                                    I.push(u);
                                    if (y.z) {
                                        for (var E in y.z) {
                                            if (m < z && x >= C) {
                                                h = 0;
                                                t = 0;
                                                w = [E];
                                                u = ["cxz"];
                                                if (y.x) {
                                                    for (var D in y.x) {
                                                        if (h < K && t >= b && !this.dataTableColumnHide[D]) {
                                                            w.push("");
                                                            u.push("cxb");
                                                            h++
                                                        }
                                                        t++
                                                    }
                                                }
                                                for (var D = 0; D < G; D++) {
                                                    if (h < K && t >= b && !this.dataTableColumnHide[e ? y.y.vars[this.varIndices[D]] : y.y.vars[D]]) {
                                                        w.push(e ? y.z[E][this.varIndices[D]] : y.z[E][D]);
                                                        u.push("cxz");
                                                        h++
                                                    }
                                                    t++
                                                }
                                                H.push(w);
                                                I.push(u);
                                                m++
                                            }
                                            x++
                                        }
                                    }
                                    for (var E = 0; E < F; E++) {
                                        if (m < z && x >= C) {
                                            h = 0;
                                            t = 0;
                                            w = [e ? y.y.smps[this.smpIndices[E]] : y.y.smps[E]];
                                            u = ["cxs"];
                                            if (y.x) {
                                                for (var D in y.x) {
                                                    if (h < K && t >= b && !this.dataTableColumnHide[D]) {
                                                        w.push(e ? y.x[D][this.smpIndices[E]] : y.x[D][E]);
                                                        u.push("cxx");
                                                        h++
                                                    }
                                                    t++
                                                }
                                            }
                                            for (var D = 0; D < G; D++) {
                                                if (h < K && t >= b && !this.dataTableColumnHide[e ? y.y.vars[this.varIndices[D]] : y.y.vars[D]]) {
                                                    if (e) {
                                                        w.push(y.y.data[this.varIndices[D]][this.smpIndices[E]] != null ? y.y.data[this.varIndices[D]][this.smpIndices[E]] : y.y.data[this.smpIndices[E]])
                                                    } else {
                                                        w.push(y.y.data[D][E] != null ? y.y.data[D][E] : y.y.data[E])
                                                    }
                                                    u.push("cxy");
                                                    h++
                                                }
                                                t++
                                            }
                                            H.push(w);
                                            I.push(u);
                                            m++
                                        }
                                        x++
                                    }
                                } else {
                                    if (y.z) {
                                        for (var E in y.z) {
                                            if (h < K && t >= b && !this.dataTableColumnHide[E]) {
                                                w.push(E);
                                                u.push("cxz");
                                                h++
                                            }
                                            t++
                                        }
                                    }
                                    for (var E = 0; E < F; E++) {
                                        if (h < K && t >= b && !this.dataTableColumnHide[e ? y.y.smps[this.smpIndices[E]] : y.y.smps[E]]) {
                                            w.push(e ? y.y.smps[this.smpIndices[E]] : y.y.smps[E]);
                                            u.push("cxs");
                                            h++
                                        }
                                        t++
                                    }
                                    H.push(w);
                                    I.push(u);
                                    if (y.x) {
                                        for (var E in y.x) {
                                            if (m < z && x >= C) {
                                                h = 0;
                                                t = 0;
                                                w = [E];
                                                u = ["cxx"];
                                                if (y.z) {
                                                    for (var D in y.z) {
                                                        if (h < K && t >= b && !this.dataTableColumnHide[D]) {
                                                            w.push("");
                                                            u.push("cxb");
                                                            h++
                                                        }
                                                        t++
                                                    }
                                                }
                                                for (var D = 0; D < F; D++) {
                                                    if (h < K && t >= b && !this.dataTableColumnHide[e ? y.y.smps[this.smpIndices[D]] : y.y.smps[D]]) {
                                                        w.push(e ? y.x[E][this.smpIndices[D]] : y.x[E][D]);
                                                        u.push("cxx");
                                                        h++
                                                    }
                                                    t++
                                                }
                                                H.push(w);
                                                I.push(u);
                                                m++
                                            }
                                            x++
                                        }
                                    }
                                    for (var E = 0; E < G; E++) {
                                        if (m < z && x >= C) {
                                            h = 0;
                                            t = 0;
                                            w = [e ? y.y.vars[this.varIndices[E]] : y.y.vars[E]];
                                            u = ["cxv"];
                                            if (y.z) {
                                                for (var D in y.z) {
                                                    if (h < K && t >= b && !this.dataTableColumnHide[D]) {
                                                        w.push(e ? y.z[D][this.varIndices[E]] : y.z[D][E]);
                                                        u.push("cxz");
                                                        h++
                                                    }
                                                    t++
                                                }
                                            }
                                            for (var D = 0; D < F; D++) {
                                                if (h < K && t >= b && !this.dataTableColumnHide[e ? y.y.smps[this.smpIndices[D]] : y.y.smps[D]]) {
                                                    if (e) {
                                                        w.push(y.y.data[this.varIndices[E]][this.smpIndices[D]] != null ? y.y.data[this.varIndices[E]][this.smpIndices[D]] : y.y.data[this.smpIndices[D]])
                                                    } else {
                                                        w.push(y.y.data[E][D] != null ? y.y.data[E][D] : y.y.data[D])
                                                    }
                                                    u.push("cxy");
                                                    h++
                                                }
                                                t++
                                            }
                                            H.push(w);
                                            I.push(u);
                                            m++
                                        }
                                        x++
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return [H, I]
    };
    this.updateDataTable = function(g, c, d, h, b) {
        if (this.dataTableLastState && this.dataTableLastState == "docked" && h) {
            this.dataTableLastX = this.configuringOn && this.configuringOn == "docked" ? 0 : 7;
            this.dataTableLastY = 0
        }
        if (!g) {
            g = this.data
        } else {
            g = this.getUngroupedDataObject(g)
        } if (!d) {
            this.setDataTableDimensions(g, c)
        }
        var a = this.getDataClassAsArray(g, this.startCol, this.maxCols, this.startRow, this.maxRows, true);
        if (d) {
            return a[0]
        } else {
            this.loadDataTableValues(a[0], a[1], h, b)
        }
    };
    this.loadDataTableValues = function(B, C, u, p) {
        var m = this.$(this.target + "-cX-DataTable");
        if (m) {
            var l = this.startRow;
            for (var x = 0; x < B.length; x++) {
                var y = this.startCol;
                for (var v = 0; v < B[x].length + this.startCol; v++) {
                    var r = this.target + "-cX-DataTableCell." + x + "." + v;
                    var E = this.target + "-cX-DataTableCellContent." + l + "." + y;
                    var g = this.target + "-cX-DataTableCellContentA." + l + "." + y;
                    var A = this.$(r);
                    if (A) {
                        if (A.hasChildNodes()) {
                            while (A.childNodes.length >= 1) {
                                A.removeChild(A.firstChild)
                            }
                        }
                        var G = B[x][v] != null ? B[x][v] : "";
                        var b = C[x][v] != null ? C[x][v] : "";
                        if (!isNaN(G) && b == "cxy") {
                            G = this.bestFormatNumber(G)
                        }
                        var f = this.$cX("div", {
                            id: E,
                            className: "CanvasXpressTableCell ",
                            title: G,
                            alt: G,
                            type: b
                        });
                        if (x == 0) {
                            var F = this.$cX("a", {
                                id: g,
                                className: "CanvasXpressTableCellHead ",
                                href: "#"
                            });
                            f.appendChild(F)
                        }
                        f.appendChild(document.createTextNode(G));
                        if (x != 0) {
                            f.style.height = this.setDataTableRowHeight(l) + "px";
                            A.style.height = this.setDataTableRowHeight(l) + "px"
                        } else {
                            f.style.height = this.setDataTableRowHeight(0) + "px";
                            A.style.height = this.setDataTableRowHeight(0) + "px"
                        } if (v != 0) {
                            f.style.width = this.setDataTableColumnWidth(y) + "px";
                            A.style.width = this.setDataTableColumnWidth(y) + "px"
                        } else {
                            f.style.width = this.setDataTableColumnWidth(0) + "px";
                            A.style.width = this.setDataTableColumnWidth(0) + "px"
                        }
                        A.appendChild(f);
                        y++
                    }
                }
                l++
            }
            if (this.activeTarget) {
                this.activeTarget.style.zIndex = 9990
            }
            if (this.sortDataTableHead) {
                var o = this.$(this.sortDataTableHead.id);
                var h = this.$(this.target + "-cX-DataTableCell.0.0").firstChild;
                var k = this.target + "-cX-DataTableCellContent.0.0";
                if (o) {
                    o.className = this.sortDataTableHead.className
                }
                if (h) {
                    h.className = this.sortDataTableHead.id == k ? this.sortDataTableHead.className : "CanvasXpressTableCell"
                }
            }
            this.activeTarget = m;
            m.style.display = "block";
            m.style.zIndex = 9991;
            if (this.dataTableLastState && this.dataTableLastState == "docked" && !u && !p) {
                var D = this.$("south-handler-" + this.target);
                this.clickViewport(false, D);
                return
            }
        }
    };
    this.moveDataTableDiv = function(e) {
        var m = this.$(this.target + "-cX-DataTable");
        if (m) {
            var o, q, i;
            var b = this.$(this.remoteParentId + "-canvasXpressRemoteWindow");
            var a = this.$("west-handler-" + this.target);
            var f = this.$("north-container-" + this.target);
            var c = this.$("west-container-" + this.target);
            var k = this.$("east-container-" + this.target);
            var n = this.$("south-container-" + this.target);
            var g = this.$("south-handler-" + this.target);
            var p = this.$("south-wrapper-" + this.target);
            var j = this;
            if (a && c && k && n && g && p) {
                if (e && e == "dock") {
                    this.dataTableLastState = "docked";
                    this.dataTableLastHeight = m.clientHeight;
                    this.dataTableLastX = m.offsetLeft;
                    this.dataTableLastY = m.offsetTop;
                    g.style.display = "block";
                    o = a.style.display == "none" ? 7 : 0;
                    q = Math.max(m.clientWidth + o, parseInt(c.style.width) + parseInt(k.style.width) + this.canvas.width) + 2;
                    i = parseInt(f.style.height) + this.canvas.height + m.clientHeight + 7 + 2;
                    if (b) {
                        this.resizeMove(b, 0, 0, q + 48, i + 54)
                    }
                    this.resizeMove(n, 0, 0, q, m.clientHeight + 7 + 2);
                    this.resizeMove(p, 0, 0, q, m.clientHeight + 2);
                    this.resizeMove(m, o, 0, m.clientWidth, m.clientHeight)
                } else {
                    if (e && e == "hide") {
                        delete(this.dataTableLastState);
                        delete(this.dataTableLastX);
                        delete(this.dataTableLastY);
                        g.style.display = "none";
                        q = parseInt(c.style.width) + parseInt(k.style.width) + this.canvas.width;
                        i = parseInt(f.style.height) + this.canvas.height + 7;
                        if (b) {
                            this.resizeMove(b, 0, 0, q + 48, i + 54)
                        }
                        this.fade(m);
                        this.resizeMove(p, 0, 0, q, 0);
                        this.resizeMove(n, 0, 0, q, 7)
                    } else {
                        if (e && (e == "max" || e == "release" || e == "undock")) {
                            this.dataTableLastState = "free";
                            g.style.display = "none";
                            q = parseInt(c.style.width) + parseInt(k.style.width) + this.canvas.width;
                            i = parseInt(f.style.height) + this.canvas.height + 7;
                            if (b) {
                                this.resizeMove(b, 0, 0, q + 48, i + 54)
                            }
                            if (e == "max" || e == "undock") {
                                this.resizeMove(m, parseInt(this.dataTableLastX), parseInt(this.dataTableLastY), m.clientWidth, parseInt(this.dataTableLastHeight) || (this.dataTableRowsHeight + 42))
                            }
                            this.resizeMove(p, 0, 0, q, 0);
                            this.resizeMove(n, 0, 0, q, 7)
                        } else {
                            this.dataTableLastX = m.offsetLeft;
                            this.dataTableLastY = m.offsetTop;
                            return
                        }
                    }
                } if (b) {
                    setTimeout(function() {
                        j.resizeExtContainer(q + 48, i + 54)
                    }, 500)
                }
            }
        }
    };
    this.updateDataTableResizerDiv = function(f, k, j) {
        if (!f) {
            f = window.event
        }
        if (f && (k == null || j == null)) {
            k = Math.abs(this.dataTableWidth) - (this.xMouseDown - f.clientX);
            j = Math.abs(this.dataTableHeight) - (this.yMouseDown - f.clientY)
        }
        if (this.dataTableTarget && this.dataTableTarget.style) {
            var g = this.$(this.target + "-cX-DataTable");
            var i = this.$(this.target + "-cX-DataTableContainer");
            var a = this.$(this.target + "-cX-DataTableTableMask");
            var l = this.$(this.target + "-cX-DataTableVer");
            var b = this.$(this.target + "-cX-DataTableHor");
            var n = this.$(this.target + "-cX-DataTableToolbar");
            if (g && i && a && l && b && n) {
                this.dataTableTarget.style.width = this.isIE ? Math.max(0, k) + "px" : k + "px";
                i.style.width = this.isIE ? Math.max(0, k) + "px" : k + "px";
                a.style.width = this.isIE ? Math.max(0, (k - 20)) + "px" : (k - 20) + "px";
                b.style.width = this.isIE ? Math.max(0, (k - 20)) + "px" : (k - 20) + "px";
                n.style.width = this.isIE ? Math.max(0, k) + "px" : k + "px";
                this.dataTableTarget.style.height = this.isIE ? Math.max(0, j) + "px" : j + "px";
                i.style.height = this.isIE ? Math.max(0, (j - 20)) + "px" : (j - 20) + "px";
                a.style.height = this.isIE ? Math.max(0, (j - 44)) + "px" : (j - 44) + "px";
                l.style.height = this.isIE ? Math.max(0, (j - 44)) + "px" : (j - 44) + "px";
                this.dataTableLastWidth = k;
                this.dataTableLastHeight = j
            }
        }
    };
    this.endDataTableResizerDiv = function(a) {
        if (this.dataTableTarget != null) {
            this.resizeDataTable();
            this.xMouseDown = null;
            this.yMouseDown = null;
            this.dataTableWidth = null;
            this.dataTableHeight = null;
            this.dataTableTarget = false;
            this.resizingDataTableOn = false
        }
    };
    this.endDataTableColumnResize = function(a) {
        this.xMouseDown = null;
        this.yMouseDown = null;
        this.resizingDataTableColumnOn = false;
        this.dataTableColumnTarget = false;
        document.body.style.cursor = "default"
    };
    this.initializeDataTableEvents = function() {
        this.addDataTableDiv()
    };
    this.initializeDataTableEvents()
};
CanvasXpress.prototype.initCanvasResizerEvents = function() {
    this.addCanvasResizerDiv = function(a) {
        if (a) {
            if (document.getElementById("canvasXpressCanvasResize")) {
                return
            }
        } else {
            if (document.getElementById(this.target + "canvasXpressCanvasResize")) {
                return
            }
        }
        var b = document.createElement("div");
        b.id = a ? "canvasXpressCanvasResize" : this.target + "canvasXpressCanvasResize";
        b.style.left = "0px";
        b.style.top = "0px";
        b.style.width = "0.5px";
        b.style.height = "0.5px";
        if (a) {
            b.style.opacity = 0.5;
            b.style.filter = "alpha(opacity = 50)";
            b.style.backgroundColor = this.resizerBackgroundColor
        }
        b.style.position = "absolute";
        b.style.display = "none";
        b.style.zIndex = 100001;
        if (a) {
            document.body.appendChild(b);
            return b
        } else {
            this.canvas.parentNode.appendChild(b)
        }
    };
    this.isCanvasResize = function(c) {
        if (this.resizable) {
            if (!c) {
                c = window.event
            }
            var b = this.adjustedCoordinates(c);
            if (b) {
                var a = b.x;
                var d = b.y;
                if (a > this.width - 18 && d > this.height - 18) {
                    this.resizeCanvasCursorShow = "se-resize";
                    return true
                } else {
                    if (a > this.width - 18 && d > 20) {
                        this.resizeCanvasCursorShow = "e-resize";
                        return true
                    } else {
                        if (d > this.height - 18) {
                            this.resizeCanvasCursorShow = "s-resize";
                            return true
                        } else {
                            this.resizeCanvasCursorShow = false;
                            return false
                        }
                    }
                }
            }
        }
    };
    this.updateCanvasResizerCursor = function(d) {
        if (this.resizable) {
            if (!d) {
                d = window.event
            }
            var b = document.getElementById(this.target);
            if (b) {
                var c = this.adjustedCoordinates(d);
                if (c) {
                    var a = c.x;
                    var f = c.y;
                    if (a > this.width - 18 && f > this.height - 18) {
                        b.style.cursor = "se-resize";
                        this.resizeCanvasCursorShow = "se-resize"
                    } else {
                        if (a > this.width - 18 && f > 20) {
                            b.style.cursor = "e-resize";
                            this.resizeCanvasCursorShow = "e-resize"
                        } else {
                            if (f > this.height - 18) {
                                b.style.cursor = "s-resize";
                                this.resizeCanvasCursorShow = "s-resize"
                            } else {
                                if (!this.movingOn) {
                                    b.style.cursor = "default";
                                    this.resizeCanvasCursorShow = false
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.updateCanvasResizer = function(f) {
        if (this.resizingCanvasOn && this.resizeCanvasCursorShow) {
            document.body.style.cursor = this.resizeCanvasCursorShow;
            var c = document.getElementById(this.target + "canvasXpressCanvasResize");
            var a = document.getElementById("canvasXpressCanvasResize");
            var b = this.adjustedCoordinates(f);
            var d = this.relativeCoordinates(this.canvas);
            if (c && b && d) {
                if (this.resizeCanvasCursorShow == "se-resize") {
                    w = b.x;
                    h = b.y
                } else {
                    if (this.resizeCanvasCursorShow == "e-resize") {
                        w = b.x;
                        h = this.height
                    } else {
                        if (this.resizeCanvasCursorShow == "s-resize") {
                            w = this.width;
                            h = b.y
                        }
                    }
                } if (!a) {
                    a = this.addCanvasResizerDiv(true)
                }
                this.preventSelection();
                dx = b.x - this.canvas.width;
                dy = b.y - this.canvas.height;
                c.style.width = w + "px";
                c.style.height = h + "px";
                c.style.display = "block";
                a.style.left = d.x + "px";
                a.style.top = d.y + "px";
                a.style.width = w + "px";
                a.style.height = h + "px";
                a.style.display = "block";
                CanvasXpress.resizing = true
            }
        }
    };
    this.endCanvasResizer = function(g) {
        if (this.resizingCanvasOn) {
            var d = document.getElementById(this.target);
            var a = document.getElementById(this.target + "canvasXpressCanvasResize");
            var o = document.getElementById("canvasXpressCanvasResize");
            var k = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowBuffer");
            var c = this.$("west-container-" + this.target);
            var n = this.$("middle-container-" + this.target);
            var f = this.$("east-container-" + this.target);
            if (d && a && o) {
                this.tmpHeight = false;
                this.tmpWidth = false;
                var m = parseInt(a.style.width);
                var j = parseInt(a.style.height);
                n.style.width = (parseInt(c.style.width) + parseInt(a.style.width) + parseInt(f.style.width)) + "px";
                n.style.height = a.style.height;
                this.resetAxesResizer();
                this.draw(m, j);
                this.resizeAcknowledgmentDiv();
                a.style.width = "0.5px";
                a.style.height = "0.5px";
                a.style.display = "none";
                d.style.cursor = "default";
                this.updateRemoteNavigationWindow();
                document.body.removeChild(o);
                this.resizeCanvasCursorShow = false;
                this.resizingCanvasOn = false;
                CanvasXpress.resizing = false
            }
        }
    };
    this.initializeCanvasResizerEvents = function() {
        if (!this.disableEvents) {
            this.addCanvasResizerDiv()
        }
    };
    this.initializeCanvasResizerEvents()
};
CanvasXpress.prototype.initAxisResizerEvents = function() {
    this.addAxesResizeDiv = function() {
        if (document.getElementById(this.target + "canvasXpressAxesResize")) {
            return
        }
        var c = ["Previous", "Next", "Current", "Middle", "Min", "Max", "Close"];
        var b = 9001;
        var e = document.createElement("div");
        e.id = this.target + "canvasXpressAxesResize";
        if (this.resizerTransparency) {
            e.style.opacity = 0.85;
            e.style.filter = "alpha(opacity = 85)"
        }
        e.style.position = "absolute";
        e.style.display = "none";
        e.style.zIndex = b;
        for (var a = 0; a < c.length; a++) {
            b++;
            var f = document.createElement("div");
            f.id = this.target + "canvasXpressAxesResize" + c[a];
            if (this.resizerTransparency) {
                f.style.opacity = 0.85;
                f.style.filter = "alpha(opacity = 85)"
            }
            f.style.position = "absolute";
            f.style.zIndex = b;
            e.appendChild(f)
        }
        this.canvas.parentNode.appendChild(e)
    };
    this.clickAxesResizeClose = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.stopEvent(b);
            a.resetAxesResizer(b);
            a.resetFlags(b)
        }
    }(this);
    this.mousemoveActiveAxesResize = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.activateDeactivateAxesResizer(b)
        }
    }(this);
    this.mousedownAxesResize = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.cancelEvent(b);
            a.registerAxesResizer(b);
            return false
        }
    }(this);
    this.mousemoveAxesResize = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.cancelEvent(b);
            a.updateAxesResizer(b);
            return false
        }
    }(this);
    this.addRemoveAxesResizerListeners = function(p) {
        var a = document.getElementById(this.target + "canvasXpressAxesResize");
        var d = document.getElementById(this.target + "canvasXpressAxesResizeMin");
        var k = document.getElementById(this.target + "canvasXpressAxesResizeMax");
        var e = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
        var i = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
        var g = document.getElementById(this.target + "canvasXpressAxesResizeClose");
        var b = [a, d, k, e, i];
        if (a) {
            this[p](a, "mousemove", this.mousemoveActiveAxesResize, false);
            this[p](a, "mouseout", this.mousemoveActiveAxesResize, false)
        }
        if (g) {
            this[p](g, "click", this.clickAxesResizeClose, false)
        }
        for (var f = 0; f < b.length; f++) {
            if (b[f]) {
                this[p](b[f], "mousedown", this.mousedownAxesResize, false)
            }
        }
    };
    this.showAxesResizer = function(f, e, c, q, o, m, b, g, t, u, n, j, i) {
        if (!this.axesResizerShow) {
            var a = document.getElementById(this.target + "canvasXpressAxesResize");
            var k = document.getElementById(this.target + "canvasXpressAxesResizeClose");
            if (a && k) {
                this.updateResizerEventData(null, null, f, e, c, q, o, m, b, g, t, u, n, j, i);
                this.refreshAxesResizer();
                a.style.display = "block";
                if (this.resizerType && this.layoutValid) {
                    k.style.display = "none"
                }
                this.addRemoveAxesResizerListeners("addEvtListener");
                if (this.layoutValid) {
                    this.layoutValidR = j;
                    this.layoutValidC = i;
                    this.layoutValidN = n
                }
                this.axesResizerShow = true
            }
        }
    };
    this.refreshAxesResizer = function() {
        if (this.resizerEventData) {
            var b = document.getElementById(this.target + "canvasXpressAxesResize");
            var e = document.getElementById(this.target + "canvasXpressAxesResizeMin");
            var o = document.getElementById(this.target + "canvasXpressAxesResizeMax");
            var f = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
            var i = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
            var g = document.getElementById(this.target + "canvasXpressAxesResizeClose");
            var k = document.getElementById(this.target + "canvasXpressAxesResizePrevious");
            var j = document.getElementById(this.target + "canvasXpressAxesResizeNext");
            if (b && e && o && i && g && k && j) {
                var s = this.resizerEventData.areas.org[1] - this.resizerEventData.areas.org[0];
                var p = this.resizerEventData.areas.org[3] - this.resizerEventData.areas.org[2];
                var d = 14;
                var a = 9;
                var q = parseInt(a / 2);
                if (this.resizerEventData.pos == "h") {
                    l = this.resizerEventData.l.match(/^t/) ? "top" : "bottom";
                    b.style.left = (this.resizerEventData.areas.org[0] - q) + "px";
                    b.style.top = this.resizerEventData.areas.org[2] + "px";
                    b.style.width = ((s + a) - 1) + "px";
                    b.style.height = d + "px";
                    b.style.backgroundImage = "url('" + this.imageDir + "scroller_empty_hor_" + l + ".png')";
                    b.style.backgroundRepeat = "repeat-x";
                    k.style.left = "0px";
                    k.style.top = "0px";
                    k.style.width = a + "px";
                    k.style.height = d + "px";
                    k.style.backgroundImage = "url('" + this.imageDir + "prev_" + l + ".png')";
                    e.style.left = this.resizerEventData.areas.min[0] + "px";
                    e.style.top = "0px";
                    e.style.width = a + "px";
                    e.style.height = d + "px";
                    e.style.cursor = "e-resize";
                    e.style.backgroundImage = "url('" + this.imageDir + "handle_left_" + l + ".png')";
                    i.style.left = this.resizerEventData.areas.cur[0] + "px";
                    i.style.top = "0px";
                    i.style.width = this.resizerEventData.areas.cur[1] + "px";
                    i.style.height = d + "px";
                    i.style.cursor = "move";
                    i.style.backgroundImage = "url('" + this.imageDir + "scroller_body_hor_" + l + ".png')";
                    i.style.backgroundRepeat = "repeat-x";
                    o.style.left = this.resizerEventData.areas.max[0] + "px";
                    o.style.top = "0px";
                    o.style.width = a + "px";
                    o.style.height = d + "px";
                    o.style.cursor = "e-resize";
                    o.style.backgroundImage = "url('" + this.imageDir + "handle_right_" + l + ".png')";
                    o.style.backgroundRepeat = "no-repeat";
                    f.style.left = (this.resizerEventData.areas.min[0] + ((this.resizerEventData.areas.cur[1] - 1) / 2)) + "px";
                    f.style.top = "0px";
                    f.style.width = "8px";
                    f.style.height = d + "px";
                    f.style.cursor = "move";
                    f.style.backgroundImage = "url('" + this.imageDir + "scroller_handle_hor_" + l + ".png')";
                    j.style.left = (s - 1) + "px";
                    j.style.top = "0px";
                    j.style.width = a + "px";
                    j.style.height = d + "px";
                    j.style.backgroundImage = "url('" + this.imageDir + "next_" + l + ".png')";
                    g.style.left = (s + a) + "px";
                    g.style.top = "0px";
                    g.style.width = a + "px";
                    g.style.height = d + "px";
                    g.style.backgroundImage = "url('" + this.imageDir + "close.png')"
                } else {
                    l = this.resizerEventData.l.match(/^l/) ? "left" : "right";
                    b.style.left = this.resizerEventData.areas.org[0] + "px";
                    b.style.top = (this.resizerEventData.areas.org[2] - q) + "px";
                    b.style.width = d + "px";
                    b.style.height = (p + a) + "px";
                    b.style.backgroundImage = "url('" + this.imageDir + "scroller_empty_ver_" + l + ".png')";
                    b.style.backgroundRepeat = "repeat-y";
                    k.style.left = "0px";
                    k.style.top = p + "px";
                    k.style.width = d + "px";
                    k.style.height = a + "px";
                    k.style.backgroundImage = "url('" + this.imageDir + "prev_" + l + ".png')";
                    e.style.left = "0px";
                    e.style.top = this.resizerEventData.areas.min[2] + "px";
                    e.style.width = d + "px";
                    e.style.height = a + "px";
                    e.style.cursor = "n-resize";
                    e.style.backgroundImage = "url('" + this.imageDir + "handle_bottom_" + l + ".png')";
                    e.style.backgroundRepeat = "no-repeat";
                    i.style.left = "0px";
                    i.style.top = this.resizerEventData.areas.cur[2] + "px";
                    i.style.width = d + "px";
                    i.style.height = this.resizerEventData.areas.cur[3] + "px";
                    i.style.cursor = "move";
                    i.style.backgroundImage = "url('" + this.imageDir + "scroller_body_ver_" + l + ".png')";
                    i.style.backgroundRepeat = "repeat-y";
                    o.style.left = "0px";
                    o.style.top = this.resizerEventData.areas.max[2] + "px";
                    o.style.width = d + "px";
                    o.style.height = a + "px";
                    o.style.cursor = "n-resize";
                    o.style.backgroundImage = "url('" + this.imageDir + "handle_top_" + l + ".png')";
                    o.style.backgroundRepeat = "no-repeat";
                    f.style.left = "0px";
                    f.style.top = (this.resizerEventData.areas.max[2] + (this.resizerEventData.areas.cur[3] / 2)) + "px";
                    f.style.width = d + "px";
                    f.style.height = d + "px";
                    f.style.cursor = "move";
                    f.style.backgroundImage = "url('" + this.imageDir + "scroller_handle_ver_" + l + ".png')";
                    f.style.backgroundRepeat = "no-repeat";
                    j.style.left = "0px";
                    j.style.top = "0px";
                    j.style.width = d + "px";
                    j.style.height = a + "px";
                    j.style.backgroundImage = "url('" + this.imageDir + "next_" + l + ".png')";
                    g.style.left = (d + 1) + "px";
                    g.style.top = -a + "px";
                    g.style.width = a + "px";
                    g.style.height = d + "px";
                    g.style.backgroundImage = "url('" + this.imageDir + "close.png')"
                }
                this.drawAxesResizerMasks()
            }
        }
    };
    this.updateResizerEventData = function(i, H, B, q, o, a, X, U, K, O, I, J, z, t, r) {
        var j, G, F, m, k, A, y, f, c, Q, P, E, D, n, W;
        B = B ? B : this.resizerEventData.axis;
        q = q ? q : this.resizerEventData.areas.org[0];
        o = o ? o : this.resizerEventData.areas.org[1];
        a = a ? a : this.resizerEventData.areas.org[2];
        X = X ? X : this.resizerEventData.areas.org[3];
        U = U ? U : this.resizerEventData.dim;
        K = K ? K : this.resizerEventData.pos;
        O = O ? O : this.resizerEventData.l;
        I = I ? I : this.resizerEventData.vals;
        J = J ? J : this.resizerEventData.set ? this.resizerEventData.set : "";
        z = z ? z : this.resizerEventData.c;
        t = t ? t : this.resizerEventData.i;
        r = r ? r : this.resizerEventData.j;
        var S = I.graphType;
        var e = o - q;
        var b = X - a;
        if (S == "Heatmap") {
            if (U == "y") {
                j = this.isGroupedData ? this.data.w.smps.length : this.data.y ? this.data.y.smps.length : 0
            } else {
                j = this.data.y ? this.data.y.vars.length : 0
            }
        } else {
            j = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y ? this.data.y.smps.length - 1 : 0
        }
        var V = this.resizerType == "samples" || S == "Heatmap" ? 0 : I[B + "AbsMin"];
        var C = this.resizerType == "samples" || S == "Heatmap" ? j : I[B + "AbsMax"];
        var u = K == "h" ? e : b;
        var R = u / (C - V);
        if (i == null || isNaN(i)) {
            if (this.resizerType == "samples") {
                i = this.isGroupedData ? this.grpIndices[0] : this.smpIndices[0]
            } else {
                if (S == "Heatmap") {
                    i = U == "y" ? Math.max(0, I.smpIndicesStart) : Math.max(0, I.varIndicesStart)
                } else {
                    i = S.match(/Scatter/) ? I["setMin" + U.toUpperCase()] : S == "BarLine" && O.match(/b|r/) ? I.setMin2 : I.setMin
                } if (i == null || isNaN(i)) {
                    i = V
                }
            }
        }
        i = Math.max(i, V);
        if (H == null || isNaN(H)) {
            if (this.resizerType == "samples") {
                H = this.isGroupedData ? this.grpIndices[this.grpIndices.length - 1] : this.smpIndices[this.smpIndices.length - 1]
            } else {
                if (S == "Heatmap") {
                    H = U == "x" ? I.varIndices.length : this.isGroupedData ? I.grpIndices.length : I.smpIndices.length;
                    H += i
                } else {
                    H = S.match(/Scatter/) ? I["setMax" + U.toUpperCase()] : S == "BarLine" && O.match(/b|r/) ? I.setMax2 : I.setMax
                } if (H == null || isNaN(H)) {
                    H = C
                }
            }
        }
        H = Math.min(H, C);
        var x = (i - V) * R;
        var T = (H - V) * R;
        var N = 14;
        var M = 9;
        var L = parseInt(M / 2);
        if (K == "h") {
            G = parseInt(x);
            F = M;
            m = 0;
            k = N;
            Q = parseInt(x + L + 1);
            P = parseInt(T - (x + 1));
            E = 0;
            D = N;
            A = parseInt(T - 1);
            y = M;
            f = 0;
            c = N;
            n = o + (M - 1);
            W = X
        } else {
            G = 0;
            F = N;
            m = this.resizerType == "samples" || S == "Heatmap" ? parseInt(T) : parseInt(b - (x + 1));
            k = M;
            Q = 0;
            P = N;
            E = this.resizerType == "samples" || S == "Heatmap" ? parseInt(x + L) : parseInt((b - T) + L);
            D = parseInt(T - x);
            A = 0;
            y = N;
            f = this.resizerType == "samples" || S == "Heatmap" ? parseInt(x + 1) : parseInt(b - T);
            c = M;
            n = o;
            W = X + (M - 1)
        }
        this.resizerEventData = {
            g: S,
            axis: B,
            dim: U,
            pos: K,
            l: O,
            vals: I,
            min: V,
            max: C,
            smin: i,
            smax: H,
            len: u,
            unit: R,
            width: N,
            set: J,
            c: z,
            i: t,
            j: r,
            areas: {
                org: [q, o, a, X],
                lim: [q, n, a, W],
                min: [G, F, m, k],
                max: [A, y, f, c],
                cur: [Q, P, E, D]
            }
        }
    };
    this.updateAxesResizer = function(v) {
        if (this.axesResizingOn) {
            if (!v) {
                v = window.event
            }
            var q = this.resizerEventData.areas;
            var A = this.adjustedCoordinates(v);
            if (A) {
                var n, B, b, c, a;
                var f = this.xMouseDown - A.x;
                var d = this.yMouseDown - A.y;
                var j, i;
                var s = null;
                var u = null;
                var z = "";
                var F = 14;
                var E = 9 - 1;
                var C = parseInt(E / 2);
                if (this.resizerEventData.g == "Heatmap") {
                    if (this.resizerEventData.dim == "y") {
                        n = this.isGroupedData ? this.data.w.smps.length : this.data.y ? this.data.y.smps.length : 0;
                        b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.isGroupedData ? this.data.w.smps.length : this.data.y.smps.length
                    } else {
                        n = this.data.y ? this.data.y.vars.length : 0;
                        b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.data.y.vars.length
                    }
                    B = this.resizerEventData.lastMin != null ? this.resizerEventData.lastMin : this.resizerEventData.smin != null ? this.resizerEventData.smin : 0;
                    a = this.resizerEventData.pos == "h" ? (q.org[1] - q.org[0]) / n : (q.org[3] - q.org[2]) / n
                } else {
                    n = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y ? this.data.y.smps.length - 1 : 0;
                    B = this.resizerEventData.lastMin != null ? this.resizerEventData.lastMin : this.resizerEventData.smin != null ? this.resizerEventData.smin : 0;
                    b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y.smps.length - 1;
                    a = this.resizerEventData.pos == "h" ? (q.org[1] - q.org[0]) / n : (q.org[3] - q.org[2]) / n
                } if (this.resizerEventData.active == "min") {
                    j = f > q.min[0] ? this.xMouseDown - q.min[0] : f < (q.min[0] + q.min[1]) - q.max[0] ? this.xMouseDown - ((q.min[0] + q.min[1]) - q.max[0]) : A.x;
                    i = d > q.min[2] - (q.max[2] + q.max[3]) ? this.yMouseDown - (q.min[2] - (q.max[2] + q.max[3])) : d < (q.lim[2] + q.min[2] + q.min[3]) - q.lim[3] ? (q.lim[3] - (q.lim[2] + q.min[2] + q.min[3])) + this.yMouseDown : A.y
                } else {
                    if (this.resizerEventData.active == "max") {
                        j = f > q.max[0] - (q.min[0] + q.min[1]) ? this.xMouseDown - (q.max[0] - (q.min[0] + q.min[1])) : f < (q.lim[0] + q.max[0] + q.max[1]) - q.lim[1] ? (q.lim[1] - (q.lim[0] + q.max[0] + q.max[1])) + this.xMouseDown : A.x;
                        i = d > q.max[2] ? this.yMouseDown - q.max[2] : d < (q.lim[2] + q.max[2] + q.max[3]) - (q.lim[2] + q.min[2]) ? ((q.lim[2] + q.min[2]) - (q.lim[2] + q.max[2] + q.max[3])) + this.yMouseDown : A.y
                    } else {
                        if (this.resizerEventData.active == "cur") {
                            j = f > q.min[0] ? this.xMouseDown - q.min[0] : f < (q.lim[0] + q.max[0] + q.max[1]) - q.lim[1] ? (q.lim[1] - (q.lim[0] + q.max[0] + q.max[1])) + this.xMouseDown : A.x;
                            i = d > q.max[2] ? this.yMouseDown - q.max[2] : d < (q.lim[2] + q.min[2] + q.min[3]) - q.lim[3] ? (q.lim[3] - (q.lim[2] + q.min[2] + q.min[3])) + this.yMouseDown : A.y
                        } else {
                            return
                        }
                    }
                }
                var m = j - this.xMouseDown;
                var k = i - this.yMouseDown;
                if (this.resizerType == "samples" || this.resizerEventData.g == "Heatmap") {
                    m -= m % a;
                    k -= k % a
                }
                var r = m / this.resizerEventData.unit;
                var p = k / this.resizerEventData.unit;
                var t = document.getElementById(this.target + "canvasXpressAxesResizeMin");
                var o = document.getElementById(this.target + "canvasXpressAxesResizeMax");
                var D = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
                var g = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
                if (t && o && D && g) {
                    if (this.resizerEventData.active == "min") {
                        if (this.resizerEventData.pos == "h") {
                            t.style.left = (q.min[0] + m) + "px";
                            D.style.left = ((q.min[0] + m) + ((q.cur[1] - m) / 2)) + "px";
                            g.style.left = (q.min[0] + m + C + 1) + "px";
                            g.style.width = (q.cur[1] - m) + "px";
                            B = parseInt((q.min[0] + E + m) / a);
                            if (this.resizerType == "samples") {
                                s = dateFormat(this.data.y.smps[B], this.timeFormat)
                            } else {
                                if (this.resizerEventData.g == "Heatmap") {
                                    s = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[B]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[B]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[B]]
                                } else {
                                    s = this.formatNumber(this.resizerEventData.smin + r)
                                }
                            }
                        } else {
                            t.style.top = (q.min[2] + k) + "px";
                            D.style.top = ((q.min[2] + k) - ((q.cur[3] + k) / 2)) + "px";
                            g.style.height = ((q.cur[3] + k)) + "px";
                            b = parseInt((q.min[2] + E + k) / a);
                            if (this.resizerType == "samples") {
                                s = dateFormat(this.data.y.smps[b], this.timeFormat)
                            } else {
                                if (this.resizerEventData.g == "Heatmap") {
                                    s = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
                                } else {
                                    s = this.formatNumber(this.resizerEventData.smin - p)
                                }
                            }
                        }
                        this.showInfoSpan(v, s)
                    } else {
                        if (this.resizerEventData.active == "max") {
                            if (this.resizerEventData.pos == "h") {
                                o.style.left = (q.max[0] + m) + "px";
                                D.style.left = ((q.min[0] + m) + ((q.cur[1] - m) / 2)) + "px";
                                g.style.width = (q.cur[1] + m) + "px";
                                b = parseInt((q.max[0] + E + m) / a);
                                if (this.resizerType == "samples") {
                                    u = dateFormat(this.data.y.smps[b], this.timeFormat)
                                } else {
                                    if (this.resizerEventData.g == "Heatmap") {
                                        u = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
                                    } else {
                                        u = this.formatNumber(this.resizerEventData.smax + r)
                                    }
                                }
                            } else {
                                o.style.top = (q.max[2] + k) + "px";
                                D.style.top = ((q.max[2] + k) + ((q.cur[3] - k) / 2)) + "px";
                                g.style.top = (q.max[2] + k + C) + "px";
                                g.style.height = (q.cur[3] - k) + "px";
                                B = parseInt((q.max[2] + E + k) / a);
                                if (this.resizerType == "samples") {
                                    u = dateFormat(this.data.y.smps[B], this.timeFormat)
                                } else {
                                    if (this.resizerEventData.g == "Heatmap") {
                                        u = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[B]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[B]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[B]]
                                    } else {
                                        u = this.formatNumber(this.resizerEventData.smax - p)
                                    }
                                }
                            }
                            this.showInfoSpan(v, u)
                        } else {
                            if (this.resizerEventData.active == "cur") {
                                if (this.resizerEventData.pos == "h") {
                                    t.style.left = (q.min[0] + m) + "px";
                                    D.style.left = ((q.min[0] + m) + (q.cur[1] / 2)) + "px";
                                    o.style.left = (q.max[0] + m) + "px";
                                    g.style.left = (q.min[0] + m + C + 1) + "px";
                                    B = parseInt((q.min[0] + E + m) / a);
                                    b = parseInt((q.max[0] + E + m) / a);
                                    if (this.resizerType == "samples") {
                                        s = dateFormat(this.data.y.smps[B], this.timeFormat);
                                        u = dateFormat(this.data.y.smps[b], this.timeFormat)
                                    } else {
                                        if (this.resizerEventData.g == "Heatmap") {
                                            s = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[B]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[B]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[B]];
                                            u = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
                                        } else {
                                            s = this.formatNumber(this.resizerEventData.smin + r);
                                            u = this.formatNumber(this.resizerEventData.smax + r)
                                        }
                                    }
                                    this.showInfoSpan(v, s + "--" + u)
                                } else {
                                    t.style.top = (q.min[2] + k) + "px";
                                    D.style.top = ((q.max[2] + k) + (q.cur[3] / 2)) + "px";
                                    o.style.top = (q.max[2] + k) + "px";
                                    g.style.top = (q.max[2] + k + C) + "px";
                                    b = parseInt((q.min[2] + E + k) / a);
                                    B = parseInt((q.max[2] + E + k) / a);
                                    if (this.resizerType == "samples") {
                                        s = dateFormat(this.data.y.smps[b], this.timeFormat);
                                        u = dateFormat(this.data.y.smps[B], this.timeFormat);
                                        this.showInfoSpan(v, u + "--" + s)
                                    } else {
                                        if (this.resizerEventData.g == "Heatmap") {
                                            s = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]];
                                            u = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[B]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[B]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[B]];
                                            this.showInfoSpan(v, u + "--" + s)
                                        } else {
                                            s = this.formatNumber(this.resizerEventData.smin - p);
                                            u = this.formatNumber(this.resizerEventData.smax - p);
                                            this.showInfoSpan(v, s + "--" + u)
                                        }
                                    }
                                }
                            }
                        }
                    }
                    this.resizerEventData.lastMin = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? B : s;
                    this.resizerEventData.lastMax = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? b : u;
                    if (this.resizerDraw) {
                        this.drawAxesResizerUpdate()
                    }
                }
            }
        }
    };
    this.drawAxesResizerUpdate = function(n) {
        var d = this.resizerEventData.lastMin != null ? parseFloat(this.resizerEventData.lastMin) : parseFloat(this.resizerEventData.smin);
        var k = this.resizerEventData.lastMax != null ? parseFloat(this.resizerEventData.lastMax) : parseFloat(this.resizerEventData.smax);
        var j = this.resizerEventData.c || 0;
        if (this.resizerType == "samples") {
            var m = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y.smps.length - 1;
            var a = [];
            var g = [];
            for (var f = 0; f < d; f++) {
                g.push(true)
            }
            for (var f = d; f <= k; f++) {
                a.push(f);
                g.push(false)
            }
            for (var f = k + 1; f < m; f++) {
                g.push(true)
            }
            if (this.isGroupedData) {
                this.grpIndices = a;
                this.hiddenGrps = g
            } else {
                this.smpIndices = a;
                this.hiddenSmps = g
            }
        } else {
            if (this.resizerEventData.g == "Heatmap") {
                if (!this.startingVarIndices || !this.startingSmpIndices) {
                    this.setOriginalIndices(j)
                }
                var b = this.startingVarIndices[j];
                var e = this.startingSmpIndices[j];
                if (this.resizerEventData.dim == "y") {
                    if (this.isGroupedData) {
                        if (this.layoutComb) {
                            this.layoutParams[j]["grpIndices"] = [];
                            for (var f = d; f < k; f++) {
                                this.layoutParams[j]["grpIndices"].push(e[f])
                            }
                            this.layoutParams[j]["smpIndicesStart"] = d
                        } else {
                            this.grpIndices = [];
                            for (var f = d; f < k; f++) {
                                this.grpIndices.push(e[f])
                            }
                            this.smpIndicesStart = d
                        }
                    } else {
                        if (this.layoutComb) {
                            this.layoutParams[j]["smpIndices"] = [];
                            for (var f = d; f < k; f++) {
                                this.layoutParams[j]["smpIndices"].push(e[f])
                            }
                            this.layoutParams[j]["smpIndicesStart"] = d
                        } else {
                            this.smpIndices = [];
                            for (var f = d; f < k; f++) {
                                this.smpIndices.push(e[f])
                            }
                            this.smpIndicesStart = d
                        }
                    }
                } else {
                    if (this.layoutComb) {
                        this.layoutParams[j]["varIndices"] = [];
                        for (var f = d; f < k; f++) {
                            this.layoutParams[j]["varIndices"].push(b[f])
                        }
                        this.layoutParams[j]["varIndicesStart"] = d
                    } else {
                        this.varIndices = [];
                        for (var f = d; f < k; f++) {
                            this.varIndices.push(b[f])
                        }
                        this.varIndicesStart = d
                    }
                }
            } else {
                if (this.resizerEventData.lastMin) {
                    this["setMin" + this.resizerEventData.set] = d
                }
                if (this.resizerEventData.lastMax) {
                    this["setMax" + this.resizerEventData.set] = k
                }
            }
        } if (n) {
            this.updateResizerEventData(d, k)
        }
        this.draw()
    };
    this.drawAxesResizerBackgroundData = function(d, p, b, o) {
        if (this.resizerType && this.resizerDataIndex > -1) {
            this.setAllSamplesVisible();
            var a, k, c, n;
            var m = this.graphType == "Candlestick" ? "close" : false;
            var g = [];
            var e = [];
            var q = [];
            for (var f = 0; f < this.smpIndices.length; f++) {
                g.push(this.getDataAtPos(this.resizerDataIndex, f, m))
            }
            var j = this.range(g);
            if (this.resizerPosition.match(/top|bottom/)) {
                a = b / (this.smpIndices.length - 1);
                k = o / ((j[1] - j[0]) * 1.2);
                c = (j[1] - j[0]) * 0.1 * k;
                n = p + o;
                e.push(d);
                q.push(n);
                for (var f = 0; f < g.length; f++) {
                    e.push(d);
                    q.push(n - (((g[f] - j[0]) * k) + c));
                    d += a
                }
                d -= a;
                e.push(d);
                q.push(n)
            } else {
                a = o / (this.smpIndices.length - 1);
                k = b / ((j[1] - j[0]) * 1.2);
                c = (j[1] - j[0]) * 0.1 * k;
                e.push(d);
                q.push(p);
                for (var f = 0; f < g.length; f++) {
                    e.push(d + ((g[f] - j[0]) * k) + c);
                    q.push(p);
                    p += a
                }
                p -= a;
                e.push(d);
                q.push(p)
            }
            this.drawShape("polygon", e, q, false, false, this.resizerBackgroundColorCurrent, this.resizerBackgroundColorOutlineCurrent, "closed")
        }
    };
    this.drawAxesResizerMasks = function() {
        if (this.resizerType) {
            var e, i, d, f;
            var c = this.resizerEventData.areas;
            var b = this.isGroupedData ? this.data.w.grps.length - 1 : this.data.y.smps.length - 1;
            var a = this.resizerEventData.pos == "h" ? (c.org[1] - c.org[0]) / b : (c.org[3] - c.org[2]) / b;
            var g = 9 - 1;
            if (this.resizerEventData.pos == "h") {
                if (this.resizerEventData.smin > 0) {
                    e = c.org[0] - 1;
                    i = c.org[2] - this.resizerWidth;
                    d = a * this.resizerEventData.smin;
                    f = this.resizerWidth;
                    this.rectangle(e, i, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
                    this.drawLine("line", e, i, e + d + 1, i, this.foreground);
                    this.drawLine("line", e + d, i, e + d, i + f, this.foreground)
                }
                if (this.resizerEventData.smax < b) {
                    e = c.org[0] + c.max[0] + 1;
                    i = c.org[2] - this.resizerWidth;
                    d = (a * (b - this.resizerEventData.smax)) + 1;
                    f = this.resizerWidth;
                    this.rectangle(e, i, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
                    this.drawLine("line", e - 1, i, e + d + 2, i, this.foreground);
                    this.drawLine("line", e - 1, i, e - 1, i + f, this.foreground)
                }
                e = c.org[0] + c.max[0];
                i = c.org[2] - 1;
                d = c.org[0] + a * this.resizerEventData.smin;
                this.drawLine("line", e, i, d, i, this.foreground)
            } else {
                if (this.resizerEventData.smin > 0) {
                    e = c.org[0] + 14;
                    i = c.org[2];
                    d = this.resizerWidth;
                    f = a * this.resizerEventData.smin;
                    this.rectangle(e, i, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
                    this.drawLine("line", e, i + f, e + d, i + f, this.foreground);
                    this.drawLine("line", e + d, i, e + d, i + f, this.foreground)
                }
                if (this.resizerEventData.smax < b) {
                    e = c.org[0] + 14;
                    i = c.org[2] + c.min[2];
                    d = this.resizerWidth;
                    f = (b - this.resizerEventData.smax) * a;
                    this.rectangle(e, i, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
                    this.drawLine("line", e, i, e + d, i, this.foreground);
                    this.drawLine("line", e + d, i, e + d, i + f, this.foreground)
                }
                e = c.org[0] + 14;
                i = c.org[2] + c.min[2];
                f = c.org[2] + (a * this.resizerEventData.smin);
                this.drawLine("line", e, i, e, f, this.foreground)
            }
        }
    };
    this.registerAxesResizer = function(d) {
        if (!d) {
            d = window.event
        }
        var i = this.adjustedCoordinates(d);
        if (i) {
            var g = i.x;
            var f = i.y;
            var c = this.resizerEventData.areas;
            var k = c.lim[1] - c.lim[0];
            var j = c.lim[3] - c.lim[2];
            var a = 5;
            var b = k > j ? "h" : "v";
            if (g >= c.min[0] + c.lim[0] && g <= c.min[0] + c.min[1] + c.lim[0] && f >= c.min[2] + c.lim[2] && f <= c.min[2] + c.min[3] + c.lim[2]) {
                this.resizerEventData.active = "min";
                this.axesResizingOn = true
            } else {
                if (g >= c.max[0] + c.lim[0] && g <= c.max[0] + c.max[1] + c.lim[0] && f >= c.max[2] + c.lim[2] && f <= c.max[2] + c.max[3] + c.lim[2]) {
                    this.resizerEventData.active = "max";
                    this.axesResizingOn = true
                } else {
                    if (g >= c.cur[0] + c.lim[0] && g <= c.cur[0] + c.cur[1] + c.lim[0] && f >= c.cur[2] + c.lim[2] && f <= c.cur[2] + c.cur[3] + c.lim[2]) {
                        this.resizerEventData.active = "cur";
                        this.axesResizingOn = true
                    } else {
                        if (b == "h") {
                            if (g >= c.lim[0] && g < c.min[0] + c.lim[0]) {
                                this.resizerEventData.active = "prev";
                                this.axesResizingOn = true
                            } else {
                                if (g > c.lim[0] + c.max[0] + c.max[1] && g <= c.lim[1] - a) {
                                    this.resizerEventData.active = "next";
                                    this.axesResizingOn = true
                                }
                            }
                        } else {
                            if (f >= c.lim[2] + c.min[2] + c.min[3] && f <= c.lim[2] + c.lim[3]) {
                                this.resizerEventData.active = "prev";
                                this.axesResizingOn = true
                            } else {
                                if (f >= c.lim[2] && f <= c.lim[2] + c.max[2]) {
                                    this.resizerEventData.active = "next";
                                    this.axesResizingOn = true
                                }
                            }
                        }
                    }
                }
            }
            this.xMouseDown = g;
            this.yMouseDown = f
        }
    };
    this.activateDeactivateAxesResizer = function(j) {
        if (!j) {
            j = window.event
        }
        var s = this.adjustedCoordinates(j);
        if (s) {
            var q;
            var r = s.x;
            var m = s.y;
            var i = this.resizerEventData.areas;
            var u = i.lim[1] - i.lim[0];
            var t = i.lim[3] - i.lim[2];
            var c = 5;
            var f = u > t ? "h" : "v";
            if (f == "h") {
                if (r >= i.lim[0] && r <= i.lim[0] + i.min[0]) {
                    q = "prev"
                } else {
                    if (r >= i.lim[0] + i.max[0] + i.max[1] && r <= i.lim[1] - c) {
                        q = "next"
                    }
                }
            } else {
                if (m >= i.lim[2] + i.min[2] + i.min[3] && m <= i.lim[2] + i.lim[3]) {
                    q = "prev"
                } else {
                    if (m >= i.lim[2] && m <= i.lim[2] + i.max[2]) {
                        q = "next"
                    }
                }
            }
            var d = document.getElementById(this.target + "canvasXpressAxesResizePrevious");
            var g = document.getElementById(this.target + "canvasXpressAxesResizeNext");
            if (d && g) {
                if (q == "prev") {
                    var k = d.style.backgroundImage;
                    if (j.type.match(/mouseout|touchcancel/i)) {
                        if (k.match(/_active.png/)) {
                            d.style.backgroundImage = k.replace("_active.png", ".png")
                        }
                    } else {
                        if (!k.match(/_active.png/)) {
                            d.style.backgroundImage = k.replace(".png", "_active.png")
                        }
                    }
                } else {
                    if (q == "next") {
                        var k = g.style.backgroundImage;
                        if (j.type.match(/mouseout|touchcancel/i)) {
                            if (k.match(/_active.png/)) {
                                g.style.backgroundImage = k.replace("_active.png", ".png")
                            }
                        } else {
                            if (!k.match(/_active.png/)) {
                                g.style.backgroundImage = k.replace(".png", "_active.png")
                            }
                        }
                    } else {
                        var k = d.style.backgroundImage;
                        if (k.match(/_active.png/)) {
                            d.style.backgroundImage = k.replace("_active.png", ".png")
                        }
                        k = g.style.backgroundImage;
                        if (k.match(/_active.png/)) {
                            g.style.backgroundImage = k.replace("_active.png", ".png")
                        }
                    }
                }
            }
            return false
        }
    };
    this.moveAxesResizer = function(k) {
        var g = this.resizerEventData.smin;
        var m = this.resizerEventData.smax;
        var c = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? 1 : (m - g) / 10;
        if ((this.resizerType == "samples" || this.resizerEventData.g == "Heatmap") && this.resizerEventData.pos == "v") {
            if (this.resizerEventData.active == "prev") {
                if (g + c < this.resizerEventData.min) {
                    c = g - this.resizerEventData.min;
                    this.resizerEventData.lastMin = this.resizerEventData.min;
                    this.resizerEventData.lastMax = m + c
                } else {
                    this.resizerEventData.lastMin = g + c;
                    this.resizerEventData.lastMax = m + c
                }
            } else {
                if (m - c > this.resizerEventData.max) {
                    c = this.resizerEventData.max - m;
                    this.resizerEventData.lastMin = g - c;
                    this.resizerEventData.lastMax = this.resizerEventData.max
                } else {
                    this.resizerEventData.lastMin = g - c;
                    this.resizerEventData.lastMax = m - c
                }
            }
        } else {
            if (this.resizerEventData.active == "prev") {
                if (g - c < this.resizerEventData.min) {
                    c = g - this.resizerEventData.min;
                    this.resizerEventData.lastMin = this.resizerEventData.min;
                    this.resizerEventData.lastMax = m - c
                } else {
                    this.resizerEventData.lastMin = g - c;
                    this.resizerEventData.lastMax = m - c
                }
            } else {
                if (m + c > this.resizerEventData.max) {
                    c = this.resizerEventData.max - m;
                    this.resizerEventData.lastMin = g + c;
                    this.resizerEventData.lastMax = this.resizerEventData.max
                } else {
                    this.resizerEventData.lastMin = g + c;
                    this.resizerEventData.lastMax = m + c
                }
            }
        }
        var f = this.resizerEventData.areas;
        var d = document.getElementById(this.target + "canvasXpressAxesResizeMin");
        var o = document.getElementById(this.target + "canvasXpressAxesResizeMax");
        var n = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
        var j = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
        var b = 14;
        var a = 9 - 1;
        var p = parseInt(a / 2);
        var i = c * this.resizerEventData.unit;
        if ((this.resizerEventData.pos == "h" && this.resizerEventData.active == "prev") || (this.resizerEventData.pos == "v" && this.resizerEventData.active == "next")) {
            i *= -1
        }
        if (this.resizerEventData.pos == "h") {
            d.style.left = (f.min[0] + i + 1) + "px";
            n.style.left = ((f.min[0] + i) + (f.cur[1] / 2)) + "px";
            o.style.left = (f.max[0] + i) + "px";
            j.style.left = (f.min[0] + i + p + 1) + "px"
        } else {
            d.style.top = (f.min[2] + i + 1) + "px";
            n.style.top = ((f.max[2] + i) + (f.cur[3] / 2)) + "px";
            o.style.top = (f.max[2] + i) + "px";
            j.style.top = (f.max[2] + i + p + 1) + "px"
        }
    };
    this.getAxesVals = function(e) {
        var d = ["minData", "maxData", "xAxisMin", "xAxisMax", "xAxis2Min", "xAxis2Max", "yAxisMin", "yAxisMax", "zAxisMin", "zAxisMax", "xAxisUnit", "xAxis2Unit", "yAxisUnit", "zAxisUnit", "setMin", "setMax", "setMin2", "setMax2", "setMinX", "setMaxX", "setMinY", "setMaxY", "setMinZ", "setMaxZ", "xAxisAbsMin", "xAxisAbsMax", "xAxis2AbsMin", "xAxis2AbsMax", "yAxisAbsMin", "yAxisAbsMax", "zAxisAbsMin", "zAxisAbsMax", "graphType", "x", "y", "varIndices", "smpIndices", "grpIndices", "varIndicesStart", "smpIndicesStart"];
        var b = {};
        if (this.layoutComb) {
            for (var a = 0; a < d.length; a++) {
                b[d[a]] = this.layoutParams[e][d[a]]
            }
        } else {
            for (var a = 0; a < d.length; a++) {
                b[d[a]] = this[d[a]]
            }
        }
        return b
    };
    this.isAxis = function(k) {
        if (!k) {
            k = window.event
        }
        if (this.resizerType && this.layoutValid) {
            return false
        }
        var t = this.adjustedCoordinates(k);
        if (t) {
            var r = t.x;
            var p = t.y;
            var n = 0;
            var s = (this.margin * 1);
            var q = (this.margin * 2);
            var a = 18;
            for (var d = 0; d < this.layoutRows; d++) {
                for (var b = 0; b < this.layoutCols; b++) {
                    var f = this.layoutComb ? this.layoutParams[n].graphType : this.graphType;
                    if (f.match(/Network|Pie|Venn|Stacked|Area|Correlation|Circular/)) {
                        return false
                    }
                    var m = this.getBoundsXY(n);
                    if (f.match(/Scatter/)) {
                        if (r >= m[0] && r <= m[1] && p >= m[3] && p <= m[3] + a) {
                            var o = this.getAxesVals(n);
                            this.showAxesResizer("xAxis", m[0], m[1], m[3] + s, m[3] + this.getAxisFont(o.x) + q, "x", "h", "b", o, "X", n, d, b);
                            return true
                        } else {
                            if (r >= m[0] - a && r <= m[0] && p >= m[2] && p <= m[3]) {
                                var o = this.getAxesVals(n);
                                this.showAxesResizer("yAxis", m[0] - (this.getAxisFont(o.y) + q), m[0] - s, m[2], m[3], "y", "v", "l", o, "Y", n, d, b);
                                return true
                            }
                        }
                    } else {
                        if (f.match(/Heatmap/)) {
                            if (r >= m[0] - a && r <= m[0] && p >= m[2] && p <= m[3]) {
                                var o = this.getAxesVals(n);
                                this.showAxesResizer("xAxis", m[0] - (this.getAxisFont(o.y) + q), m[0] - s, m[2], m[3], "y", "v", "l", o, "", n, d, b);
                                return true
                            } else {
                                if (r >= m[1] && r <= m[1] + a && p >= m[2] && p <= m[3]) {
                                    var o = this.getAxesVals(n);
                                    this.showAxesResizer("xAxis", m[1] + s, m[1] + this.getAxisFont(o.y) + q, m[2], m[3], "y", "v", "r", o, "", n, d, b);
                                    return true
                                } else {
                                    if (r >= m[0] && r <= m[1] && p >= m[2] - a && p <= m[2]) {
                                        var o = this.getAxesVals(n);
                                        this.showAxesResizer("xAxis", m[0], m[1], m[2] - (this.getAxisFont(o.x) + q), m[2] - s, "x", "h", "t", o, "", n, d, b);
                                        return true
                                    } else {
                                        if (r >= m[0] && r <= m[1] && p >= m[3] && p <= m[3] + a) {
                                            var o = this.getAxesVals(n);
                                            this.showAxesResizer("xAxis", m[0], m[1], m[3] + s, m[3] + this.getAxisFont(o.x) + q, "x", "h", "b", o, "", n, d, b);
                                            return true
                                        }
                                    }
                                }
                            }
                        } else {
                            if (this.graphOrientation == "vertical") {
                                if (r >= m[0] - a && r <= m[0] && p >= m[2] && p <= m[3]) {
                                    var o = this.getAxesVals(n);
                                    this.showAxesResizer("xAxis", m[0] - (this.getAxisFont(o.y) + q), m[0] - s, m[2], m[3], "y", "v", "l", o, "", n, d, b);
                                    return true
                                } else {
                                    if (r >= m[1] && r <= m[1] + a && p >= m[2] && p <= m[3]) {
                                        var o = this.getAxesVals(n);
                                        if (f == "BarLine") {
                                            this.showAxesResizer("xAxis2", m[1] + s, m[1] + this.getAxisFont(o.y) + q, m[2], m[3], "y", "v", "r", o, "2", n, d, b)
                                        } else {
                                            this.showAxesResizer("xAxis", m[1] + s, m[1] + this.getAxisFont(o.y) + q, m[2], m[3], "y", "v", "r", o, "", n, d, b)
                                        }
                                        return true
                                    }
                                }
                            } else {
                                if (r >= m[0] && r <= m[1] && p >= m[2] - a && p <= m[2]) {
                                    var o = this.getAxesVals(n);
                                    this.showAxesResizer("xAxis", m[0], m[1], m[2] - (this.getAxisFont(o.x) + q), m[2] - s, "x", "h", "t", o, "", n, d, b);
                                    return true
                                } else {
                                    if (r >= m[0] && r <= m[1] && p >= m[3] && p <= m[3] + a) {
                                        var o = this.getAxesVals(n);
                                        if (f == "BarLine") {
                                            this.showAxesResizer("xAxis2", m[0], m[1], m[3] + s, m[3] + this.getAxisFont(o.x) + q, "x", "h", "b", o, "2", n, d, b)
                                        } else {
                                            this.showAxesResizer("xAxis", m[0], m[1], m[3] + s, m[3] + this.getAxisFont(o.x) + q, "x", "h", "b", o, "", n, d, b)
                                        }
                                        return true
                                    }
                                }
                            }
                        }
                    }
                    n++
                }
            }
        }
        return false
    };
    this.endAxesResizer = function(a) {
        if (this.axesResizingOn) {
            this.resetInfoSpan(a);
            if (this.resizerEventData.active == "prev" || this.resizerEventData.active == "next") {
                this.moveAxesResizer(a)
            }
            this.drawAxesResizerUpdate(true);
            this.axesResizingOn = false
        } else {
            if (this.resizerType) {
                this.updateResizerEventData();
                this.refreshAxesResizer()
            }
        }
    };
    this.resetAxesResizer = function(b) {
        if (this.axesResizerShow) {
            var a = document.getElementById(this.target + "canvasXpressAxesResize");
            if (a) {
                this.addRemoveAxesResizerListeners("removeEvtListener");
                a.style.display = "none";
                this.resizerEventData = {};
                this.resetInfoSpan(b);
                this.axesResizerShow = false
            }
        }
    };
    this.initializeAxisResizerEvents = function() {
        if (!this.disableEvents) {
            this.addAxesResizeDiv()
        }
    };
    this.initializeAxisResizerEvents()
};
CanvasXpress.prototype.initDraggingEvents = function() {
    this.addDragDiv = function() {
        if (this.$(this.target + "-cX-Drag")) {
            return
        }
        var a = this.$cX("div", {
            id: this.target + "-cX-Drag",
            className: "CanvasXpressDrag"
        }, {
            width: "0px",
            height: "0px",
            zIndex: 9000
        });
        this.canvas.parentNode.appendChild(a)
    };
    this.registerDragNetwork = function(l) {
        var c, j, f;
        var k = this.isEvent(l, true);
        var b = this.getTargetEvent(l);
        var a = k[1];
        if (a && a.match(/-legend-/)) {
            if (a.match(/-legend-Nodes/)) {
                this.moveLegend = "Nodes"
            } else {
                if (a.match(/-legend-Edges/)) {
                    this.moveLegend = "Edges"
                } else {
                    if (a.match(/-legend-Decorations/)) {
                        this.moveLegend = "Decorations"
                    } else {
                        this.moveLegend = a.split(/-legend-/)[1]
                    }
                }
            }
        } else {
            if (a && a.match(/-lab$/)) {
                if (l.shiftKey) {
                    j = true
                }
                c = k[0][0]
            } else {
                if (a && a.match(/-dec$/)) {
                    if (l.shiftKey) {
                        c = k[0][0];
                        f = true
                    } else {
                        this.resetDrag(l);
                        this.resetFlags(l)
                    }
                } else {
                    c = k ? k[0][0] : "NaN"
                }
            } if (!isNaN(c) && c < this.data.nodes.length) {
                b.style.cursor = "move";
                this.moveNode = true;
                this.moveNodeIndex = c;
                if (j) {
                    this.moveNodeLab = true
                } else {
                    if (f) {
                        this.moveNodeDec = true
                    }
                }
                var d = this.data.nodes[this.moveNodeIndex];
                this.moveNodeW = d.width ? d.width : d.size ? (this.nodeSize * d.size) : this.nodeSize;
                this.moveNodeH = d.height ? d.height : d.size ? (this.nodeSize * d.size) : this.nodeSize;
                if (this.moveNodeLab) {
                    this.moveNodeX = d.labelX != null ? d.labelX - ((this.xMouseDown / this.scaleFactor) - this.offsetX) : 0;
                    this.moveNodeY = d.labelY != null ? d.labelY - ((this.yMouseDown / this.scaleFactor) - this.offsetY) : 0
                } else {
                    if (this.moveNodeDec) {
                        this.moveNodeX = d.decorationsX ? d.decorationsX - ((this.xMouseDown / this.scaleFactor) - this.offsetX) : 0;
                        this.moveNodeY = d.decorationsY ? d.decorationsY - ((this.yMouseDown / this.scaleFactor) - this.offsetY) : 0
                    } else {
                        if (this.is3DNetwork) {
                            this.moveNodeX = d.x3d - ((this.xMouseDown / this.scaleFactor) - this.offsetX);
                            this.moveNodeY = d.y3d - ((this.yMouseDown / this.scaleFactor) - this.offsetY)
                        } else {
                            this.moveNodeX = d.x - ((this.xMouseDown / this.scaleFactor) - this.offsetX);
                            this.moveNodeY = d.y - ((this.yMouseDown / this.scaleFactor) - this.offsetY)
                        }
                    }
                }
            }
        } if (this.networkStack.length < 1 || this.networkStack.length - 1 != this.networkStackIndex) {
            var h = this.cloneObject(this.networkStack);
            var m = this.networkStackIndex;
            this.clearNetworkStack();
            for (var g = 0; g < m; g++) {
                this.networkStack.push(this.cloneObject(h[g]))
            }
            this.addToNetworkStack();
            h = false
        }
    };
    this.registerDragGenome = function(b) {
        var a = this.isEvent(b, true);
        if (a && isNaN(a[0][0])) {
            this.moveGenome = a[0][0]
        } else {
            this.moveGenome = false
        }
    };
    this.registerDrag = function(n) {
        if (!n) {
            n = window.event
        }
        if (this.isCanvasResize(n)) {
            this.resizingCanvasOn = true;
            this.hideViewport()
        } else {
            if (!n) {
                return false
            }
            if (!this.touches) {
                this.touches = []
            }
            var a = this.getTargetEvent(n);
            var s = this.adjustedCoordinates(n);
            if (s) {
                CanvasXpress.current = a.id;
                var f = s.x;
                var u = s.y;
                var r = 0;
                for (var k = 0; k < this.layoutRows; k++) {
                    for (var h = 0; h < this.layoutCols; h++) {
                        var m = this.layoutComb ? this.layoutParams[r].graphType : this.graphType;
                        var q = this.getBoundsXY(r);
                        if (m.match(/Correlation|Pie|Venn|Stacked|Area|Circular|Treemap/)) {
                            if (this.mobileApp) {
                                if (f >= q[0] && f <= q[1] && u >= q[2] && u <= q[3] || this.moveGenome) {
                                    this.skipClick = false;
                                    this.draggingOn = true;
                                    this.xMouseDown = f;
                                    this.yMouseDown = u;
                                    this.touches.push([f, u, new Date().getTime()]);
                                    return false
                                }
                            } else {
                                return false
                            }
                        } else {
                            if (m == "Genome") {
                                this.registerDragGenome(n)
                            }
                        } if (f >= q[0] && f <= q[1] && u >= q[2] && u <= q[3] || this.moveGenome) {
                            this.skipClick = false;
                            this.draggingOn = true;
                            this.xMouseDown = f;
                            this.yMouseDown = u;
                            this.touches.push([f, u, new Date().getTime()]);
                            var p = this.$(this.target + "-cX-Drag");
                            if (m == "Network") {
                                this.registerDragNetwork(n)
                            }
                            if ((!m.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && !n.shiftKey) || (!m.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && n.shiftKey)) {
                                p.style.left = q[0] + "px"
                            } else {
                                p.style.left = this.xMouseDown + "px"
                            } if ((!m.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && !n.shiftKey) || (!m.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && n.shiftKey) || m == "Genome") {
                                p.style.top = q[2] + "px"
                            } else {
                                p.style.top = this.yMouseDown + "px"
                            } if (this.layoutValid) {
                                this.layoutValidR = k;
                                this.layoutValidC = h;
                                this.layoutValidN = r
                            }
                            return false
                        } else {
                            if (f >= q[4] && f <= q[5] && u >= q[6] && u <= q[7]) {
                                var b = this.isEvent(n);
                                if (b) {
                                    this.skipClick = false;
                                    this.draggingOn = true;
                                    this.xMouseDown = f;
                                    this.yMouseDown = u;
                                    this.touches.push([f, u, new Date().getTime()]);
                                    var p = this.$(this.target + "-cX-Drag");
                                    if (b[0].match("Smp")) {
                                        this.moveSmp = b[0];
                                        if (m.match(/Heatmap/) || this.graphOrientation == "horizontal") {
                                            p.style.left = q[4] + "px";
                                            p.style.width = (q[5] - q[4]) + "px";
                                            p.style.height = "3px"
                                        } else {
                                            p.style.width = "3px";
                                            p.style.top = q[6] + "px";
                                            p.style.height = (q[7] - q[6]) + "px"
                                        }
                                    } else {
                                        if (b[0].match("Var")) {
                                            this.moveVar = b[0];
                                            p.style.width = "3px";
                                            p.style.top = q[6] + "px";
                                            p.style.height = (q[7] - q[6]) + "px"
                                        }
                                    }
                                    return false
                                }
                            }
                        }
                        r++
                    }
                }
                return false
            }
        }
    };
    this.updateDragScatter3D = function(b, f, e, d, k) {
        if (this.mobileApp && this.touches && this.touches.length > 1) {
            return
        }
        var g = this;
        var h = this.mobileApp ? 100 : 1;
        var a = function() {
            clearTimeout(a);
            var i = g.xMouseDown;
            var n = g.yMouseDown;
            var c = b;
            var m = f;
            var j = g.lineLength(i, n, c, m);
            var p = g.layoutComb ? g.layoutParams[k].x : g.x;
            var l = g.layoutComb ? g.layoutParams[k].y : g.y;
            var r = ((c - i) * g.rotationSensitivity) / p;
            var q = ((m - n) * g.rotationSensitivity) / l;
            var o = (j * g.rotationSensitivity) / p;
            g.xRotate -= r;
            g.yRotate += q;
            g.zRotate -= o;
            g.draw();
            g.skipClick = true
        };
        setTimeout(a, h)
    };
    this.updateDragNetwork = function(D, r, n, z, v, E) {
        if (this.mobileApp && this.touches && this.touches.length > 1) {
            return
        }
        this.movingOn = true;
        var d = r;
        var b = n;
        var q, m, f, o, s, u;
        var B = this.getTargetEvent(D);
        var p = {};
        if (this.moveNode || this.moveLegend) {
            if (this.moveLegend) {
                if (this.moveLegend == "Nodes") {
                    m = this.data.legend.pos.nodes.x - ((d / this.scaleFactor) - this.offsetX);
                    f = this.data.legend.pos.nodes.y - ((b / this.scaleFactor) - this.offsetY);
                    this.data.legend.pos.nodes.x -= m;
                    this.data.legend.pos.nodes.y -= f
                } else {
                    if (this.moveLegend == "Edges") {
                        m = this.data.legend.pos.edges.x - ((d / this.scaleFactor) - this.offsetX);
                        f = this.data.legend.pos.edges.y - ((b / this.scaleFactor) - this.offsetY);
                        this.data.legend.pos.edges.x -= m;
                        this.data.legend.pos.edges.y -= f
                    } else {
                        if (this.moveLegend == "Decorations") {
                            m = this.data.legend.pos.decorations.x - ((d / this.scaleFactor) - this.offsetX);
                            f = this.data.legend.pos.decorations.y - ((b / this.scaleFactor) - this.offsetY);
                            this.data.legend.pos.decorations.x -= m;
                            this.data.legend.pos.decorations.y -= f
                        } else {
                            o = parseInt(this.moveLegend.replace("Text", ""));
                            m = this.data.legend.text[o].x - ((d / this.scaleFactor) - this.offsetX);
                            f = this.data.legend.text[o].y - ((b / this.scaleFactor) - this.offsetY);
                            this.data.legend.text[o].x -= m;
                            this.data.legend.text[o].y -= f
                        }
                    }
                }
            } else {
                if (this.data.nodes[this.moveNodeIndex]) {
                    q = this.data.nodes[this.moveNodeIndex];
                    if (this.is3DNetwork) {
                        m = (q.x3d - ((d / this.scaleFactor) - this.offsetX)) - this.moveNodeX;
                        f = (q.y3d - ((b / this.scaleFactor) - this.offsetY)) - this.moveNodeY
                    } else {
                        m = (q.x - ((d / this.scaleFactor) - this.offsetX)) - this.moveNodeX;
                        f = (q.y - ((b / this.scaleFactor) - this.offsetY)) - this.moveNodeY
                    } if (this.moveNodeLab) {
                        m = q.labelX != null ? (q.labelX - ((d / this.scaleFactor) - this.offsetX)) - this.moveNodeX : m;
                        f = q.labelY != null ? (q.labelY - ((b / this.scaleFactor) - this.offsetY)) - this.moveNodeY : f;
                        this.modifyXYNodeLab(q.id, m, f)
                    } else {
                        if (this.moveNodeDec) {
                            m = q.decorationsX ? (q.decorationsX - ((d / this.scaleFactor) - this.offsetX)) - this.moveNodeX : m;
                            f = q.decorationsY ? (q.decorationsY - ((b / this.scaleFactor) - this.offsetY)) - this.moveNodeY : f;
                            this.modifyXYNodeDec(q.id, m, f)
                        } else {
                            if (D.shiftKey && !D.ctrlKey) {
                                var g = (this.moveNodeW - m) + ((r - this.xMouseDown) / this.scaleFactor);
                                var A = (this.moveNodeH - f) + ((n - this.yMouseDown) / this.scaleFactor);
                                this.modifyNodeSize(q.id, Math.abs(g), Math.abs(A));
                                for (var o in this.selectNode) {
                                    if (o != q.id) {
                                        this.modifyNodeSize(o, g, A)
                                    }
                                }
                            } else {
                                u = this.findParentNodes(q.id);
                                if (this.networkLayoutType != "radial" && ((this.moveParentsWithChildren && !D.shiftKey && !D.ctrlKey) || (!this.moveParentsWithChildren && D.shiftKey && D.ctrlKey)) && u) {
                                    q = this.data.nodes[this.data.nodeIndices[u[0]]]
                                }
                                this.modifyXYNode(q.id, m, f);
                                if (this.selectNode) {
                                    p[q.id] = true;
                                    u = this.findChildrenNodeIndices(q.id);
                                    if (u) {
                                        for (var s = 0; s < u.length; s++) {
                                            p[this.data.nodes[u[s]].id] = true
                                        }
                                    }
                                    for (var o in this.selectNode) {
                                        if (!p.hasOwnProperty(o)) {
                                            var C = this.data.nodes[this.data.nodeIndices[o]];
                                            u = this.findParentNodes(C.id);
                                            if (this.networkLayoutType != "radial" && ((this.moveParentsWithChildren && !D.shiftKey && !D.ctrlKey) || (!this.moveParentsWithChildren && D.shiftKey && D.ctrlKey)) && u) {
                                                C = this.data.nodes[this.data.nodeIndices[u[0]]]
                                            }
                                            this.modifyXYNode(C.id, m, f);
                                            p[C.id] = true;
                                            u = this.findChildrenNodeIndices(C.id);
                                            if (u) {
                                                for (var s = 0; s < u.length; s++) {
                                                    p[this.data.nodes[u[s]].id] = true
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            this.panningX = ((r - this.xMouseDown) / this.scaleFactor);
            this.panningY = ((n - this.yMouseDown) / this.scaleFactor)
        }
        this.skipClick = m != null || f != null ? true : false;
        this.draw(false, false, false, true);
        if (this.is3DNetwork && q) {
            this.moveNodeIndex = this.data.nodeIndices[q.id]
        }
        var a = this.$(B.id);
        if (a) {
            a.style.cursor = D.shiftKey ? "se-resize" : "move"
        }
    };
    this.updateDragGenome = function(h, a, g, f, b, m) {
        if (this.mobileApp && this.touches && this.touches.length > 1) {
            return
        }
        if (this.moveGenome) {
            this.movingOn = true;
            var k = this.$(this.target + "-cX-Drag");
            k.style.left = "0px";
            k.style.width = this.width + "px";
            k.style.top = g + "px";
            k.style.height = "3px"
        } else {
            var k = (a - this.xMouseDown) / this.xAxisUnit;
            if (this.setMinX == null) {
                this.setMinX = this.xAxisMin
            }
            if (this.setMaxX == null) {
                this.setMaxX = this.xAxisMax
            }
            this.setMinX -= k;
            this.setMaxX -= k;
            this.draw();
            this.xMouseDown = a
        }
    };
    this.updateDrag = function(k) {
        if (this.draggingOn) {
            if (!k) {
                k = window.event
            }
            var u = this.adjustedCoordinates(k);
            if (this.resetOn) {
                this.resetOn = false;
                this.stopEvent(k);
                return
            }
            if (u) {
                this.touchEvent = "drag";
                var a = u.x;
                var v = u.y;
                var f = this.layoutValidR;
                var b = this.layoutValidC;
                var o = this.layoutValidN || 0;
                var h = this.layoutComb ? this.layoutParams[o].graphType : this.graphType;
                var q = this.layoutComb ? this.layoutParams[o].varIndices : this.varIndices;
                var s;
                if (this.isGroupedData) {
                    s = this.layoutComb ? this.layoutParams[o].grpIndices : this.grpIndices
                } else {
                    s = this.layoutComb ? this.layoutParams[o].smpIndices : this.smpIndices
                } if (h.match(/Correlation|Pie|Venn|Stacked|Area|Circular|Treemap/)) {
                    if (this.mobileApp) {
                        this.movingOn = true;
                        this.resetOn = false
                    }
                    return false
                }
                if ((h == "Scatter3D" && !k.shiftKey) || this.is3DPlot) {
                    this.updateDragScatter3D(a, v, f, b, o)
                } else {
                    if (h == "Network" && ((this.moveNode || this.moveLegend) || (!k.ctrlKey && !k.shiftKey && !k.altKey))) {
                        this.updateDragNetwork(k, a, v, f, b, o)
                    } else {
                        if (h == "Genome" && (this.moveGenome || !k.shiftKey)) {
                            this.updateDragGenome(k, a, v, f, b, o)
                        } else {
                            if (this.moveVar || this.moveSmp) {
                                var n = this.getBoundsXY(o);
                                var m = this.$(this.target + "-cX-Drag");
                                this.skipClick = true;
                                if (a >= n[4] && a <= n[5] && v >= n[6] && v <= n[7]) {
                                    if (this.moveSmp) {
                                        if (h.match(/Heatmap/) || this.graphOrientation == "horizontal") {
                                            m.style.top = v + "px"
                                        } else {
                                            m.style.left = a + "px"
                                        }
                                    } else {
                                        m.style.left = a + "px"
                                    }
                                }
                            } else {
                                if (this.mobileApp && this.touches && this.touches.length > 1) {
                                    return
                                }
                                var p;
                                if (this.varIndicesStart > 0 || this.smpIndicesStart > 0) {
                                    p = true
                                } else {
                                    if (this.varIndicesStart == 0 && this.startingVarIndices && this.startingVarIndices[o]) {
                                        if (this.varIndicesStart + q.length < this.startingVarIndices[o].length) {
                                            p = true
                                        } else {
                                            p = false
                                        }
                                    } else {
                                        if (this.smpIndicesStart == 0 && this.startingSmpIndices && this.startingSmpIndices[o]) {
                                            if (this.smpIndicesStart + s.length < this.startingSmpIndices[o].length) {
                                                p = true
                                            } else {
                                                p = false
                                            }
                                        } else {
                                            p = false
                                        }
                                    }
                                } if (h.match(/Heatmap|Bar|Line|Dotplot|Boxplot/) && p) {
                                    this.panningOn = true;
                                    var w = Math.abs(this.xMouseDown - a);
                                    var r = Math.abs(this.yMouseDown - v);
                                    var m = false;
                                    if (w > r) {
                                        if (w > this.x / 10) {
                                            m = this.xMouseDown > a ? 39 : 37;
                                            this.xMouseDown = a;
                                            this.yMouseDown = v
                                        }
                                    } else {
                                        if (r > this.y / 10) {
                                            m = this.yMouseDown > v ? 40 : 38;
                                            this.xMouseDown = a;
                                            this.yMouseDown = v
                                        }
                                    } if (m) {
                                        this.handlePanning(k, m)
                                    }
                                    this.movingOn = true;
                                    this.resetOn = false;
                                    return false
                                }
                                var n = this.getBoundsXY(o);
                                var m = this.$(this.target + "-cX-Drag");
                                this.skipClick = true;
                                if ((!h.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && !k.shiftKey) || (!h.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && k.shiftKey)) {
                                    m.style.width = (n[1] - n[0]) + "px"
                                } else {
                                    if (a > this.xMouseDown) {
                                        if (a > n[1]) {
                                            m.style.width = (n[1] - this.xMouseDown) + "px"
                                        } else {
                                            m.style.width = (a - this.xMouseDown) + "px"
                                        }
                                    } else {
                                        if (a < n[0]) {
                                            m.style.left = n[0] + "px";
                                            m.style.width = (this.xMouseDown - n[0]) + "px"
                                        } else {
                                            m.style.left = a + "px";
                                            m.style.width = (this.xMouseDown - a) + "px"
                                        }
                                    }
                                } if ((!h.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && !k.shiftKey) || (!h.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && k.shiftKey) || h == "Genome") {
                                    m.style.height = (n[3] - n[2]) + "px"
                                } else {
                                    if (v > this.yMouseDown) {
                                        if (v > n[3]) {
                                            m.style.height = (n[3] - this.yMouseDown) + "px"
                                        } else {
                                            m.style.height = (v - this.yMouseDown) + "px"
                                        }
                                    } else {
                                        if (v < n[2]) {
                                            m.style.top = n[2] + "px";
                                            m.style.height = (this.yMouseDown - n[2]) + "px"
                                        } else {
                                            m.style.top = v + "px";
                                            m.style.height = (this.yMouseDown - v) + "px"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.movingOn = true;
            this.resetOn = false
        }
    };
    this.endDrag = function(z) {
        if (this.draggingOn) {
            var b = this.layoutComb ? this.layoutParams[this.layoutValidN].graphType : this.graphType;
            if (b.match(/Correlation|Pie|Venn|Stacked|Area|Circular|Treemap/)) {
                return false
            }
            if (!z) {
                z = window.event
            }
            var j = this.$(this.target);
            if (j) {
                j.style.cursor = "default";
                var w = this.getTargetEvent(z);
                if (w && w.style) {
                    w.style.cursor = "default"
                }
            }
            this.panningGlobalX += this.panningX;
            this.panningGlobalY += this.panningY;
            this.panningX = 0;
            this.panningY = 0;
            if ((b == "Scatter3D" && !z.shiftKey) || this.is3DPlot) {
                this.resetDrag(z)
            } else {
                if (b == "Network" && (this.moveNode || this.moveLegend)) {
                    if (j) {
                        if (this.isSelectNodes && this.movingOn) {
                            this.resetSelectedNodes();
                            this.draw()
                        }
                        if (this.userEvents.enddragnode && this.movingOn) {
                            var m;
                            if (this.moveLegend) {
                                m = {
                                    legend: this.moveLegend
                                }
                            } else {
                                var p = this.moveNodeIndex;
                                var k = this.findChildrenNodeIndices(this.data.nodes[p].id);
                                if (k) {
                                    k.push(p)
                                } else {
                                    k = [p]
                                }
                                m = this.extractDataObject(k)
                            }
                            this.resetDrag(z);
                            this.userEvents.enddragnode.call(this, m)
                        } else {
                            this.resetDrag(z)
                        }
                        this.addToNetworkStack()
                    }
                } else {
                    if (b == "Genome" && (this.moveGenome || !z.shiftKey)) {
                        if (this.movingOn && this.moveGenome) {
                            var B = this.adjustedCoordinates(z);
                            var C = [];
                            if (B) {
                                var n = B.y;
                                if (n != this.yMouseDown) {
                                    var A = this.moveGenome.replace("track-", "").split(":");
                                    var a = parseInt(A[0]);
                                    var u = A.length > 1 ? parseInt(A[1]) : null;
                                    for (var v = 0; v < this.subtracksInfo.length; v++) {
                                        if (this.subtracksInfo[v]) {
                                            var q = this.subtracksInfo[v].start;
                                            var h = this.subtracksInfo[v].track;
                                            var g = this.subtracksInfo[v].index;
                                            if (q > n) {
                                                if (a != h && a != h - 1) {
                                                    if (h > a) {
                                                        h--
                                                    }
                                                    var o = this.data.tracks.splice(a, 1)[0];
                                                    this.data.tracks.splice(h, 0, o);
                                                    this.draw()
                                                } else {
                                                    if (u != null) {
                                                        if (a == h - 1) {
                                                            g = this.subtracksInfo[v - 1].index;
                                                            g++
                                                        }
                                                        u = this.subtracksInfo[u].index;
                                                        if (u != g) {
                                                            if (g > u) {
                                                                g--
                                                            }
                                                            var o = this.data.tracks[a].data.splice(u, 1)[0];
                                                            this.data.tracks[a].data.splice(g, 0, o);
                                                            this.draw()
                                                        }
                                                    }
                                                }
                                                break
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        this.resetDrag(z)
                    } else {
                        if (this.movingOn && !this.panningOn) {
                            var B = this.adjustedCoordinates(z);
                            if (B) {
                                var r = B.x;
                                var n = B.y;
                                if (r != this.xMouseDown || n != this.yMouseDown) {
                                    var A = this.$(this.target + "-cX-Drag");
                                    var y = parseInt(A.style.left);
                                    var f = parseInt(A.style.top);
                                    var x = y + parseInt(A.style.width);
                                    var c = f + parseInt(A.style.height);
                                    this.handleDragEvent(z, y, f, x, c);
                                    this.resetDrag(z)
                                }
                            }
                        } else {
                            this.resetDrag(z)
                        }
                    }
                }
            }
        } else {
            this.resetDrag(z)
        }
    };
    this.validateMinMax = function(c, a, d, b) {
        if (!isNaN(c) && !isNaN(a)) {
            if (c > a || d > c || b < a) {
                return false
            }
            return true
        } else {
            return false
        }
    };
    this.handleDragEventNetwork = function(m, c, r, b, p) {
        var f = {};
        var k = [];
        var v = [];
        var u = [];
        var o = [];
        var q = {};
        for (var j = 0; j < this.dataEvent.length; j++) {
            var g = this.dataEvent[j][0];
            var a = this.dataEvent[j][1];
            var l = this.dataEvent[j][2];
            if (this.isObjectInsideArea(a, l, c, r, b, p)) {
                if (g < this.data.nodes.length) {
                    f[g] = 1
                }
            }
        }
        for (var j = 0; j < this.data.nodes.length; j++) {
            if (!f[j]) {
                k.push(this.data.nodes[j].id)
            } else {
                v.push(this.data.nodes[j].id);
                u.push(j)
            }
        }
        if (k.length < this.data.nodes.length) {
            if (m.shiftKey) {
                this.setSelectNodes(v);
                this.isSelectNodes = v.length;
                this.draw();
                this.draggingOn = false;
                this.showInfoSpan(m, "While mouse-over nodes:<br>1. Press Shift and drag mouse to resize nodes<br>2. Drag mouse to move nodes")
            } else {
                this.resetZoomPan();
                this.hideUnhideNodes(k, true);
                this.ctx.translate(-this.offsetX, -this.offsetY);
                this.ctx.scale(1 / this.scaleFactor, 1 / this.scaleFactor);
                this.draw(false, false, false, true)
            } if (this.showDataTableOnSelect) {
                if (this.networkShowDataTable == "edges") {
                    for (var j = 0; j < v.length; j++) {
                        q[v[j]] = 1
                    }
                    for (var j = 0; j < this.data.edges.length; j++) {
                        if (q[this.data.edges[j].id1] || q[this.data.edges[j].id2]) {
                            o.push(this.data.nodes.length + j)
                        }
                    }
                    this.updateDataTable(this.extractDataObject(o))
                } else {
                    this.updateDataTable(this.extractDataObject(u))
                }
            }
        }
    };
    this.setOriginalIndices = function(f, e, a, d) {
        if (f == null) {
            f = 0
        }
        if (!e) {
            e = this.layoutComb ? this.layoutParams[f].varIndices : this.varIndices
        }
        if (!a) {
            if (this.isGroupedData) {
                a = this.layoutComb ? this.layoutParams[f].grpIndices : this.grpIndices
            } else {
                a = this.layoutComb ? this.layoutParams[f].smpIndices : this.smpIndices
            }
        }
        if (d) {
            this.startingVarIndices = [];
            this.startingSmpIndices = []
        }
        if (!this.startingVarIndices) {
            this.startingVarIndices = []
        }
        if (!this.startingSmpIndices) {
            this.startingSmpIndices = []
        }
        if (!this.startingVarIndices[f]) {
            this.startingVarIndices[f] = [];
            for (var b = 0; b < e.length; b++) {
                this.startingVarIndices[f][b] = e[b]
            }
        }
        if (!this.startingSmpIndices[f]) {
            this.startingSmpIndices[f] = [];
            for (var b = 0; b < a.length; b++) {
                this.startingSmpIndices[f][b] = a[b]
            }
        }
    };
    this.reorderOriginalIndices = function(k, l, m) {
        var a = [];
        var f = [];
        var b = l == "varDendrogram" ? this.startingVarIndices[k] : this.startingSmpIndices[k];
        var h = false;
        if (k == null) {
            k = 0
        }
        while (b.length > 0) {
            var g = b.shift();
            if (g == m[1]) {
                f.push(g);
                while (!h) {
                    var e = b.shift();
                    if (e == m[0]) {
                        h = true
                    }
                    f.push(e)
                }
                f = f.reverse();
                a = a.concat(f)
            } else {
                a.push(g)
            }
        }
        if (l == "varDendrogram") {
            this.startingVarIndices[k] = a
        } else {
            this.startingSmpIndices[k] = a
        }
    };
    this.handleDragEventHeatmap = function(h, d, k, a, j) {
        var l = [];
        var p = [];
        var n;
        this.resetAxesResizer();
        var m = this.layoutComb ? this.layoutParams[h].varIndices : this.varIndices;
        if (this.isGroupedData) {
            n = this.layoutComb ? this.layoutParams[h].grpIndices : this.grpIndices
        } else {
            n = this.layoutComb ? this.layoutParams[h].smpIndices : this.smpIndices
        }
        this.setOriginalIndices(h, m, n);
        if (this.layoutComb) {
            this.varIndicesStart = this.layoutParams[h].varIndicesStart < 0 ? 0 : this.layoutParams[h].varIndicesStart;
            this.smpIndicesStart = this.layoutParams[h].smpIndicesStart < 0 ? 0 : this.layoutParams[h].smpIndicesStart
        } else {
            this.varIndicesStart = this.varIndicesStart < 0 ? 0 : this.varIndicesStart;
            this.smpIndicesStart = this.smpIndicesStart < 0 ? 0 : this.smpIndicesStart
        }
        this.varIndices = [];
        if (this.isGroupedData) {
            this.grpIndices = []
        } else {
            this.smpIndices = []
        }
        for (var f = 0; f < this.dataEvent.length; f++) {
            var e = this.dataEvent[f][0];
            var g = this.dataEvent[f][2];
            if ((d < g[0] || d < g[2]) && a > g[0] && (k < g[1] || k < g[3]) && j > g[1]) {
                if (!l[e[0]]) {
                    this.varIndices.push(e[0]);
                    l[e[0]] = 1
                }
                if (!p[e[1]]) {
                    if (this.isGroupedData) {
                        this.grpIndices.push(e[1])
                    } else {
                        this.smpIndices.push(e[1])
                    }
                    p[e[1]] = 1
                }
            }
        }
        for (var f = 0; f < m.length; f++) {
            if (m[f] == this.varIndices[0]) {
                this.varIndicesStart += f
            }
        }
        for (var f = 0; f < n.length; f++) {
            if (this.isGroupedData) {
                if (n[f] == this.grpIndices[0]) {
                    this.smpIndicesStart += f
                }
            } else {
                if (n[f] == this.smpIndices[0]) {
                    this.smpIndicesStart += f
                }
            }
        }
        this.draw();
        if (this.showDataTableOnSelect) {
            var b = this.extractDataObject(this.smpIndices, this.varIndices);
            this.updateDataTable(b)
        }
        this.skipClick = false
    };
    this.handleDragEventScatter = function(B, d, C, A, l, y, k) {
        this.selectDataPoint = [];
        var a = {
            v: {},
            s: {}
        };
        var r = 0;
        if (B.shiftKey) {
            for (var w = 0; w < this.dataEvent.length; w++) {
                var n = this.dataEvent[w][0];
                var x = this.dataEvent[w][1];
                var m = this.dataEvent[w][2];
                if (this.isObjectInsideArea(x, m, A, l, y, k)) {
                    this.addRemoveToSelectedDataPoints(d, n);
                    a.v[n.shift()] = 1;
                    for (var v = 0; v < n.length; v++) {
                        a.s[n[v]] = 1
                    }
                    r++
                }
            }
            if (r > 0) {
                this.isSelectDataPoints = r;
                this.draw();
                if (this.showDataTableOnSelect) {
                    var u = [];
                    var z = [];
                    for (w in a.v) {
                        u.push(parseInt(w))
                    }
                    for (w in a.s) {
                        z.push(parseInt(w))
                    }
                    u.sort(function(e, c) {
                        return (e - c)
                    });
                    z.sort(function(e, c) {
                        return (e - c)
                    });
                    var t = this.extractDataObject(z, u);
                    this.updateDataTable(t)
                }
            }
        } else {
            var p = this;
            var q = function(e, c) {
                if (p[e + "Transform"]) {
                    if (p[e + "Transform"] == "log2") {
                        p["setMin" + c] = Math.pow(2, p["setMin" + c]);
                        p["setMax" + c] = Math.pow(2, p["setMax" + c])
                    } else {
                        if (p[e + "Transform"] == "log10") {
                            p["setMin" + c] = Math.pow(10, p["setMin" + c]);
                            p["setMax" + c] = Math.pow(10, p["setMax" + c])
                        } else {
                            if (p[e + "Transform"] == "exp2") {
                                p["setMin" + c] = Math.log(p["setMin" + c]) / Math.LN2;
                                p["setMax" + c] = Math.log(p["setMax" + c]) / Math.LN2
                            } else {
                                if (p[e + "Transform"] == "exp10") {
                                    p["setMin" + c] = Math.log(p["setMin" + c]) / Math.LN10;
                                    p["setMax" + c] = Math.log(p["setMax" + c]) / Math.LN10
                                }
                            }
                        }
                    }
                }
            };
            var t = this.layoutComb ? this.layoutParams[C] : this;
            var h = t.xAxisMin + ((A - (this.marginLeft + t.offsetX + t.left)) / t.xAxisUnit);
            var g = t.xAxisMin + ((y - (this.marginLeft + t.offsetX + t.left)) / t.xAxisUnit);
            var b = t.yAxisMax - ((l - (this.marginTop + t.offsetY + t.top)) / t.yAxisUnit);
            var f = t.yAxisMax - ((k - (this.marginTop + t.offsetY + t.top)) / t.yAxisUnit);
            if (this.validateMinMax(h, g, this.xAxisMin, this.xAxisMax) && this.validateMinMax(f, b), this.yAxisMin, this.yAxisMax) {
                this.setMinX = h;
                this.setMaxX = g;
                this.setMaxY = b;
                this.setMinY = f;
                q("xAxis", "X");
                q("yAxis", "Y");
                this.draw()
            }
        }
    };
    this.handleDragEventGenome = function(i, d, f, b, e) {
        var a, h;
        var g = this.layoutComb ? this.layoutParams[i] : this;
        var a = g.xAxisMin + ((d - (this.marginLeft + g.offsetX + g.left)) / g.xAxisUnit);
        var h = g.xAxisMin + ((b - (this.marginLeft + g.offsetX + g.left)) / g.xAxisUnit);
        if (this.validateMinMax(a, h, this.xAxisMin, this.xAxisMax)) {
            this.setMinX = a;
            this.setMaxX = h;
            this.draw()
        }
    };
    this.handleDragEventOneDimension = function(D, a, H, B, d, A, b, K) {
        if (this.moveVar) {
            var l = this.moveVar.split("-")[1];
            if (this.showVarDendrogram && this.varDendrogram) {
                alert("Ooops. Cannot change order when showing the dendrogram");
                return false
            }
            var u = this.layoutComb ? this.layoutParams[H].varIndices : this.varIndices;
            var p;
            for (var y = 0; y < u.length; y++) {
                if (u[y] == l) {
                    p = y;
                    break
                }
            }
            l = u.splice(p, 1);
            this.varInfo.splice(p, 1);
            var I = [];
            p = u.length;
            for (var y = 0; y < u.length; y++) {
                if (this.varInfo[y] > B) {
                    p = y;
                    break
                }
            }
            u.splice(p, 0, l[0]);
            this.draw();
            this.skipClick = false
        } else {
            if (this.moveSmp) {
                var l = this.moveSmp.split("-")[1];
                var r;
                var j = this.isGroupedData ? this.grpIndices : this.smpIndices;
                if (this.isGroupedData) {
                    r = this.layoutComb ? this.layoutParams[H].grpIndices : this.grpIndices
                } else {
                    r = this.layoutComb ? this.layoutParams[H].smpIndices : this.smpIndices;
                    if (this.showSmpDendrogram && this.smpDendrogram) {
                        alert("Ooops. Cannot change order when showing the dendrogram");
                        return false
                    }
                }
                var p;
                for (var y = 0; y < r.length; y++) {
                    if (r[y] == l) {
                        p = y;
                        break
                    }
                }
                l = r.splice(p, 1);
                this.smpInfo.splice(p, 1);
                var I = [];
                p = r.length;
                var x = a.match(/Heatmap/) || this.graphOrientation == "horizontal" ? d : B;
                for (var y = 0; y < r.length; y++) {
                    if (this.smpInfo[y] > x) {
                        p = y;
                        break
                    }
                }
                r.splice(p, 0, l[0]);
                this.draw();
                this.skipClick = false
            } else {
                if (D.shiftKey || K) {
                    var n = {};
                    var J = [];
                    var r;
                    var u = this.layoutComb ? this.layoutParams[H].varIndices : this.varIndices;
                    var j = this.isGroupedData ? this.grpIndices : this.smpIndices;
                    var h = false;
                    if (this.isGroupedData) {
                        r = this.layoutComb ? this.layoutParams[H].grpIndices : this.grpIndices
                    } else {
                        r = this.layoutComb ? this.layoutParams[H].smpIndices : this.smpIndices
                    }
                    this.setOriginalIndices(H, u, r);
                    for (var y = 0; y < this.dataEvent.length; y++) {
                        var g = this.dataEvent[y][0];
                        var w = this.dataEvent[y][1];
                        var f = this.dataEvent[y][2];
                        if (this.isObjectInsideArea(w, f, B, d, A, b)) {
                            n[g[1]] = true
                        }
                    }
                    for (var y = 0; y < j.length; y++) {
                        if (n.hasOwnProperty(j[y])) {
                            J.push(j[y]);
                            if (!h) {
                                this.smpIndicesStart = y;
                                h = true
                            }
                        }
                    }
                    this.setSamplesVisible(J, true);
                    this.draw();
                    if (this.showDataTableOnSelect) {
                        var q = this.extractDataObject(J, this.varIndices);
                        this.updateDataTable(q)
                    }
                } else {
                    var q = this.layoutComb ? this.layoutParams[H] : this;
                    var m = a == "Candlestick" && H > 0 && this.showVolume;
                    var k = this.layoutComb && this.layoutCurrent != H;
                    var v = m && k ? q.xAxis2Min : q.xAxisMin;
                    var z = m && k ? q.xAxis2Max : q.xAxisMax;
                    var G = this.marginLeft + q.offsetX + q.left;
                    var F = G + q.x;
                    var E = this.marginTop + q.offsetY + q.top;
                    var C = E + q.y;
                    if (this.graphOrientation == "vertical") {
                        v = m ? v + (Math.max(C - b, 0) / q.xAxis2Unit) : v + (Math.max(C - b, 0) / q.xAxisUnit);
                        z = m ? z - (Math.max(d - E, 0) / q.xAxis2Unit) : z - (Math.max(d - E, 0) / q.xAxisUnit)
                    } else {
                        v = m ? v + (Math.max(B - G, 0) / q.xAxis2Unit) : v + (Math.max(B - G, 0) / q.xAxisUnit);
                        z = m ? z - (Math.max(F - A, 0) / q.xAxis2Unit) : z - (Math.max(F - A, 0) / q.xAxisUnit)
                    } if (this.validateMinMax(v, z, this.xAxisMin, this.xAxisMax)) {
                        if (m) {
                            this.setMinX2 = v;
                            this.setMaxX2 = z
                        } else {
                            this.setMinX = v;
                            this.setMaxX = z
                        }
                        this.draw()
                    }
                }
            }
        }
    };
    this.handleDragEvent = function(h, b, f, a, d) {
        var i = this.layoutComb ? this.layoutValidN : 0;
        var g = this.layoutComb ? this.layoutParams[i].graphType : this.graphType;
        if (g == "Network") {
            this.handleDragEventNetwork(h, b, f, a, d)
        } else {
            if (g == "Heatmap" && !this.moveVar && !this.moveSmp) {
                this.handleDragEventHeatmap(i, b, f, a, d)
            } else {
                if (g.match(/Scatter/)) {
                    this.handleDragEventScatter(h, g, i, b, f, a, d)
                } else {
                    if (g == "Genome") {
                        this.handleDragEventGenome(i, b, f, a, d)
                    } else {
                        this.handleDragEventOneDimension(h, g, i, b, f, a, d)
                    }
                }
            }
        }
    };
    this.resetDrag = function(a) {
        var b = this.$(this.target + "-cX-Drag");
        if (b) {
            b.style.left = "0px";
            b.style.top = "0px";
            b.style.width = "0px";
            b.style.height = "0px"
        }
    };
    this.initializeDraggingEvents = function() {
        if (!this.disableEvents) {
            this.addDragDiv()
        }
    };
    this.initializeDraggingEvents()
};
CanvasXpress.prototype.initKeyEvents = function() {
    this.getKeyCode = function(a) {
        if (a) {
            if ((a.charCode) && (a.keyCode == 0)) {
                return a.charCode
            } else {
                return a.keyCode
            }
        }
    };
    this.registerKey = function(b) {
        if (!b) {
            b = window.event
        }
        var a = this.getTargetEvent(b);
        var d = this.getKeyCode(b);
        if (this.eventKeys || (b.ctrlKey && b.altKey && d == 107)) {
            if (d == 27) {
                if (this.animationOn) {
                    this.animationOn = false;
                    return false
                }
                this.masterReset(b)
            } else {
                if (this.configuringOn) {
                    return
                } else {
                    if (d == 16 && this.helpKeyEvents) {
                        if (b.ctrlKey && b.altKey) {
                            this.showCtrlShiftAltShorts()
                        } else {
                            if (b.ctrlKey) {
                                this.showCtrlShiftShorts()
                            } else {
                                if (b.altKey) {
                                    this.showShiftAltShorts()
                                } else {
                                    this.showShiftShorts()
                                }
                            }
                        }
                    } else {
                        if (d == 17 && this.helpKeyEvents) {
                            if (b.shiftKey && b.altKey) {
                                this.showCtrlShiftAltShorts()
                            } else {
                                if (b.shiftKey) {
                                    this.showCtrlShiftShorts()
                                } else {
                                    if (b.altKey) {
                                        this.showCtrlAltShorts()
                                    } else {
                                        this.showCtrlShorts()
                                    }
                                }
                            }
                        } else {
                            if ((d == 18 || d == 224) && this.helpKeyEvents) {
                                if (b.ctrlKey && b.shiftKey) {
                                    this.showCtrlShiftAltShorts()
                                } else {
                                    if (b.ctrlKey) {
                                        this.showCtrlAltShorts()
                                    } else {
                                        if (b.shiftKey) {
                                            this.showShiftAltShorts()
                                        } else {
                                            this.showAltShorts()
                                        }
                                    }
                                }
                            } else {
                                if (b.ctrlKey && b.shiftKey) {
                                    if (d >= 33 && d <= 40) {
                                        this.arrowMove(d, true)
                                    } else {
                                        if (d == 80 && !this.keyOn) {
                                            this.keyOn = true;
                                            this.print()
                                        } else {
                                            if (d == 88 && !this.keyOn) {
                                                this.keyOn = true;
                                                this.clearNetworkStack()
                                            } else {
                                                if (d == 90 && this.graphType == "Network" && !this.keyOn) {
                                                    this.keyOn = true;
                                                    this.alignDistributeSelectedNodes(b, d)
                                                }
                                            }
                                        }
                                    }
                                    document.defaultAction = true
                                } else {
                                    if (b.ctrlKey && b.altKey) {
                                        if (d == 80 && !this.keyOn) {
                                            this.keyOn = true;
                                            this.print()
                                        }
                                        document.defaultAction = true
                                    } else {
                                        if (b.shiftKey && b.altKey) {
                                            if (d >= 50 && d < 90 && !this.keyOn) {
                                                this.keyOn = true;
                                                this.setGraphType(d)
                                            }
                                            document.defaultAction = true
                                        } else {
                                            if (b.ctrlKey) {
                                                if (d >= 33 && d <= 40) {
                                                    if (d == 36 && this.isSelectDataPoints && this.graphType == "Scatter3D") {
                                                        this.showHideSelectedDataPoint(b, d)
                                                    } else {
                                                        if (d == 36 && this.isSelectNodes && this.graphType == "Network") {
                                                            this.showHideSelectedDataPoint(b, d)
                                                        } else {
                                                            this.arrowMove(d)
                                                        }
                                                    }
                                                } else {
                                                    if ((d == 45 || d == 46) && !this.keyOn) {
                                                        this.keyOn = true;
                                                        this.showHideSelectedDataPoint(b, d)
                                                    } else {
                                                        if ((d >= 48 && d < 58) && !this.keyOn) {
                                                            this.keyOn = true;
                                                            this.setLayout(d - 48)
                                                        } else {
                                                            if (d >= 65 && d <= 90) {
                                                                if (d == 80 && !this.keyOn) {
                                                                    this.keyOn = true;
                                                                    this.print()
                                                                }
                                                                if (this.graphType == "Network" && !this.keyOn && !/input|textarea|select/i.test(a.tagName)) {
                                                                    this.keyOn = true;
                                                                    this.alignDistributeSelectedNodes(b, d)
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                document.defaultAction = true
                                            } else {
                                                if (d == 107 || d == 109 || d == 61 || d == 187 || d == 189) {
                                                    if (this.eventPlusMinusKeys && !/input|textarea|select/i.test(a.tagName)) {
                                                        if (d == 109 || d == 189) {
                                                            this.handleWheelEvent(b, -1)
                                                        } else {
                                                            this.handleWheelEvent(b, 1)
                                                        }
                                                    }
                                                } else {
                                                    if (b.shiftKey && d >= 33 && d <= 40) {
                                                        if (this.eventArrowKeys && !/input|textarea|select/i.test(a.tagName)) {
                                                            this.handlePanning(b, d)
                                                        } else {
                                                            document.defaultAction = true
                                                        }
                                                    } else {
                                                        if (d >= 36 && d <= 40) {
                                                            if (this.eventArrowKeys && !/input|textarea|select/i.test(a.tagName)) {
                                                                this.handlePanning(b, d)
                                                            }
                                                        } else {
                                                            if (b.shiftKey) {
                                                                document.defaultAction = true
                                                            } else {
                                                                if (b.altKey) {
                                                                    document.defaultAction = true
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.handlePanning = function(f, j) {
        if (this.graphType == "Network") {
            this.cancelEvent(f);
            var m = Math.abs(this.x * this.panningStep);
            var k = Math.abs(this.y * this.panningStep);
            if (j == 33) {
                this.panningY -= k * 5
            } else {
                if (j == 34) {
                    this.panningY += k * 5
                } else {
                    if (j == 35) {
                        this.panningX = m * 20;
                        this.panningY = k * 20
                    } else {
                        if (j == 36) {
                            this.panningX = 0;
                            this.panningY = 0
                        } else {
                            if (j == 37) {
                                this.panningX -= m
                            } else {
                                if (j == 38) {
                                    this.panningY -= k
                                } else {
                                    if (j == 39) {
                                        this.panningX += m
                                    } else {
                                        if (j == 40) {
                                            this.panningY += k
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.draw(false, false, false, true)
        } else {
            if (this.graphType == "Genome") {
                var p = this.genomeResolution == "high" ? 1 : this.xAxisRange * this.panningStep;
                if (this.setMinX == null) {
                    this.setMinX = this.xAxisMin
                }
                if (this.setMaxX == null) {
                    this.setMaxX = this.xAxisMax
                }
                this.cancelEvent(f);
                if (j == 37 || j == 38) {
                    this.setMinX -= p;
                    this.setMaxX -= p
                } else {
                    if (j == 39 || j == 40) {
                        this.setMinX += p;
                        this.setMaxX += p
                    } else {
                        if (j == 33) {
                            this.setMinX += this.xAxisRange * 0.95;
                            this.setMaxX += this.xAxisRange * 0.95
                        } else {
                            if (j == 34) {
                                this.setMinX -= this.xAxisRange * 0.95;
                                this.setMaxX -= this.xAxisRange * 0.95
                            } else {
                                if (j == 35) {
                                    this.setMaxX = null
                                } else {
                                    if (j == 36) {
                                        this.setMinX = null
                                    }
                                }
                            }
                        }
                    }
                }
                this.draw()
            } else {
                if (this.graphType == "Heatmap") {
                    this.cancelEvent(f);
                    this.resetAxesResizer(f);
                    var g = this.layoutComb ? this.layoutValidN : 0;
                    var q;
                    var n = this.layoutComb ? this.layoutParams[g].varIndices : this.varIndices;
                    if (this.isGroupedData) {
                        q = this.layoutComb ? this.layoutParams[g].grpIndices : this.grpIndices
                    } else {
                        q = this.layoutComb ? this.layoutParams[g].smpIndices : this.smpIndices
                    }
                    this.setOriginalIndices(j, n, q);
                    if (j == 35) {
                        return false
                    } else {
                        if (j == 36) {
                            this.varIndicesStart = -1;
                            this.smpIndicesStart = -1;
                            this.varIndices = this.startingVarIndices[g];
                            if (this.isGroupedData) {
                                this.grpIndices = this.startingSmpIndices[g]
                            } else {
                                this.smpIndices = this.startingSmpIndices[g]
                            }
                            this.draw()
                        } else {
                            if (j == 37) {
                                if (this.varIndicesStart > 0) {
                                    this.varIndices.unshift(this.startingVarIndices[g][this.varIndicesStart - 1]);
                                    this.varIndices.pop();
                                    this.varIndicesStart--;
                                    this.draw()
                                }
                            } else {
                                if (j == 38 || j == 33) {
                                    var o = j == 33 ? 5 : 1;
                                    var h = false;
                                    var a = this.isGroupedData ? this.grpIndices : this.smpIndices;
                                    for (var b = 0; b < o; b++) {
                                        if (this.smpIndicesStart > 0) {
                                            a.unshift(this.startingSmpIndices[g][this.smpIndicesStart - 1]);
                                            a.pop();
                                            this.smpIndicesStart--;
                                            h = true
                                        }
                                    }
                                    if (h) {
                                        this.draw()
                                    }
                                } else {
                                    if (j == 39) {
                                        if (this.varIndicesStart > -1 && this.varIndicesStart + n.length < this.startingVarIndices[g].length) {
                                            this.varIndices.push(this.startingVarIndices[g][this.varIndicesStart + this.varIndices.length]);
                                            this.varIndices.shift();
                                            this.varIndicesStart++;
                                            this.draw()
                                        }
                                    } else {
                                        if (j == 40 || j == 34) {
                                            var o = j == 34 ? 5 : 1;
                                            var h = false;
                                            var a = this.isGroupedData ? this.grpIndices : this.smpIndices;
                                            for (var b = 0; b < o; b++) {
                                                if (this.smpIndicesStart > -1 && this.smpIndicesStart + q.length < this.startingSmpIndices[g].length) {
                                                    a.push(this.startingSmpIndices[g][this.smpIndicesStart + a.length]);
                                                    a.shift();
                                                    this.smpIndicesStart++;
                                                    h = true
                                                }
                                            }
                                            if (h) {
                                                this.draw()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked/)) {
                        this.cancelEvent(f);
                        this.resetAxesResizer(f);
                        var g = this.layoutComb ? this.layoutValidN : 0;
                        var q;
                        var h = false;
                        var n = this.layoutComb ? this.layoutParams[g].varIndices : this.varIndices;
                        if (this.isGroupedData) {
                            q = this.layoutComb ? this.layoutParams[g].grpIndices : this.grpIndices
                        } else {
                            q = this.layoutComb ? this.layoutParams[g].smpIndices : this.smpIndices
                        }
                        this.setOriginalIndices(g, n, q);
                        if (j == 35 || j == 36) {
                            return false
                        } else {
                            if (j == 37 || j == 38 || j == 33) {
                                var o = j == 33 ? 5 : 1;
                                for (var b = 0; b < o; b++) {
                                    if (this.smpIndicesStart > 0) {
                                        this.smpIndicesStart--;
                                        q.unshift(this.startingSmpIndices[g][this.smpIndicesStart]);
                                        q.pop();
                                        h = true
                                    }
                                }
                            } else {
                                if (j == 39 || j == 40 || j == 34) {
                                    var o = j == 34 ? 5 : 1;
                                    for (var b = 0; b < o; b++) {
                                        if (this.smpIndicesStart + q.length < this.startingSmpIndices[g].length) {
                                            q.push(this.startingSmpIndices[g][this.smpIndicesStart + q.length]);
                                            q.shift();
                                            this.smpIndicesStart++;
                                            h = true
                                        }
                                    }
                                }
                            }
                        } if (h) {
                            this.draw()
                        }
                    }
                }
            }
        }
        return false
    };
    this.showCtrlShiftAltShorts = function() {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Ctrl + Shift + Alt</th></tr>";
        a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showCtrlShiftShorts = function() {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Shift + Ctrl</th></tr>";
        if (this.graphType == "Network") {
            if (this.is3DNetwork) {
                a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (this.rotationStep * 3) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (this.rotationStep * 3) + "&deg; continuously</td></tr>"
            } else {
                a += "<tr><td class=k>&rarr; or &darr;</td><td class=d>Rotate clockwise " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>&larr; or &uarr;</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 3) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise " + (this.rotationStep * 3) + "&deg; continuously</td></tr>"
            }
        } else {
            if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
                if (this.type2D == "XYZ") {
                    if (this.xAxis.length > 1) {
                        a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X, Y and Z axes continuously (1x)</td></tr>";
                        a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X, Y and Z axes continuously (2x)</td></tr>"
                    }
                } else {
                    if (this.type2D == "XY") {
                        if (this.zAxis.length > 1) {
                            a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update sample in Z axis continuously (1x)</td></tr>";
                            a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update sample in Z axis continuously (2x)</td></tr>"
                        }
                    } else {
                        if (this.type2D == "X") {
                            if (this.yAxis.length > 1) {
                                a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in Y and Z axes continuously (1x)</td></tr>";
                                a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in Y and Z axes continuously (2x)</td></tr>"
                            }
                        } else {
                            if (this.xAxis.length > 1) {
                                a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X and Z axes continuously (1x)</td></tr>";
                                a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X and Z axes continuously (2x)</td></tr>"
                            }
                        }
                    }
                }
            } else {
                if (this.graphType == "Scatter3D") {
                    a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Rotate continuously</td></tr>";
                    a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Rotate continuously</td></tr>"
                }
            }
        }
        a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showCtrlAltShorts = function() {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Ctrl + Alt</th></tr>";
        a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showShiftAltShorts = function() {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Shift + Alt</th></tr>";
        a += "<tr><td class=k>2</td><td class=d>Scatter2D</td></tr>";
        a += "<tr><td class=k>3</td><td class=d>Scatter3D</td></tr>";
        a += "<tr><td class=k>4</td><td class=d>ScatterBubble2D</td></tr>";
        a += "<tr><td class=k>A</td><td class=d>Area</td></tr>";
        a += "<tr><td class=k>B</td><td class=d>Bar</td></tr>";
        a += "<tr><td class=k>C</td><td class=d>BarLine</td></tr>";
        a += "<tr><td class=k>D</td><td class=d>Dotplot</td></tr>";
        a += "<tr><td class=k>G</td><td class=d>Genome</td></tr>";
        a += "<tr><td class=k>H</td><td class=d>Heatmap</td></tr>";
        a += "<tr><td class=k>Y</td><td class=d>Treemap</td></tr>";
        a += "<tr><td class=k>I</td><td class=d>Boxplot</td></tr>";
        a += "<tr><td class=k>L</td><td class=d>Line</td></tr>";
        a += "<tr><td class=k>M</td><td class=d>Candlestick</td></tr>";
        a += "<tr><td class=k>N</td><td class=d>Network</td></tr>";
        a += "<tr><td class=k>P</td><td class=d>Pie</td></tr>";
        a += "<tr><td class=k>R</td><td class=d>Circular</td></tr>";
        a += "<tr><td class=k>S</td><td class=d>Stacked</td></tr>";
        a += "<tr><td class=k>T</td><td class=d>StackedPercent</td></tr>";
        a += "<tr><td class=k>U</td><td class=d>StackedLine</td></tr>";
        a += "<tr><td class=k>W</td><td class=d>StackedPercentLine</td></tr>";
        a += "<tr><td class=k>V</td><td class=d>Venn</td></tr>";
        a += "<tr><td class=k>X</td><td class=d>Correlation</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showCtrlShorts = function() {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Ctrl</th></tr>";
        if (this.graphType == "Network") {
            if (this.is3DNetwork) {
                a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (this.rotationStep * 3) + "&deg;</td></tr>";
                a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (this.rotationStep * 3) + "&deg;</td></tr>"
            } else {
                a += "<tr><td class=k>&rarr; or &darr;</td><td class=d>Rotate clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>&larr; or &uarr;</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 3) + "&deg;</td></tr>";
                a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise " + (this.rotationStep * 3) + "&deg;</td></tr>"
            }
            a += "<tr><td class=k>click</td><td class=d>Select/Unselect node</td></tr>";
            if (this.isSelectNodes) {
                a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
                a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>";
                a += "<tr><td class=k>Home</td><td class=d>Show connected nodes to slected nodes</td></tr>";
                a += "<tr><td class=k>t</td><td class=d>Align top</td></tr>";
                a += "<tr><td class=k>r</td><td class=d>Align right</td></tr>";
                a += "<tr><td class=k>b</td><td class=d>Align bottom</td></tr>";
                a += "<tr><td class=k>l</td><td class=d>Align left</td></tr>";
                a += "<tr><td class=k>v</td><td class=d>Distribute verticaly</td></tr>";
                a += "<tr><td class=k>h</td><td class=d>Distribute Horizontaly</td></tr>";
                a += "<tr><td class=k>z</td><td class=d>Undo</td></tr>";
                a += "<tr><td class=k>y</td><td class=d>Redo</td></tr>"
            }
        } else {
            if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
                if (this.type2D == "XYZ") {
                    if (this.xAxis.length > 1) {
                        a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X, Y and Z axes (1x)</td></tr>";
                        a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X, Y and Z axes (2x)</td></tr>"
                    }
                } else {
                    if (this.type2D == "XY") {
                        if (this.zAxis.length > 1) {
                            a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update sample in Z axis (1x)</td></tr>";
                            a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update sample in Z axis (2x)</td></tr>"
                        }
                    } else {
                        if (this.type2D == "X") {
                            if (this.yAxis.length > 1) {
                                a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in Y and Z axes (1x)</td></tr>";
                                a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in Y and Z axes (2x)</td></tr>"
                            }
                        } else {
                            if (this.xAxis.length > 1) {
                                a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X and Z axes (1x)</td></tr>";
                                a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X and Z axes (2x)</td></tr>"
                            }
                        }
                    }
                } if (this.isSelectDataPoints) {
                    a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
                    a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>"
                }
            } else {
                if (this.graphType == "Scatter3D") {
                    a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                    a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                    a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (this.rotationStep * 1) + "&deg;</td></tr>";
                    a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (this.rotationStep * 1) + "&deg;</td></tr>";
                    a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (this.rotationStep * 3) + "&deg;</td></tr>";
                    a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (this.rotationStep * 3) + "&deg;</td></tr>";
                    a += "<tr><td class=k>click</td><td class=d>Select/Unselect data points</td></tr>";
                    if (this.isSelectDataPoints) {
                        a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
                        a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>";
                        a += "<tr><td class=k>Home</td><td class=d>Zoom to selected nodes</td></tr>"
                    }
                } else {
                    if (this.isSegregable()) {}
                }
            }
        }
        a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showShiftShorts = function() {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Shift</th></tr>";
        if (this.isSegregable()) {
            a += "<tr><td class=k>Click and Drag</td><td class=d>Select Samples</td></tr>"
        } else {
            a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>"
        }
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showAltShorts = function() {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Alt</th></tr>";
        a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.arrowMove = function(j, b) {
        var e = this.graphType;
        if (this.is3DPlot) {
            e = "Scatter3D;"
        }
        switch (e) {
            case "Network":
                if (this.is3DNetwork) {
                    if (j == 33) {
                        this.xRotate += (this.rotationStep * 3);
                        this.yRotate -= (this.rotationStep * 3)
                    } else {
                        if (j == 34) {
                            this.xRotate -= (this.rotationStep * 3);
                            this.yRotate += (this.rotationStep * 3)
                        } else {
                            if (j == 37) {
                                this.xRotate += this.rotationStep
                            } else {
                                if (j == 38) {
                                    this.yRotate -= this.rotationStep
                                } else {
                                    if (j == 39) {
                                        this.xRotate -= this.rotationStep
                                    } else {
                                        if (j == 40) {
                                            this.yRotate += this.rotationStep
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (j == 33) {
                        this.network2DRotate -= (this.rotationStep * 3)
                    } else {
                        if (j == 34) {
                            this.network2DRotate += (this.rotationStep * 3)
                        } else {
                            if (j == 37 || j == 38) {
                                this.network2DRotate -= this.rotationStep
                            } else {
                                if (j == 39 || j == 40) {
                                    this.network2DRotate += this.rotationStep
                                }
                            }
                        }
                    }
                }
                break;
            case "Scatter2D":
            case "ScatterBubble2D":
                var f;
                var h;
                if (this.type2D == "XYZ") {
                    f = ["xAxisCurrent", "yAxisCurrent", "zAxisCurrent"];
                    h = ["xAxis", "yAxis", "zAxis"]
                } else {
                    if (this.type2D == "XY") {
                        f = ["zAxisCurrent"];
                        h = ["zAxis"]
                    } else {
                        if (this.type2D == "X") {
                            f = ["yAxisCurrent", "zAxisCurrent"];
                            h = ["yAxis", "zAxis"]
                        } else {
                            f = ["xAxisCurrent", "zAxisCurrent"];
                            h = ["xAxis", "zAxis"]
                        }
                    }
                } if (j == 33) {
                    for (var d = 0; d < f.length; d++) {
                        this[f[d]] += 2
                    }
                } else {
                    if (j == 34) {
                        for (var d = 0; d < f.length; d++) {
                            this[f[d]] -= 2
                        }
                    } else {
                        if (j == 35) {
                            for (var d = 0; d < f.length; d++) {
                                this[f[d]] = this[h[d]].length - 1
                            }
                        } else {
                            if (j == 36) {
                                for (var d = 0; d < f.length; d++) {
                                    this[f[d]] = 0
                                }
                            } else {
                                if (j == 37 || j == 40) {
                                    for (var d = 0; d < f.length; d++) {
                                        this[f[d]]--
                                    }
                                } else {
                                    if (j == 38 || j == 39) {
                                        for (var d = 0; d < f.length; d++) {
                                            this[f[d]]++
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                this.xAxisCurrent = this.xAxisCurrent < 0 ? this.xAxis.length - 1 : this.xAxisCurrent > this.xAxis.length - 1 ? 0 : this.xAxisCurrent;
                this.yAxisCurrent = this.yAxisCurrent < 0 ? this.xAxis.length - 1 : this.yAxisCurrent > this.yAxis.length - 1 ? 0 : this.yAxisCurrent;
                this.zAxisCurrent = this.zAxisCurrent < 0 ? this.xAxis.length - 1 : this.zAxisCurrent > this.zAxis.length - 1 ? 0 : this.zAxisCurrent;
                break;
            case "Scatter3D":
                if (j == 33) {
                    this.xRotate += (this.rotationStep * 3);
                    this.yRotate -= (this.rotationStep * 3)
                } else {
                    if (j == 34) {
                        this.xRotate -= (this.rotationStep * 3);
                        this.yRotate += (this.rotationStep * 3)
                    } else {
                        if (j == 35) {
                            this.xRotate = 0;
                            this.yRotate = 0;
                            this.zRotate = 45
                        } else {
                            if (j == 36) {
                                this.xRotate = 45;
                                this.yRotate = 0;
                                this.zRotate = 0
                            } else {
                                if (j == 37) {
                                    this.xRotate += this.rotationStep
                                } else {
                                    if (j == 38) {
                                        this.yRotate -= this.rotationStep
                                    } else {
                                        if (j == 39) {
                                            this.xRotate -= this.rotationStep
                                        } else {
                                            if (j == 40) {
                                                this.yRotate += this.rotationStep
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                break
        }
        if (b && !this.animationOn) {
            this.animationOn = true;
            this.animate(j)
        } else {
            this.draw(false, false, false, true)
        }
    };
    this.animate = function(d) {
        var a = this;
        var b = function() {
            this.update = function() {
                if (!a.animationOn) {
                    clearInterval(c)
                }
                a.arrowMove(d);
                var e = a.graphType;
                if (a.is3DPlot) {
                    e = "Scatter3D"
                }
                switch (e) {
                    case "Network":
                        if (this.is3DNetwork) {
                            if (d == 33) {
                                this.xRotate += (this.rotationStep * 3);
                                this.yRotate -= (this.rotationStep * 3)
                            } else {
                                if (d == 34) {
                                    this.xRotate -= (this.rotationStep * 3);
                                    this.yRotate += (this.rotationStep * 3)
                                } else {
                                    if (d == 37) {
                                        this.xRotate -= this.rotationStep
                                    } else {
                                        if (d == 38) {
                                            this.yRotate -= this.rotationStep
                                        } else {
                                            if (d == 39) {
                                                this.xRotate += this.rotationStep
                                            } else {
                                                if (d == 40) {
                                                    this.yRotate += this.rotationStep
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if (d == 33) {
                                this.network2DRotate += (this.rotationStep * 3)
                            } else {
                                if (d == 34) {
                                    this.network2DRotate -= (this.rotationStep * 3)
                                } else {
                                    if (d == 37 || d == 38) {
                                        this.network2DRotate -= this.rotationStep
                                    } else {
                                        if (d == 39 || d == 40) {
                                            this.network2DRotate += this.rotationStep
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "Scatter2D":
                    case "ScatterBubble2D":
                        if (d != 37) {
                            if (a.graphType == "ScatterBubble2D" && a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length && a.xAxisIndices.length == a.zAxisIndices.length) {
                                if (a.xAxisCurrent >= a.xAxis.length - 1) {
                                    a.xAxisCurrent = a.xAxis.length - 1;
                                    a.yAxisCurrent = a.yAxis.length - 1;
                                    a.zAxisCurrent = a.zAxis.length - 1;
                                    d = 37
                                }
                            } else {
                                if (a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length) {
                                    if (a.zAxisCurrent >= a.zAxis.length - 1) {
                                        a.zAxisCurrent = a.zAxis.length - 1;
                                        d = 37
                                    }
                                } else {
                                    if (a.xAxisIndices.length > a.yAxisIndices.length) {
                                        if (a.yAxisCurrent >= a.yAxis.length - 1) {
                                            a.yAxisCurrent = a.yAxis.length - 1
                                        }
                                        if (a.zAxisCurrent >= a.zAxis.length - 1) {
                                            a.zAxisCurrent = a.zAxis.length - 1
                                        }
                                        if (a.yAxisCurrent >= a.yAxis.length - 1 && a.zAxisCurrent >= a.zAxis.length - 1) {
                                            d = 37
                                        }
                                    } else {
                                        if (a.xAxisCurrent >= a.xAxis.length - 1) {
                                            a.xAxisCurrent = a.xAxis.length - 1
                                        }
                                        if (a.zAxisCurrent >= a.zAxis.length - 1) {
                                            a.zAxisCurrent = a.zAxis.length - 1
                                        }
                                        if (a.xAxisCurrent >= a.xAxis.length - 1 && a.zAxisCurrent >= a.zAxis.length - 1) {
                                            d = 37
                                        }
                                    }
                                }
                            }
                        } else {
                            if (d != 39) {
                                if (a.graphType == "ScatterBubble2D" && a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length && a.xAxisIndices.length == a.zAxisIndices.length) {
                                    if (a.xAxisCurrent <= 0) {
                                        a.xAxisCurrent = 0;
                                        a.yAxisCurrent = 0;
                                        a.zAxisCurrent = 0;
                                        d = 39
                                    }
                                } else {
                                    if (a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length) {
                                        if (a.zAxisCurrent <= 0) {
                                            a.zAxisCurrent = 0;
                                            d = 39
                                        }
                                    } else {
                                        if (a.xAxisIndices.length > a.yAxisIndices.length) {
                                            if (a.yAxisCurrent <= 0) {
                                                a.yAxisCurrent = 0
                                            }
                                            if (a.zAxisCurrent <= 0) {
                                                a.zAxisCurrent = 0
                                            }
                                            if (a.yAxisCurrent <= 0 && a.zAxisCurrent <= 0) {
                                                d = 39
                                            }
                                        } else {
                                            if (a.xAxisCurrent <= 0) {
                                                a.xAxisCurrent = 0
                                            }
                                            if (a.zAxisCurrent <= 0) {
                                                a.zAxisCurrent = 0
                                            }
                                            if (a.xAxisCurrent <= 0 && a.zAxisCurrent <= 0) {
                                                d = 39
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "Scatter3D":
                        if (a.xRotate <= 0 && (d == 39 || d < 37)) {
                            a.xRotate = 0;
                            a.yRotate = 0;
                            d = 40
                        } else {
                            if (a.xRotate >= 90 && (d == 37 || d < 37)) {
                                a.xRotate = 90;
                                a.yRotate = 90;
                                d = 38
                            } else {
                                if (a.yRotate <= 0 && (d == 38 || d < 37)) {
                                    a.yRotate = 0;
                                    a.xRotate = 90;
                                    d = 39
                                } else {
                                    if (a.yRotate >= 90 && (d == 40 || d < 37)) {
                                        a.yRotate = 90;
                                        a.xRotate = 0;
                                        d = 37
                                    }
                                }
                            }
                        }
                        break
                }
            };
            var c = setInterval(this.update, a.animationTime)
        };
        b.call()
    };
    this.setGraphType = function(b) {
        var a;
        if (b == 66) {
            a = "Bar"
        } else {
            if (b == 76) {
                a = "Line"
            } else {
                if (b == 65) {
                    a = "Area"
                } else {
                    if (b == 67) {
                        a = "BarLine"
                    } else {
                        if (b == 73) {
                            a = "Boxplot"
                        } else {
                            if (b == 68) {
                                a = "Dotplot"
                            } else {
                                if (b == 72) {
                                    a = "Heatmap"
                                } else {
                                    if (b == 83) {
                                        a = "Stacked"
                                    } else {
                                        if (b == 85) {
                                            a = "StackedLine"
                                        } else {
                                            if (b == 84) {
                                                a = "StackedPercent"
                                            } else {
                                                if (b == 87) {
                                                    a = "StackedPercentLine"
                                                } else {
                                                    if (b == 50) {
                                                        a = "Scatter2D"
                                                    } else {
                                                        if (b == 52) {
                                                            a = "ScatterBubble2D"
                                                        } else {
                                                            if (b == 51) {
                                                                a = "Scatter3D"
                                                            } else {
                                                                if (b == 88) {
                                                                    a = "Correlation"
                                                                } else {
                                                                    if (b == 86) {
                                                                        a = "Venn"
                                                                    } else {
                                                                        if (b == 80) {
                                                                            a = "Pie"
                                                                        } else {
                                                                            if (b == 78) {
                                                                                a = "Network"
                                                                            } else {
                                                                                if (b == 71) {
                                                                                    a = "Genome"
                                                                                } else {
                                                                                    if (b == 77) {
                                                                                        a = "Candlestick"
                                                                                    } else {
                                                                                        if (b == 82) {
                                                                                            a = "Circular"
                                                                                        } else {
                                                                                            if (b == 89) {
                                                                                                a = "Treemap"
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } if (a && this.isValidGraphType(a)) {
            this.graphType = a;
            this.draw()
        } else {
            alert("Dude! You cannot plot this data in a " + a + " graph")
        }
    };
    this.reset = function() {
        this.varIndicesStart = -1;
        this.smpIndicesStart = -1;
        switch (this.graphType) {
            case "Area":
            case "AreaLine":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Heatmap":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Bar":
            case "Line":
            case "BarLine":
            case "Boxplot":
            case "Dotplot":
            case "Candlestick":
            case "Circular":
            case "Treemap":
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                break;
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Scatter3D":
                this.resetSelectedDataPoints();
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                break;
            case "Network":
                this.resetSelectedNodes();
                this.setAllNodesVisible();
                this.ctx.translate(-this.offsetX, -this.offsetY);
                this.ctx.scale(1 / this.scaleFactor, 1 / this.scaleFactor);
                break;
            case "Genome":
                this.setAllFeaturesVisible();
                break
        }
    };
    this.redraw = function() {
        this.varIndicesStart = -1;
        this.smpIndicesStart = -1;
        switch (this.graphType) {
            case "Area":
            case "AreaLine":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Circular":
            case "Treemap":
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                break;
            case "Bar":
            case "Line":
            case "BarLine":
            case "Boxplot":
            case "Dotplot":
            case "Genome":
            case "Candlestick":
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                this.setMinX = null;
                this.setMaxX = null;
                this.setMinX2 = null;
                this.setMaxX2 = null;
                this.xRotate = 45;
                this.yRotate = 0;
                break;
            case "Scatter2D":
            case "ScatterBubble2D":
                this.resetSelectedDataPoints();
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                this.setMinX = null;
                this.setMaxX = null;
                this.setMinY = null;
                this.setMaxY = null;
                break;
            case "Scatter3D":
                this.resetSelectedDataPoints();
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                this.xRotate = 45;
                this.yRotate = 0;
                break;
            case "Heatmap":
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                break;
            case "Network":
                this.resetSelectedNodes();
                this.setAllNodesVisible();
                this.network2DRotate = 0;
                if (this.randomData) {
                    this.layoutDone = true
                }
                this.ctx.translate(-this.offsetX, -this.offsetY);
                this.ctx.scale(1 / this.scaleFactor, 1 / this.scaleFactor);
                break
        }
        this.setInitialConfig();
        this.draw();
        return true
    };
    this.resetZoomPan = function() {
        this.zoom = 1;
        this.panningX = 0;
        this.panningY = 0;
        this.panningGlobalX = 0;
        this.panningGlobalY = 0;
        this.padX = this.x / 2;
        this.padY = this.y / 2;
        this.padZ = this.y / 2
    };
    this.resetSelectedObjects = function() {
        if (this.isSelectDataPoints || this.isSelectNodes) {
            this.resetSelectedDataPoints();
            this.resetSelectedNodes();
            this.draw()
        }
    };
    this.masterReset = function(a) {
        this.resetTooltipDivs();
        this.resetDrag(a);
        this.resetSelectedDataPoints();
        this.resetSelectedNodes();
        if (this.dataTableLastState && this.dataTableLastState != "docked") {
            this.hideUnhideDataTable(true)
        }
        this.resetConfigurator();
        this.resetAxesResizer(a);
        this.resetFlags(a);
        this.resetZoomPan();
        this.redraw()
    }
};
CanvasXpress.prototype.initSelectEvents = function() {
    this.showHideSelectedDataPoint = function(j, l) {
        if (j) {
            this.stopEvent(j)
        }
        var o = this.layoutComb ? this.layoutValidN : 0;
        var r = this.layoutComb ? this.layoutParams[o].graphType : this.graphType;
        var q = [];
        if (l == 45 || l == 46) {
            if (r == "Network") {
                var a = [];
                var k = l == 45 ? false : true;
                for (var d in this.selectNode) {
                    a.push(d)
                }
                if (a.length > 0) {
                    this.hideUnhideNodes(a, k)
                }
            } else {
                if (r.match(/Scatter/)) {
                    if (l == 45) {
                        this.selectDataPoint = this.hideDataPoint;
                        this.hideDataPoint = []
                    } else {
                        if (l == 46) {
                            this.hideDataPoint = this.selectDataPoint;
                            this.selectDataPoint = []
                        }
                    } if (r == "Scatter3D") {
                        var m = this.xAxisIndex + ":" + this.yAxisIndex + ":" + this.zAxisIndex;
                        for (var g = 0; g < this.data.y.vars.length; g++) {
                            if (this.isVisibleSelectedDataPoint(g, m)) {
                                q.push(g)
                            }
                        }
                        this.varIndices = q
                    }
                }
            }
            this.draw()
        } else {
            if (l == 36) {
                if (r == "Network") {
                    var b = {};
                    var h = [];
                    var a = this.data.nodes;
                    var f = this.data.edges;
                    for (var g = 0; g < f.length; g++) {
                        if (this.selectNode.hasOwnProperty(f[g].id1) || this.selectNode.hasOwnProperty(f[g].id2)) {
                            b[f[g].id1] = true;
                            b[f[g].id2] = true
                        }
                    }
                    for (var g = 0; g < a.length; g++) {
                        if (!b.hasOwnProperty(a[g].id) || a[g].hide) {
                            h.push(a[g].id)
                        }
                    }
                    this.resetSelectedNodes();
                    if (h.length > 0) {
                        this.hideUnhideNodes(h, true);
                        this.draw()
                    }
                } else {
                    if (r == "Scatter3D") {
                        if (this.isSelectDataPoints) {
                            for (var g in this.selectDataPoint) {
                                var p = parseInt(g);
                                if (!isNaN(p)) {
                                    q.push(this.varIndices[p])
                                }
                            }
                            this.isSelectDataPoints = 0;
                            this.selectDataPoint = [];
                            this.varIndices = q;
                            this.draw()
                        }
                    }
                }
            }
        }
    };
    this.addRemoveToSelectedDataPoints = function(h, f) {
        var b = this.broadcast ? CanvasXpress.references : [this];
        for (var e = 0; e < b.length; e++) {
            var g = b[e];
            if (!h) {
                var j = g.layoutComb ? g.layoutValidN : 0;
                h = g.layoutComb ? g.layoutParams[j].graphType : g.graphType
            }
            if (h == "Network") {
                var a = parseInt(f.join(", "));
                if (a < g.data.nodes.length) {
                    var d = g.data.nodes[a].id;
                    if (g.selectNode.hasOwnProperty(d)) {
                        g.isSelectNodes--;
                        delete(g.selectNode[d])
                    } else {
                        g.isSelectNodes++;
                        g.selectNode[d] = true
                    }
                }
            } else {
                if (h.match(/Scatter/)) {
                    var d;
                    if (!g.selectDataPoint[f[0]]) {
                        g.selectDataPoint[f[0]] = {}
                    }
                    if (h == "Scatter3D") {
                        d = f[1] + ":" + f[2] + ":" + f[3]
                    } else {
                        d = f[1] + ":" + f[2]
                    } if (g.selectDataPoint[f[0]].hasOwnProperty(d)) {
                        g.isSelectDataPoints--;
                        if (this.broadcastType == "var") {
                            delete(g.selectDataPoint[f[0]])
                        } else {
                            delete(g.selectDataPoint[f[0]][d])
                        }
                    } else {
                        g.isSelectDataPoints++;
                        if (this.broadcastType == "var") {
                            g.selectDataPoint[f[0]][d] = true
                        } else {
                            g.selectDataPoint[f[0]] = true
                        }
                    }
                }
            } if (this.userEvents.select) {
                if (h == "Network") {
                    this.userEvents.select.call(g, g.selectNode)
                } else {
                    this.userEvents.select.call(g, g.selectDataPoint)
                }
            }
        }
    };
    this.resetSelectedDataPoints = function() {
        if (this.isSelectDataPoints) {
            this.selectDataPoint = [];
            this.hideDataPoint = [];
            this.isSelectDataPoints = 0
        }
    };
    this.resetSelectedNodes = function() {
        if (this.isSelectNodes) {
            this.selectNode = {};
            this.isSelectNodes = 0
        }
    }
};
CanvasXpress.prototype.initDendrogramEvents = function() {
    this.modifyDendrogram = function(g) {
        this.setOriginalIndices();
        var c = g.t.t.replace("Dendrogram", "s");
        var f = this[g.t.t].object;
        var h = g.t.d + "-" + g.t.o;
        var e = this.findDendrogramBranch(f, h);
        var b = this.reverseDendrogramBranch(e);
        var d = this.findDendrogramIndices(g.t.t, e);
        var a = this.writeNewick(f, true);
        this.data.t[c] = a;
        this.reorderOriginalIndices(g.t.c || 0, g.t.t, d);
        this.draw()
    };
    this.findDendrogramBranch = function(b, c, a) {
        if (b.id == c) {
            a = b
        }
        if (!a) {
            if (b.left) {
                a = this.findDendrogramBranch(b.left, c, a)
            }
            if (b.right) {
                a = this.findDendrogramBranch(b.right, c, a)
            }
        } else {
            return a
        }
        return a
    };
    this.findDendrogramIndices = function(c, f) {
        var b, d;
        var e = f.left;
        var a = f.right;
        while (e.left) {
            b = e.id;
            e = e.left
        }
        b = e.id;
        while (a.right) {
            d = a.id;
            a = a.right
        }
        d = a.id;
        if (c == "varDendrogram") {
            b = this.getVariableIndices(b);
            d = this.getVariableIndices(d)
        } else {
            b = this.getSampleIndices(b);
            d = this.getSampleIndices(d)
        }
        return [b, d]
    };
    this.reverseDendrogramBranch = function(b) {
        if (b && b.right && b.left) {
            b.right = this.reverseDendrogramBranch(b.right);
            b.left = this.reverseDendrogramBranch(b.left);
            var a = b.left;
            b.left = b.right;
            b.right = a;
            if (b.mid) {
                b.mid = b.mid.reverse()
            }
        }
        return b
    };
    this.zoomDendrogram = function(e) {
        this.setOriginalIndices();
        var d = false;
        var k = e.t.c || 0;
        var j = this[e.t.t].object;
        var b = e.t.d + "-" + e.t.o;
        var m = this.findDendrogramBranch(j, b);
        var f = this.findDendrogramIndices(e.t.t, m);
        var g = f[0];
        var a = f[1];
        if (e.t.t == "varDendrogram") {
            this.varIndices = [];
            for (var h = 0; h < this.startingVarIndices[k].length; h++) {
                if (this.startingVarIndices[k][h] == g) {
                    this.varIndicesStart = h;
                    d = true
                } else {
                    if (this.startingVarIndices[k][h] == a) {
                        this.varIndices.push(this.startingVarIndices[k][h]);
                        break
                    }
                } if (d) {
                    this.varIndices.push(this.startingVarIndices[k][h])
                }
            }
        } else {
            this.smpIndices = [];
            for (var h = 0; h < this.startingSmpIndices[k].length; h++) {
                if (this.startingSmpIndices[k][h] == g) {
                    this.smpIndicesStart = h;
                    d = true
                } else {
                    if (this.startingSmpIndices[k][h] == a) {
                        this.smpIndices.push(this.startingSmpIndices[k][h]);
                        break
                    }
                } if (d) {
                    this.smpIndices.push(this.startingSmpIndices[k][h])
                }
            }
        }
        this.draw()
    }
};
CanvasXpress.prototype.initCanvasEvents = function() {
    this.contextmenuCanvas = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            if (c) {
                if (a.Ext && a.Ext.contextmenu) {
                    return
                } else {
                    a.cancelEvent(c);
                    var b = a.getEventDataId(c);
                    a.handleMouseEvents("contextmenu", c, b)
                }
            }
            return false
        }
    }(this);
    this.mousedownCanvas = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            if (c && c.which ? c.which != 3 : c.button != 2) {
                if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
                    a.touchEvent = "hold";
                    a.registerDrag(c);
                    if (a.mobileApp) {
                        var b = function() {
                            clearTimeout(b);
                            if (a.touches && a.touches.length == 1 && a.touchEvent == "hold") {
                                a.masterReset(c)
                            }
                        };
                        setTimeout(b, 500)
                    }
                }
            }
            return false
        }
    }(this);
    this.clickCanvas = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            a.resetMenuLinks();
            a.closeHelp();
            a.clickBuffer = function() {
                if (!a.doubleClick) {
                    if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
                        if (!a.skipClick && (a.lastCanvasEvent != "drag")) {
                            if (a.isHelp(b)) {
                                a.stopEvent(b);
                                a.showInfoSpan(b, 'Modify "helpKeyEvents"<br>&nbsp;&nbsp;&nbsp;to show or hide help<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on key events"')
                            } else {
                                if (a.isAxis(b)) {
                                    a.stopEvent(b)
                                } else {
                                    if (a.axesResizerShow && !a.resizerType) {
                                        a.stopEvent(b);
                                        a.resetAxesResizer(b)
                                    } else {
                                        if (a.mobileApp) {
                                            a.stopEvent(b);
                                            a.addConfigurator(b)
                                        } else {
                                            var c = a.getEventDataId(b);
                                            if (c) {
                                                a.handleMouseEvents("click", b, c)
                                            } else {
                                                a.resetSelectedObjects()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        a.resetConfigurator()
                    }
                    a.lastCanvasEvent = "click"
                }
            };
            setTimeout(a.clickBuffer, 250);
            setTimeout(function() {
                a.doubleClick = false
            }, 500)
        }
    }(this);
    this.dblclickCanvas = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            a.doubleClick = true;
            if (a.clickBuffer) {
                clearTimeout(a.clickBuffer);
                a.clickBuffer = null
            }
            if (!a.skipClick) {
                var b = a.getEventDataId(c);
                if (b) {
                    a.handleMouseEvents("dblclick", c, b)
                } else {
                    a.cancelEvent(c);
                    a.addConfigurator(c)
                }
                a.lastCanvasEvent = "dblclick"
            }
            return false
        }
    }(this);
    this.wheelCanvas = function(a) {
        return function(b) {
            if (!a.isWheelingOn) {
                a.isWheelingOn = true;
                if (!b) {
                    b = window.event
                }
                var c = 0;
                if (!b) {
                    b = window.event
                }
                if (b.wheelDelta) {
                    c = b.wheelDelta / 120;
                    if (window.opera) {
                        c = -c
                    }
                } else {
                    if (b.detail) {
                        c = -b.detail / 3
                    }
                } if (c) {
                    a.handleWheelEvent(b, c)
                }
                a.isWheelingOn = false
            }
        }
    }(this);
    this.addRemoveCanvasListeners = function(a) {
        this[a](this.canvas, "contextmenu", this.contextmenuCanvas, false);
        this[a](this.canvas, "mousedown", this.mousedownCanvas, false);
        this[a](this.canvas, "touchstart", this.mousedownCanvas, false);
        this[a](this.canvas, "click", this.clickCanvas, false);
        this[a](this.canvas, "dblclick", this.dblclickCanvas, false);
        this[a](this.canvas, "mousewheel", this.wheelCanvas, false)
    };
    this.isVersion = function(b) {
        if (this.showVersion) {
            var a = this.adjustedCoordinates(b);
            return a && a.x > 0 && a.x <= 10 && a.y > 0 && a.y <= 10 ? true : false
        }
    };
    this.isHelp = function(b) {
        var a = this.adjustedCoordinates(b);
        return a && a.x > 0 && a.x <= 10 && a.y > 0 && a.y <= 10 ? true : false
    };
    this.handleWheelEvent = function(G, H, K) {
        var F = this.getTargetEvent(G);
        if (/CanvasXpress/.test(F.className)) {
            CanvasXpress.current = F.id
        }
        if (this.graphType == "Network") {
            this.cancelEvent(G);
            if (!K) {
                K = this.adjustedCoordinates(G)
            }
            if (K) {
                if (G.type == "keydown") {
                    K.x = this.width / 2;
                    K.y = this.height / 2
                }
                var u = this.scaleFactor * this.zoomStep;
                var m = (this.widthBounds / 2) - (K.x / this.scaleFactor);
                var k = (this.heightBounds / 2) - (K.y / this.scaleFactor);
                this.scaleFactor = H > 0 ? this.scaleFactor + u : this.scaleFactor - u;
                this.widthBounds = this.x / this.scaleFactor;
                this.heightBounds = this.y / this.scaleFactor;
                var g = (this.widthBounds / 2) - (K.x / this.scaleFactor);
                var M = (this.heightBounds / 2) - (K.y / this.scaleFactor);
                this.panningX = m - g;
                this.panningY = k - M;
                if (!this.networkFreeze) {
                    u = this.zoom * this.zoomStep;
                    this.zoom = H > 0 ? this.zoom + u : this.zoom - u
                }
                this.draw(false, false, false, true);
                this.panningGlobalX += this.panningX;
                this.panningGlobalY += this.panningY
            }
        } else {
            if (this.graphType == "Genome") {
                this.cancelEvent(G);
                if (this.xAxisUnit > 100 && H > 0) {
                    return
                }
                if (!K) {
                    K = this.adjustedCoordinates(G)
                }
                if (K) {
                    var j = (K.x - (this.marginLeft + this.left)) / this.x;
                    var v = 1 - j;
                    var y = this.xAxisRange * this.zoomStep;
                    if (H > 0) {
                        this.setMinX = this.setMinX != null ? this.setMinX + (y * j) : this.xAxisMin + (y * j);
                        this.setMaxX = this.setMaxX != null ? this.setMaxX - (y * v) : this.xAxisMax - (y * v)
                    } else {
                        this.setMinX = this.setMinX != null ? this.setMinX - (y * j) : this.xAxisMin - (y * j);
                        this.setMaxX = this.setMaxX != null ? this.setMaxX + (y * v) : this.xAxisMax + (y * v)
                    }
                    this.draw()
                }
            } else {
                if (this.graphType == "Heatmap") {
                    this.cancelEvent(G);
                    this.resetAxesResizer(G);
                    var I = this.layoutComb ? this.layoutValidN : 0;
                    var z;
                    var B = this.layoutComb ? this.layoutParams[I].varIndices : this.varIndices;
                    var n = this.isGroupedData ? this.grpIndices : this.smpIndices;
                    if (this.isGroupedData) {
                        z = this.layoutComb ? this.layoutParams[I].grpIndices : this.grpIndices
                    } else {
                        z = this.layoutComb ? this.layoutParams[I].smpIndices : this.smpIndices
                    }
                    this.setOriginalIndices(I, B, z);
                    if (!K) {
                        K = this.adjustedCoordinates(G)
                    }
                    if (K) {
                        if (G.type == "keydown") {
                            K.x = this.width / 2;
                            K.y = this.height / 2
                        }
                        K.x -= (this.marginLeft + this.left);
                        K.y -= (this.marginTop + this.top);
                        var A = Math.min(Math.max(K.x, 0), this.x) / this.x;
                        var J = Math.ceil(B.length / 10) * 2;
                        var a = Math.round(A * J);
                        var q = J - a;
                        var D = Math.min(Math.max(K.y, 0), this.y) / this.y;
                        var L = Math.ceil(z.length / 10) * 2;
                        var f = Math.round(D * L);
                        var t = L - f;
                        var s = false;
                        if (H > 0) {
                            if (!this.zoomVariablesDisable && B.length > 3) {
                                if (this.varIndicesStart < 0) {
                                    this.varIndicesStart++
                                }
                                for (var E = 0; E < a; E++) {
                                    this.varIndices.shift();
                                    this.varIndicesStart++
                                }
                                for (var E = 0; E < q; E++) {
                                    this.varIndices.pop()
                                }
                                s = true
                            }
                            if (!this.zoomSamplesDisable && z.length > 3) {
                                if (this.smpIndicesStart < 0) {
                                    this.smpIndicesStart++
                                }
                                for (var E = 0; E < f; E++) {
                                    this.smpIndices.shift();
                                    this.smpIndicesStart++
                                }
                                for (var E = 0; E < t; E++) {
                                    this.smpIndices.pop()
                                }
                                s = true
                            }
                        } else {
                            if (!this.zoomVariablesDisable) {
                                for (var E = 0; E < a; E++) {
                                    if (this.varIndicesStart >= 0 && this.varIndicesStart + B.length < this.startingVarIndices[I].length) {
                                        this.varIndices.push(this.startingVarIndices[I][this.varIndicesStart + B.length]);
                                        s = true
                                    } else {
                                        if (this.varIndicesStart > 0) {
                                            this.varIndicesStart--;
                                            this.varIndices.unshift(this.startingVarIndices[I][this.varIndicesStart]);
                                            s = true
                                        }
                                    }
                                }
                                for (var E = 0; E < q; E++) {
                                    if (this.varIndicesStart > 0) {
                                        this.varIndicesStart--;
                                        this.varIndices.unshift(this.startingVarIndices[I][this.varIndicesStart]);
                                        s = true
                                    } else {
                                        if (this.varIndicesStart >= 0 && this.varIndicesStart + B.length < this.startingVarIndices[I].length) {
                                            this.varIndices.push(this.startingVarIndices[I][this.varIndicesStart + B.length]);
                                            s = true
                                        }
                                    }
                                }
                            }
                            if (!this.zoomSamplesDisable) {
                                for (var E = 0; E < f; E++) {
                                    if (this.smpIndicesStart >= 0 && this.smpIndicesStart + z.length < this.startingSmpIndices[I].length) {
                                        this.smpIndices.push(this.startingSmpIndices[I][this.smpIndicesStart + z.length]);
                                        s = true
                                    } else {
                                        if (this.smpIndicesStart > 0) {
                                            this.smpIndicesStart--;
                                            this.smpIndices.unshift(this.startingSmpIndices[I][this.smpIndicesStart]);
                                            s = true
                                        }
                                    }
                                }
                                for (var E = 0; E < t; E++) {
                                    if (this.smpIndicesStart > 0) {
                                        this.smpIndicesStart--;
                                        this.smpIndices.unshift(this.startingSmpIndices[I][this.smpIndicesStart]);
                                        s = true
                                    } else {
                                        if (this.smpIndicesStart >= 0 && this.smpIndicesStart + z.length < this.startingSmpIndices[I].length) {
                                            this.smpIndices.push(this.startingSmpIndices[I][this.smpIndicesStart + z.length]);
                                            s = true
                                        }
                                    }
                                }
                            }
                        } if (s) {
                            this.draw()
                        }
                    }
                } else {
                    if (this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked/) && !this.is3DPlot) {
                        this.cancelEvent(G);
                        this.resetAxesResizer(G);
                        var I = this.layoutComb ? this.layoutValidN : 0;
                        var z;
                        var B = this.layoutComb ? this.layoutParams[I].varIndices : this.varIndices;
                        var n = this.isGroupedData ? this.grpIndices : this.smpIndices;
                        if (this.isGroupedData) {
                            z = this.layoutComb ? this.layoutParams[I].grpIndices : this.grpIndices
                        } else {
                            z = this.layoutComb ? this.layoutParams[I].smpIndices : this.smpIndices
                        }
                        this.setOriginalIndices(I, B, z);
                        if (!K) {
                            K = this.adjustedCoordinates(G)
                        }
                        if (K) {
                            if (G.type == "keydown") {
                                K.x = this.width / 2;
                                K.y = this.height / 2
                            }
                            K.x -= (this.marginLeft + this.left);
                            K.y -= (this.marginTop + this.top);
                            var p = this.graphOrientation == "vertical" ? Math.min(Math.max(K.x, 0), this.x) / this.x : Math.min(Math.max(K.y, 0), this.y) / this.y;
                            var C = Math.ceil(z.length / 10) * 2;
                            var l = Math.round(p * C);
                            var h = C - l;
                            var b = [];
                            if (H > 0) {
                                if (z.length > 3) {
                                    if (this.smpIndicesStart < 0) {
                                        this.smpIndicesStart++
                                    }
                                    this.smpIndicesStart += l;
                                    for (var E = l; E < z.length - h; E++) {
                                        b.push(z[E])
                                    }
                                    this.setSamplesVisible(b, true);
                                    this.draw()
                                }
                            } else {
                                if (this.startingSmpIndices[I].length > z.length) {
                                    b = z;
                                    for (var E = 0; E < h; E++) {
                                        if (this.startingSmpIndices[I].length > this.smpIndicesStart + z.length) {
                                            b.push(this.startingSmpIndices[I][this.smpIndicesStart + z.length])
                                        } else {
                                            if (this.smpIndicesStart > 0) {
                                                this.smpIndicesStart--;
                                                b.unshift(this.startingSmpIndices[I][this.smpIndicesStart])
                                            }
                                        }
                                    }
                                    for (var E = 0; E < l; E++) {
                                        if (this.smpIndicesStart > 0) {
                                            this.smpIndicesStart--;
                                            b.unshift(this.startingSmpIndices[I][this.smpIndicesStart])
                                        } else {
                                            if (this.startingSmpIndices[I].length > this.smpIndicesStart + z.length) {
                                                b.push(this.startingSmpIndices[I][this.smpIndicesStart + z.length])
                                            }
                                        }
                                    }
                                    this.setSamplesVisible(b, true);
                                    this.draw()
                                }
                            }
                        }
                    } else {
                        if (this.graphType == "Scatter3D" || this.is3DPlot) {
                            this.cancelEvent(G);
                            if (!K) {
                                K = this.adjustedCoordinates(G)
                            }
                            if (K) {
                                K.x -= (this.marginLeft + this.left);
                                K.y -= (this.marginTop + this.top);
                                var x = (Math.min(Math.max(K.x, 0), this.x) / this.x) - 0.5;
                                var w = (Math.min(Math.max(K.y, 0), this.y) / this.y) - 0.5
                            }
                            if (H > 0) {
                                if (this.zoom >= 4) {
                                    return
                                }
                                this.zoom *= 1.1;
                                this.padX -= x * this.padX / 4;
                                this.padY -= w * this.padY / 4
                            } else {
                                if (this.zoom <= 0.5) {
                                    return
                                }
                                this.zoom *= 0.9;
                                this.padX += x * this.padX / 4;
                                this.padY += w * this.padY / 4
                            }
                            this.draw()
                        } else {
                            if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
                                this.cancelEvent(G);
                                return;
                                if (!K) {
                                    K = this.adjustedCoordinates(G)
                                }
                                if (K) {
                                    K.x -= (this.marginLeft + this.left);
                                    K.y -= (this.marginTop + this.top);
                                    var x = Math.min(Math.max(K.x, 0), this.x) / this.x;
                                    var w = Math.min(Math.max(K.y, 0), this.y) / this.y;
                                    var r = this.xAxisMin + (x * this.xAxisRange);
                                    var o = this.yAxisMax - (w * this.yAxisRange)
                                }
                            }
                        }
                    }
                }
            }
        }
        return false
    };
    this.setLayoutValidIndices = function(k) {
        if (this.layoutComb) {
            var h = this.adjustedCoordinates(k);
            if (h) {
                var a = h.x;
                var g = h.y;
                var m = 0;
                for (var f = 0; f < this.layoutRows; f++) {
                    for (var d = 0; d < this.layoutCols; d++) {
                        var b = this.getBoundsXY(m);
                        if (a >= b[0] && a <= b[1] && g >= b[2] && g <= b[3]) {
                            if (this.layoutValid) {
                                this.layoutValidR = f;
                                this.layoutValidC = d;
                                this.layoutValidN = m
                            }
                        }
                        m++
                    }
                }
            }
        }
    };
    this.getNetworkEventDataId = function(c) {
        var a = this.isEvent(c, true);
        var d = a[0];
        var b = a[1];
        if (d) {
            return b && b.match(/-legend-/) ? false : d
        } else {
            return false
        }
    };
    this.getEventDataId = function(a) {
        return this.graphType == "Network" ? this.getNetworkEventDataId(a) : this.isEvent(a)
    };
    this.getEventAreaData = function(a) {
        return this.extractDataObject(this.getEventDataId(a))
    };
    this.handleMouseEvents = function(b, c, a) {
        if (a[0] == -1) {
            this.showInfoSpan(c, "CanvasXpress (" + this.version + ")")
        } else {
            if (this.layoutComb && !this.layoutValidN) {
                this.setLayoutValidIndices(c)
            }
            var d = this.extractDataObject(a);
            if (this.userEvents[b]) {
                if (typeof(this.userEvents[b]) == "object" && this.userEvents[b].handler && this.userEvents[b].scope) {
                    if (c.ctrlKey && b == "click") {
                        if (c.altKey && b == "click") {
                            alert(this.prettyJSON(d))
                        } else {
                            if (c.shiftKey && b == "click") {
                                this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                this.draw()
                            } else {
                                this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                this.draw()
                            }
                        }
                    } else {
                        if (c.shiftKey && b == "click" && this.graphType == "Network" && this.networkLayoutType == "radial") {
                            this.reRootRadialNetwork(this.getEventDataId(c))
                        } else {
                            if (c.shiftKey && b == "click") {} else {
                                if (c.altKey && b == "click") {} else {
                                    if (b == "click") {
                                        this.resetSelectedObjects()
                                    }
                                    this.userEvents[b].handler.apply(this.userEvents[b].scope, [d, c, this, a])
                                }
                            }
                        }
                    }
                } else {
                    if (typeof(this.userEvents[b]) == "object" && this.userEvents[b].handler) {
                        if (c.ctrlKey && b == "click") {
                            if (c.altKey && b == "click") {
                                alert(this.prettyJSON(d))
                            } else {
                                if (c.shiftKey && b == "click") {
                                    this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                    this.draw()
                                } else {
                                    this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                    this.draw()
                                }
                            }
                        } else {
                            if (c.shiftKey && b == "click" && this.graphType == "Network" && this.networkLayoutType == "radial") {
                                this.reRootRadialNetwork(this.getEventDataId(c))
                            } else {
                                if (c.shiftKey && b == "click") {} else {
                                    if (c.altKey && b == "click") {} else {
                                        if (b == "click") {
                                            this.resetSelectedObjects()
                                        }
                                        this.userEvents[b].handler(d, c, this, a)
                                    }
                                }
                            }
                        }
                    } else {
                        if (c.ctrlKey && b == "click") {
                            if (c.altKey && b == "click") {
                                alert(this.prettyJSON(d))
                            } else {
                                if (c.shiftKey && b == "click") {
                                    this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                    this.draw()
                                } else {
                                    this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                    this.draw()
                                }
                            }
                        } else {
                            if (c.shiftKey && b == "click" && this.graphType == "Network" && this.networkLayoutType == "radial") {
                                this.reRootRadialNetwork(this.getEventDataId(c))
                            } else {
                                if (c.shiftKey && b == "click") {} else {
                                    if (c.altKey && b == "click") {} else {
                                        if (b == "click") {
                                            this.resetSelectedObjects()
                                        }
                                        this.userEvents[b](d, c, this, a)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.formatCoords = function(j, k) {
        var f = [];
        if (this.graphType != "Network") {
            for (var e = 0; e < k.length; e++) {
                if (e % 2) {
                    f.push(sprintf("%.0f", (k[e] + this.translateY) * this.scaleY))
                } else {
                    if (this.layoutValid && j == "circle" && e == 2) {
                        f.push(sprintf("%.0f", k[e] * ((this.scaleX + this.scaleY) / 2)))
                    } else {
                        f.push(sprintf("%.0f", (k[e] + this.translateX) * this.scaleX))
                    }
                }
            }
        } else {
            for (var e = 0; e < k.length; e++) {
                f.push(sprintf("%.0f", parseInt(k[e])))
            }
        } if (j == "rect") {
            var b = Math.min(f[0], f[2]);
            var d = Math.min(f[1], f[3]);
            var a = Math.max(f[0], f[2]);
            var g = Math.max(f[1], f[3]);
            f = [b, d, a, g]
        }
        return f.join(",")
    };
    this.addArea = function(e, a, d) {
        if (!e || !a) {
            return
        }
        var b = e.shift();
        if (b && e) {
            switch (b) {
                case "rect":
                    e[0] -= this.outlineWidth;
                    e[1] -= this.outlineWidth;
                    e[2] += (this.outlineWidth * 2);
                    e[3] += (this.outlineWidth * 2);
                    break;
                case "circle":
                    e[2] += (this.outlineWidth * 2);
                    break;
                case "poly":
                    break
            }
            this.dataEvent.push([a, b, e, d])
        }
    };
    this.flash = function(b, p, m, f, k, a) {
        var j = this.$cX("div", {
            id: this.target + "canvasXpressFlash" + new Date().getTime()
        }, {
            left: (b - (m / 2)) + "px",
            top: (p - (f / 2)) + "px",
            width: m + "px",
            height: f + "px",
            borderRadius: "999px",
            WebkitBorderRadius: "999px",
            MozBorderRadius: "999px",
            opacity: 0.6,
            filter: "alpha(opacity = 60)",
            position: "absolute",
            zIndex: 100000,
            display: "block",
            backgroundColor: k ? k : this.resizerBackgroundColor
        });
        this.canvas.parentNode.appendChild(j);
        if (!a) {
            a = 3
        }
        var g = this;
        var e = 1;
        var o = function() {
            this.update = function() {
                if (e % 2) {
                    j.style.display = "none"
                } else {
                    j.style.display = "block"
                } if (e >= (a * 2)) {
                    g.canvas.parentNode.removeChild(j);
                    clearInterval(c)
                }
                e++
            };
            var c = setInterval(this.update, 300)
        };
        o.call()
    };
    this.initializeCanvasEvents = function() {
        if (!this.disableEvents) {
            this.addRemoveCanvasListeners("addEvtListener")
        }
    };
    this.initializeCanvasEvents()
};
CanvasXpress.prototype.initCleanupEvents = function() {
    this.destroy = function(a) {
        if (a) {
            if (CanvasXpress.references.length == 1 && CanvasXpress.references[0].target == a) {
                return this.destroy()
            } else {
                this.removeReference(a)
            }
        } else {
            while (CanvasXpress.references.length > 0) {
                a = CanvasXpress.references[0];
                this.removeReference(a.target)
            }
            CanvasXpress.cacheImages = {};
            CanvasXpress.cacheText = {};
            CanvasXpress.stack = {};
            CanvasXpress.current = false
        }
    };
    this.monitorReference = function() {
        var b = [];
        for (var a = 0; a < CanvasXpress.references.length; a++) {
            var d = this.$(CanvasXpress.references[a].target);
            if (!d) {
                b.push(CanvasXpress.references[a].target)
            }
        }
        for (var a = 0; a < b.length; a++) {
            this.destroy(b[a])
        }
    };
    this.removeReference = function(e, b) {
        var d = CanvasXpress.references;
        CanvasXpress.references = [];
        for (var c = 0; c < d.length; c++) {
            if (d[c].target != e) {
                CanvasXpress.references.push(d[c])
            } else {
                var f = d[c];
                f.resetTooltipDivs();
                f.cleanEvtListeners(b);
                f.removeTarget("container-" + f.target);
                f.removeTarget(f.target + "-cX-Info")
            }
        }
    };
    this.cleanEvtListeners = function(b) {
        this.addRemoveLinkListeners("removeEvtListener");
        this.addRemoveViewportListeners("removeEvtListener");
        this.addRemoveToolbarListeners("removeEvtListener");
        this.addRemoveCodeListeners("removeEvtListener");
        this.addRemoveItemListeners("removeEvtListener");
        this.addRemoveConfiguratorListeners("removeEvtListener");
        this.addRemoveDataTableListeners("removeEvtListener");
        this.removeGenericDataFilterListenersOrReset();
        this.addRemoveDataFilterListeners("removeEvtListener");
        this.addRemoveCanvasListeners("removeEvtListener");
        this.addRemoveAxesResizerListeners("removeEvtListener");
        this.addRemoveNavigationTopListeners("removeEvtListener");
        this.addRemoveNavigationLeftRightListeners("removeEvtListener");
        this.removeEvtListener(document, "mousemove", this.mousemoveDoc, false);
        this.removeEvtListener(document, "touchmove", this.mousemoveDoc, false);
        this.removeEvtListener(document, "mouseup", this.mouseupDoc, false);
        this.removeEvtListener(document, "touchend", this.mouseupDoc, false);
        this.removeEvtListener(document, "keydown", this.keydownDoc, false);
        this.removeEvtListener(document, "keyup", this.keyupDoc, false);
        this.removeEvtListener(window, "resize", this.resizeWindow, false)
    };
    this.initializeCleanupEvents = function() {
        if (this.destroyCanvasXpressZombies) {
            var b = this;
            var a = function() {
                this.monitor = function() {
                    if (CanvasXpress.references.length < 1) {
                        clearInterval(c)
                    }
                    b.monitorReference()
                };
                var c = setInterval(this.monitor, b.monitorCanvasXpressZombiesTime)
            };
            a.call()
        }
    };
    this.initializeCleanupEvents()
};
CanvasXpress.prototype.initEvents = function() {
    this.relativeCoordinates = function(a) {
        var b = {
            x: 0,
            y: 0
        };
        while (a && !isNaN(a.offsetLeft) && !isNaN(a.offsetTop)) {
            b.x += a.offsetLeft;
            b.y += a.offsetTop;
            a = a.offsetParent
        }
        return b
    };
    this.absoluteCoordinates = function(a) {
        var b = {
            x: 0,
            y: 0
        };
        while (a && !isNaN(a.offsetLeft) && !isNaN(a.offsetTop)) {
            b.x += a.offsetLeft - a.scrollLeft;
            b.y += a.offsetTop - a.scrollTop;
            a = a.offsetParent
        }
        return b
    };
    this.adjustedCoordinates = function(g, b) {
        if (!g) {
            g = window.event
        }
        if (!b) {
            b = this.$(this.target)
        }
        if (this.isIE && this.useFlashIE && this.browserVersion < 9) {
            if (!window.event) {
                return
            }
        }
        if (b) {
            var h = {};
            var a = b.parentNode.getClientRects();
            var d = g && g.changedTouches ? g.changedTouches[0] : false;
            if (a && a[0]) {
                var f = a[0].left;
                var k = a[0].top;
                var j = g && g.clientX ? g.clientX : d ? d.clientX : g && g[0] ? g[0] : f;
                var i = g && g.clientY ? g.clientY : d ? d.clientY : g && g[1] ? g[1] : k;
                h.x = document.body.scrollLeft > Math.abs(f) + j && j > document.body.scrollLeft - f ? Math.abs(f) + j : j - f;
                h.y = document.body.scrollTop > Math.abs(k) + i && i > document.body.scrollTop - k ? Math.abs(k) + i : (i - k)
            } else {
                h.x = 0;
                h.y = 0
            }
            return h
        }
    };
    this.isObjectInsideArea = function(b, g, d, l, c, j) {
        var k, h;
        switch (b) {
            case "rect":
                k = (g[0] + g[2]) / 2;
                h = (g[1] + g[3]) / 2;
                break;
            case "circle":
                k = g[0];
                h = g[1];
                break;
            case "poly":
                var e = [];
                var a = [];
                for (var f = 0; f < g.length; f++) {
                    if (f % 2) {
                        a.push(g[f])
                    } else {
                        e.push(g[f])
                    }
                }
                e.sort(function(m, i) {
                    return (m - i)
                });
                a.sort(function(m, i) {
                    return (m - i)
                });
                k = (e[0] + e[e.length - 1]) / 2;
                h = (a[0] + a[a.length - 1]) / 2;
                break
        }
        return this.isPointInsideArea("rect", k, h, [d, l, c, j])
    };
    this.isPointInsideArea = function(n, m, l, k) {
        switch (n) {
            case "rect":
                if (k[0] > k[2]) {
                    k[4] = k[0];
                    k[0] = k[2];
                    k[2] = k[4]
                }
                if (k[1] > k[3]) {
                    k[4] = k[1];
                    k[1] = k[3];
                    k[3] = k[4]
                }
                if (m >= k[0] && m <= k[2] && l >= k[1] && l <= k[3]) {
                    return true
                } else {
                    return false
                }
            case "circle":
                var f = k[2] / 2;
                if (m >= k[0] - f && m <= k[0] + f && l >= k[1] - f && l <= k[1] + f) {
                    return true
                } else {
                    return false
                }
            case "poly":
                var d = [];
                var a = [];
                var g = false;
                for (var e = 0; e < k.length; e++) {
                    if (e % 2) {
                        a.push(k[e])
                    } else {
                        d.push(k[e])
                    }
                }
                if (a[0] < a[1]) {
                    a = a.reverse();
                    d = d.reverse()
                }
                for (var e = 0, b = d.length - 1; e < d.length; b = e++) {
                    if (((a[e] <= l && l < a[b]) || (a[b] <= l && l < a[e])) && (m < (d[b] - d[e]) * (l - a[e]) / (a[b] - a[e]) + d[e])) {
                        g = !g
                    }
                }
                return g
        }
    };
    this.isEvent = function(o, h, j) {
        var u = this.adjustedCoordinates(o);
        if (u) {
            var d = this.getTargetEvent(o);
            if (d && d.id && d.id.match(this.target)) {
                var t = u.x;
                var q = u.y;
                var r = this.dataEvent;
                var b = [];
                for (var k = r.length - 1; k >= 0; k--) {
                    var g = r[k][0];
                    var v = r[k][1];
                    var p = r[k][2];
                    var l = r[k][3];
                    if (this.isPointInsideArea(v, t, q, p)) {
                        if (l) {
                            l = g[0] + l
                        }
                        if (j) {
                            if (l) {
                                b.push(l)
                            } else {
                                b.push(g[0])
                            }
                        } else {
                            return h ? [g, l] : l ? [l] : g
                        }
                    }
                }
                if (b.length > 0) {
                    return b
                }
            }
        }
        return false
    };
    this.getBoundsXY = function(e) {
        var d = this.layoutComb ? this.layoutParams[e] : this;
        var a = this.graphType == "Network" ? 0 : this.marginLeft + d.offsetX;
        var b = this.graphType == "Network" ? 0 : this.marginTop + d.offsetY;
        return [a + d.left, a + d.left + d.x, b + d.top, b + d.top + d.y, a, a + d.left + d.x + d.right, b, b + d.top + d.y + d.bottom]
    };
    this.getUngroupedDataObject = function(d) {
        if (this.isGroupedData) {
            var b = this.getVariableIndices(d.w.vars);
            var c = [];
            for (var a = 0; a < d.w.grps.length; a++) {
                c = c.concat(d.w.grps[a])
            }
            this.isGroupedData = false;
            d = this.extractDataObject(c, b);
            this.isGroupedData = true
        }
        return d
    };
    this.extractDataObject = function(h, b) {
        var k = this;
        var E = this.layoutComb && this.layoutValidN > -1 ? this.layoutParams[this.layoutValidN].graphType : this.graphType;
        var K = [];
        var I = [];
        var H = [];
        var w = function(d) {
            var n = {};
            for (var j in k.data.x) {
                n[j] = [];
                for (var g = 0; g < d.length; g++) {
                    n[j].push(k.data.x[j][d[g]])
                }
            }
            return n
        };
        var v = function(d) {
            var n = {};
            for (var j in k.data.z) {
                n[j] = [];
                for (var g = 0; g < d.length; g++) {
                    n[j].push(k.data.z[j][d[g]])
                }
            }
            return n
        };
        var F = function(d) {
            var j = [];
            for (var g = 0; g < d.length; g++) {
                j.push(k.data.y.vars[d[g]])
            }
            return j
        };
        var l = function(j, p) {
            var d = p ? k.data.w.smps : k.data.y.smps;
            var s = [];
            for (var n = 0; n < j.length; n++) {
                s.push(d[j[n]])
            }
            return s
        };
        var f = function(d) {
            var j = [];
            for (var g = 0; g < d.length; g++) {
                j.push(k.data.w.grps[d[g]])
            }
            return j
        };
        var e = function(g, d, t) {
            var s = [];
            if (!t) {
                t = "data"
            }
            if (d) {
                for (var p = 0; p < g.length; p++) {
                    s[p] = [];
                    for (var n = 0; n < d.length; n++) {
                        s[p].push(k.data.y[t][g[p]][d[n]])
                    }
                }
            } else {
                for (var p = 0; p < g.length; p++) {
                    s.push(k.data.y[t][g[p]])
                }
            }
            return s
        };
        switch (E) {
            case "Area":
            case "AreaLine":
            case "Bar":
            case "Line":
            case "BarLine":
            case "Boxplot":
            case "Dotplot":
            case "Heatmap":
            case "Pie":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Scatter3D":
            case "Candlestick":
            case "Circular":
            case "Treemap":
                if (!h || h.length == 0 || h[0] == null) {
                    return
                } else {
                    if (isNaN(h[0])) {
                        if (h[0] && h[0].match(/Dendrogram/)) {
                            var y = {
                                t: {}
                            };
                            var x = h[0].split("-");
                            y.t.d = parseInt(x[1]);
                            y.t.o = parseInt(x[2]);
                            y.t.t = x[3];
                            y.objectType = "Dendrogram";
                            return y
                        } else {
                            if (h[0] && h[0].match(/Var/)) {
                                var x = h[0].split("-");
                                var D = parseInt(x[1]);
                                var J = [D];
                                J = J.concat(this.smpIndices);
                                var y = this.extractDataObject(J);
                                if (h[0].match(/VarOvr/)) {
                                    y.display = this.data.y.vars[D] + " : " + this.varOverlays[x[2]] + " : " + this.data.z[this.varOverlays[x[2]]][D]
                                } else {
                                    y.display = this.data.y.vars[D]
                                }
                                y.objectType = "Var";
                                return y
                            } else {
                                if (h[0] && h[0].match(/Smp/)) {
                                    var x = h[0].split("-");
                                    var D = parseInt(x[1]);
                                    var y = this.extractDataObject([D], this.varIndices);
                                    if (h[0].match(/SmpOvr/)) {
                                        y.display = this.isGroupedData ? this.data.w.smps[D] + " : " + this.smpOverlays[x[2]] + " : " + this.data.w.factors[this.smpOverlays[x[2]]][D] : this.data.y.smps[D] + " : " + this.smpOverlays[x[2]] + " : " + this.data.x[this.smpOverlays[x[2]]][D]
                                    } else {
                                        y.display = this.isGroupedData ? this.data.w.smps[D] : this.data.y.smps[D]
                                    }
                                    y.objectType = "Smp";
                                    return y
                                } else {
                                    return
                                }
                            }
                        }
                    } else {
                        if (b) {
                            K = b;
                            I = h
                        } else {
                            K = [h[0]];
                            I = [];
                            for (var D = 1; D < h.length; D++) {
                                I.push(h[D])
                            }
                        } if (E.match(/Scatter/)) {
                            if (this.colorBy && this.getSampleIndices(this.colorBy) > -1) {
                                I.push(this.getSampleIndices(this.colorBy))
                            }
                            if (this.shapeBy && this.getSampleIndices(this.shapeBy) > -1) {
                                I.push(this.getSampleIndices(this.shapeBy))
                            }
                            if (this.sizeBy && this.getSampleIndices(this.sizeBy) > -1) {
                                I.push(this.getSampleIndices(this.sizeBy))
                            }
                        }
                    }
                } if (E.match(/Area/)) {
                    return {
                        x: this.data.x,
                        y: {
                            vars: F(K),
                            smps: this.data.y.smps,
                            data: e(K)
                        },
                        z: v(K)
                    }
                } else {
                    if (this.isGroupedData) {
                        var y = {
                            x: {},
                            w: {},
                            z: v(K)
                        };
                        if (E == "Boxplot" && I[1] != null) {
                            y.y = {
                                data: this.data.y.data[K[0]][I[1]],
                                vars: this.data.y.vars[I[1]],
                                smps: this.data.y.smps[I[1]]
                            }
                        }
                        for (var x in this.data.w) {
                            if (x == "smps") {
                                y.w[x] = l(I, true)
                            } else {
                                if (x == "grps") {
                                    y.w[x] = f(I)
                                } else {
                                    if (x == "vars") {
                                        y.w[x] = F(K)
                                    } else {
                                        if (this.data.w[x].length > K[0] && this.data.w[x][K[0]].length > I[0]) {
                                            y.w[x] = [];
                                            y.w[x].push(this.data.w[x][K[0]][I[0]])
                                        }
                                    }
                                }
                            }
                        }
                        for (var x in this.data.x) {
                            var m = [];
                            for (var D = 0; D < y.w.grps[0].length; D++) {
                                m.push(this.data.x[x][y.w.grps[0][D]])
                            }
                            y.x[x] = m
                        }
                    } else {
                        var y = {
                            x: w(I),
                            y: {
                                vars: F(K),
                                smps: l(I)
                            },
                            z: v(K)
                        };
                        if (E == "Candlestick") {
                            for (var x in this.data.y) {
                                if (x && x != "vars" && x != "smps" && x != "desc") {
                                    y.y[x] = [];
                                    for (var D = 0; D < K.length; D++) {
                                        y.y[x][D] = [];
                                        for (var C = 0; C < I.length; C++) {
                                            y.y[x][D].push(this.data.y[x][K[D]][I[C]])
                                        }
                                    }
                                }
                            }
                        } else {
                            y.y.data = e(K, I);
                            if (this.isMultidimensionalHeatmap) {
                                var A = ["outline", "shape", "size"];
                                for (var D = 0; D < A.length; D++) {
                                    var B = A[D] + "ByData";
                                    if (this.data.y[this[B]]) {
                                        y.y[this[B]] = e(K, I, this[B])
                                    }
                                }
                            }
                        }
                    }
                }
                return y;
            case "Correlation":
                if (!h || (isNaN(h[0]) && !h[0].match(/^\d/))) {
                    return
                } else {
                    var G = this.isGroupedData ? this.data.w.cor : this.data.y.cor
                } if (this.correlationAxis == "samples") {
                    var y = {
                        x: {},
                        y: {}
                    };
                    for (var x in this.data.x) {
                        var m = [];
                        for (var D = 0; D < h.length; D++) {
                            m.push(this.data.x[x][h[D]])
                        }
                        y.x[x] = m
                    }
                    y.y.smps = [this.data.y.smps[h[0]], this.data.y.smps[h[1]]]
                } else {
                    var y = {
                        y: {},
                        z: {}
                    };
                    for (var x in this.data.y) {
                        var c = [];
                        for (var D = 0; D < h.length; D++) {
                            c.push(this.data.y[x][h[D]])
                        }
                        y.z[x] = c
                    }
                    y.y.vars = [this.data.y.vars[h[0]], this.data.y.vars[h[1]]]
                }
                y.y.data = G[h[0]][h[1]];
                return y;
            case "Venn":
                var y = {
                    venn: {
                        data: {}
                    }
                };
                y.venn.data[this.vennCompartments[h[0]]] = this.data.venn.data[this.vennCompartments[h[0]]];
                return y;
            case "Network":
                var y = {};
                if (!h || h.length == 0) {
                    return
                }
                if (isNaN(h[0])) {
                    h[0] = h[0].toString();
                    if (h[0].match(/legend/)) {
                        if (h[0].match(/Nodes/)) {
                            y = {
                                nodeLegend: this.data.legend.nodes
                            }
                        } else {
                            if (h[0].match(/Edges/)) {
                                y = {
                                    edgeLegend: this.data.legend.edges
                                }
                            } else {
                                if (h[0].match(/Decorations/)) {
                                    y = {
                                        decorationLegend: this.data.legend.decorations
                                    }
                                } else {
                                    var q = parseInt(h[0].replace("-1-legend-Text", ""));
                                    y = {
                                        textLegend: this.data.legend.text[q]
                                    }
                                }
                            }
                        }
                    }
                } else {
                    for (var D = 0; D < h.length; D++) {
                        if (h[D] >= this.data.nodes.length) {
                            if (!y.edges) {
                                y.edges = []
                            }
                            y.edges.push(this.data.edges[h[D] - this.data.nodes.length])
                        } else {
                            if (!y.nodes) {
                                y.nodes = []
                            }
                            y.nodes.push(this.data.nodes[h[D]])
                        }
                    }
                }
                return y;
            case "Genome":
                var E;
                var y = [];
                y[0] = {
                    data: []
                };
                var q = 0;
                var r = isNaN(h[0]) && h[0].match(":") ? h[0].match(/:(\d+)/)[1] : false;
                for (var D = 0; D < this.data.tracks.length; D++) {
                    var z = this.data.tracks[D].data.length;
                    q += z;
                    if (isNaN(h[0])) {
                        if (h[0] == "track-" + D) {
                            return {
                                name: this.data.tracks[D].name
                            }
                        } else {
                            if (h[0] == "track-" + D + ":" + r) {
                                var u = parseInt(r) - (q - z);
                                for (var x in this.data.tracks[D]) {
                                    if (x == "data") {
                                        y[0][x].push(this.data.tracks[D][x][u])
                                    } else {
                                        y[0][x] = this.data.tracks[D][x]
                                    }
                                }
                                return y
                            }
                        }
                        continue
                    }
                    if (h[h.length - 1] < q) {
                        for (var C = 0; C < h.length; C++) {
                            var u = h[C] - (q - z);
                            for (var x in this.data.tracks[D]) {
                                if (x == "data") {
                                    y[0][x].push(this.data.tracks[D][x][u])
                                } else {
                                    y[0][x] = this.data.tracks[D][x]
                                }
                            }
                        }
                        return y
                    }
                }
        }
    };
    this.getSummaryDataObject = function(b) {
        if (b) {
            switch (this.graphType) {
                case "Bar":
                case "Line":
                case "Area":
                case "AreaLine":
                case "BarLine":
                case "Boxplot":
                case "Dotplot":
                case "Heatmap":
                case "Stacked":
                case "StackedLine":
                case "StackedPercent":
                case "StackedPercentLine":
                case "Scatter2D":
                case "ScatterBubble2D":
                case "Scatter3D":
                case "Circular":
                case "Treemap":
                    var i = "";
                    if (b.display) {
                        return "<b>" + b.display + "</b><br>"
                    } else {
                        if (this.isGroupedData && b.w) {
                            i = "<b>" + b.w.vars[0] + "</b><br>";
                            if (this.summaryType == "mean") {
                                for (var d = 0; d < b.w.smps.length; d++) {
                                    i += "<b>" + b.w.smps[d] + "</b>: " + this.bestFormatNumber(b.w.mean[d]);
                                    if (b.w.stdev && b.w.stdev[d] != null) {
                                        i += " <i>&plusmn;" + this.bestFormatNumber(b.w.stdev[d]) + "</i>"
                                    }
                                    if (b.w.n && b.w.n[d] != null) {
                                        i += " (" + b.w.n + ")"
                                    }
                                    i += "<br>"
                                }
                            } else {
                                if (this.summaryType == "median" || this.summaryType == "iqr") {
                                    for (var d = 0; d < b.w.smps.length; d++) {
                                        i += "<b>" + b.w.smps[d] + "</b>: " + this.bestFormatNumber(b.w.median[d]);
                                        if (b.w.stdev && b.w.stdev[d] != null) {
                                            i += " <i>&plusmn;" + this.bestFormatNumber(b.w.stdev[d]) + "</i>"
                                        }
                                        if (b.w.n && b.w.n[d] != null) {
                                            i += " (" + b.w.n + ")"
                                        }
                                        i += "<br>"
                                    }
                                } else {
                                    if (this.summaryType == "sum") {
                                        for (var d = 0; d < b.w.smps.length; d++) {
                                            i += "<b>" + b.w.smps[d] + "</b>: " + this.bestFormatNumber(b.w.sum[d]);
                                            if (b.w.stdev && b.w.stdev[d] != null) {
                                                i += " <i>&plusmn;" + this.bestFormatNumber(b.w.stdev[d]) + "</i>"
                                            }
                                            if (b.w.n && b.w.n[d] != null) {
                                                i += " (" + b.w.n + ")"
                                            }
                                            i += "<br>"
                                        }
                                    }
                                }
                            }
                        } else {
                            if (b.y) {
                                i = "<b>" + b.y.vars[0] + "</b><br>";
                                for (var d = 0; d < b.y.smps.length; d++) {
                                    if (this.isMultidimensionalHeatmap) {
                                        var l = [b.y.data[0][d]];
                                        var g = ["outline", "shape", "size"];
                                        for (var c = 0; c < g.length; c++) {
                                            var m = g[c] + "ByData";
                                            if (b.y[this[m]] && b.y[this[m]][0][d]) {
                                                l.push(b.y[this[m]][0][d])
                                            }
                                        }
                                        i += "<b>" + b.y.smps[d] + "</b>: " + l.join(", ") + "<br>"
                                    } else {
                                        i += "<b>" + b.y.smps[d] + "</b>: " + b.y.data[0][d] + "<br>"
                                    }
                                }
                            } else {
                                if (b.t) {
                                    i = "<b>" + b.t.t + "</b><br>Depth: " + b.t.d + "<br>"
                                }
                            }
                        }
                    }
                    return i;
                case "Pie":
                    var n = "<b>" + b.y.smps[0] + "</b><br>";
                    for (var d = 0; d < b.y.vars.length; d++) {
                        var a = sprintf("%." + this.pieSegmentPrecision + "f", (b.y.data[d] / this.varPie.tot) * 100);
                        n += "<b>" + b.y.vars[d] + "</b>: " + b.y.data[d] + " (" + a + "%)<br>"
                    }
                    return n;
                case "Candlestick":
                    return dateFormat(b.y.smps[0], this.timeFormat) + ", " + b.y.close[0];
                case "Correlation":
                    var n;
                    if (this.correlationAxis == "samples") {
                        n = b.y.smps[0] + " vs " + b.y.smps[1]
                    } else {
                        n = b.y.vars[0] + " vs " + b.y.vars[1]
                    }
                    return n;
                case "Venn":
                    for (var e in b.venn.data) {
                        return e + " = " + b.venn.data[e]
                    }
                case "Network":
                    var n;
                    if (b && b.nodes) {
                        if (b.nodes[0]) {
                            n = b.nodes[0].hideTooltip ? "" : b.nodes[0].tooltip || b.nodes[0].name || b.nodes[0].label || b.nodes[0].id
                        }
                    } else {
                        if (b && b.edges) {
                            var h = this.nodes[b.edges[0].id1];
                            var f = this.nodes[b.edges[0].id2];
                            n = (h.label || h.id) + " - " + (f.label || f.id);
                            n = b.edges[0].hideTooltip ? "" : b.edges[0].tooltip || b.edges[0].name || b.edges[0].label || n
                        }
                    }
                    return n;
                case "Genome":
                    return b.name || b[0].data[0].id
            }
        } else {
            return ""
        }
    };
    this.setUserEvents = function() {
        this.userEvents = {};
        if (this.disableEvents) {
            return
        }
        var b = this;
        if (this.events && this.events.enddragnode) {
            this.userEvents.enddragnode = this.events.enddragnode
        }
        if (this.events && this.events.stackchange) {
            this.userEvents.stackchange = this.events.stackchange
        }
        if (this.events && this.events.select) {
            this.userEvents.select = this.events.select
        }
        if (this.events && this.events.enddraw) {
            this.userEvents.enddraw = this.events.enddraw
        }
        if (this.events && this.events.mouseout) {
            this.userEvents.mouseout = this.events.mouseout
        } else {
            this.userEvents.mouseout = function(h, g, f, d) {
                f.resetInfoSpan(g)
            }
        } if (this.events && this.events.contextmenu) {
            this.userEvents.contextmenu = this.events.contextmenu
        } else {
            this.userEvents.contextmenu = function(h, g, f, d) {
                if (f.graphType == "Network") {
                    if (h && h.nodes && h.nodes.length == 1) {
                        if (f.selectNode && !f.selectNode[h.nodes[0].id]) {
                            f.resetSelectedObjects();
                            f.addRemoveToSelectedDataPoints(false, d)
                        }
                    } else {
                        if (h && h.edges && h.edges.length == 1) {}
                    }
                }
                f.addMenu(g)
            }
        } if (this.events && this.events.click) {
            this.userEvents.click = this.events.click
        } else {
            this.userEvents.click = function(h, g, f, d) {
                if (h && h.t) {
                    f.modifyDendrogram(h)
                } else {
                    if (h.nodes && h.nodes.length == 1 && h.nodes[0].links) {
                        f.showLinkDiv(g, h.nodes[0].links, h.nodes[0].label != null ? h.nodes[0].label : h.nodes[0].name ? h.nodes[0].name : h.nodes[0].id)
                    } else {
                        if (h.edges && h.edges.length == 1 && h.edges[0].links) {
                            f.showLinkDiv(g, h.edges[0].links, h.edges[0].label != null ? h.edges[0].label : h.edges[0].name ? h.edges[0].name : h.edges[0].id1 + "-" + h.edges[0].id2)
                        } else {
                            f.showTooltipDiv(g, f.arrayToHTML(f.getDataClassAsArray(f.getUngroupedDataObject(h))))
                        }
                    }
                }
                return false
            }
        } if (this.events && this.events.dblclick) {
            this.userEvents.dblclick = this.events.dblclick
        } else {
            this.userEvents.dblclick = function(h, g, f, d) {
                if (h && h.t) {
                    f.zoomDendrogram(h)
                } else {
                    if (f.graphType == "Network" || f.graphType == "Genome") {
                        f.addConfigurator(g, d)
                    } else {
                        if (h) {
                            alert(f.prettyJSON(h))
                        }
                    }
                }
                return false
            }
        }
        var c = ["mouseover", "mousemove"];
        for (var a = 0; a < c.length; a++) {
            if (this.events && this.events[c[a]]) {
                this.userEvents[c[a]] = this.events[c[a]]
            } else {
                this.userEvents[c[a]] = function(g, d) {
                    var f = b.getSummaryDataObject(g);
                    if (f && f != "") {
                        b.showInfoSpan(d, f)
                    }
                }
            }
        }
    };
    this.resetFlags = function(a) {
        this.resetOn = true;
        this.animationOn = false;
        this.draggingOn = false;
        this.movingOn = false;
        this.panningOn = false;
        this.changingColorOn = false;
        this.keyOn = false;
        this.xMouseDown = false;
        this.yMouseDown = false;
        this.touches = false;
        this.toucheEvent = false;
        this.moveNode = false;
        this.moveNodeIndex = false;
        this.moveNodeLab = false;
        this.moveNodeDec = false;
        this.moveLegend = false;
        this.moveNodeX = false;
        this.moveNodeY = false;
        this.moveNodeW = false;
        this.moveNodeH = false;
        this.moveGenome = false;
        this.moveVar = false;
        this.moveSmp = false;
        if (a) {
            this.stopEvent(a)
        }
        document.defaultAction = true;
        document.body.style.cursor = "default"
    };
    this.mousemoveDoc = function(a) {
        return function(f) {
            if (!f) {
                f = window.event
            }
            var b = a.getTargetEvent(f);
            if (b.className == "CanvasXpress" && !CanvasXpress.resizing) {
                CanvasXpress.current = b.id
            }
            if ((CanvasXpress.current && CanvasXpress.current == a.target) || CanvasXpress.resizing || b.id.match(/-cX-API-Example/)) {
                if (!this.toolbarPermanent) {
                    a.isToolbar(f)
                }
                if (a.isVersion(f)) {
                    var g = a.$(a.target);
                    g.style.cursor = "help";
                    a.showInfoSpan([f.clientX, f.clientY + 50], "CanvasXpress (" + a.version + ")")
                } else {
                    if (a.filteringNumericOn) {
                        a.preventSelection();
                        a.updateNumericFilter(f)
                    } else {
                        if (a.filteringStringOn) {
                            a.preventSelection();
                            a.updateStringFilter(f)
                        } else {
                            if (a.draggingTargetOn) {
                                a.preventSelection();
                                a.updateMousemove(f)
                            } else {
                                if (a.resizingDataTableOn) {
                                    a.preventSelection();
                                    a.updateDataTableResizerDiv(f)
                                } else {
                                    if (a.axesResizingOn) {
                                        a.preventSelection();
                                        a.mousemoveAxesResize(f)
                                    } else {
                                        if (a.resizingDataTableColumnOn) {
                                            a.preventSelection();
                                            a.mousemoveDataTableHeader(f)
                                        } else {
                                            if (a.changingColorOn) {
                                                a.preventSelection();
                                                a.updateColorValue(f)
                                            } else {
                                                if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
                                                    if (a.draggingOn) {
                                                        a.preventSelection();
                                                        a.cancelEvent(f);
                                                        a.updateDrag(f);
                                                        a.lastCanvasEvent = "drag"
                                                    } else {
                                                        if (a.resizingCanvasOn && a.resizeCanvasCursorShow) {
                                                            a.preventSelection();
                                                            a.cancelEvent(f);
                                                            a.updateCanvasResizer(f);
                                                            a.lastCanvasEvent = "resize"
                                                        } else {
                                                            if (a.mobileApp) {} else {
                                                                a.cancelEvent(f);
                                                                a.updateCanvasResizerCursor(f)
                                                            }
                                                        }
                                                    }
                                                    var d = a.graphType == "Genome" ? a.isEvent(f, false, true) : a.isEvent(f);
                                                    if (d) {
                                                        if (b.className == "CanvasXpress") {
                                                            a.handleMouseEvents("mousemove", f, d)
                                                        }
                                                    } else {
                                                        a.resetInfoSpan(f, true)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                a.cancelEvent(f)
            }
            return false
        }
    }(this);
    this.registerMousemove = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            var b = c.target || c.srcElement;
            if ((c.button == 1 && window.event != null || c.button == 0) && a.hasClass(b, "draggable")) {
                if (a.activeTarget) {
                    a.activeTarget.style.zIndex = 10000
                }
                a.draggableTarget = b.parentNode && a.hasClass(b.parentNode, "draggable-container") ? b.parentNode : b;
                a.activeTarget = a.draggableTarget;
                a.activeTarget.style.zIndex = 10001;
                a.xMouseDown = c.clientX;
                a.yMouseDown = c.clientY;
                a.draggableXoffset = parseInt(a.draggableTarget.style.left) || 0;
                a.draggableYoffset = parseInt(a.draggableTarget.style.top) || 0;
                a.draggingTargetOn = true;
                a.removeMenus()
            }
        }
    }(this);
    this.updateMousemove = function(b) {
        if (!b) {
            b = window.event
        }
        if (this.draggableTarget && this.draggableTarget.style) {
            var a = this.draggableXoffset + b.clientX - this.xMouseDown;
            var c = this.draggableYoffset + b.clientY - this.yMouseDown;
            this.draggableTarget.style.left = a + "px";
            this.draggableTarget.style.top = c + "px";
            this.draggableLastX = a;
            this.draggableLastY = c;
            if (this.draggableTarget.id == this.target + "-cX-DataTable" && this.dataTableLastState == "docked") {
                this.moveDataTableDiv("release")
            }
        }
    };
    this.endMousemove = function(a) {
        if (this.draggableTarget != null) {
            this.moveDataTableDiv();
            document.onselectstart = null;
            this.xMouseDown = null;
            this.yMouseDown = null;
            this.draggableXoffset = null;
            this.draggableYoffset = null;
            this.draggableTarget.ondragstart = null;
            this.draggableTarget = false;
            this.draggingTargetOn = false
        }
    };
    this.mouseupDoc = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            var b = a.getTargetEvent(c);
            if ((CanvasXpress.current && CanvasXpress.current == a.target) || b.id.match(/-cX-API-Example/)) {
                if (a.draggingTargetOn) {
                    a.endMousemove(c)
                } else {
                    if (a.resizingDataTableOn) {
                        a.endDataTableResizerDiv(c)
                    } else {
                        if (a.resizingDataTableColumnOn) {
                            a.endDataTableColumnResize(c)
                        } else {
                            if (a.changingColorOn) {
                                a.endColorChange(c)
                            } else {
                                if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
                                    a.stopEvent(c);
                                    a.endDrag(c);
                                    a.endCanvasResizer(c);
                                    a.endAxesResizer(c);
                                    a.endNumericFilter(c);
                                    a.endStringFilter(c);
                                    a.resetFlags(c)
                                }
                            }
                        }
                    }
                }
            }
        }
    }(this);
    this.touchendDoc = function(a) {
        return function(g) {
            if (CanvasXpress.current && CanvasXpress.current == a.target) {
                if (!a.touchEvent || !a.mobileApp || !a.touches) {
                    return a.mouseupDoc(g)
                }
                var f = a.layoutComb ? a.layoutParams[a.layoutValidN].graphType : a.graphType;
                var d = a;
                var b = function() {
                    clearTimeout(b);
                    if (d.touches.length > 1) {
                        var k = d.touches[0];
                        var j = d.touches[1];
                        var r = Math.abs(j[0] - k[0]);
                        var q = Math.abs(j[1] - k[1]);
                        var n = Math.atan2(j[1] - k[1], j[0] - k[0]) * 180 / Math.PI;
                        if (r < 20 && q < 20) {
                            d.touchEvent = "dbltap"
                        } else {
                            d.touchEvent = "pinch"
                        }
                    } else {
                        if (d.touchEvent != "drag") {
                            if (d.touchEvent == "dbltap" || d.touchEvent == "pinch") {
                                return false
                            }
                            d.touchEvent = "tap"
                        }
                    } if (d.touchEvent == "pinch" && d.touchesEnd.length > 1) {
                        if (d.graphType.match(/Network|Genome|Heatmap|Bar|Line|Dotplot|Boxplot|Area|Stacked|Scatter3D|Circular/)) {
                            var o = d.euclidianDistance([d.touches[0][0], d.touches[1][0]], [d.touches[0][1], d.touches[1][1]]);
                            var e = d.euclidianDistance([d.touchesEnd[0][0], d.touchesEnd[1][0]], [d.touchesEnd[0][1], d.touchesEnd[1][1]]);
                            var p = (d.touchesEnd[0][0] + d.touchesEnd[1][0]) / 2;
                            var m = (d.touchesEnd[0][1] + d.touchesEnd[1][1]) / 2;
                            var l = d.zoomStep;
                            d.zoomStep *= 3;
                            d.resetFlags(g);
                            d.handleWheelEvent(g, e - o, {
                                x: p,
                                y: m
                            });
                            d.zoomStep = l
                        }
                        d.touchesEnd = false;
                        return false
                    } else {
                        if (d.touchEvent == "dbltap") {
                            d.stopEvent(g);
                            d.addConfigurator(g, false, 3, 3);
                            d.resetFlags(g);
                            return false
                        } else {
                            if (d.touchEvent == "tap") {
                                var h = d.getEventDataId(g);
                                if (h) {
                                    d.handleMouseEvents("click", g, h)
                                } else {
                                    d.resetSelectedObjects()
                                }
                                d.resetFlags(g);
                                return false
                            }
                        }
                    }
                    d.stopEvent(g);
                    d.endDrag(g);
                    d.endCanvasResizer(g);
                    d.endAxesResizer(g);
                    d.resetFlags(g)
                };
                var c = a.adjustedCoordinates(g);
                if (c) {
                    if (!a.touchesEnd) {
                        a.touchesEnd = []
                    }
                    a.touchesEnd.push([c.x, c.y, new Date().getTime()]);
                    setTimeout(b, 250)
                }
            }
        }
    }(this);
    this.keydownDoc = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            if (CanvasXpress.current && CanvasXpress.current == a.target) {
                a.registerKey(b)
            }
        }
    }(this);
    this.keyupDoc = function(a) {
        return function(c) {
            if (!c) {
                c = window.event
            }
            var b = a.getTargetEvent(c);
            if (CanvasXpress.current && CanvasXpress.current == a.target) {
                a.keyOn = false;
                if (b.id.match(/cX-DataFilterInput/)) {
                    a.updateSelectStringFilter(b.id)
                } else {
                    if (a.configuringOn) {
                        a.selectConfig(c)
                    } else {
                        if (a.remoteService) {
                            a.selectDataSet(c)
                        }
                    }
                }
            }
        }
    }(this);
    this.resizeWindow = function(a) {
        return function(b) {
            if (!b) {
                b = window.event
            }
            if (a.resizeImage) {
                a.resizeImage(true)
            }
            return false
        }
    }(this);
    this.initDocEvents = function() {
        this.addEvtListener(document, "mousemove", this.mousemoveDoc, false);
        this.addEvtListener(document, "touchmove", this.mousemoveDoc, false);
        this.addEvtListener(document, "mouseup", this.mouseupDoc, false);
        this.addEvtListener(document, "touchend", this.touchendDoc, false);
        this.addEvtListener(document, "keydown", this.keydownDoc, false);
        this.addEvtListener(document, "keyup", this.keyupDoc, false);
        this.addEvtListener(window, "resize", this.resizeWindow, false)
    };
    this.initializeEvents = function() {
        this.setUserEvents();
        this.initViewport();
        this.initToolbarTooltip();
        this.initMenuLinks();
        this.initConfigurator();
        this.initDataFilter();
        this.initDataTable();
        this.initDraggingEvents();
        this.initCanvasResizerEvents();
        this.initAxisResizerEvents();
        this.initKeyEvents();
        this.initSelectEvents();
        this.initDendrogramEvents();
        this.initCanvasEvents();
        this.initAcknowlegments();
        this.initCodeInfo();
        this.initDocEvents();
        this.initCleanupEvents()
    };
    this.initializeEvents()
};
CanvasXpress.prototype.initAnimation = function() {
    this.saveSnapshot = function() {
        var a = this.cloneVisualData(this.data);
        if (a) {
            this.snapshots.push(a)
        }
    };
    this.playSnapshot = function(b, d, c) {
        if (this.snapshots.length < 1) {
            return
        }
        this.stopSnapshotPlay();
        var a = this;
        this.snapshotPlay = {
            idx: 0,
            time: b,
            task: setTimeout(function() {
                a.nextSnapshot(c)
            }, 0),
            callback: d,
            oldData: this.data
        };
        this.snapshotPaused = false
    };
    this.nextSnapshot = function(c) {
        if (this.snapshotPlay.idx >= this.snapshots.length) {
            if (this.snapshotPlay.callback) {
                this.snapshotPlay.callback.call(this, c)
            } else {
                this.snapshotPlay.idx = 0
            }
        }
        if (this.snapshotPlay) {
            var b = this.snapshotPlay.time || this.snapshots[this.snapshotPlay.idx].time || 50;
            this.loadData(this.snapshots[this.snapshotPlay.idx++], true);
            var a = this;
            this.snapshotPlay.task = setTimeout(function() {
                a.nextSnapshot(c)
            }, b);
            this.snapshotPaused = false
        }
    };
    this.stopSnapshotPlay = function(a) {
        if (!this.snapshotPlay) {
            return
        }
        clearTimeout(this.snapshotPlay.task);
        this.loadData(this.snapshotPlay.oldData, a);
        delete(this.snapshotPlay);
        this.snapshotPaused = false
    };
    this.clearSnapshot = function() {
        this.stopSnapshotPlay(true);
        this.snapshots = [];
        this.snapshotPaused = false
    };
    this.duplicateSnapshot = function() {
        if (this.snapshots.length < 1) {
            return
        }
        var a = (this.snapshotPlay ? this.snapshotPlay.idx : this.snapshots.length) - 1;
        var b = this.cloneVisualData(this.snapshots[a]);
        if (this.snapshotPlay) {
            this.snapshots.splice(a + 1, 0, b);
            this.snapshotPlay.idx++
        } else {
            this.snapshots.push(b)
        }
    };
    this.makeSnapshotPlay = function() {
        if (!this.snapshotPlay) {
            this.snapshotPlay = {
                idx: this.snapshots.length,
                oldData: this.data
            }
        } else {
            this.pauseSnapshot()
        }
    };
    this.moveSnapshot = function(c) {
        if (this.snapshots.length < 1) {
            return
        }
        this.makeSnapshotPlay();
        var b = this.snapshotPlay.idx - 1,
            a = b + c;
        if (a >= 0 && a <= this.snapshots.length) {
            this.snapshots.splice(a, 0, (this.snapshots.splice(b, 1))[0])
        }
        this.snapshotPlay.idx = a + 1
    };
    this.prevSnapshotOnce = function() {
        if (this.snapshots.length < 2) {
            return
        }
        this.makeSnapshotPlay();
        this.snapshotPlay.idx -= 2;
        if (this.snapshotPlay.idx < 0) {
            this.snapshotPlay.idx = 0
        }
        this.loadData(this.snapshots[this.snapshotPlay.idx++], true);
        this.snapshotPaused = true
    };
    this.nextSnapshotOnce = function() {
        if (!this.snapshotPlay) {
            return
        }
        if (this.snapshotPlay.idx < this.snapshots.length) {
            this.loadData(this.snapshots[this.snapshotPlay.idx++], true)
        }
        this.snapshotPaused = true
    };
    this.hasNextSnapshot = function() {
        return this.snapshots.length > 1 && this.snapshotPlay && this.snapshotPaused && this.snapshotPlay.idx < this.snapshots.length
    };
    this.hasPrevSnapshot = function() {
        return this.snapshots.length > 1 && (!this.snapshotPlay || (this.snapshotPlay.idx > 1 && this.snapshotPaused))
    };
    this.updateSnapshot = function() {
        if (this.snapshotPlay) {
            this.snapshots[this.snapshotPlay.idx - 1] = this.cloneVisualData(this.data)
        }
    };
    this.pauseSnapshot = function() {
        if (!this.snapshotPlay) {
            return
        }
        if (this.snapshotPlay.task) {
            clearTimeout(this.snapshotPlay.task)
        }
        this.snapshotPaused = true
    };
    this.setSnapshotTime = function(a) {
        if (a > 0) {
            this.snapshots[this.snapshotPlay.idx - 1].time = a
        }
    };
    this.getSnapshotTime = function() {
        return this.snapshots[this.snapshotPlay.idx - 1].time || 50
    };
    this.assembleObj = function(b, k, m) {
        var e = [];
        if (!k[m]) {
            return b[m]
        }
        if (!k[m].indices) {
            k[m].indices = {}
        }
        for (var h = 0; h < b[m].length; h++) {
            var f = b[m][h],
                a = f.id || f.id1 + "-" + f.id2;
            if (!k[m].deleted[a]) {
                var l = k[m].changed[a];
                if (l) {
                    for (var g in l) {
                        f[g] = l[g]
                    }
                }
                var p = k[m].indices[a] != null ? k[m].indices[a] : m == "nodes" ? b.nodeIndices[a] : b.edgeIndices[a];
                e[p] = f;
                k[m].indices[a] = p
            }
        }
        for (var a in k[m].added) {
            e[k[m].indices[a]] = k[m].added[a]
        }
        return e
    };
    this.assembleData = function(b, c) {
        var a = {};
        a.nodes = this.assembleObj(b, c, "nodes");
        a.nodeIndices = c.nodes && c.nodes.indices ? c.nodes.indices : b.nodeIndices;
        a.edges = this.assembleObj(b, c, "edges");
        a.legend = c.legend || b.legend;
        return a
    };
    this.loadData = function(d, e) {
        this.data = d;
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Dotplot":
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Circular":
                break;
            case "Scatter3D":
            case "Area":
            case "AreaLine":
            case "Boxplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Candlestick":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Genome":
                return false;
                break;
            case "Network":
                if (this.data.type == "changedData") {
                    this.data = this.assembleData(this.cloneObject(this.snapshotsBase), this.cloneObject(this.data))
                }
                this.edges = this.data.edges;
                var b = {};
                for (var c = 0; c < this.data.nodes.length; c++) {
                    var a = this.data.nodes[c];
                    b[a.id] = a
                }
                this.nodes = b;
                break
        }
        if (e) {
            this.draw(false, false, true)
        }
    };
    this.changedNodeData = function(c, g) {
        var i = {
            deleted: {},
            changed: {},
            added: {}
        };
        for (var b in c.nodeIndices) {
            var j = g.nodeIndices[b];
            if (j == null) {
                i.deleted[b] = 1
            } else {
                var h = c.nodes[c.nodeIndices[b]],
                    e = g.nodes[j],
                    k = {
                        id: b
                    }, f = false;
                for (var a in e) {
                    if (!this.isSameObject(e[a], h[a])) {
                        k[a] = e[a];
                        f = true
                    }
                }
                if (f) {
                    i.changed[b] = k
                }
            }
        }
        for (var b in g.nodeIndices) {
            if (c.nodeIndices[b] == null) {
                i.added[b] = g.nodes[g.nodeIndices[b]]
            }
        }
        i.indices = this.changedIndices(c.nodeIndices, g.nodeIndices);
        return i
    };
    this.getEdgeIndices = function(f) {
        var b = {};
        if (f.edges.length) {
            for (var a = 0; a < f.edges.length; a++) {
                var c = f.edges[a];
                b[c.id1 + "-" + c.id2] = a
            }
        }
        return b
    };
    this.changedEdgeData = function(f, g) {
        var c = {
            deleted: {},
            changed: {},
            added: {}
        };
        if (!f.edgeIndices) {
            f.edgeIndices = this.getEdgeIndices(f)
        }
        var e = this.getEdgeIndices(g);
        for (var h in f.edgeIndices) {
            var a = e[h];
            if (a == null) {
                c.deleted[h] = 1
            } else {
                var b = g.edges[a];
                if (!this.isSameObject(f.edges[f.edgeIndices[h]], b)) {
                    c.changed[h] = b
                }
            }
        }
        for (var h in e) {
            if (f.edgeIndices[h] == null) {
                c.added[h] = g.edges[e[h]]
            }
        }
        c.indices = this.changedIndices(f.edgeIndices, e);
        return c
    };
    this.changedIndices = function(b, c) {
        var a = {};
        for (var e in c) {
            if (b[e] == null || b[e] != c[e]) {
                a[e] = c[e]
            }
        }
        return a
    };
    this.getSnapshotChanged = function(b) {
        var a = this.snapshotsBase;
        return {
            type: "changedData",
            nodes: this.changedNodeData(a, b),
            edges: this.changedEdgeData(a, b),
            legend: this.isSameObject(a.legend, b.legend) ? null : b.legend
        }
    };
    this.cloneVisualData = function(f) {
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Dotplot":
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Circular":
                return this.cloneObject(f);
                break;
            case "Scatter3D":
            case "Area":
            case "AreaLine":
            case "Boxplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Candlestick":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Genome":
                return false;
                break;
            case "Network":
                if (this.snapshotCopyChangeOnly) {
                    if (this.snapshots.length) {
                        return f.type == "changedData" ? this.cloneObject(f) : this.getSnapshotChanged(f)
                    } else {
                        this.snapshotsBase = this.cloneObject(f);
                        return {
                            type: "changedData"
                        }
                    }
                }
                if (!this.snapshotNoCopyData) {
                    return this.cloneObject(f)
                }
                var c = {
                    nodes: [],
                    edges: []
                };
                if (f.nodes && f.nodes.length) {
                    for (var b = 0; b < f.nodes.length; b++) {
                        var g = {};
                        var e = f.nodes[b];
                        var h = ["outline", "width", "height", "pattern", "rotate", "color", "shape", "size", "x", "y", "id", "hideLabel", "hideChildren", "hideParent", "label", "labelX", "labelY", "labelSize", "name", "hide", "anchor", "parentNode", "imagePath"];
                        for (var a = 0; a < h.length; a++) {
                            g[h[a]] = e[h[a]]
                        }
                        c.nodes.push(g)
                    }
                }
                if (f.edges && f.edges.length) {
                    for (var b = 0; b < f.edges.length; b++) {
                        var g = {};
                        var e = f.edges[b];
                        var h = ["color", "width", "type", "id1", "id2", "anchor"];
                        for (var a = 0; a < h.length; a++) {
                            g[h[a]] = e[h[a]]
                        }
                        c.edges.push(g)
                    }
                }
                return c;
                break
        }
    };
    this.isValidAnimation = function() {
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Dotplot":
            case "Scatter2D":
            case "ScatterBubble2D":
                return true;
            case "Scatter3D":
            case "Area":
            case "AreaLine":
            case "Boxplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Candlestick":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Genome":
            case "Network":
            case "Circular":
                return false
        }
    };
    this.createAnimation = function(e) {
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Dotplot":
            case "Scatter2D":
            case "ScatterBubble2D":
                this.isAnimation = true;
                var f = this.cloneVisualData(this.data);
                if (e.match(/grow|spring|random/) && this.data.y.data) {
                    var d = this.animationCycles;
                    for (var c = 0; c < d; c++) {
                        for (var b = 0; b < this.data.y.data.length; b++) {
                            for (var a = 0; a < this.data.y.data[b].length; a++) {
                                if (!isNaN(this.data.y.data[b][a])) {
                                    var g = this.data.y.data[b][a];
                                    if (e == "grow") {
                                        this.data.y.data[b][a] = g / d * c
                                    } else {
                                        if (e == "spring") {
                                            this.data.y.data[b][a] = g / (d - 1.5) * (c + 1)
                                        } else {
                                            this.data.y.data[b][a] = g / d * Math.floor(Math.random() * c)
                                        }
                                    }
                                }
                            }
                        }
                        this.saveSnapshot();
                        this.data = this.cloneVisualData(f)
                    }
                }
                this.data = f;
                this.saveSnapshot();
                this.playSnapshot(this.animationTime, this.stopAnimation);
                break;
            case "Scatter3D":
            case "Area":
            case "AreaLine":
            case "Boxplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Candlestick":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Genome":
            case "Network":
            case "Circular":
                return;
                break
        }
    };
    this.stopAnimation = function() {
        this.stopSnapshotPlay();
        this.snapshots = [];
        this.isAnimation = false
    };
    this.setSnapshotsData = function(a) {
        this.snapshots = a.ss || a;
        this.snapshotsBase = a.base
    };
    this.getSnapshotsData = function() {
        return {
            base: this.snapshotsBase,
            ss: this.snapshots
        }
    };
    this.createDemoNetworkAnimation = function(h) {
        var p = [],
            e = {}, q = [];
        for (var u = 0; u < h; u++) {
            var n = u + 1;
            p.push({
                size: 0.5,
                x: Math.floor(Math.random() * h * 5),
                y: Math.floor(Math.random() * h * 5),
                outline: "rgb(255,255,255)",
                color: "rgb(255,0,0)",
                id: n,
                label: n,
                hideLabel: true,
                labelSize: 0.7,
                name: "Node " + n,
                pattern: "closed",
                shape: "star"
            });
            e[n] = u
        }
        var d = {
            nodes: p,
            nodeIndices: e,
            edges: [],
            edgeIndices: {}
        };
        q.push({
            type: "changedData"
        });
        var s = 10;
        var b = 5;
        var o = 255 / b;
        var a = 0.5 / b;
        var k = 5;
        for (var t = 0; t < s; t++) {
            var m = Math.floor(Math.random() * p.length);
            for (var u = 0; u < b; u++) {
                var g = Math.floor(255 - (u + 1) * o);
                var l = Math.floor((u + 1) * o),
                    v = [g, l, l];
                var f = {};
                f[p[m].id] = {
                    size: 0.5 + a * (u + 1),
                    color: "rgb(" + v.join(",") + ")"
                };
                q.push({
                    type: "changedData",
                    nodes: {
                        deleted: {},
                        added: {},
                        changed: f
                    },
                    time: 5
                })
            }
        }
        this.setSnapshotsData({
            base: d,
            ss: q
        })
    };
    this.createDemoNetworkAnimation1 = function() {
        var b = [];
        var l = {};
        var o = [];
        var n = 10;
        var m = 200;
        var a = "ball";
        var f = {
            width: n,
            x: 100,
            y: 0,
            color: "rgb(0,255,0)",
            id: a,
            label: a,
            hideLabel: true,
            labelSize: 0.7,
            name: a,
            pattern: "closed",
            shape: "sphere"
        };
        a = "plank";
        var g = {
            width: 200,
            height: 5,
            x: 100,
            y: m,
            color: "rgb(255,255,0)",
            id: a,
            label: a,
            hideLabel: true,
            labelSize: 0.7,
            name: a,
            pattern: "closed",
            shape: "rectangle"
        };
        a = "ref";
        var d = {
            width: 10,
            x: 80,
            y: 0,
            color: "rgb(0,0,255)",
            id: a,
            label: a,
            hideLabel: true,
            labelSize: 0.7,
            name: a,
            pattern: "closed",
            shape: "sphere"
        };
        var c = {
            nodes: [f, g, d],
            nodeIndices: {
                ball: 0,
                plank: 1,
                ref: 2
            },
            edges: [],
            edgeIndices: {}
        };
        o.push({
            type: "changedData"
        });
        for (var k = 1, h = 0; h < m - n / 2; h += n / 2, k += 0.1) {
            var e = k * k;
            o.push({
                type: "changedData",
                nodes: {
                    deleted: {},
                    added: {},
                    changed: {
                        ball: {
                            y: h,
                            time: 25 * n > h ? 50 - h * 2 / n : 5
                        }
                    }
                },
                time: 100 / e
            })
        }
        this.setSnapshotsData({
            base: c,
            ss: o
        })
    };
    this.fade = function(e, a, f, d) {
        if (e) {
            if (!a) {
                a = 1000
            }
            if (e.fadeState == null) {
                if (e.style.opacity == null || e.style.opacity == "" || e.style.opacity == "1") {
                    e.fadeState = 2
                } else {
                    e.fadeState = -2
                }
            }
            if (e.fadeState == 1 || e.fadeState == -1) {
                e.fadeState = e.fadeState == 1 ? -1 : 1;
                e.fadeleft = a - e.fadeleft
            } else {
                var b = this;
                e.fadeState = e.fadeState == 2 ? -1 : 1;
                e.fadeleft = a;
                setTimeout(function() {
                    b.animateFade(new Date().getTime(), e, f, d)
                }, 33)
            }
        }
    };
    this.animateFade = function(a, h, j, d) {
        var b = this;
        var g = new Date().getTime();
        var f = g - a;
        if (h.fadeleft <= f) {
            h.style.opacity = h.fadeState == 1 ? "1" : "0";
            h.style.filter = "alpha(opacity = " + (h.fadeState == 1 ? "100" : "0") + ")";
            h.fadeState = h.fadeState == 1 ? 2 : -2;
            if (j != null) {
                j()
            }
            if (d) {
                setTimeout(function() {
                    b.resetFade(h);
                    for (var c = 0; c < d.length; c++) {
                        delete(h.style[d[c]])
                    }
                }, 500)
            }
            return
        }
        h.fadeleft -= f;
        var i = h.fadeleft / 1000;
        if (h.fadeState == 1) {
            i = 1 - i
        }
        h.style.opacity = i;
        h.style.filter = "alpha(opacity = " + (i * 100) + ")";
        setTimeout(function() {
            b.animateFade(g, h, j)
        }, 33)
    };
    this.resetFade = function(a) {
        if (a) {
            a.style.opacity = 1;
            a.style.filter = "alpha(opacity = 100)";
            if (!this.isIE) {
                delete(a.fadeState);
                delete(a.fadeleft)
            }
        }
    };
    this.resizeMove = function(d, b, m, k, e, q, l) {
        if (d) {
            if (!q) {
                q = 500
            }
            var p = parseInt(d.style.left) || 0;
            var i = parseInt(d.style.top) || 0;
            var g = parseInt(d.style.width) || 0;
            var a = parseInt(d.style.height) || 0;
            var j = 1;
            if (q > 0) {
                j = q / 40
            }
            var n = b - p;
            if (n != 0) {
                n /= j
            }
            var h = m - i;
            if (h != 0) {
                h /= j
            }
            var f = k - g;
            if (f != 0) {
                f /= j
            }
            var r = e - a;
            if (r != 0) {
                r /= j
            }
            this.updateResizeMove(d, p, b, n, i, m, h, g, k, f, a, e, r, l)
        }
    };
    this.updateResizeMove = function(d, n, b, m, i, l, h, g, j, f, a, e, q, k) {
        if (d) {
            var p = this;
            n = this.stepResizeMove(n, b, m);
            i = this.stepResizeMove(i, l, h);
            g = this.stepResizeMove(g, j, f);
            a = this.stepResizeMove(a, e, q);
            d.style.left = Math.round(n) + "px";
            d.style.top = Math.round(i) + "px";
            d.style.width = Math.round(g) + "px";
            d.style.height = Math.round(a) + "px";
            if (n == b && i == l && a == e && g == j) {
                if (k != null) {
                    k()
                }
                return
            }
            setTimeout(function() {
                p.updateResizeMove(d, n, b, m, i, l, h, g, j, f, a, e, q, k)
            }, 40)
        }
    };
    this.stepResizeMove = function(d, b, a) {
        if (a == 0 || d == b) {
            return b
        }
        d += a;
        if ((a > 0 && d >= b) || (a < 0 && d <= b)) {
            return b
        }
        return d
    };
    this.transitionAccordion = function(a, d, h, j) {
        var f = this;
        var b = new Date().getTime();
        var g = b - a;
        if (d <= g) {
            if (h) {
                h.style.height = this.dataFilterHeight + "px"
            }
            if (j) {
                j.style.height = "0px";
                j.style.display = "none"
            }
            if (h) {
                if (h.clientWidth - h.scrollWidth) {
                    this.resizeDataFilterForScroller(true)
                } else {
                    if (h.clientHeight < this.canvas.height && this.dataFilterScroller) {
                        this.resizeDataFilterForScroller()
                    }
                }
            }
            return
        }
        d -= g;
        var i = Math.round((d / 250) * this.dataFilterHeight);
        if (h) {
            if (h.style.display != "block") {
                h.style.display = "block"
            }
            h.style.height = (this.dataFilterHeight - i) + "px"
        }
        if (j) {
            j.style.height = i + "px"
        }
        setTimeout(function() {
            f.transitionAccordion(b, d, h, j)
        }, 33)
    }
};
CanvasXpress.prototype.initExample = function() {
    this.dataSetGeneric = {
        z: {
            Annt1: ["Desc:1", "Desc:2", "Desc:3", "Desc:4"],
            Annt2: ["Desc:A", "Desc:B", "Desc:A", "Desc:B"],
            Annt3: ["Desc:X", "Desc:X", "Desc:Y", "Desc:Y"]
        },
        x: {
            Factor1: ["Lev:1", "Lev:2", "Lev:3", "Lev:1", "Lev:2", "Lev:3"],
            Factor2: ["Lev:A", "Lev:B", "Lev:A", "Lev:B", "Lev:A", "Lev:B"],
            Factor3: ["Lev:X", "Lev:X", "Lev:Y", "Lev:Y", "Lev:Z", "Lev:Z"]
        },
        y: {
            vars: ["Variable1", "Variable2", "Variable3", "Variable4"],
            smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6"],
            data: [
                [5, 10, 25, 40, 45, 50],
                [95, 80, 75, 70, 55, 40],
                [25, 30, 45, 60, 65, 70],
                [55, 40, 35, 30, 15, 1]
            ],
            desc: ["Magnitude1", "Magnitude2"]
        },
        a: {
            xAxis: ["Variable1", "Variable2"],
            xAxis2: ["Variable3", "Variable4"]
        },
        t: {
            vars: "(((Variable1,Variable3),Variable4),Variable2)",
            smps: "(((((Sample1,Sample2),Sample3),Sample4),Sample5),Sample6)"
        }
    };
    this.dataSetCircular = {
        z: {
            Ring: ["1", "2", "2", "3"]
        },
        x: {
            Segment: ["Seg1", "Seg1", "Seg1", "Seg1", "Seg1", "Seg2", "Seg2", "Seg2", "Seg2", "Seg2", "Seg3", "Seg3", "Seg3", "Seg3", "Seg3"],
            Factor1: ["L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5"]
        },
        y: {
            vars: ["Variable1", "Variable2", "Variable3", "Variable4"],
            smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12", "Sample13", "Sample14", "Sample15"],
            data: [
                [5, 15, 25, 35, 45, 55, 65, 75, 85, 75, 65, 55, 45, 35, 25],
                [95, 85, 75, 65, 55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55],
                [25, 35, 45, 55, 65, 75, 85, 95, 85, 75, 65, 55, 45, 35, 25],
                [55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55, 65, 75, 85, 95]
            ],
            desc: ["Magnitude1"]
        },
        c: [
            ["rgb(51,125,255)", "Sample1", "Sample10"],
            ["rgb(125,255,51)", "Sample8", "Sample11"],
            ["rgb(255,51,125)", "Sample12", "Sample4"],
            ["rgb(125,255,51)", "Sample9", "Sample2"],
            ["rgb(51,125,255)", "Sample3", "Sample6"]
        ]
    };
    this.dataSetCircular2 = {
        z: {
            Ring: ["-1", "1", "2", "2", "3"]
        },
        x: {
            Segment: ["Seg1", "Seg1", "Seg1", "Seg1", "Seg1", "Seg2", "Seg2", "Seg2", "Seg2", "Seg2", "Seg3", "Seg3", "Seg3", "Seg3", "Seg3"],
            Factor1: ["L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5"]
        },
        y: {
            vars: ["Number", "Variable1", "Variable2", "Variable3", "Variable4"],
            smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12", "Sample13", "Sample14", "Sample15"],
            data: [
                [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5],
                [5, 15, 25, 35, 45, 55, 65, 75, 85, 75, 65, 55, 45, 35, 25],
                [95, 85, 75, 65, 55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55],
                [25, 35, 45, 55, 65, 75, 85, 95, 85, 75, 65, 55, 45, 35, 25],
                [55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55, 65, 75, 85, 95]
            ],
            desc: ["Magnitude1"]
        },
        c: [
            ["rgb(51,125,255)", "Seg1", 1, "Seg2", 5, 1, 1],
            ["rgb(125,255,51)", "Seg2", 3, "Seg3", 1, 1, 2],
            ["rgb(255,51,125)", "Seg3", 2, "Seg1", 4, 2, 1],
            ["rgb(125,255,51)", "Seg2", 4, "Seg1", 2, 1, 1],
            ["rgb(51,125,255)", "Seg1", 3, "Seg3", 4, 1, 1]
        ]
    };
    this.dataSetBoxplot = {
        x: {
            Factor1: ["Lev1", "Lev1", "Lev1", "Lev1", "Lev1", "Lev1", "Lev2", "Lev2", "Lev2", "Lev2", "Lev2", "Lev2"]
        },
        y: {
            vars: ["Variable1", "Variable2"],
            smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
            data: [
                [5, 8, 10, 6, 8, 20, 25, 27, 30, 27, 6, 29],
                [49, 18, 14, 16, 18, 15, 65, 67, 60, 72, 76, 9]
            ],
            desc: ["Magnitude1"]
        }
    };
    this.dataSetMultidimensionalHeatmap = {
        y: {
            vars: ["Variable1", "Variable2", "Variable3", "Variable4", "Variable5"],
            smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10"],
            data: [
                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
            ],
            data2: [
                [1, 1, 2, 2, 3, 3, 4, 4, 5, 5],
                [6, 6, 7, 7, 8, 8, 9, 9, 10, 10],
                [10, 10, 9, 9, 8, 8, 7, 7, 6, 6],
                [5, 5, 4, 4, 3, 3, 2, 2, 1, 1],
                [3, 3, 4, 4, 5, 5, 6, 6, 7, 7]
            ],
            data3: [
                ["A", "A", "B", "B", "C", "C", "D", "D", "E", "E"],
                ["E", "E", "D", "D", "C", "C", "B", "B", "A", "A"],
                ["A", "A", "B", "B", "C", "C", "D", "D", "E", "E"],
                ["E", "E", "D", "D", "C", "C", "B", "B", "A", "A"],
                ["A", "A", "B", "B", "C", "C", "D", "D", "E", "E"]
            ],
            data4: [
                ["A", "A", "B", "B", "A", "A", "B", "B", "A", "A"],
                ["B", "B", "A", "A", "B", "B", "A", "A", "B", "B"],
                ["A", "A", "B", "B", "A", "A", "B", "B", "A", "A"],
                ["B", "B", "A", "A", "B", "B", "A", "A", "B", "B"],
                ["A", "A", "B", "B", "A", "A", "B", "B", "A", "A"]
            ]
        },
        x: {
            Factor: ["Lev:1", "Lev:2", "Lev:1", "Lev:2", "Lev:1", "Lev:2", "Lev:1", "Lev:2", "Lev:1", "Lev:2"]
        },
        z: {
            Annt: ["Desc:1", "Desc:2", "Desc:1", "Desc:2", "Desc:1", "Desc:2", "Desc:1", "Desc:2", "Desc:1", "Desc:2"]
        }
    };
    this.dataSet3DScatter = {
        y: {
            vars: ["Variable1", "Variable2", "Variable3", "Variable4", "Variable5", "Variable6", "Variable7", "Variable8", "Variable9", "Variable10", "Variable11", "Variable12", "Variable13", "Variable14", "Variable15", "Variable16", "Variable17", "Variable18", "Variable19", "Variable20", "Variable21", "Variable22", "Variable23", "Variable24", "Variable25", "Variable26", "Variable27", "Variable28", "Variable29", "Variable30", "Variable31", "Variable32", "Variable33", "Variable34", "Variable35", "Variable36", "Variable37", "Variable38", "Variable39", "Variable40", "Variable41", "Variable42", "Variable43", "Variable44", "Variable45", "Variable46", "Variable47", "Variable48", "Variable49", "Variable50", "Variable51", "Variable52", "Variable53", "Variable54", "Variable55", "Variable56", "Variable57", "Variable58", "Variable59", "Variable60", "Variable61", "Variable62", "Variable63", "Variable64", "Variable65", "Variable66", "Variable67", "Variable68", "Variable69", "Variable70", "Variable71", "Variable72", "Variable73", "Variable74", "Variable75", "Variable76", "Variable77", "Variable78", "Variable79", "Variable80", "Variable81"],
            smps: ["Sample1", "Sample2", "Sample3"],
            data: [
                [-5, 5, 5],
                [-5, 15, 15],
                [-5, 25, 25],
                [-5, 35, 35],
                [-5, 45, 45],
                [-5, 35, 55],
                [-5, 25, 65],
                [-5, 15, 75],
                [-5, 5, 85],
                [-15, 15, 5],
                [-15, 25, 15],
                [-15, 35, 25],
                [-15, 45, 35],
                [-15, 55, 45],
                [-15, 45, 55],
                [-15, 35, 65],
                [-15, 25, 75],
                [-15, 15, 85],
                [-25, 25, 5],
                [-25, 35, 15],
                [-25, 45, 25],
                [-25, 55, 35],
                [-25, 65, 45],
                [-25, 55, 55],
                [-25, 45, 65],
                [-25, 35, 75],
                [-25, 25, 85],
                [-35, 35, 5],
                [-35, 45, 15],
                [-35, 55, 25],
                [-35, 65, 35],
                [-35, 75, 45],
                [-35, 65, 55],
                [-35, 55, 65],
                [-35, 45, 75],
                [-35, 35, 85],
                [-45, 45, 5],
                [-45, 55, 15],
                [-45, 65, 25],
                [-45, 75, 35],
                [-45, 85, 45],
                [-45, 75, 55],
                [-45, 65, 65],
                [-45, 55, 75],
                [-45, 45, 85],
                [-55, 35, 5],
                [-55, 45, 15],
                [-55, 55, 25],
                [-55, 65, 35],
                [-55, 75, 45],
                [-55, 65, 55],
                [-55, 55, 65],
                [-55, 45, 75],
                [-55, 35, 85],
                [-65, 25, 5],
                [-65, 35, 15],
                [-65, 45, 25],
                [-65, 55, 35],
                [-65, 65, 45],
                [-65, 55, 55],
                [-65, 45, 65],
                [-65, 35, 75],
                [-65, 25, 85],
                [-75, 15, 5],
                [-75, 25, 15],
                [-75, 35, 25],
                [-75, 45, 35],
                [-75, 55, 45],
                [-75, 45, 55],
                [-75, 35, 65],
                [-75, 25, 75],
                [-75, 15, 85],
                [-85, 5, 5],
                [-85, 15, 15],
                [-85, 25, 25],
                [-85, 35, 35],
                [-85, 45, 45],
                [-85, 35, 55],
                [-85, 25, 65],
                [-85, 15, 75],
                [-85, 5, 85]
            ]
        }
    };
    this.dataSetFunction = {
        fx: "sin(2y) * cos(3x) / sec(xy)"
    };
    this.dataSetNonLinearFit = {
        y: {
            vars: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
            smps: ["Concentration", "Variable1"],
            data: [
                [0.0009, 172],
                [0.0018, 177],
                [0.0037, 160],
                [0.0073, 166],
                [0.0146, 211],
                [0.0293, 248],
                [0.0586, 269],
                [0.117, 283],
                [0.234, 298],
                [0.469, 314],
                [0.938, 328],
                [1.88, 316]
            ]
        },
        d: {
            nlfit: [{
                param: [164, 313, 0.031, -1.5, 0.0000012, 1.9],
                label: "Custom Fit",
                type: "cst"
            }, {
                param: [164, 313, 0.031, 1.5, 0.0000012, 1.9],
                label: "Regular Fit",
                type: "reg"
            }]
        }
    };
    this.dataSetDecorationLine = {
        y: {
            vars: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
            smps: ["Concentration", "Variable1"],
            data: [
                [0.0009, 172],
                [0.0018, 177],
                [0.0037, 160],
                [0.0073, 166],
                [0.0146, 211],
                [0.0293, 248],
                [0.0586, 269],
                [0.117, 283],
                [0.234, 298],
                [0.469, 314],
                [0.938, 328],
                [1.88, 316]
            ]
        },
        d: {
            line: [{
                x: 0.4,
                y: 200,
                color: "rgb(255,125,51)",
                type: "dashedLine"
            }, {
                x: 0.15,
                color: "rgb(51,255,125)",
                type: "line"
            }]
        }
    };
    this.dataSetDecorationLines = {
        y: {
            vars: ["Concentration"],
            smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
            data: [
                [0.0009, 0.0018, 0.0037, 0.0073, 0.0146, 0.0293, 0.0586, 0.117, 0.234, 0.469, 0.938, 1.88]
            ]
        },
        d: {
            lines: [{
                value: 0.25,
                label: "Background",
                color: "rgb(255,125,51)",
                type: "dashedLine"
            }]
        }
    };
    this.dataSetDecorationArea = {
        y: {
            vars: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
            smps: ["Concentration", "Variable1"],
            data: [
                [0.0009, 172],
                [0.0018, 177],
                [0.0037, 160],
                [0.0073, 166],
                [0.0146, 211],
                [0.0293, 248],
                [0.0586, 269],
                [0.117, 283],
                [0.234, 298],
                [0.469, 314],
                [0.938, 328],
                [1.88, 316]
            ]
        },
        d: {
            area: [{
                x: 1.42,
                y: 322,
                label: "Area",
                width: 1.2,
                height: 30,
                color: "rgb(255,125,51,0.5)",
                ouline: "rgb(255,125,51,0.5)",
                pattern: "closed",
                rotate: 0.1,
                type: "oval"
            }]
        }
    };
    this.dataSetKaplanMeyer = {
        y: {
            vars: ["p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10", "p11", "p12", "p13", "p14", "p15", "p16", "p17", "p18", "p19", "p20"],
            smps: ["Time", "Censored-1", "Censored-2"],
            data: [
                [1, 0, 1],
                [2, 0, 1],
                [3, 0, 1],
                [3, 0, 1],
                [1, 1, 1],
                [2, 1, 1],
                [2, 1, 2],
                [3, 1, 1],
                [3, 1, 1],
                [4, 0, 0],
                [5, 0, 0],
                [6, 0, 0],
                [6, 0, 0],
                [7, 1, 0],
                [8, 0, 1],
                [9, 0, 0],
                [9, 0],
                [9, 0],
                [10, 1],
                [11, 1]
            ]
        }
    };
    this.dataSetDashDot = {
        nodes: [{
            id: "Id1",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 0
        }, {
            id: "Id2",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 0
        }, {
            id: "Id3",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 50
        }, {
            id: "Id4",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 50
        }, {
            id: "Id5",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 100
        }, {
            id: "Id6",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 100
        }],
        edges: [{
            id1: "Id1",
            id2: "Id2",
            color: "rgb(0,255,0)",
            type: "line"
        }, {
            id1: "Id3",
            id2: "Id4",
            color: "rgb(0,255,0)",
            type: "dashedLine"
        }, {
            id1: "Id5",
            id2: "Id6",
            color: "rgb(0,255,0)",
            type: "dottedLine"
        }]
    };
    this.dataSetLines = {
        nodes: [{
            id: "Id1",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 0
        }, {
            id: "Id2",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 0
        }, {
            id: "Id3",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 0
        }, {
            id: "Id4",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 0
        }, {
            id: "Id5",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 100
        }, {
            id: "Id6",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 100
        }, {
            id: "Id7",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 100
        }, {
            id: "Id8",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 100
        }, {
            id: "Id9",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 200
        }, {
            id: "Id10",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 200
        }, {
            id: "Id11",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 200
        }, {
            id: "Id12",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 200
        }, {
            id: "Id13",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 300
        }, {
            id: "Id14",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 300
        }, {
            id: "Id15",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 300
        }, {
            id: "Id16",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 300
        }, {
            id: "Id17",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 400
        }, {
            id: "Id18",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 400
        }, {
            id: "Id19",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 400
        }, {
            id: "Id20",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 400
        }, {
            id: "Id21",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 500
        }, {
            id: "Id22",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 500
        }, {
            id: "Id23",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 500
        }, {
            id: "Id24",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 500
        }, {
            id: "Id25",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 600
        }, {
            id: "Id26",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 600
        }, {
            id: "Id27",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 600
        }, {
            id: "Id28",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 600
        }, {
            id: "Id29",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 700
        }, {
            id: "Id30",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 700
        }, {
            id: "Id31",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 700
        }, {
            id: "Id32",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 700
        }, {
            id: "Id33",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 800
        }, {
            id: "Id34",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 800
        }, {
            id: "Id35",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 800
        }, {
            id: "Id36",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 800
        }, {
            id: "Id37",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 900
        }, {
            id: "Id39",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 900
        }, {
            id: "Id40",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 1000
        }, {
            id: "Id41",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 1100
        }, {
            id: "Id42",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 1000
        }, {
            id: "Id43",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 1100
        }, {
            id: "Id44",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 1000
        }, {
            id: "Id45",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 1100
        }, {
            id: "Id46",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 1200
        }, {
            id: "Id47",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 1300
        }, {
            id: "Id48",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 1200
        }, {
            id: "Id49",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 1300
        }, {
            id: "Id50",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 1200
        }, {
            id: "Id51",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 1300
        }, {
            id: "Id52",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 1400
        }, {
            id: "Id54",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 200,
            y: 1400
        }, {
            id: "Id56",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 400,
            y: 1400
        }, {
            id: "Id57",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 600,
            y: 1400
        }],
        edges: [{
            id1: "Id1",
            id2: "Id2",
            color: "rgb(0,255,0)",
            type: "line"
        }, {
            id1: "Id2",
            id2: "Id3",
            color: "rgb(0,255,0)",
            type: "dashedLine"
        }, {
            id1: "Id3",
            id2: "Id4",
            color: "rgb(0,255,0)",
            type: "dottedLine"
        }, {
            id1: "Id5",
            id2: "Id6",
            color: "rgb(0,255,0)",
            type: "arrowHeadLine"
        }, {
            id1: "Id6",
            id2: "Id7",
            color: "rgb(0,255,0)",
            type: "arrowLine"
        }, {
            id1: "Id7",
            id2: "Id8",
            color: "rgb(0,255,0)",
            type: "arrowTailLine"
        }, {
            id1: "Id9",
            id2: "Id10",
            color: "rgb(0,255,0)",
            type: "arrowHeadDashedLine"
        }, {
            id1: "Id10",
            id2: "Id11",
            color: "rgb(0,255,0)",
            type: "arrowDashedLine"
        }, {
            id1: "Id11",
            id2: "Id12",
            color: "rgb(0,255,0)",
            type: "arrowTailDashedLine"
        }, {
            id1: "Id13",
            id2: "Id14",
            color: "rgb(0,255,0)",
            type: "arrowHeadDottedLine"
        }, {
            id1: "Id14",
            id2: "Id15",
            color: "rgb(0,255,0)",
            type: "arrowDottedLine"
        }, {
            id1: "Id15",
            id2: "Id16",
            color: "rgb(0,255,0)",
            type: "arrowTailDottedLine"
        }, {
            id1: "Id17",
            id2: "Id18",
            color: "rgb(0,255,0)",
            type: "squareHeadLine"
        }, {
            id1: "Id18",
            id2: "Id19",
            color: "rgb(0,255,0)",
            type: "squareLine"
        }, {
            id1: "Id19",
            id2: "Id20",
            color: "rgb(0,255,0)",
            type: "squareTailLine"
        }, {
            id1: "Id21",
            id2: "Id22",
            color: "rgb(0,255,0)",
            type: "squareHeadDashedLine"
        }, {
            id1: "Id22",
            id2: "Id23",
            color: "rgb(0,255,0)",
            type: "squareDashedLine"
        }, {
            id1: "Id23",
            id2: "Id24",
            color: "rgb(0,255,0)",
            type: "squareTailDashedLine"
        }, {
            id1: "Id25",
            id2: "Id26",
            color: "rgb(0,255,0)",
            type: "squareHeadDottedLine"
        }, {
            id1: "Id26",
            id2: "Id27",
            color: "rgb(0,255,0)",
            type: "squareDottedLine"
        }, {
            id1: "Id27",
            id2: "Id28",
            color: "rgb(0,255,0)",
            type: "squareTailDottedLine"
        }, {
            id1: "Id29",
            id2: "Id30",
            color: "rgb(0,255,0)",
            type: "squareHeadArrowTailLine"
        }, {
            id1: "Id30",
            id2: "Id31",
            color: "rgb(0,255,0)",
            type: "squareHeadArrowTailDashedLine"
        }, {
            id1: "Id31",
            id2: "Id32",
            color: "rgb(0,255,0)",
            type: "squareHeadArrowTailDottedLine"
        }, {
            id1: "Id33",
            id2: "Id34",
            color: "rgb(0,255,0)",
            type: "arrowHeadSquareTailLine"
        }, {
            id1: "Id34",
            id2: "Id35",
            color: "rgb(0,255,0)",
            type: "arrowHeadSquareTailDashedLine"
        }, {
            id1: "Id35",
            id2: "Id36",
            color: "rgb(0,255,0)",
            type: "arrowHeadSquareTailDottedLine"
        }, {
            id1: "Id37",
            id2: "Id42",
            color: "rgb(0,255,0)",
            type: "bezierLine"
        }, {
            id1: "Id44",
            id2: "Id39",
            color: "rgb(0,255,0)",
            type: "bezierYLine"
        }, {
            id1: "Id40",
            id2: "Id41",
            color: "rgb(0,255,0)",
            type: "arrowBezierLine"
        }, {
            id1: "Id42",
            id2: "Id43",
            color: "rgb(0,255,0)",
            type: "arrowTailBezierLine"
        }, {
            id1: "Id44",
            id2: "Id45",
            color: "rgb(0,255,0)",
            type: "arrowHeadBezierLine"
        }, {
            id1: "Id46",
            id2: "Id47",
            color: "rgb(0,255,0)",
            type: "squareBezierLine"
        }, {
            id1: "Id48",
            id2: "Id49",
            color: "rgb(0,255,0)",
            type: "squareTailBezierLine"
        }, {
            id1: "Id50",
            id2: "Id51",
            color: "rgb(0,255,0)",
            type: "squareHeadBezierLine"
        }, {
            id1: "Id49",
            id2: "Id57",
            color: "rgb(0,255,0)",
            type: "arrowBezierYLine"
        }, {
            id1: "Id47",
            id2: "Id56",
            color: "rgb(0,255,0)",
            type: "arrowTailBezierYLine"
        }, {
            id1: "Id35",
            id2: "Id42",
            color: "rgb(0,255,0)",
            type: "arrowHeadBezierYLine"
        }, {
            id1: "Id46",
            id2: "Id41",
            color: "rgb(0,255,0)",
            type: "squareBezierYLine"
        }, {
            id1: "Id48",
            id2: "Id43",
            color: "rgb(0,255,0)",
            type: "squareTailBezierYLine"
        }, {
            id1: "Id50",
            id2: "Id45",
            color: "rgb(0,255,0)",
            type: "squareHeadBezierYLine"
        }, {
            id1: "Id9",
            id2: "Id1",
            color: "rgb(0,255,0)",
            type: "curvedLine"
        }, {
            id1: "Id13",
            id2: "Id5",
            color: "rgb(0,255,0)",
            type: "squareCurvedLine"
        }, {
            id1: "Id25",
            id2: "Id17",
            color: "rgb(0,255,0)",
            type: "squareHeadCurvedLine"
        }, {
            id1: "Id29",
            id2: "Id21",
            color: "rgb(0,255,0)",
            type: "squareTailCurvedLine"
        }, {
            id1: "Id40",
            id2: "Id33",
            color: "rgb(0,255,0)",
            type: "arrowCurvedLine"
        }, {
            id1: "Id52",
            id2: "Id46",
            color: "rgb(0,255,0)",
            type: "arrowHeadCurvedLine"
        }, {
            id1: "Id4",
            id2: "Id12",
            color: "rgb(0,255,0)",
            type: "arrowTailCurvedLine"
        }, {
            id1: "Id8",
            id2: "Id16",
            color: "rgb(0,255,0)",
            type: "arrowHeadSquareTailCurvedLine"
        }, {
            id1: "Id20",
            id2: "Id28",
            color: "rgb(0,255,0)",
            type: "squareTailArrowHeadCurvedLine"
        }, {
            id1: "Id24",
            id2: "Id32",
            color: "rgb(0,255,0)",
            type: "squareHeadArrowTailCurvedLine"
        }, {
            id1: "Id39",
            id2: "Id45",
            color: "rgb(0,255,0)",
            type: "arrowTailSquareHeadCurvedLine"
        }]
    };
    this.dataSetShapes = {
        nodes: [{
            id: "Id1",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 0,
            y: 0
        }, {
            id: "Id2",
            color: "rgb(255,0,0)",
            shape: "square",
            size: 1,
            x: 200,
            y: 0
        }, {
            id: "Id3",
            color: "rgb(255,0,0)",
            shape: "triangle",
            size: 1,
            x: 400,
            y: 0
        }, {
            id: "Id4",
            color: "rgb(255,0,0)",
            shape: "star",
            size: 1,
            x: 600,
            y: 0
        }, {
            id: "Id5",
            color: "rgb(255,0,0)",
            shape: "rhombus",
            size: 1,
            x: 0,
            y: 100
        }, {
            id: "Id6",
            color: "rgb(255,0,0)",
            shape: "octagon",
            size: 1,
            x: 200,
            y: 100
        }, {
            id: "Id7",
            color: "rgb(255,0,0)",
            shape: "oval",
            size: 1,
            x: 400,
            y: 100
        }, {
            id: "Id8",
            color: "rgb(255,0,0)",
            shape: "plus",
            size: 1,
            x: 600,
            y: 100
        }, {
            id: "Id9",
            color: "rgb(255,0,0)",
            shape: "minus",
            size: 1,
            x: 0,
            y: 200
        }, {
            id: "Id10",
            color: "rgb(255,0,0)",
            shape: "pacman",
            size: 1,
            x: 200,
            y: 200
        }, {
            id: "Id11",
            color: "rgb(255,0,0)",
            shape: "pacman2",
            size: 1,
            x: 400,
            y: 200
        }, {
            id: "Id12",
            color: "rgb(255,0,0)",
            shape: "mdavid",
            size: 1,
            x: 600,
            y: 200
        }, {
            id: "Id13",
            color: "rgb(255,0,0)",
            shape: "rect2",
            size: 1,
            x: 0,
            y: 300
        }, {
            id: "Id14",
            color: "rgb(255,0,0)",
            shape: "rect3",
            size: 1,
            x: 200,
            y: 300
        }, {
            id: "Id15",
            color: "rgb(255,0,0)",
            shape: "arc",
            size: 1,
            x: 400,
            y: 300
        }, {
            id: "Id16",
            color: "rgb(255,0,0)",
            shape: "rectangle",
            size: 1,
            x: 600,
            y: 300
        }, {
            id: "Id17",
            color: "rgb(255,0,0)",
            shape: "image",
            imagePath: "cx.png",
            size: 1,
            x: 0,
            y: 400
        }, {
            id: "Id18",
            color: "rgb(255,0,0)",
            shape: "pie0",
            size: 1,
            x: 200,
            y: 400
        }, {
            id: "Id19",
            color: "rgb(255,0,0)",
            shape: "pie1",
            size: 1,
            x: 400,
            y: 400
        }, {
            id: "Id20",
            color: "rgb(255,0,0)",
            shape: "pie2",
            size: 1,
            x: 600,
            y: 400
        }, {
            id: "Id21",
            color: "rgb(255,0,0)",
            shape: "pie3",
            size: 1,
            x: 0,
            y: 500
        }, {
            id: "Id22",
            color: "rgb(255,0,0)",
            shape: "pie4",
            size: 1,
            x: 200,
            y: 500
        }, {
            id: "Id23",
            color: "rgb(255,0,0)",
            shape: "pie5",
            size: 1,
            x: 400,
            y: 500
        }, {
            id: "Id24",
            color: "rgb(255,0,0)",
            shape: "pie6",
            size: 1,
            x: 600,
            y: 500
        }, {
            id: "Id25",
            color: "rgb(255,0,0)",
            shape: "pie7",
            size: 1,
            x: 0,
            y: 600
        }, {
            id: "Id26",
            color: "rgb(255,0,0)",
            shape: "pie8",
            size: 1,
            x: 200,
            y: 600
        }, {
            id: "Id27",
            color: "rgb(255,0,0)",
            shape: "pie9",
            size: 1,
            x: 400,
            y: 600
        }, {
            id: "Id28",
            color: "rgb(255,0,0)",
            shape: "circle",
            size: 1,
            x: 600,
            y: 600
        }, {
            id: "Id29",
            color: "rgb(255,0,0)",
            shape: "box",
            size: 1,
            x: 0,
            y: 700
        }, {
            id: "Id30",
            color: "rgb(255,0,0)",
            shape: "rect",
            size: 1,
            x: 200,
            y: 700
        }, {
            id: "Id31",
            color: "rgb(255,0,0)",
            shape: "rect2",
            size: 1,
            x: 400,
            y: 700
        }, {
            id: "Id32",
            color: "rgb(255,0,0)",
            shape: "rect3",
            size: 1,
            x: 600,
            y: 700
        }, {
            id: "Id33",
            color: "rgb(255,0,0)",
            shape: "roundrect",
            size: 1,
            x: 0,
            y: 800
        }, {
            id: "Id34",
            color: "rgb(255,0,0)",
            shape: "triangle2",
            size: 1,
            x: 200,
            y: 800
        }, {
            id: "Id35",
            color: "rgb(255,0,0)",
            shape: "equilateral",
            size: 1,
            x: 400,
            y: 800
        }, {
            id: "Id36",
            color: "rgb(255,0,0)",
            shape: "equilateral2",
            size: 1,
            x: 600,
            y: 800
        }, {
            id: "Id37",
            color: "rgb(255,0,0)",
            shape: "hexagon",
            size: 1,
            x: 0,
            y: 900
        }, {
            id: "Id38",
            color: "rgb(255,0,0)",
            shape: "oval2",
            size: 1,
            x: 200,
            y: 900
        }, {
            id: "Id39",
            color: "rgb(255,0,0)",
            shape: "oval3",
            size: 1,
            x: 400,
            y: 900
        }, {
            id: "Id40",
            color: "rgb(255,0,0)",
            shape: "ellipse",
            size: 1,
            x: 600,
            y: 900
        }, {
            id: "Id41",
            color: "rgb(255,0,0)",
            shape: "ellipse2",
            size: 1,
            x: 0,
            y: 1000
        }, {
            id: "Id42",
            color: "rgb(255,0,0)",
            shape: "ellipse3",
            size: 1,
            x: 200,
            y: 1000
        }],
        edges: []
    };
    this.dataSetNetworkDecorations = {
        nodes: [{
            id: "Gene1",
            exp1: 1,
            exp2: 2,
            exp3: 4,
            exp4: {
                cl1: 2,
                cl2: 4,
                cl3: 3
            },
            exp5: {
                cl1: 12,
                cl2: 1,
                cl3: 5
            },
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 155,
            y: 160
        }, {
            id: "Gene2",
            exp1: 2,
            exp2: 4,
            exp3: 1,
            exp4: {
                cl1: 7,
                cl2: 1,
                cl3: 8
            },
            exp5: {
                cl1: 1,
                cl2: 11,
                cl3: 8
            },
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 155,
            y: 340
        }, {
            id: "Gene3",
            exp1: 1,
            exp2: 5,
            exp3: 1,
            exp4: {
                cl1: 12,
                cl2: 4,
                cl3: 8
            },
            exp5: {
                cl1: 3,
                cl2: 7,
                cl3: 5
            },
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 355,
            y: 160
        }, {
            id: "Gene4",
            exp1: 4,
            exp2: 2,
            exp3: 1,
            exp4: {
                cl1: 1,
                cl2: 14,
                cl3: 7
            },
            exp5: {
                cl1: 2,
                cl2: 1,
                cl3: 15
            },
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 355,
            y: 340
        }, {
            id: "Gene5",
            exp1: 1,
            exp2: 3,
            exp3: 2,
            exp4: {
                cl1: 4,
                cl2: 4,
                cl3: 8
            },
            exp5: {
                cl1: 6,
                cl2: 7,
                cl3: 2
            },
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 255,
            y: 100
        }, {
            id: "Gene6",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 255,
            y: 400
        }, {
            id: "Gene7",
            exp1: 3,
            exp2: 3,
            exp3: 4,
            exp4: {
                cl1: 2,
                cl2: 14,
                cl3: 1
            },
            exp5: {
                cl1: 9,
                cl2: 3,
                cl3: 5
            },
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 50,
            y: 250
        }, {
            id: "Gene8",
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 450,
            y: 250
        }],
        edges: [{
            id1: "Gene1",
            id2: "Gene2",
            color: "rgb(51,12,255)",
            width: "3",
            type: "curvedArrowHeadLine"
        }, {
            id1: "Gene4",
            id2: "Gene3",
            color: "rgb(51,12,255)",
            width: "3",
            type: "curvedArrowHeadLine"
        }, {
            id1: "Gene5",
            id2: "Gene6",
            color: "rgb(51,12,255)",
            width: "3",
            type: "arrowHeadLine"
        }, {
            id1: "Gene3",
            id2: "Gene8",
            color: "rgb(51,12,255)",
            width: "3",
            type: "bezierArrowHeadLine"
        }, {
            id1: "Gene7",
            id2: "Gene1",
            color: "rgb(51,12,255)",
            width: "3",
            type: "bezierArrowHeadLine"
        }]
    };
    this.dataSetNetworkRadial = {
        nodes: [{
            id: "Gene1",
            color: "rgb(255,0,0)",
            shape: "square"
        }, {
            id: "Gene2",
            color: "rgb(255,0,0)",
            shape: "square"
        }, {
            id: "Gene3",
            color: "rgb(255,0,0)",
            shape: "square"
        }, {
            id: "Gene4",
            color: "rgb(255,0,0)",
            shape: "square"
        }, {
            id: "Gene5",
            color: "rgb(255,0,0)",
            shape: "square"
        }, {
            id: "Gene6",
            color: "rgb(255,0,0)",
            shape: "square"
        }, {
            id: "Gene7",
            color: "rgb(255,0,0)",
            shape: "square"
        }, {
            id: "Gene8",
            color: "rgb(255,0,0)",
            shape: "square"
        }, {
            id: "SNP1",
            color: "rgb(0,255,0)",
            shape: "sphere"
        }, {
            id: "SNP2",
            color: "rgb(0,255,0)",
            shape: "sphere"
        }, {
            id: "SNP3",
            color: "rgb(0,255,0)",
            shape: "sphere"
        }, {
            id: "SNP4",
            color: "rgb(0,255,0)",
            shape: "sphere"
        }, {
            id: "SNP5",
            color: "rgb(0,255,0)",
            shape: "sphere"
        }, {
            id: "SNP6",
            color: "rgb(0,255,0)",
            shape: "sphere"
        }, {
            id: "SNP7",
            color: "rgb(0,255,0)",
            shape: "sphere"
        }, {
            id: "SNP8",
            color: "rgb(0,255,0)",
            shape: "sphere"
        }, {
            id: "PH1",
            color: "rgb(0,255,255)",
            shape: "star"
        }, {
            id: "PH1a",
            color: "rgb(0,255,255)",
            shape: "star",
            parentNode: "PH1"
        }, {
            id: "PH1b",
            color: "rgb(0,255,255)",
            shape: "star",
            parentNode: "PH1"
        }, {
            id: "PH2",
            color: "rgb(0,255,255)",
            shape: "star"
        }, {
            id: "PH2a",
            color: "rgb(0,255,255)",
            shape: "star",
            parentNode: "PH2"
        }, {
            id: "PH2b",
            color: "rgb(0,255,255)",
            shape: "star",
            parentNode: "PH2"
        }, {
            id: "PH2ba",
            color: "rgb(0,255,255)",
            shape: "star",
            parentNode: "PH2b"
        }, {
            id: "PH3",
            color: "rgb(0,255,255)",
            shape: "star"
        }, {
            id: "PH4",
            color: "rgb(0,255,255)",
            shape: "star"
        }],
        edges: [{
            id1: "Gene1",
            id2: "Gene2",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "SNP1",
            id2: "PH1",
            color: "rgb(51,12,152)",
            type: "line"
        }, {
            id1: "Gene2",
            id2: "Gene7",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "Gene2",
            id2: "Gene8",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "Gene1",
            id2: "Gene3",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "SNP4",
            id2: "PH4",
            color: "rgb(51,12,152)",
            type: "line"
        }, {
            id1: "PH1",
            id2: "PH1a",
            color: "rgb(102,12,152)",
            type: "line"
        }, {
            id1: "PH1",
            id2: "PH1b",
            color: "rgb(102,12,152)",
            type: "line"
        }, {
            id1: "Gene4",
            id2: "SNP3",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "Gene6",
            id2: "SNP4",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "PH2",
            id2: "PH2a",
            color: "rgb(51,12,152)",
            type: "line"
        }, {
            id1: "PH2",
            id2: "PH2b",
            color: "rgb(102,12,152)",
            type: "line"
        }, {
            id1: "Gene6",
            id2: "SNP5",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "Gene7",
            id2: "SNP6",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "SNP6",
            id2: "SNP7",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "Gene1",
            id2: "Gene4",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "Gene1",
            id2: "Gene5",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "SNP7",
            id2: "Gene6",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "SNP6",
            id2: "SNP8",
            color: "rgb(153,12,255)",
            type: "line"
        }, {
            id1: "Gene3",
            id2: "SNP1",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "Gene3",
            id2: "SNP2",
            color: "rgb(51,12,255)",
            type: "line"
        }, {
            id1: "SNP2",
            id2: "PH2",
            color: "rgb(153,12,255)",
            type: "line"
        }, {
            id1: "SNP3",
            id2: "PH3",
            color: "rgb(51,12,152)",
            type: "line"
        }, {
            id1: "PH2b",
            id2: "PH2ba",
            color: "rgb(102,12,152)",
            type: "line"
        }]
    };
    this.dataSetNetworkBasic = {
        nodes: [{
            id: "Cell",
            shape: "image",
            eventless: true,
            width: 525,
            height: 400,
            imagePath: "cell.png",
            x: 250,
            y: 250,
            hideLabel: true
        }, {
            id: "Gene1",
            exp1: 1,
            exp2: 2,
            exp3: 4,
            exp4: {
                cl1: 2,
                cl2: 4,
                cl3: 3
            },
            exp5: {
                cl1: 12,
                cl2: 1,
                cl3: 5
            },
            shape: "image",
            width: 40,
            height: 40,
            imagePath: "prot.png",
            x: 155,
            y: 160
        }, {
            id: "Gene2",
            exp1: 2,
            exp2: 4,
            exp3: 1,
            exp4: {
                cl1: 7,
                cl2: 1,
                cl3: 8
            },
            exp5: {
                cl1: 1,
                cl2: 11,
                cl3: 8
            },
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 155,
            y: 340
        }, {
            id: "Gene3",
            exp1: 1,
            exp2: 5,
            exp3: 1,
            exp4: {
                cl1: 12,
                cl2: 4,
                cl3: 8
            },
            exp5: {
                cl1: 3,
                cl2: 7,
                cl3: 5
            },
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 355,
            y: 160
        }, {
            id: "Gene4",
            label: "Receptor\nGene4",
            exp1: 4,
            exp2: 2,
            exp3: 1,
            exp4: {
                cl1: 1,
                cl2: 14,
                cl3: 7
            },
            exp5: {
                cl1: 2,
                cl2: 1,
                cl3: 15
            },
            color: "rgb(255,0,0)",
            shape: "sphere",
            size: 1,
            x: 355,
            y: 340
        }, {
            id: "Gene5",
            exp1: 1,
            exp2: 3,
            exp3: 2,
            exp4: {
                cl1: 4,
                cl2: 4,
                cl3: 8
            },
            exp5: {
                cl1: 6,
                cl2: 7,
                cl3: 2
            },
            color: "rgb(255,0,0)",
            shape: "sphere",
            width: 20,
            height: 20,
            x: 255,
            y: 100
        }, {
            id: "Met",
            shape: "image",
            width: 40,
            height: 40,
            imagePath: "met.png",
            x: 255,
            y: 400,
            hideLabel: true
        }, {
            id: "Gene7",
            exp1: 3,
            exp2: 3,
            exp3: 4,
            exp4: {
                cl1: 2,
                cl2: 14,
                cl3: 1
            },
            exp5: {
                cl1: 9,
                cl2: 3,
                cl3: 5
            },
            shape: "image",
            width: 40,
            height: 40,
            imagePath: "prot7.png",
            x: 50,
            y: 250
        }, {
            id: "DNA",
            shape: "image",
            width: 40,
            height: 40,
            imagePath: "dna1.png",
            x: 450,
            y: 250,
            hideLabel: true
        }],
        edges: [{
            id1: "Gene1",
            id2: "Gene2",
            color: "rgb(51,12,255)",
            width: "3",
            type: "curvedArrowHeadLine"
        }, {
            id1: "Gene4",
            id2: "Gene3",
            color: "rgb(51,12,255)",
            width: "3",
            type: "curvedArrowHeadLine"
        }, {
            id1: "Gene5",
            id2: "Met",
            color: "rgb(51,12,255)",
            width: "3",
            type: "arrowHeadLine"
        }, {
            id1: "Gene3",
            id2: "DNA",
            color: "rgb(51,12,255)",
            width: "3",
            type: "bezierArrowHeadLine"
        }, {
            id1: "Gene7",
            id2: "Gene1",
            color: "rgb(51,12,255)",
            width: "3",
            type: "bezierArrowHeadLine"
        }],
        legend: {
            nodes: [{
                shape: "sphere",
                color: "rgb(255,0,0)",
                text: "Gene",
                id: "nodesLegendId0"
            }],
            edges: [{
                type: "arrowHeadLine",
                text: "Activate",
                id: "edgesLegendId0"
            }],
            text: [{
                text: "Cool Pathway",
                x: 150,
                y: 460,
                id: "textLegendId0"
            }],
            pos: {
                nodes: {
                    x: -5,
                    y: -5
                },
                edges: {
                    x: 360,
                    y: -5
                },
                decorations: {
                    x: 20,
                    y: 80
                }
            }
        }
    };
    this.dataSetVenn = {
        venn: {
            data: {
                A: 340,
                B: 562,
                C: 620,
                D: 592,
                AB: 639,
                AC: 456,
                AD: 257,
                BC: 915,
                BD: 354,
                CD: 143,
                ABC: 552,
                ABD: 578,
                ACD: 298,
                BCD: 613,
                ABCD: 148
            },
            legend: {
                A: "List 1",
                B: "List 2",
                C: "List 3",
                D: "List 4"
            }
        }
    };
    this.dataSetMarket = {
        market: [{
            symbol: "BMY",
            data: [
                [20100824, 26.26, 26.37, 25.95, 26.02, 11625900, 26.02],
                [20100823, 26.48, 26.76, 26.38, 26.48, 12146600, 26.48],
                [20100820, 26.31, 26.54, 26.08, 26.44, 18140100, 26.44],
                [20100819, 26.2, 26.29, 25.81, 26.06, 8218000, 26.06],
                [20100818, 26.53, 26.57, 26.23, 26.28, 12235800, 26.28],
                [20100817, 26.4, 26.79, 26.26, 26.59, 12325700, 26.59],
                [20100816, 26.24, 26.34, 26.04, 26.28, 10377700, 26.28],
                [20100813, 26.24, 26.46, 26.1, 26.32, 5760100, 26.32],
                [20100812, 26.01, 26.39, 26, 26.33, 7350500, 26.33],
                [20100811, 26.32, 26.5, 26.15, 26.25, 8808100, 26.25],
                [20100810, 26.32, 26.78, 26.3, 26.66, 7009500, 26.66],
                [20100809, 26.37, 26.54, 26.3, 26.51, 6825300, 26.51],
                [20100806, 26.29, 26.45, 26.05, 26.37, 8774900, 26.37],
                [20100805, 25.83, 26.38, 25.8, 26.38, 12264600, 26.38],
                [20100804, 25.7, 26.13, 25.61, 26.03, 10233700, 26.03],
                [20100803, 25.65, 25.85, 25.58, 25.68, 6842900, 25.68],
                [20100802, 25.33, 25.61, 25.29, 25.53, 9770900, 25.53],
                [20100730, 24.98, 25.13, 24.78, 24.92, 11435700, 24.92],
                [20100729, 25.37, 25.5, 24.85, 25.08, 9463800, 25.08],
                [20100728, 25.25, 25.36, 25.02, 25.12, 8072400, 25.12],
                [20100727, 25.09, 25.35, 24.84, 25.32, 14152600, 25.32],
                [20100726, 24.57, 25.03, 24.57, 24.97, 8817400, 24.97],
                [20100723, 24.94, 24.95, 24.26, 24.65, 13043700, 24.65],
                [20100722, 24.96, 25.22, 24.75, 24.93, 10385300, 24.93],
                [20100721, 24.92, 25.11, 24.59, 24.75, 9830000, 24.75],
                [20100720, 24.65, 25.09, 24.46, 25.02, 10655500, 25.02],
                [20100719, 25.27, 25.27, 24.78, 24.84, 11804800, 24.84],
                [20100716, 25.44, 25.47, 25.1, 25.17, 13136300, 25.17]
            ]
        }]
    };
    this.dataSetGenomeTranslate = {
        tracks: [{
            subtype: "DNA",
            type: "sequence",
            data: [{
                id: "Sequence",
                fill: "rgb(51,255,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 1,
                sequence: "TACGTACGTACGTACGTACG",
                translate: [-3, -2, -1, 1, 2, 3]
            }]
        }]
    };
    this.dataSetGenomeSimple = {
        tracks: [{
            subtype: "DNA",
            type: "sequence",
            data: [{
                id: "Reference Sequence",
                fill: "rgb(51,255,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 1,
                sequence: "TACGTACGTACGTACGTACGTACGTACGT",
                index: 0,
                counter: 0,
                measureText: 108
            }, {
                id: "R1-0000-1234",
                fill: "rgb(255,255,51)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 1,
                gaps: [
                    [4, 2],
                    [8, 1]
                ],
                sequence: "TACGCGTAGTACGT",
                index: 1,
                counter: 1,
                measureText: 74
            }, {
                id: "R1-0000-2345",
                fill: "rgb(255,255,102)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 6,
                gaps: [
                    [3, 1],
                    [10, 1]
                ],
                sequence: "ACGACGTACGACG",
                index: 2,
                counter: 2,
                measureText: 74
            }, {
                id: "R1-0000-3456",
                fill: "rgb(255,51,255)",
                outline: "rgb(0,0,0)",
                dir: "left",
                offsetLeft: "23",
                gaps: [
                    [7, 2]
                ],
                sequence: "GTACGTATAC",
                index: 3,
                counter: 3,
                offset: 12,
                measureText: 74
            }, {
                id: "R1-0000-4567",
                fill: "rgb(255,102,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 15,
                gaps: [
                    [5, 1]
                ],
                sequence: "CGTACTACGTA",
                index: 4,
                counter: 4,
                measureText: 74
            }, {
                id: "R1-0000-5678",
                fill: "rgb(51,255,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 18,
                gaps: [
                    [7, 1]
                ],
                sequence: "ACGTACGACGT",
                index: 5,
                counter: 5,
                measureText: 74
            }]
        }]
    };
    this.dataSetGenomeIntermediate = {
        tracks: [{
            subtype: "DNA",
            highlight: [{
                offset: 8,
                width: 1,
                color: "rgb(120,120,180)"
            }, {
                offset: 22,
                width: 1,
                color: "rgb(180,20,180)"
            }],
            type: "sequence",
            data: [{
                id: "Reference Sequence",
                fill: "rgb(51,255,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 1,
                sequence: "TACGTACGTACGTACGTACGTACGTACGT",
                translate: [-3, -2, -1, 1, 2, 3],
                index: 0,
                counter: 0,
                measureText: 108
            }, {
                id: "R1-0000-1234",
                fill: "rgb(255,255,51)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 1,
                gaps: [
                    [4, 2],
                    [8, 1]
                ],
                sequence: "TACGCGTAGTACGT",
                coordinate: 50,
                trace: {
                    A: [15, 27, 47, 72, 93, 101, 93, 72, 47, 27, 15, 54, 120, 224, 350, 459, 502, 459, 350, 224, 120, 54, 3, 4, 6, 12, 24, 43, 67, 86, 94, 86, 67, 43, 24, 12, 6, 4, 3, 13, 26, 45, 69, 89, 97, 89, 69, 45, 26, 13, 13, 26, 46, 70, 92, 100, 92, 70, 46, 26, 13, 5, 12, 26, 48, 75, 99, 108, 99, 75, 48, 26, 12, 5, 2, 4, 10, 22, 41, 64, 83, 91, 83, 64, 41, 22, 10, 4, 2, 22, 55, 122, 226, 353, 462, 505, 462, 353, 226, 122, 55, 22, 4, 11, 24, 45, 70, 92, 100, 92, 70, 45, 24, 11, 4, 2, 3, 6, 13, 28, 50, 78, 102, 111, 102, 78, 50, 28, 13, 6, 3, 2, 6, 11, 26, 62, 135, 249, 388, 506, 553, 506, 388, 249, 135, 62, 26, 11, 6, 6, 8, 14, 26, 45, 68, 87, 95, 87, 68, 45, 26, 14, 8, 6, 11, 23, 43, 67, 88, 96, 88, 67, 43, 23, 11, 5, 6, 8, 15, 28, 48, 73, 94, 102, 94, 73, 48, 28, 15, 8, 6, 5],
                    C: [10, 16, 26, 39, 50, 54, 50, 39, 26, 16, 10, 7, 14, 26, 40, 51, 56, 51, 40, 26, 14, 7, 4, 8, 20, 50, 109, 203, 317, 414, 453, 414, 317, 203, 109, 50, 20, 8, 4, 9, 16, 26, 39, 51, 55, 51, 39, 26, 16, 9, 56, 123, 229, 357, 467, 511, 467, 357, 229, 123, 56, 2, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 2, 1, 3, 6, 13, 25, 39, 50, 55, 50, 39, 25, 13, 6, 3, 1, 5, 8, 15, 26, 39, 50, 55, 50, 39, 26, 15, 8, 5, 2, 5, 11, 21, 32, 42, 46, 42, 32, 21, 11, 5, 2, 2, 2, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 2, 2, 5, 5, 6, 9, 16, 25, 37, 47, 51, 47, 37, 25, 16, 9, 6, 5, 5, 10, 24, 56, 121, 223, 347, 453, 495, 453, 347, 223, 121, 56, 24, 10, 6, 13, 24, 37, 48, 52, 48, 37, 24, 13, 6, 5, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 5],
                    G: [7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 4, 7, 13, 19, 25, 27, 25, 19, 13, 7, 4, 3, 3, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 3, 3, 56, 122, 226, 353, 461, 504, 461, 353, 226, 122, 56, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 22, 58, 130, 245, 383, 502, 549, 502, 383, 245, 130, 58, 22, 1, 1, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 1, 1, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 19, 51, 114, 213, 334, 437, 478, 437, 334, 213, 114, 51, 19, 2, 2, 3, 4, 8, 14, 21, 26, 29, 26, 21, 14, 8, 4, 3, 2, 2, 5, 5, 5, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 5, 5, 5, 5, 5, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 5, 5, 53, 119, 223, 349, 457, 500, 457, 349, 223, 119, 53, 5, 5, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 5, 5],
                    T: [62, 135, 249, 388, 507, 554, 507, 388, 249, 135, 62, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 3, 3, 3, 4, 5, 7, 9, 12, 12, 12, 9, 7, 5, 4, 3, 3, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 7, 22, 58, 130, 244, 383, 501, 548, 501, 383, 244, 130, 58, 22, 7, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 3, 8, 21, 54, 119, 222, 347, 454, 497, 454, 347, 222, 119, 54, 21, 8, 3, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 6, 11, 25, 61, 131, 242, 377, 492, 538, 492, 377, 242, 131, 61, 25, 11, 6],
                    peak: [5, 16, 30, 44, 55, 67, 81, 95, 108, 123, 140, 156, 169, 183],
                    max: 507
                },
                index: 1,
                counter: 1,
                measureText: 74
            }, {
                id: "R1-0000-2345",
                fill: "rgb(255,255,102)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 6,
                gaps: [
                    [3, 1],
                    [10, 1]
                ],
                sequence: "ACGACGTACGACG",
                coordinate: 80,
                trace: {
                    A: [49, 110, 206, 323, 424, 463, 424, 323, 206, 110, 49, 3, 5, 12, 24, 45, 69, 90, 98, 90, 69, 45, 24, 12, 5, 3, 5, 7, 14, 28, 49, 75, 97, 105, 97, 75, 49, 28, 14, 7, 5, 5, 10, 25, 61, 132, 245, 382, 499, 545, 499, 382, 245, 132, 61, 25, 10, 5, 7, 13, 27, 48, 74, 96, 105, 96, 74, 48, 27, 13, 7, 4, 6, 13, 25, 46, 70, 91, 100, 91, 70, 46, 25, 13, 6, 4, 4, 7, 14, 27, 49, 76, 99, 108, 99, 76, 49, 27, 14, 7, 4, 3, 8, 22, 57, 125, 234, 366, 479, 524, 479, 366, 234, 125, 57, 22, 8, 3, 5, 8, 15, 30, 52, 80, 104, 113, 104, 80, 52, 30, 15, 8, 5, 7, 13, 25, 44, 66, 86, 94, 86, 66, 44, 25, 13, 7, 23, 58, 127, 236, 368, 482, 527, 482, 368, 236, 127, 58, 23, 3, 4, 6, 13, 26, 47, 73, 95, 104, 95, 73, 47, 26, 13, 6, 4, 3, 5, 6, 9, 16, 30, 52, 79, 102, 111, 102, 79, 52, 30, 16, 9, 6, 5],
                    C: [5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 7, 21, 53, 117, 218, 341, 447, 488, 447, 341, 218, 117, 53, 21, 7, 4, 5, 9, 15, 26, 38, 49, 53, 49, 38, 26, 15, 9, 5, 4, 4, 4, 6, 9, 16, 27, 40, 51, 56, 51, 40, 27, 16, 9, 6, 4, 4, 20, 50, 109, 203, 317, 415, 453, 415, 317, 203, 109, 50, 20, 3, 4, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 4, 3, 3, 4, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 4, 3, 2, 2, 3, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 3, 2, 2, 9, 23, 55, 118, 219, 342, 447, 489, 447, 342, 219, 118, 55, 23, 9, 5, 9, 16, 26, 39, 50, 54, 50, 39, 26, 16, 9, 5, 4, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 4, 4, 9, 22, 55, 120, 224, 349, 457, 500, 457, 349, 224, 120, 55, 22, 9, 4, 5, 5, 7, 10, 17, 27, 40, 51, 56, 51, 40, 27, 17, 10, 7, 5, 5],
                    G: [3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 2, 2, 4, 7, 12, 17, 22, 24, 22, 17, 12, 7, 4, 2, 2, 10, 24, 59, 129, 239, 373, 487, 533, 487, 373, 239, 129, 59, 24, 10, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 9, 23, 59, 129, 239, 374, 489, 534, 489, 374, 239, 129, 59, 23, 9, 3, 3, 5, 8, 13, 18, 23, 25, 23, 18, 13, 8, 5, 3, 3, 2, 2, 2, 4, 7, 12, 17, 22, 24, 22, 17, 12, 7, 4, 2, 2, 2, 4, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 4, 22, 52, 113, 209, 325, 425, 465, 425, 325, 209, 113, 52, 22, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 3, 3, 5, 8, 14, 20, 26, 28, 26, 20, 14, 8, 5, 3, 3, 3, 6, 11, 26, 62, 133, 246, 383, 501, 547, 501, 383, 246, 133, 62, 26, 11, 6],
                    T: [2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 3, 8, 21, 52, 115, 213, 333, 436, 476, 436, 333, 213, 115, 52, 21, 8, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 5, 5, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 5, 5],
                    peak: [5, 18, 33, 49, 64, 78, 93, 109, 125, 139, 152, 167, 184],
                    max: 501
                },
                index: 2,
                counter: 2,
                measureText: 74
            }, {
                id: "R1-0000-3456",
                fill: "rgb(255,51,255)",
                outline: "rgb(0,0,0)",
                dir: "left",
                offsetLeft: "23",
                gaps: [
                    [7, 2]
                ],
                sequence: "GTACGTATAC",
                coordinate: 150,
                trace: {
                    A: [4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 8, 20, 50, 110, 205, 320, 418, 457, 418, 320, 205, 110, 50, 20, 8, 5, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 5, 8, 23, 59, 130, 243, 380, 498, 545, 498, 380, 243, 130, 59, 23, 8, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 10, 23, 57, 124, 230, 358, 468, 512, 468, 358, 230, 124, 57, 23, 10, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1],
                    C: [4, 4, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 4, 4, 2, 3, 4, 8, 14, 21, 26, 29, 26, 21, 14, 8, 4, 3, 2, 3, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 5, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 5, 2, 2, 4, 7, 13, 19, 24, 26, 24, 19, 13, 7, 4, 2, 2, 2, 7, 21, 56, 126, 236, 370, 485, 531, 485, 370, 236, 126, 56, 21, 7, 2, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 5, 6, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 6, 5, 4, 4, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 4, 4, 21, 54, 122, 228, 357, 467, 511, 467, 357, 228, 122, 54, 21],
                    G: [10, 24, 57, 125, 231, 360, 470, 514, 470, 360, 231, 125, 57, 24, 10, 2, 3, 7, 13, 23, 35, 46, 50, 46, 35, 23, 13, 7, 3, 2, 3, 5, 8, 15, 26, 39, 51, 55, 51, 39, 26, 15, 8, 5, 3, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 2, 3, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 3, 2, 1, 1, 2, 6, 12, 22, 34, 44, 48, 44, 34, 22, 12, 6, 2, 1, 1, 59, 130, 242, 377, 494, 540, 494, 377, 242, 130, 59, 5, 7, 10, 17, 28, 41, 53, 57, 53, 41, 28, 17, 10, 7, 5, 4, 5, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 4, 2, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 2],
                    T: [5, 8, 15, 28, 50, 76, 99, 108, 99, 76, 50, 28, 15, 8, 5, 7, 19, 50, 110, 206, 322, 421, 460, 421, 322, 206, 110, 50, 19, 7, 4, 7, 13, 27, 49, 75, 98, 107, 98, 75, 49, 27, 13, 7, 4, 11, 24, 58, 124, 228, 355, 464, 507, 464, 355, 228, 124, 58, 24, 11, 3, 6, 13, 26, 48, 75, 98, 107, 98, 75, 48, 26, 13, 6, 3, 1, 2, 4, 11, 24, 44, 69, 90, 99, 90, 69, 44, 24, 11, 4, 2, 1, 13, 25, 45, 69, 89, 97, 89, 69, 45, 25, 13, 11, 24, 58, 124, 228, 356, 465, 508, 465, 356, 228, 124, 58, 24, 11, 5, 8, 15, 29, 51, 79, 102, 111, 102, 79, 51, 29, 15, 8, 5, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4],
                    peak: [8, 23, 38, 53, 68, 84, 98, 111, 126, 140],
                    reversed: true,
                    max: 511
                },
                index: 3,
                counter: 3,
                offset: 12,
                measureText: 74
            }, {
                id: "R1-0000-4567",
                fill: "rgb(255,102,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 15,
                gaps: [
                    [5, 1]
                ],
                sequence: "CGTACTACGTA",
                coordinate: 20,
                trace: {
                    A: [9, 16, 29, 51, 78, 100, 110, 100, 78, 51, 29, 16, 9, 15, 28, 50, 77, 100, 109, 100, 77, 50, 28, 15, 4, 5, 7, 13, 25, 44, 67, 86, 94, 86, 67, 44, 25, 13, 7, 5, 4, 4, 8, 21, 53, 115, 214, 335, 438, 479, 438, 335, 214, 115, 53, 21, 8, 4, 2, 3, 5, 11, 23, 42, 65, 85, 93, 85, 65, 42, 23, 11, 5, 3, 2, 8, 15, 29, 52, 80, 103, 113, 103, 80, 52, 29, 15, 8, 4, 9, 23, 57, 126, 233, 365, 477, 522, 477, 365, 233, 126, 57, 23, 9, 4, 2, 4, 10, 23, 42, 66, 87, 95, 87, 66, 42, 23, 10, 4, 2, 3, 5, 12, 25, 46, 71, 93, 101, 93, 71, 46, 25, 12, 5, 3, 4, 5, 8, 14, 28, 50, 76, 99, 108, 99, 76, 50, 28, 14, 8, 5, 4, 19, 49, 108, 202, 316, 413, 452, 413, 316, 202, 108, 49, 19],
                    C: [24, 56, 121, 223, 348, 454, 496, 454, 348, 223, 121, 56, 24, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 4, 4, 5, 8, 15, 24, 36, 46, 50, 46, 36, 24, 15, 8, 5, 4, 4, 3, 3, 4, 8, 14, 25, 38, 48, 53, 48, 38, 25, 14, 8, 4, 3, 3, 3, 8, 21, 54, 119, 222, 348, 455, 498, 455, 348, 222, 119, 54, 21, 8, 3, 5, 9, 15, 25, 38, 48, 52, 48, 38, 25, 15, 9, 5, 3, 3, 5, 8, 15, 26, 39, 51, 55, 51, 39, 26, 15, 8, 5, 3, 3, 6, 18, 48, 107, 201, 315, 412, 451, 412, 315, 201, 107, 48, 18, 6, 2, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 2, 4, 4, 6, 9, 16, 28, 42, 54, 58, 54, 42, 28, 16, 9, 6, 4, 4, 3, 7, 13, 24, 37, 47, 52, 47, 37, 24, 13, 7, 3],
                    G: [6, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 6, 56, 121, 223, 348, 455, 498, 455, 348, 223, 121, 56, 4, 4, 5, 6, 10, 16, 23, 28, 31, 28, 23, 16, 10, 6, 5, 4, 4, 3, 3, 4, 5, 9, 14, 21, 26, 29, 26, 21, 14, 9, 5, 4, 3, 3, 2, 2, 2, 4, 7, 12, 18, 24, 26, 24, 18, 12, 7, 4, 2, 2, 2, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 3, 3, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 3, 1, 2, 3, 7, 12, 19, 24, 27, 24, 19, 12, 7, 3, 2, 1, 7, 20, 51, 113, 211, 330, 432, 473, 432, 330, 211, 113, 51, 20, 7, 4, 4, 4, 6, 9, 15, 21, 26, 29, 26, 21, 15, 9, 6, 4, 4, 4, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3],
                    T: [5, 6, 7, 9, 11, 13, 14, 13, 11, 9, 7, 6, 5, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 5, 10, 24, 60, 130, 241, 376, 492, 538, 492, 376, 241, 130, 60, 24, 10, 5, 3, 3, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 3, 3, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 22, 53, 114, 211, 328, 429, 469, 429, 328, 211, 114, 53, 22, 3, 3, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 3, 3, 1, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 5, 10, 24, 58, 127, 235, 366, 479, 524, 479, 366, 235, 127, 58, 24, 10, 5, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2],
                    peak: [6, 18, 32, 49, 66, 81, 96, 112, 127, 143, 158],
                    max: 492
                },
                index: 4,
                counter: 4,
                measureText: 74
            }, {
                id: "R1-0000-5678",
                fill: "rgb(51,255,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 18,
                gaps: [
                    [7, 1]
                ],
                sequence: "ACGTACGACGT",
                coordinate: 120,
                trace: {
                    A: [10, 25, 60, 131, 244, 380, 497, 544, 497, 380, 244, 131, 60, 25, 10, 5, 6, 8, 15, 28, 48, 73, 95, 103, 95, 73, 48, 28, 15, 8, 6, 5, 4, 6, 13, 26, 47, 72, 94, 102, 94, 72, 47, 26, 13, 6, 4, 6, 8, 15, 28, 49, 74, 95, 104, 95, 74, 49, 28, 15, 8, 6, 2, 7, 22, 58, 129, 243, 380, 498, 545, 498, 380, 243, 129, 58, 22, 7, 2, 11, 23, 43, 66, 86, 94, 86, 66, 43, 23, 11, 5, 8, 15, 28, 50, 77, 100, 109, 100, 77, 50, 28, 15, 8, 5, 6, 11, 24, 58, 125, 232, 361, 471, 515, 471, 361, 232, 125, 58, 24, 11, 6, 12, 24, 43, 66, 85, 93, 85, 66, 43, 24, 12, 14, 28, 50, 76, 99, 108, 99, 76, 50, 28, 14, 5, 7, 14, 27, 47, 72, 93, 101, 93, 72, 47, 27, 14, 7, 5],
                    C: [4, 5, 8, 15, 24, 36, 46, 50, 46, 36, 24, 15, 8, 5, 4, 6, 11, 26, 62, 135, 249, 388, 506, 554, 506, 388, 249, 135, 62, 26, 11, 6, 3, 5, 8, 15, 25, 38, 49, 54, 49, 38, 25, 15, 8, 5, 3, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 1, 1, 3, 6, 13, 24, 37, 49, 53, 49, 37, 24, 13, 6, 3, 1, 1, 53, 117, 219, 342, 447, 489, 447, 342, 219, 117, 53, 4, 5, 8, 15, 25, 36, 47, 51, 47, 36, 25, 15, 8, 5, 4, 5, 5, 7, 10, 17, 28, 41, 53, 57, 53, 41, 28, 17, 10, 7, 5, 5, 57, 124, 231, 360, 471, 516, 471, 360, 231, 124, 57, 9, 16, 27, 40, 51, 55, 51, 40, 27, 16, 9, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4],
                    G: [4, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 5, 5, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 5, 5, 8, 21, 53, 116, 216, 337, 440, 482, 440, 337, 216, 116, 53, 21, 8, 5, 6, 7, 11, 17, 23, 29, 32, 29, 23, 17, 11, 7, 6, 5, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 4, 8, 13, 20, 25, 27, 25, 20, 13, 8, 4, 9, 21, 52, 111, 206, 321, 420, 459, 420, 321, 206, 111, 52, 21, 9, 5, 5, 5, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 5, 5, 5, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 57, 124, 230, 358, 468, 512, 468, 358, 230, 124, 57, 4, 4, 6, 9, 14, 20, 25, 28, 25, 20, 14, 9, 6, 4, 4],
                    T: [4, 4, 5, 6, 8, 11, 14, 14, 14, 11, 8, 6, 5, 4, 4, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 11, 24, 57, 122, 224, 349, 456, 498, 456, 349, 224, 122, 57, 24, 11, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 10, 25, 60, 131, 242, 378, 494, 540, 494, 378, 242, 131, 60, 25, 10],
                    peak: [7, 23, 39, 54, 70, 84, 97, 113, 127, 138, 151],
                    max: 512
                },
                index: 5,
                counter: 5,
                measureText: 74
            }]
        }]
    };
    this.dataSetGenomeAdvanced = {
        tracks: [{
            name: "Affymetrix Probes",
            type: "box",
            connect: true,
            data: [{
                id: "123456_at",
                fill: "rgb(255,255,51)",
                outline: "rgb(0,0,0)",
                dir: "right",
                data: [
                    [10, 20],
                    [30, 40],
                    [50, 60],
                    [70, 80],
                    [90, 100],
                    [110, 120]
                ],
                sequences: ["GTTTTACGTAC", "TACGTACGTAC", "GGTTTACGTAC", "GGTTTACGTAC", "GGTTTACGTAC", "GGTTTACGTAC"],
                index: 0,
                counter: 0,
                start: 10,
                end: 120,
                measureText: 56
            }, {
                id: "234567_at",
                fill: "rgb(255,255,51)",
                outline: "rgb(0,0,0)",
                dir: "left",
                data: [
                    [50, 60],
                    [70, 80],
                    [90, 100],
                    [110, 120],
                    [130, 140],
                    [150, 160]
                ],
                index: 1,
                counter: 1,
                start: 50,
                end: 160,
                measureText: 56
            }, {
                id: "345678_at",
                fill: "rgb(255,255,51)",
                outline: "rgb(0,0,0)",
                dir: "right",
                data: [
                    [100, 110],
                    [120, 130],
                    [140, 150],
                    [160, 170],
                    [180, 190]
                ],
                index: 2,
                counter: 2,
                start: 100,
                end: 190,
                measureText: 56
            }],
            startY: 50,
            endY: 82,
            displayedFeatures: 3,
            totalFeatures: 3
        }, {
            name: "Sanger Sequencing (Multiple sequeneces)",
            highlight: [{
                offset: 80,
                width: 1,
                color: "rgb(120,120,180)"
            }, {
                offset: 185,
                width: 1,
                color: "rgb(180,20,180)"
            }],
            subtype: "DNA",
            type: "sequence",
            data: [{
                id: "Reference Sequence",
                fill: "rgb(51,255,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 1,
                sequence: "AAAACCCGGGTTTTACGTACGTACGTACGTACGTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTAAACC",
                translate: [-3, -2, -1, 1, 2, 3],
                index: 0,
                counter: 3,
                measureText: 108
            }, {
                id: "R1-0000-1234",
                fill: "rgb(255,255,51)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 1,
                gaps: [
                    [18, 1],
                    [22, 1]
                ],
                sequence: "AAAACCCGGGTTTTACGTCGTAGTACGTACGTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAA",
                coordinate: 50,
                trace: {
                    A: [57, 127, 237, 371, 486, 531, 486, 371, 237, 127, 57, 54, 117, 217, 339, 442, 484, 442, 339, 217, 117, 54, 10, 24, 60, 130, 240, 375, 490, 535, 490, 375, 240, 130, 60, 24, 10, 56, 121, 222, 346, 452, 494, 452, 346, 222, 121, 56, 7, 14, 27, 48, 74, 95, 104, 95, 74, 48, 27, 14, 7, 6, 8, 14, 27, 46, 69, 90, 98, 90, 69, 46, 27, 14, 8, 6, 4, 5, 7, 14, 27, 47, 72, 93, 101, 93, 72, 47, 27, 14, 7, 5, 4, 5, 11, 23, 42, 65, 85, 92, 85, 65, 42, 23, 11, 5, 7, 14, 27, 48, 74, 95, 104, 95, 74, 48, 27, 14, 7, 1, 2, 4, 10, 22, 42, 65, 85, 93, 85, 65, 42, 22, 10, 4, 2, 1, 5, 12, 24, 44, 68, 88, 97, 88, 68, 44, 24, 12, 5, 4, 5, 7, 14, 27, 47, 72, 94, 102, 94, 72, 47, 27, 14, 7, 5, 4, 2, 4, 10, 22, 41, 64, 83, 91, 83, 64, 41, 22, 10, 4, 2, 12, 24, 43, 67, 87, 95, 87, 67, 43, 24, 12, 21, 52, 113, 210, 328, 429, 469, 429, 328, 210, 113, 52, 21, 4, 6, 13, 26, 47, 72, 93, 102, 93, 72, 47, 26, 13, 6, 4, 4, 6, 13, 26, 46, 71, 92, 100, 92, 71, 46, 26, 13, 6, 4, 6, 8, 14, 27, 46, 69, 89, 97, 89, 69, 46, 27, 14, 8, 6, 4, 5, 8, 14, 28, 49, 76, 98, 107, 98, 76, 49, 28, 14, 8, 5, 4, 7, 13, 25, 45, 68, 88, 96, 88, 68, 45, 25, 13, 7, 5, 11, 24, 43, 67, 88, 96, 88, 67, 43, 24, 11, 5, 22, 54, 118, 219, 342, 447, 489, 447, 342, 219, 118, 54, 22, 5, 12, 25, 46, 71, 93, 102, 93, 71, 46, 25, 12, 5, 5, 12, 24, 44, 68, 89, 97, 89, 68, 44, 24, 12, 5, 20, 54, 121, 226, 355, 465, 508, 465, 355, 226, 121, 54, 20, 3, 4, 6, 13, 25, 45, 70, 91, 99, 91, 70, 45, 25, 13, 6, 4, 3, 6, 8, 15, 27, 47, 71, 91, 99, 91, 71, 47, 27, 15, 8, 6, 1, 2, 4, 11, 24, 44, 69, 90, 98, 90, 69, 44, 24, 11, 4, 2, 1, 6, 11, 25, 60, 128, 237, 369, 482, 527, 482, 369, 237, 128, 60, 25, 11, 6, 2, 5, 12, 25, 47, 74, 97, 106, 97, 74, 47, 25, 12, 5, 2, 5, 8, 15, 29, 51, 78, 101, 110, 101, 78, 51, 29, 15, 8, 5, 5, 12, 26, 48, 75, 98, 107, 98, 75, 48, 26, 12, 5, 6, 18, 48, 107, 201, 315, 412, 451, 412, 315, 201, 107, 48, 18, 6, 9, 16, 31, 53, 81, 105, 114, 105, 81, 53, 31, 16, 9, 6, 8, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 8, 6, 11, 23, 42, 65, 85, 92, 85, 65, 42, 23, 11, 19, 51, 113, 212, 332, 434, 475, 434, 332, 212, 113, 51, 19, 8, 15, 28, 49, 74, 95, 104, 95, 74, 49, 28, 15, 8, 12, 26, 49, 76, 99, 109, 99, 76, 49, 26, 12, 12, 24, 43, 67, 86, 94, 86, 67, 43, 24, 12, 22, 54, 118, 218, 341, 445, 487, 445, 341, 218, 118, 54, 22, 21, 52, 112, 208, 324, 423, 462, 423, 324, 208, 112, 52, 21, 10, 23, 54, 115, 212, 330, 430, 471, 430, 330, 212, 115, 54, 23, 10, 2, 3, 5, 12, 25, 45, 69, 91, 99, 91, 69, 45, 25, 12, 5, 3, 2, 2, 3, 5, 12, 24, 44, 68, 88, 97, 88, 68, 44, 24, 12, 5, 3, 2, 8, 15, 28, 50, 77, 100, 109, 100, 77, 50, 28, 15, 8, 12, 26, 48, 74, 96, 105, 96, 74, 48, 26, 12, 13, 27, 48, 74, 96, 105, 96, 74, 48, 27, 13, 13, 25, 45, 70, 91, 99, 91, 70, 45, 25, 13, 7, 14, 28, 49, 75, 97, 105, 97, 75, 49, 28, 14, 7, 2, 5, 12, 26, 48, 74, 97, 106, 97, 74, 48, 26, 12, 5, 2, 16, 30, 53, 80, 103, 113, 103, 80, 53, 30, 16, 25, 61, 133, 246, 384, 501, 548, 501, 384, 246, 133, 61, 25, 6, 13, 25, 45, 69, 90, 98, 90, 69, 45, 25, 13, 6, 5, 6, 9, 15, 29, 50, 77, 99, 108, 99, 77, 50, 29, 15, 9, 6, 5, 10, 23, 42, 65, 86, 94, 86, 65, 42, 23, 10, 9, 23, 55, 120, 223, 348, 454, 497, 454, 348, 223, 120, 55, 23, 9, 2, 4, 11, 23, 43, 67, 88, 96, 88, 67, 43, 23, 11, 4, 2, 2, 3, 6, 12, 26, 48, 74, 96, 105, 96, 74, 48, 26, 12, 6, 3, 2, 15, 28, 49, 74, 96, 104, 96, 74, 49, 28, 15, 22, 55, 120, 223, 348, 455, 498, 455, 348, 223, 120, 55, 22, 22, 53, 115, 213, 332, 434, 474, 434, 332, 213, 115, 53, 22, 7, 20, 53, 118, 221, 346, 454, 496, 454, 346, 221, 118, 53, 20, 7, 2, 3, 5, 11, 24, 44, 67, 88, 96, 88, 67, 44, 24, 11, 5, 3, 2, 15, 28, 50, 75, 97, 106, 97, 75, 50, 28, 15, 1, 2, 5, 12, 25, 47, 74, 96, 105, 96, 74, 47, 25, 12, 5, 2, 1, 6, 8, 15, 28, 49, 74, 96, 104, 96, 74, 49, 28, 15, 8, 6, 5, 12, 26, 47, 72, 94, 103, 94, 72, 47, 26, 12, 5, 8, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 8, 3, 5, 11, 23, 42, 65, 84, 92, 84, 65, 42, 23, 11, 5, 3, 5, 12, 25, 45, 70, 91, 100, 91, 70, 45, 25, 12, 5, 1, 2, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 2, 1, 7, 20, 51, 113, 212, 331, 433, 474, 433, 331, 212, 113, 51, 20, 7, 2, 3, 5, 12, 25, 46, 72, 94, 102, 94, 72, 46, 25, 12, 5, 3, 2, 2, 4, 11, 25, 46, 72, 94, 102, 94, 72, 46, 25, 11, 4, 2, 2, 3, 6, 12, 26, 48, 74, 97, 106, 97, 74, 48, 26, 12, 6, 3, 2, 10, 25, 61, 133, 247, 386, 504, 551, 504, 386, 247, 133, 61, 25, 10, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 5, 8, 15, 28, 50, 76, 99, 108, 99, 76, 50, 28, 15, 8, 5, 2, 3, 6, 13, 26, 48, 75, 98, 107, 98, 75, 48, 26, 13, 6, 3, 2, 8, 22, 57, 127, 238, 372, 487, 532, 487, 372, 238, 127, 57, 22, 8, 60, 129, 237, 370, 483, 528, 483, 370, 237, 129, 60],
                    C: [6, 13, 23, 34, 45, 49, 45, 34, 23, 13, 6, 9, 16, 28, 41, 53, 58, 53, 41, 28, 16, 9, 4, 5, 9, 15, 26, 39, 49, 54, 49, 39, 26, 15, 9, 5, 4, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 21, 51, 111, 206, 321, 419, 459, 419, 321, 206, 111, 51, 21, 11, 26, 62, 134, 248, 387, 505, 552, 505, 387, 248, 134, 62, 26, 11, 5, 10, 24, 58, 126, 233, 364, 475, 520, 475, 364, 233, 126, 58, 24, 10, 5, 3, 7, 13, 23, 35, 46, 50, 46, 35, 23, 13, 7, 3, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 3, 6, 13, 22, 34, 45, 49, 45, 34, 22, 13, 6, 3, 4, 4, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 4, 4, 1, 2, 6, 12, 23, 36, 47, 51, 47, 36, 23, 12, 6, 2, 1, 7, 13, 23, 34, 44, 48, 44, 34, 23, 13, 7, 5, 8, 15, 27, 41, 52, 57, 52, 41, 27, 15, 8, 5, 8, 21, 52, 113, 211, 329, 431, 471, 431, 329, 211, 113, 52, 21, 8, 3, 4, 8, 14, 24, 37, 47, 51, 47, 37, 24, 14, 8, 4, 3, 5, 6, 10, 16, 27, 39, 50, 54, 50, 39, 27, 16, 10, 6, 5, 5, 9, 22, 52, 114, 210, 328, 428, 468, 428, 328, 210, 114, 52, 22, 9, 5, 6, 9, 16, 27, 41, 53, 57, 53, 41, 27, 16, 9, 6, 3, 7, 13, 24, 36, 47, 51, 47, 36, 24, 13, 7, 3, 4, 8, 15, 25, 38, 49, 54, 49, 38, 25, 15, 8, 4, 4, 7, 14, 25, 38, 49, 54, 49, 38, 25, 14, 7, 4, 3, 7, 14, 24, 37, 48, 52, 48, 37, 24, 14, 7, 3, 2, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 2, 4, 8, 21, 52, 114, 212, 331, 433, 474, 433, 331, 212, 114, 52, 21, 8, 4, 5, 6, 10, 16, 27, 39, 50, 54, 50, 39, 27, 16, 10, 6, 5, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 5, 5, 7, 10, 17, 29, 43, 54, 59, 54, 43, 29, 17, 10, 7, 5, 5, 6, 18, 49, 109, 203, 319, 417, 457, 417, 319, 203, 109, 49, 18, 6, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 1, 2, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 2, 1, 25, 61, 131, 242, 376, 492, 538, 492, 376, 242, 131, 61, 25, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 7, 14, 26, 39, 51, 56, 51, 39, 26, 14, 7, 3, 6, 13, 24, 38, 50, 54, 50, 38, 24, 13, 6, 3, 24, 56, 121, 224, 348, 454, 497, 454, 348, 224, 121, 56, 24, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 8, 14, 24, 36, 47, 51, 47, 36, 24, 14, 8, 5, 9, 15, 25, 38, 48, 53, 48, 38, 25, 15, 9, 5, 5, 9, 15, 25, 37, 47, 51, 47, 37, 25, 15, 9, 5, 5, 7, 10, 17, 29, 42, 54, 59, 54, 42, 29, 17, 10, 7, 5, 3, 7, 20, 52, 116, 217, 339, 443, 485, 443, 339, 217, 116, 52, 20, 7, 3, 3, 8, 22, 55, 123, 229, 358, 469, 513, 469, 358, 229, 123, 55, 22, 8, 3, 22, 52, 114, 210, 328, 428, 468, 428, 328, 210, 114, 52, 22, 7, 14, 25, 38, 49, 54, 49, 38, 25, 14, 7, 7, 13, 23, 35, 45, 49, 45, 35, 23, 13, 7, 8, 14, 24, 36, 47, 51, 47, 36, 24, 14, 8, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 1, 2, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 2, 1, 10, 16, 26, 39, 49, 54, 49, 39, 26, 16, 10, 5, 8, 14, 24, 36, 46, 49, 46, 36, 24, 14, 8, 5, 22, 54, 119, 222, 346, 453, 495, 453, 346, 222, 119, 54, 22, 5, 5, 6, 10, 16, 26, 38, 49, 53, 49, 38, 26, 16, 10, 6, 5, 5, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 4, 5, 9, 15, 26, 38, 49, 53, 49, 38, 26, 15, 9, 5, 4, 7, 20, 53, 119, 223, 349, 457, 500, 457, 349, 223, 119, 53, 20, 7, 2, 2, 4, 7, 14, 25, 38, 50, 54, 50, 38, 25, 14, 7, 4, 2, 2, 10, 16, 27, 39, 50, 55, 50, 39, 27, 16, 10, 5, 8, 15, 27, 41, 52, 57, 52, 41, 27, 15, 8, 5, 6, 9, 16, 27, 40, 51, 56, 51, 40, 27, 16, 9, 6, 1, 2, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 2, 1, 3, 8, 22, 56, 124, 232, 362, 474, 519, 474, 362, 232, 124, 56, 22, 8, 3, 56, 120, 221, 345, 450, 492, 450, 345, 221, 120, 56, 2, 7, 21, 55, 122, 229, 358, 469, 513, 469, 358, 229, 122, 55, 21, 7, 2, 5, 7, 10, 17, 27, 40, 51, 56, 51, 40, 27, 17, 10, 7, 5, 3, 7, 13, 23, 35, 45, 50, 45, 35, 23, 13, 7, 3, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 2, 3, 7, 13, 24, 37, 48, 52, 48, 37, 24, 13, 7, 3, 2, 4, 7, 14, 25, 39, 50, 55, 50, 39, 25, 14, 7, 4, 1, 1, 2, 6, 12, 22, 34, 44, 49, 44, 34, 22, 12, 6, 2, 1, 1, 2, 3, 7, 13, 23, 35, 46, 50, 46, 35, 23, 13, 7, 3, 2, 3, 8, 23, 58, 129, 240, 376, 492, 539, 492, 376, 240, 129, 58, 23, 8, 3, 1, 2, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 2, 1, 2, 2, 3, 6, 12, 22, 34, 44, 48, 44, 34, 22, 12, 6, 3, 2, 2, 4, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 4, 57, 122, 225, 350, 457, 500, 457, 350, 225, 122, 57, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4, 2, 2, 3, 6, 13, 22, 34, 45, 49, 45, 34, 22, 13, 6, 3, 2, 2, 2, 3, 7, 13, 24, 36, 47, 51, 47, 36, 24, 13, 7, 3, 2, 10, 16, 26, 38, 48, 52, 48, 38, 26, 16, 10],
                    G: [4, 8, 14, 20, 26, 29, 26, 20, 14, 8, 4, 6, 9, 14, 20, 26, 28, 26, 20, 14, 9, 6, 4, 5, 6, 10, 15, 22, 27, 29, 27, 22, 15, 10, 6, 5, 4, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 5, 5, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 5, 5, 4, 4, 5, 6, 10, 15, 22, 28, 30, 28, 22, 15, 10, 6, 5, 4, 4, 22, 57, 127, 237, 370, 485, 530, 485, 370, 237, 127, 57, 22, 24, 60, 130, 242, 377, 493, 539, 493, 377, 242, 130, 60, 24, 2, 7, 21, 55, 123, 230, 361, 472, 517, 472, 361, 230, 123, 55, 21, 7, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 3, 5, 8, 14, 20, 25, 28, 25, 20, 14, 8, 5, 3, 3, 9, 22, 55, 120, 224, 349, 457, 499, 457, 349, 224, 120, 55, 22, 9, 5, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 5, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 22, 54, 116, 215, 335, 438, 479, 438, 335, 215, 116, 54, 22, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 22, 57, 127, 237, 371, 485, 530, 485, 371, 237, 127, 57, 22, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 3, 3, 3, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 3, 3, 3, 11, 25, 59, 127, 234, 364, 476, 520, 476, 364, 234, 127, 59, 25, 11, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 5, 5, 5, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 5, 5, 5, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 10, 23, 56, 121, 223, 348, 455, 498, 455, 348, 223, 121, 56, 23, 10, 1, 3, 6, 12, 18, 23, 25, 23, 18, 12, 6, 3, 1, 1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 1, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 11, 25, 61, 131, 243, 378, 494, 540, 494, 378, 243, 131, 61, 25, 11, 4, 8, 14, 20, 26, 29, 26, 20, 14, 8, 4, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 5, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 5, 50, 112, 211, 330, 432, 473, 432, 330, 211, 112, 50, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 5, 5, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 5, 5, 2, 2, 2, 4, 7, 12, 17, 22, 24, 22, 17, 12, 7, 4, 2, 2, 2, 2, 2, 3, 4, 8, 13, 20, 25, 27, 25, 20, 13, 8, 4, 3, 2, 2, 5, 6, 10, 15, 22, 28, 30, 28, 22, 15, 10, 6, 5, 59, 130, 243, 381, 498, 545, 498, 381, 243, 130, 59, 54, 118, 218, 341, 446, 488, 446, 341, 218, 118, 54, 57, 126, 234, 365, 477, 522, 477, 365, 234, 126, 57, 4, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 4, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 4, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 4, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 6, 10, 24, 56, 121, 223, 347, 453, 495, 453, 347, 223, 121, 56, 24, 10, 6, 3, 6, 12, 18, 23, 25, 23, 18, 12, 6, 3, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 3, 8, 23, 59, 131, 244, 382, 500, 547, 500, 382, 244, 131, 59, 23, 8, 3, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 3, 5, 8, 13, 19, 24, 27, 24, 19, 13, 8, 5, 3, 5, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 5, 1, 2, 3, 7, 13, 20, 25, 28, 25, 20, 13, 7, 3, 2, 1, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 11, 24, 57, 122, 225, 350, 457, 500, 457, 350, 225, 122, 57, 24, 11, 23, 58, 129, 241, 377, 494, 540, 494, 377, 241, 129, 58, 23, 26, 62, 133, 246, 384, 501, 548, 501, 384, 246, 133, 62, 26, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 2, 2, 4, 8, 13, 19, 25, 27, 25, 19, 13, 8, 4, 2, 2, 2, 7, 20, 54, 120, 224, 351, 460, 503, 460, 351, 224, 120, 54, 20, 7, 2, 2, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 2, 2, 4, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 7, 10, 16, 22, 27, 29, 27, 22, 16, 10, 7, 10, 23, 57, 124, 230, 359, 469, 513, 469, 359, 230, 124, 57, 23, 10, 2, 2, 3, 4, 8, 14, 21, 27, 29, 27, 21, 14, 8, 4, 3, 2, 2, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 7, 11, 17, 24, 29, 32, 29, 24, 17, 11, 7],
                    T: [3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 4, 4, 4, 5, 6, 8, 10, 13, 14, 13, 10, 8, 6, 5, 4, 4, 4, 2, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 2, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 1, 1, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 1, 23, 59, 131, 244, 382, 501, 548, 501, 382, 244, 131, 59, 23, 5, 10, 24, 59, 129, 239, 373, 488, 534, 488, 373, 239, 129, 59, 24, 10, 5, 6, 19, 50, 112, 210, 329, 431, 472, 431, 329, 210, 112, 50, 19, 6, 54, 118, 219, 342, 447, 488, 447, 342, 219, 118, 54, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 10, 23, 54, 115, 213, 331, 433, 473, 433, 331, 213, 115, 54, 23, 10, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 21, 54, 119, 223, 348, 456, 498, 456, 348, 223, 119, 54, 21, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 2, 3, 4, 6, 8, 11, 12, 11, 8, 6, 4, 3, 2, 23, 58, 129, 242, 378, 495, 541, 495, 378, 242, 129, 58, 23, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 5, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 5, 2, 6, 19, 51, 113, 212, 332, 435, 476, 435, 332, 212, 113, 51, 19, 6, 2, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 20, 53, 119, 222, 349, 456, 499, 456, 349, 222, 119, 53, 20, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 5, 6, 7, 9, 12, 15, 15, 15, 12, 9, 7, 6, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 57, 126, 235, 367, 481, 526, 481, 367, 235, 126, 57, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 58, 128, 237, 371, 485, 530, 485, 371, 237, 128, 58, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 5, 5, 6, 7, 9, 11, 14, 15, 14, 11, 9, 7, 6, 5, 5, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 4, 5, 7, 9, 12, 12, 12, 9, 7, 5, 4, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 23, 55, 119, 221, 345, 451, 493, 451, 345, 221, 119, 55, 23, 7, 22, 58, 130, 243, 381, 499, 546, 499, 381, 243, 130, 58, 22, 7, 61, 133, 245, 381, 498, 545, 498, 381, 245, 133, 61, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 50, 111, 207, 325, 426, 466, 426, 325, 207, 111, 50, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 56, 119, 220, 342, 447, 489, 447, 342, 220, 119, 56, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 4, 5, 6, 8, 11, 14, 14, 14, 11, 8, 6, 5, 4, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 7, 21, 53, 117, 219, 343, 449, 491, 449, 343, 219, 117, 53, 21, 7, 21, 55, 122, 228, 356, 466, 510, 466, 356, 228, 122, 55, 21, 2, 6, 18, 48, 108, 202, 316, 414, 452, 414, 316, 202, 108, 48, 18, 6, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 8, 23, 59, 132, 246, 385, 504, 551, 504, 385, 246, 132, 59, 23, 8, 3, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 6, 7, 9, 11, 13, 14, 13, 11, 9, 7, 6, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 3, 7, 21, 53, 117, 219, 343, 448, 491, 448, 343, 219, 117, 53, 21, 7, 3, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5],
                    peak: [5, 16, 29, 42, 54, 68, 84, 99, 112, 127, 142, 157, 173, 186, 198, 212, 227, 242, 258, 273, 286, 299, 312, 325, 338, 353, 369, 385, 402, 418, 433, 447, 461, 475, 489, 502, 514, 527, 539, 550, 562, 575, 589, 605, 622, 637, 649, 660, 671, 683, 697, 710, 722, 735, 750, 764, 777, 792, 808, 822, 834, 847, 861, 877, 891, 905, 921, 935, 948, 962, 976, 991, 1007, 1023, 1039, 1055, 1071, 1084, 1097, 1113, 1129, 1142]
                },
                index: 1,
                counter: 4,
                measureText: 74
            }, {
                id: "R1-0000-2345",
                fill: "rgb(255,255,102)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 31,
                gaps: [
                    [9, 1],
                    [58, 1]
                ],
                sequence: "ACGTACGTAGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGTTTACGTACGTAAACCCGGGTTTACGTAC",
                coordinate: 10,
                trace: {
                    A: [4, 9, 22, 56, 123, 228, 357, 467, 510, 467, 357, 228, 123, 56, 22, 9, 4, 5, 12, 25, 45, 70, 91, 100, 91, 70, 45, 25, 12, 5, 11, 24, 43, 67, 87, 95, 87, 67, 43, 24, 11, 3, 4, 7, 14, 27, 49, 76, 99, 108, 99, 76, 49, 27, 14, 7, 4, 3, 57, 125, 233, 364, 475, 520, 475, 364, 233, 125, 57, 16, 30, 51, 78, 101, 110, 101, 78, 51, 30, 16, 4, 6, 12, 25, 44, 68, 88, 96, 88, 68, 44, 25, 12, 6, 4, 6, 12, 26, 47, 73, 95, 104, 95, 73, 47, 26, 12, 6, 55, 117, 216, 337, 440, 481, 440, 337, 216, 117, 55, 5, 11, 24, 43, 67, 87, 95, 87, 67, 43, 24, 11, 5, 4, 5, 8, 14, 28, 50, 76, 98, 107, 98, 76, 50, 28, 14, 8, 5, 4, 22, 57, 127, 236, 370, 484, 529, 484, 370, 236, 127, 57, 22, 50, 111, 208, 325, 426, 466, 426, 325, 208, 111, 50, 24, 57, 122, 225, 350, 457, 500, 457, 350, 225, 122, 57, 24, 2, 4, 11, 24, 45, 70, 92, 100, 92, 70, 45, 24, 11, 4, 2, 1, 2, 5, 11, 25, 47, 73, 96, 105, 96, 73, 47, 25, 11, 5, 2, 1, 14, 28, 50, 76, 99, 108, 99, 76, 50, 28, 14, 8, 14, 28, 50, 76, 99, 108, 99, 76, 50, 28, 14, 8, 3, 5, 11, 23, 42, 65, 84, 92, 84, 65, 42, 23, 11, 5, 3, 7, 14, 28, 50, 76, 99, 108, 99, 76, 50, 28, 14, 7, 4, 6, 13, 26, 46, 70, 91, 100, 91, 70, 46, 26, 13, 6, 4, 2, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 2, 11, 23, 43, 67, 88, 96, 88, 67, 43, 23, 11, 24, 60, 131, 244, 381, 498, 544, 498, 381, 244, 131, 60, 24, 1, 2, 5, 12, 26, 49, 77, 101, 110, 101, 77, 49, 26, 12, 5, 2, 1, 6, 12, 26, 47, 73, 95, 104, 95, 73, 47, 26, 12, 6, 2, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 2, 53, 117, 217, 339, 443, 485, 443, 339, 217, 117, 53, 1, 2, 5, 12, 26, 49, 76, 100, 109, 100, 76, 49, 26, 12, 5, 2, 1, 5, 12, 26, 49, 76, 100, 109, 100, 76, 49, 26, 12, 5, 5, 8, 15, 28, 50, 77, 99, 108, 99, 77, 50, 28, 15, 8, 5, 51, 112, 207, 324, 423, 463, 423, 324, 207, 112, 51, 18, 48, 108, 203, 318, 416, 455, 416, 318, 203, 108, 48, 18, 10, 23, 53, 114, 209, 326, 426, 465, 426, 326, 209, 114, 53, 23, 10, 2, 4, 10, 22, 41, 64, 83, 91, 83, 64, 41, 22, 10, 4, 2, 1, 2, 5, 12, 27, 49, 77, 101, 110, 101, 77, 49, 27, 12, 5, 2, 1, 12, 24, 43, 67, 87, 95, 87, 67, 43, 24, 12, 8, 15, 29, 51, 78, 101, 110, 101, 78, 51, 29, 15, 8, 1, 2, 4, 11, 24, 44, 69, 90, 98, 90, 69, 44, 24, 11, 4, 2, 1, 15, 28, 50, 77, 100, 109, 100, 77, 50, 28, 15, 1, 2, 4, 11, 24, 44, 69, 90, 99, 90, 69, 44, 24, 11, 4, 2, 1, 4, 7, 14, 28, 51, 79, 102, 112, 102, 79, 51, 28, 14, 7, 4, 4, 7, 13, 27, 48, 74, 97, 105, 97, 74, 48, 27, 13, 7, 4, 4, 9, 24, 60, 131, 244, 381, 498, 545, 498, 381, 244, 131, 60, 24, 9, 4, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 15, 28, 50, 76, 99, 108, 99, 76, 50, 28, 15, 6, 9, 16, 30, 52, 79, 102, 111, 102, 79, 52, 30, 16, 9, 6, 6, 18, 48, 108, 202, 317, 415, 454, 415, 317, 202, 108, 48, 18, 6, 2, 3, 6, 13, 27, 49, 76, 99, 108, 99, 76, 49, 27, 13, 6, 3, 2, 9, 16, 30, 53, 81, 104, 114, 104, 81, 53, 30, 16, 9, 3, 6, 12, 26, 47, 73, 95, 104, 95, 73, 47, 26, 12, 6, 3, 2, 6, 19, 51, 115, 215, 336, 440, 482, 440, 336, 215, 115, 51, 19, 6, 2, 11, 25, 59, 128, 236, 368, 481, 526, 481, 368, 236, 128, 59, 25, 11, 8, 22, 55, 123, 229, 358, 469, 513, 469, 358, 229, 123, 55, 22, 8, 6, 13, 27, 49, 76, 98, 108, 98, 76, 49, 27, 13, 6, 5, 12, 26, 49, 76, 99, 108, 99, 76, 49, 26, 12, 5, 3, 6, 13, 27, 50, 77, 100, 110, 100, 77, 50, 27, 13, 6, 3, 12, 25, 45, 70, 91, 99, 91, 70, 45, 25, 12, 3, 5, 12, 25, 45, 69, 90, 99, 90, 69, 45, 25, 12, 5, 3, 12, 24, 44, 69, 90, 98, 90, 69, 44, 24, 12, 3, 4, 7, 13, 27, 49, 75, 97, 106, 97, 75, 49, 27, 13, 7, 4, 3, 5, 8, 14, 28, 50, 76, 99, 108, 99, 76, 50, 28, 14, 8, 5, 55, 122, 227, 356, 466, 509, 466, 356, 227, 122, 55, 3, 6, 12, 26, 48, 74, 97, 106, 97, 74, 48, 26, 12, 6, 3, 13, 27, 48, 73, 95, 104, 95, 73, 48, 27, 13, 3, 4, 7, 14, 27, 49, 76, 99, 108, 99, 76, 49, 27, 14, 7, 4, 3, 6, 11, 26, 61, 132, 243, 379, 495, 541, 495, 379, 243, 132, 61, 26, 11, 6, 14, 27, 46, 69, 89, 97, 89, 69, 46, 27, 14, 4, 11, 24, 45, 71, 93, 101, 93, 71, 45, 24, 11, 4, 2, 3, 6, 13, 27, 50, 77, 100, 110, 100, 77, 50, 27, 13, 6, 3, 2, 2, 7, 20, 53, 118, 222, 348, 456, 499, 456, 348, 222, 118, 53, 20, 7, 2, 3, 8, 22, 58, 128, 240, 375, 491, 537, 491, 375, 240, 128, 58, 22, 8, 3, 6, 18, 49, 109, 204, 320, 420, 459, 420, 320, 204, 109, 49, 18, 6, 4, 10, 22, 41, 64, 83, 91, 83, 64, 41, 22, 10, 4, 3, 6, 13, 28, 50, 78, 102, 111, 102, 78, 50, 28, 13, 6, 3, 5, 12, 25, 45, 70, 91, 100, 91, 70, 45, 25, 12, 5, 6, 8, 15, 28, 49, 74, 95, 103, 95, 74, 49, 28, 15, 8, 6, 12, 25, 45, 70, 91, 100, 91, 70, 45, 25, 12, 6, 13, 26, 48, 75, 97, 106, 97, 75, 48, 26, 13, 6, 5, 12, 26, 48, 75, 98, 107, 98, 75, 48, 26, 12, 5, 3, 4, 6, 12, 24, 43, 67, 86, 94, 86, 67, 43, 24, 12, 6, 4, 3, 9, 15, 29, 50, 76, 98, 107, 98, 76, 50, 29, 15, 9, 6, 11, 26, 61, 132, 243, 379, 495, 541, 495, 379, 243, 132, 61, 26, 11, 6, 2, 5, 12, 25, 47, 73, 96, 105, 96, 73, 47, 25, 12, 5, 2, 8, 15, 29, 52, 79, 103, 112, 103, 79, 52, 29, 15, 8, 3, 6, 12, 26, 47, 73, 95, 104, 95, 73, 47, 26, 12, 6, 3, 9, 22, 56, 122, 227, 354, 463, 506, 463, 354, 227, 122, 56, 22, 9, 4, 6, 13, 26, 46, 70, 91, 100, 91, 70, 46, 26, 13, 6, 4],
                    C: [3, 3, 5, 8, 15, 26, 40, 51, 56, 51, 40, 26, 15, 8, 5, 3, 3, 22, 57, 126, 234, 367, 480, 525, 480, 367, 234, 126, 57, 22, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 3, 4, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 4, 3, 3, 7, 13, 23, 34, 44, 48, 44, 34, 23, 13, 7, 52, 112, 206, 321, 419, 458, 419, 321, 206, 112, 52, 3, 4, 8, 14, 24, 37, 47, 52, 47, 37, 24, 14, 8, 4, 3, 3, 7, 14, 24, 37, 48, 52, 48, 37, 24, 14, 7, 3, 10, 17, 29, 42, 54, 58, 54, 42, 29, 17, 10, 3, 7, 13, 23, 35, 45, 49, 45, 35, 23, 13, 7, 3, 4, 4, 5, 9, 16, 26, 39, 50, 54, 50, 39, 26, 16, 9, 5, 4, 4, 4, 7, 14, 25, 38, 49, 53, 49, 38, 25, 14, 7, 4, 7, 14, 25, 39, 51, 55, 51, 39, 25, 14, 7, 7, 10, 17, 27, 41, 52, 56, 52, 41, 27, 17, 10, 7, 6, 19, 50, 112, 210, 329, 430, 471, 430, 329, 210, 112, 50, 19, 6, 2, 6, 18, 49, 109, 204, 320, 419, 459, 419, 320, 204, 109, 49, 18, 6, 2, 55, 121, 224, 351, 458, 501, 458, 351, 224, 121, 55, 5, 9, 15, 25, 37, 48, 52, 48, 37, 25, 15, 9, 5, 2, 3, 7, 13, 23, 36, 47, 51, 47, 36, 23, 13, 7, 3, 2, 4, 7, 13, 23, 34, 44, 48, 44, 34, 23, 13, 7, 4, 3, 5, 8, 15, 27, 41, 53, 57, 53, 41, 27, 15, 8, 5, 3, 1, 2, 6, 12, 23, 35, 46, 50, 46, 35, 23, 12, 6, 2, 1, 6, 12, 23, 35, 46, 50, 46, 35, 23, 12, 6, 4, 8, 14, 24, 37, 47, 51, 47, 37, 24, 14, 8, 4, 2, 7, 21, 55, 124, 232, 363, 475, 520, 475, 363, 232, 124, 55, 21, 7, 2, 4, 7, 14, 25, 38, 50, 54, 50, 38, 25, 14, 7, 4, 1, 2, 6, 12, 23, 35, 46, 51, 46, 35, 23, 12, 6, 2, 1, 7, 13, 23, 35, 45, 49, 45, 35, 23, 13, 7, 2, 7, 22, 57, 128, 239, 375, 491, 537, 491, 375, 239, 128, 57, 22, 7, 2, 3, 6, 13, 25, 38, 50, 55, 50, 38, 25, 13, 6, 3, 4, 5, 9, 15, 26, 38, 49, 53, 49, 38, 26, 15, 9, 5, 4, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 2, 6, 12, 22, 35, 45, 50, 45, 35, 22, 12, 6, 2, 5, 7, 10, 17, 29, 42, 54, 59, 54, 42, 29, 17, 10, 7, 5, 6, 19, 50, 111, 209, 327, 428, 469, 428, 327, 209, 111, 50, 19, 6, 2, 7, 21, 56, 126, 236, 370, 484, 530, 484, 370, 236, 126, 56, 21, 7, 2, 55, 120, 223, 349, 456, 499, 456, 349, 223, 120, 55, 5, 9, 15, 25, 38, 49, 53, 49, 38, 25, 15, 9, 5, 1, 1, 2, 5, 12, 22, 34, 44, 48, 44, 34, 22, 12, 5, 2, 1, 1, 9, 15, 25, 37, 47, 51, 47, 37, 25, 15, 9, 1, 1, 3, 6, 13, 25, 39, 51, 55, 51, 39, 25, 13, 6, 3, 1, 1, 3, 5, 8, 15, 27, 41, 53, 57, 53, 41, 27, 15, 8, 5, 3, 3, 4, 8, 14, 24, 37, 47, 52, 47, 37, 24, 14, 8, 4, 3, 3, 3, 4, 7, 14, 24, 35, 46, 50, 46, 35, 24, 14, 7, 4, 3, 3, 61, 131, 241, 376, 491, 537, 491, 376, 241, 131, 61, 9, 15, 25, 38, 48, 52, 48, 38, 25, 15, 9, 5, 7, 10, 17, 28, 41, 53, 58, 53, 41, 28, 17, 10, 7, 5, 1, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 1, 3, 7, 20, 50, 112, 208, 326, 426, 466, 426, 326, 208, 112, 50, 20, 7, 3, 7, 10, 17, 29, 42, 54, 59, 54, 42, 29, 17, 10, 7, 2, 3, 7, 13, 23, 35, 45, 49, 45, 35, 23, 13, 7, 3, 2, 1, 1, 3, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 3, 1, 1, 5, 6, 9, 16, 25, 37, 47, 51, 47, 37, 25, 16, 9, 6, 5, 2, 3, 7, 13, 24, 36, 47, 52, 47, 36, 24, 13, 7, 3, 2, 23, 59, 130, 243, 380, 498, 544, 498, 380, 243, 130, 59, 23, 22, 58, 131, 245, 384, 503, 550, 503, 384, 245, 131, 58, 22, 7, 20, 52, 114, 213, 333, 435, 476, 435, 333, 213, 114, 52, 20, 7, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 2, 4, 7, 14, 25, 38, 49, 53, 49, 38, 25, 14, 7, 4, 2, 7, 14, 25, 39, 50, 55, 50, 39, 25, 14, 7, 3, 3, 4, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 4, 3, 3, 4, 5, 9, 15, 26, 38, 49, 53, 49, 38, 26, 15, 9, 5, 4, 7, 14, 26, 39, 51, 56, 51, 39, 26, 14, 7, 7, 19, 49, 108, 202, 316, 413, 452, 413, 316, 202, 108, 49, 19, 7, 8, 15, 25, 38, 49, 53, 49, 38, 25, 15, 8, 3, 3, 5, 8, 15, 26, 40, 52, 56, 52, 40, 26, 15, 8, 5, 3, 3, 5, 5, 6, 10, 16, 26, 38, 49, 53, 49, 38, 26, 16, 10, 6, 5, 5, 58, 124, 229, 356, 465, 509, 465, 356, 229, 124, 58, 3, 6, 13, 25, 38, 50, 55, 50, 38, 25, 13, 6, 3, 2, 2, 4, 7, 14, 24, 37, 48, 53, 48, 37, 24, 14, 7, 4, 2, 2, 1, 1, 3, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 3, 1, 1, 2, 2, 3, 7, 13, 24, 36, 47, 51, 47, 36, 24, 13, 7, 3, 2, 2, 1, 2, 5, 11, 21, 33, 43, 47, 43, 33, 21, 11, 5, 2, 1, 21, 55, 123, 231, 361, 473, 518, 473, 361, 231, 123, 55, 21, 7, 19, 50, 109, 204, 319, 418, 457, 418, 319, 204, 109, 50, 19, 7, 22, 57, 125, 234, 366, 479, 524, 479, 366, 234, 125, 57, 22, 5, 7, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 7, 5, 6, 13, 22, 34, 45, 49, 45, 34, 22, 13, 6, 3, 7, 13, 23, 35, 46, 50, 46, 35, 23, 13, 7, 3, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 3, 3, 4, 8, 14, 24, 37, 47, 51, 47, 37, 24, 14, 8, 4, 3, 3, 6, 9, 15, 25, 37, 46, 50, 46, 37, 25, 15, 9, 6, 5, 5, 6, 9, 15, 25, 37, 47, 51, 47, 37, 25, 15, 9, 6, 5, 5, 6, 18, 49, 109, 204, 320, 419, 458, 419, 320, 204, 109, 49, 18, 6, 5, 8, 15, 24, 36, 47, 51, 47, 36, 24, 15, 8, 5, 2, 3, 7, 13, 24, 37, 48, 52, 48, 37, 24, 13, 7, 3, 2, 3, 4, 8, 14, 24, 37, 47, 51, 47, 37, 24, 14, 8, 4, 3, 8, 22, 54, 119, 222, 346, 453, 495, 453, 346, 222, 119, 54, 22, 8],
                    G: [3, 3, 4, 5, 9, 14, 20, 26, 28, 26, 20, 14, 9, 5, 4, 3, 3, 3, 4, 8, 13, 20, 25, 28, 25, 20, 13, 8, 4, 3, 58, 129, 241, 378, 494, 541, 494, 378, 241, 129, 58, 3, 3, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 3, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 8, 22, 54, 118, 219, 342, 447, 489, 447, 342, 219, 118, 54, 22, 8, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 19, 50, 110, 205, 321, 420, 459, 420, 321, 205, 110, 50, 19, 4, 4, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 4, 2, 4, 7, 12, 18, 24, 26, 24, 18, 12, 7, 4, 2, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 5, 7, 10, 15, 21, 27, 29, 27, 21, 15, 10, 7, 5, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 1, 5, 9, 15, 22, 27, 30, 27, 22, 15, 9, 5, 21, 51, 110, 204, 318, 416, 454, 416, 318, 204, 110, 51, 21, 8, 22, 58, 128, 239, 374, 489, 535, 489, 374, 239, 128, 58, 22, 8, 22, 55, 122, 226, 353, 462, 505, 462, 353, 226, 122, 55, 22, 3, 4, 5, 9, 15, 22, 27, 30, 27, 22, 15, 9, 5, 4, 3, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 4, 5, 9, 15, 22, 28, 30, 28, 22, 15, 9, 5, 4, 1, 1, 2, 3, 7, 13, 20, 26, 28, 26, 20, 13, 7, 3, 2, 1, 1, 21, 54, 120, 224, 350, 458, 501, 458, 350, 224, 120, 54, 21, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 21, 55, 124, 232, 364, 476, 521, 476, 364, 232, 124, 55, 21, 4, 4, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 4, 4, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 1, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 1, 5, 5, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 5, 5, 1, 1, 3, 6, 12, 18, 24, 26, 24, 18, 12, 6, 3, 1, 1, 1, 1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 1, 1, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 24, 57, 125, 231, 361, 472, 516, 472, 361, 231, 125, 57, 24, 2, 6, 19, 49, 110, 207, 324, 424, 464, 424, 324, 207, 110, 49, 19, 6, 2, 57, 124, 229, 358, 467, 511, 467, 358, 229, 124, 57, 1, 1, 2, 3, 7, 13, 19, 25, 28, 25, 19, 13, 7, 3, 2, 1, 1, 3, 4, 5, 9, 14, 20, 26, 28, 26, 20, 14, 9, 5, 4, 3, 3, 3, 5, 8, 13, 18, 23, 25, 23, 18, 13, 8, 5, 3, 3, 3, 3, 3, 5, 8, 13, 18, 23, 25, 23, 18, 13, 8, 5, 3, 3, 3, 7, 11, 17, 23, 29, 32, 29, 23, 17, 11, 7, 55, 120, 223, 347, 454, 496, 454, 347, 223, 120, 55, 5, 5, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 5, 5, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 2, 2, 2, 4, 7, 13, 19, 25, 27, 25, 19, 13, 7, 4, 2, 2, 2, 24, 58, 125, 230, 359, 469, 512, 469, 359, 230, 125, 58, 24, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 1, 1, 1, 3, 6, 11, 17, 23, 25, 23, 17, 11, 6, 3, 1, 1, 1, 5, 5, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 5, 5, 2, 2, 4, 8, 13, 19, 25, 27, 25, 19, 13, 8, 4, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 1, 3, 6, 12, 18, 23, 25, 23, 18, 12, 6, 3, 1, 2, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 2, 53, 118, 221, 346, 452, 495, 452, 346, 221, 118, 53, 8, 22, 55, 123, 229, 359, 470, 514, 470, 359, 229, 123, 55, 22, 8, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 3, 4, 5, 9, 15, 22, 28, 30, 28, 22, 15, 9, 5, 4, 3, 3, 4, 5, 6, 10, 15, 22, 28, 30, 28, 22, 15, 10, 6, 5, 4, 4, 8, 13, 20, 25, 28, 25, 20, 13, 8, 4, 2, 2, 4, 7, 13, 19, 24, 27, 24, 19, 13, 7, 4, 2, 2, 56, 123, 229, 358, 469, 513, 469, 358, 229, 123, 56, 3, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3, 3, 5, 5, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 5, 5, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 19, 49, 109, 205, 321, 421, 460, 421, 321, 205, 109, 49, 19, 2, 2, 3, 4, 8, 14, 20, 26, 29, 26, 20, 14, 8, 4, 3, 2, 2, 1, 1, 2, 3, 7, 13, 20, 26, 28, 26, 20, 13, 7, 3, 2, 1, 1, 2, 2, 3, 4, 8, 14, 21, 26, 29, 26, 21, 14, 8, 4, 3, 2, 2, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 2, 2, 4, 7, 13, 19, 24, 26, 24, 19, 13, 7, 4, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 11, 24, 58, 124, 228, 355, 464, 508, 464, 355, 228, 124, 58, 24, 11, 59, 131, 244, 382, 500, 547, 500, 382, 244, 131, 59, 21, 55, 121, 226, 354, 463, 507, 463, 354, 226, 121, 55, 21, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 3, 3, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 3, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 5, 5, 5, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 5, 5, 5, 1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 1, 22, 53, 114, 211, 329, 431, 471, 431, 329, 211, 114, 53, 22, 2, 2, 4, 7, 13, 19, 25, 27, 25, 19, 13, 7, 4, 2, 2, 3, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3],
                    T: [3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 4, 9, 22, 56, 122, 226, 353, 462, 506, 462, 353, 226, 122, 56, 22, 9, 4, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 3, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 3, 22, 58, 128, 238, 373, 488, 534, 488, 373, 238, 128, 58, 22, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 5, 10, 23, 56, 121, 223, 348, 455, 498, 455, 348, 223, 121, 56, 23, 10, 5, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 8, 21, 52, 115, 213, 332, 435, 475, 435, 332, 213, 115, 52, 21, 8, 7, 21, 56, 125, 235, 367, 481, 527, 481, 367, 235, 125, 56, 21, 7, 56, 125, 234, 366, 480, 525, 480, 366, 234, 125, 56, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 2, 3, 4, 6, 9, 12, 12, 12, 9, 6, 4, 3, 2, 6, 19, 51, 114, 214, 336, 440, 481, 440, 336, 214, 114, 51, 19, 6, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 1, 1, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 9, 23, 55, 120, 223, 347, 454, 496, 454, 347, 223, 120, 55, 23, 9, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 5, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 5, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 1, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 1, 4, 5, 7, 10, 13, 13, 13, 10, 7, 5, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 1, 1, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 1, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 2, 7, 21, 57, 126, 237, 371, 486, 532, 486, 371, 237, 126, 57, 21, 7, 2, 8, 21, 52, 115, 213, 333, 436, 477, 436, 333, 213, 115, 52, 21, 8, 9, 23, 59, 129, 240, 375, 490, 536, 490, 375, 240, 129, 59, 23, 9, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 10, 23, 55, 118, 217, 337, 440, 482, 440, 337, 217, 118, 55, 23, 10, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 7, 20, 52, 115, 215, 336, 439, 480, 439, 336, 215, 115, 52, 20, 7, 1, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 51, 113, 211, 330, 432, 472, 432, 330, 211, 113, 51, 4, 9, 22, 55, 122, 226, 353, 462, 505, 462, 353, 226, 122, 55, 22, 9, 4, 10, 23, 56, 121, 225, 351, 459, 501, 459, 351, 225, 121, 56, 23, 10, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 4, 8, 21, 54, 117, 218, 341, 446, 488, 446, 341, 218, 117, 54, 21, 8, 4, 5, 5, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 5, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 3, 8, 22, 56, 124, 231, 361, 473, 517, 473, 361, 231, 124, 56, 22, 8, 3, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 5, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 5, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 21, 55, 124, 232, 364, 477, 522, 477, 364, 232, 124, 55, 21, 4, 9, 22, 55, 121, 226, 353, 461, 505, 461, 353, 226, 121, 55, 22, 9, 4, 25, 60, 128, 237, 369, 482, 527, 482, 369, 237, 128, 60, 25, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 8, 21, 55, 121, 225, 353, 462, 505, 462, 353, 225, 121, 55, 21, 8, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3],
                    peak: [8, 23, 35, 49, 63, 74, 87, 101, 113, 125, 140, 155, 167, 179, 193, 209, 223, 235, 249, 263, 277, 292, 305, 317, 332, 347, 361, 374, 388, 403, 417, 430, 442, 456, 471, 487, 501, 513, 528, 542, 556, 572, 587, 603, 617, 628, 641, 656, 672, 687, 701, 717, 733, 748, 762, 775, 789, 802, 815, 828, 842, 858, 871, 884, 897, 911, 928, 942, 954, 969, 986, 1003, 1019, 1033, 1047, 1061, 1075, 1088, 1100, 1113, 1128, 1143, 1158, 1174, 1188, 1202, 1217, 1232]
                },
                index: 2,
                counter: 5,
                measureText: 74
            }, {
                id: "R1-0000-3456",
                fill: "rgb(255,51,255)",
                outline: "rgb(0,0,0)",
                dir: "left",
                offsetLeft: "134",
                sequence: "AAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAAC",
                coordinate: 230,
                trace: {
                    A: [6, 18, 49, 109, 203, 319, 417, 457, 417, 319, 203, 109, 49, 18, 6, 2, 6, 19, 50, 112, 210, 330, 432, 472, 432, 330, 210, 112, 50, 19, 6, 2, 5, 10, 23, 57, 124, 230, 359, 469, 513, 469, 359, 230, 124, 57, 23, 10, 5, 13, 27, 48, 74, 96, 105, 96, 74, 48, 27, 13, 5, 11, 23, 42, 65, 85, 93, 85, 65, 42, 23, 11, 5, 2, 4, 11, 24, 45, 70, 91, 100, 91, 70, 45, 24, 11, 4, 2, 11, 24, 44, 69, 90, 98, 90, 69, 44, 24, 11, 6, 13, 28, 50, 78, 102, 111, 102, 78, 50, 28, 13, 6, 12, 26, 49, 76, 100, 109, 100, 76, 49, 26, 12, 2, 4, 11, 24, 45, 70, 91, 100, 91, 70, 45, 24, 11, 4, 2, 2, 4, 10, 23, 42, 66, 86, 94, 86, 66, 42, 23, 10, 4, 2, 1, 2, 4, 11, 24, 46, 71, 93, 102, 93, 71, 46, 24, 11, 4, 2, 1, 3, 8, 21, 55, 122, 228, 357, 468, 512, 468, 357, 228, 122, 55, 21, 8, 3, 15, 28, 49, 75, 96, 105, 96, 75, 49, 28, 15, 1, 2, 5, 11, 25, 46, 72, 95, 104, 95, 72, 46, 25, 11, 5, 2, 1, 6, 13, 26, 48, 75, 98, 107, 98, 75, 48, 26, 13, 6, 7, 22, 58, 130, 243, 381, 499, 546, 499, 381, 243, 130, 58, 22, 7, 4, 6, 12, 24, 43, 65, 85, 93, 85, 65, 43, 24, 12, 6, 4, 5, 12, 26, 48, 75, 98, 107, 98, 75, 48, 26, 12, 5, 2, 4, 11, 24, 44, 68, 89, 98, 89, 68, 44, 24, 11, 4, 2, 24, 58, 125, 230, 358, 468, 512, 468, 358, 230, 125, 58, 24, 50, 109, 203, 317, 414, 453, 414, 317, 203, 109, 50, 8, 22, 54, 119, 220, 344, 450, 492, 450, 344, 220, 119, 54, 22, 8, 4, 10, 23, 42, 65, 86, 94, 86, 65, 42, 23, 10, 4, 5, 12, 26, 48, 75, 99, 108, 99, 75, 48, 26, 12, 5, 9, 16, 29, 51, 78, 100, 109, 100, 78, 51, 29, 16, 9, 3, 4, 6, 13, 25, 45, 69, 90, 98, 90, 69, 45, 25, 13, 6, 4, 3, 1, 2, 5, 12, 26, 48, 74, 97, 106, 97, 74, 48, 26, 12, 5, 2, 1, 3, 5, 11, 23, 42, 65, 84, 92, 84, 65, 42, 23, 11, 5, 3, 4, 5, 7, 14, 27, 48, 73, 95, 103, 95, 73, 48, 27, 14, 7, 5, 4, 15, 28, 49, 74, 95, 104, 95, 74, 49, 28, 15, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 5, 9, 22, 54, 116, 215, 336, 439, 480, 439, 336, 215, 116, 54, 22, 9, 5, 11, 24, 45, 70, 91, 99, 91, 70, 45, 24, 11, 7, 14, 27, 48, 73, 95, 103, 95, 73, 48, 27, 14, 7, 2, 3, 5, 12, 25, 45, 70, 91, 100, 91, 70, 45, 25, 12, 5, 3, 2, 23, 59, 132, 246, 385, 504, 551, 504, 385, 246, 132, 59, 23, 11, 23, 43, 66, 86, 94, 86, 66, 43, 23, 11, 7, 14, 27, 49, 76, 99, 108, 99, 76, 49, 27, 14, 7, 1, 2, 5, 12, 26, 49, 76, 100, 109, 100, 76, 49, 26, 12, 5, 2, 1, 50, 113, 211, 331, 433, 474, 433, 331, 211, 113, 50, 2, 7, 20, 54, 120, 225, 352, 461, 505, 461, 352, 225, 120, 54, 20, 7, 2, 7, 21, 56, 125, 234, 366, 480, 525, 480, 366, 234, 125, 56, 21, 7, 9, 15, 29, 50, 76, 99, 108, 99, 76, 50, 29, 15, 9, 16, 30, 52, 79, 103, 112, 103, 79, 52, 30, 16, 13, 25, 44, 67, 87, 95, 87, 67, 44, 25, 13, 7, 14, 28, 51, 78, 102, 111, 102, 78, 51, 28, 14, 7, 2, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 2, 2, 4, 11, 23, 43, 67, 88, 96, 88, 67, 43, 23, 11, 4, 2, 5, 7, 13, 25, 45, 68, 88, 96, 88, 68, 45, 25, 13, 7, 5, 4, 5, 8, 15, 28, 50, 76, 99, 108, 99, 76, 50, 28, 15, 8, 5, 4, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 7, 21, 56, 125, 235, 368, 482, 528, 482, 368, 235, 125, 56, 21, 7, 6, 12, 25, 44, 68, 88, 96, 88, 68, 44, 25, 12, 6, 2, 3, 5, 11, 23, 42, 66, 85, 93, 85, 66, 42, 23, 11, 5, 3, 2, 2, 4, 10, 22, 41, 65, 85, 93, 85, 65, 41, 22, 10, 4, 2, 4, 8, 22, 54, 118, 220, 343, 448, 490, 448, 343, 220, 118, 54, 22, 8, 4, 13, 26, 45, 69, 90, 98, 90, 69, 45, 26, 13, 4, 5, 8, 15, 30, 52, 80, 104, 113, 104, 80, 52, 30, 15, 8, 5, 4, 2, 3, 6, 13, 27, 49, 76, 99, 108, 99, 76, 49, 27, 13, 6, 3, 2, 9, 23, 55, 120, 222, 347, 453, 496, 453, 347, 222, 120, 55, 23, 9, 60, 131, 243, 380, 496, 543, 496, 380, 243, 131, 60, 11, 26, 61, 132, 244, 380, 496, 542, 496, 380, 244, 132, 61, 26, 11, 2, 4, 11, 24, 44, 69, 90, 98, 90, 69, 44, 24, 11, 4, 2, 4, 11, 24, 45, 70, 91, 100, 91, 70, 45, 24, 11, 4, 8, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 8, 12, 26, 47, 74, 96, 105, 96, 74, 47, 26, 12, 5, 6, 9, 15, 29, 51, 77, 99, 108, 99, 77, 51, 29, 15, 9, 6, 5, 3, 5, 11, 23, 42, 66, 86, 94, 86, 66, 42, 23, 11, 5, 3, 4, 5, 7, 14, 26, 47, 71, 92, 100, 92, 71, 47, 26, 14, 7, 5, 4, 5, 8, 15, 29, 52, 79, 102, 112, 102, 79, 52, 29, 15, 8, 5, 5, 6, 9, 16, 30, 53, 80, 104, 113, 104, 80, 53, 30, 16, 9, 6, 5, 20, 50, 110, 204, 318, 416, 455, 416, 318, 204, 110, 50, 20, 11, 25, 46, 72, 94, 103, 94, 72, 46, 25, 11, 3, 4, 6, 13, 26, 46, 71, 93, 101, 93, 71, 46, 26, 13, 6, 4, 3, 13, 27, 50, 77, 101, 110, 101, 77, 50, 27, 13, 60, 132, 245, 383, 501, 548, 501, 383, 245, 132, 60, 13, 27, 50, 77, 101, 110, 101, 77, 50, 27, 13, 10, 23, 42, 66, 86, 95, 86, 66, 42, 23, 10, 4, 6, 12, 25, 44, 67, 87, 95, 87, 67, 44, 25, 12, 6, 4, 58, 129, 242, 380, 498, 544, 498, 380, 242, 129, 58, 6, 18, 49, 109, 204, 320, 419, 458, 419, 320, 204, 109, 49, 18, 6, 23, 57, 125, 232, 362, 474, 518, 474, 362, 232, 125, 57, 23, 4, 5, 8, 15, 29, 52, 80, 103, 112, 103, 80, 52, 29, 15, 8, 5, 4],
                    C: [1, 3, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 3, 1, 1, 1, 2, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 2, 1, 1, 4, 4, 5, 8, 15, 24, 36, 46, 50, 46, 36, 24, 15, 8, 5, 4, 4, 60, 132, 246, 385, 504, 551, 504, 385, 246, 132, 60, 19, 50, 110, 206, 322, 421, 460, 421, 322, 206, 110, 50, 19, 7, 21, 56, 124, 233, 365, 478, 523, 478, 365, 233, 124, 56, 21, 7, 6, 13, 25, 38, 50, 55, 50, 38, 25, 13, 6, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 6, 13, 23, 36, 47, 52, 47, 36, 23, 13, 6, 1, 2, 5, 11, 21, 33, 43, 47, 43, 33, 21, 11, 5, 2, 1, 1, 2, 5, 11, 21, 33, 42, 46, 42, 33, 21, 11, 5, 2, 1, 1, 1, 3, 6, 13, 24, 38, 50, 54, 50, 38, 24, 13, 6, 3, 1, 1, 2, 2, 4, 7, 14, 25, 38, 50, 54, 50, 38, 25, 14, 7, 4, 2, 2, 56, 120, 221, 344, 449, 491, 449, 344, 221, 120, 56, 1, 1, 3, 6, 13, 24, 37, 48, 52, 48, 37, 24, 13, 6, 3, 1, 1, 4, 7, 14, 26, 39, 51, 56, 51, 39, 26, 14, 7, 4, 1, 2, 6, 12, 22, 35, 45, 50, 45, 35, 22, 12, 6, 2, 1, 8, 21, 53, 116, 216, 337, 441, 482, 441, 337, 216, 116, 53, 21, 8, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 1, 3, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 3, 1, 6, 10, 16, 26, 38, 48, 53, 48, 38, 26, 16, 10, 6, 8, 15, 26, 39, 50, 55, 50, 39, 26, 15, 8, 3, 4, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 4, 3, 20, 53, 119, 224, 350, 459, 502, 459, 350, 224, 119, 53, 20, 19, 50, 112, 211, 330, 432, 473, 432, 330, 211, 112, 50, 19, 23, 55, 118, 218, 340, 444, 485, 444, 340, 218, 118, 55, 23, 3, 3, 5, 8, 15, 26, 40, 51, 56, 51, 40, 26, 15, 8, 5, 3, 3, 1, 1, 3, 6, 13, 24, 37, 48, 52, 48, 37, 24, 13, 6, 3, 1, 1, 2, 3, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 3, 2, 4, 4, 5, 8, 14, 24, 36, 45, 49, 45, 36, 24, 14, 8, 5, 4, 4, 10, 17, 29, 43, 55, 59, 55, 43, 29, 17, 10, 10, 17, 28, 42, 53, 58, 53, 42, 28, 17, 10, 4, 4, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 4, 4, 54, 121, 226, 354, 464, 508, 464, 354, 226, 121, 54, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 2, 2, 3, 7, 13, 23, 36, 47, 51, 47, 36, 23, 13, 7, 3, 2, 2, 4, 7, 14, 25, 39, 51, 55, 51, 39, 25, 14, 7, 4, 51, 113, 210, 329, 430, 471, 430, 329, 210, 113, 51, 4, 8, 14, 24, 37, 47, 51, 47, 37, 24, 14, 8, 4, 1, 1, 2, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 2, 1, 1, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 1, 1, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 1, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 22, 52, 112, 206, 321, 419, 458, 419, 321, 206, 112, 52, 22, 55, 117, 216, 337, 440, 481, 440, 337, 216, 117, 55, 53, 115, 212, 331, 432, 472, 432, 331, 212, 115, 53, 5, 8, 15, 26, 39, 51, 55, 51, 39, 26, 15, 8, 5, 1, 2, 6, 12, 22, 35, 46, 50, 46, 35, 22, 12, 6, 2, 1, 1, 2, 5, 11, 21, 32, 42, 46, 42, 32, 21, 11, 5, 2, 1, 4, 6, 9, 16, 28, 41, 53, 58, 53, 41, 28, 16, 9, 6, 4, 4, 4, 5, 9, 16, 26, 39, 50, 54, 50, 39, 26, 16, 9, 5, 4, 4, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 1, 2, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 2, 1, 23, 57, 125, 233, 364, 476, 521, 476, 364, 233, 125, 57, 23, 2, 2, 3, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 3, 2, 2, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 3, 3, 5, 8, 15, 27, 41, 52, 57, 52, 41, 27, 15, 8, 5, 3, 3, 54, 116, 215, 335, 437, 478, 437, 335, 215, 116, 54, 4, 4, 6, 9, 16, 26, 39, 50, 55, 50, 39, 26, 16, 9, 6, 4, 4, 2, 2, 4, 7, 14, 24, 37, 49, 53, 49, 37, 24, 14, 7, 4, 2, 2, 4, 6, 9, 16, 26, 39, 51, 55, 51, 39, 26, 16, 9, 6, 4, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 6, 9, 16, 25, 37, 47, 51, 47, 37, 25, 16, 9, 6, 5, 7, 22, 57, 128, 239, 375, 491, 537, 491, 375, 239, 128, 57, 22, 7, 22, 58, 130, 244, 383, 501, 548, 501, 383, 244, 130, 58, 22, 22, 53, 113, 208, 324, 423, 463, 423, 324, 208, 113, 53, 22, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 5, 5, 7, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 7, 5, 5, 2, 4, 7, 14, 26, 40, 52, 56, 52, 40, 26, 14, 7, 4, 2, 4, 4, 5, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 4, 4, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4, 5, 5, 6, 9, 16, 25, 37, 48, 52, 48, 37, 25, 16, 9, 6, 5, 5, 4, 7, 14, 24, 35, 46, 50, 46, 35, 24, 14, 7, 4, 51, 113, 212, 332, 435, 476, 435, 332, 212, 113, 51, 3, 3, 5, 8, 15, 26, 39, 50, 55, 50, 39, 26, 15, 8, 5, 3, 3, 6, 12, 22, 34, 43, 47, 43, 34, 22, 12, 6, 8, 14, 24, 37, 47, 52, 47, 37, 24, 14, 8, 56, 123, 230, 360, 471, 515, 471, 360, 230, 123, 56, 6, 13, 23, 36, 47, 52, 47, 36, 23, 13, 6, 3, 5, 8, 15, 26, 39, 51, 55, 51, 39, 26, 15, 8, 5, 3, 5, 11, 21, 33, 43, 46, 43, 33, 21, 11, 5, 1, 2, 6, 12, 23, 36, 47, 51, 47, 36, 23, 12, 6, 2, 1, 4, 7, 13, 23, 34, 44, 48, 44, 34, 23, 13, 7, 4, 5, 10, 23, 57, 123, 228, 355, 465, 508, 465, 355, 228, 123, 57, 23, 10, 5],
                    G: [1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 1, 1, 1, 1, 3, 6, 11, 17, 22, 25, 22, 17, 11, 6, 3, 1, 1, 1, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 5, 8, 14, 20, 26, 28, 26, 20, 14, 8, 5, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 1, 1, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 1, 1, 58, 129, 242, 379, 497, 543, 497, 379, 242, 129, 58, 21, 55, 122, 228, 356, 466, 510, 466, 356, 228, 122, 55, 21, 51, 114, 214, 335, 438, 480, 438, 335, 214, 114, 51, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 1, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 1, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 2, 6, 18, 49, 109, 204, 319, 418, 457, 418, 319, 204, 109, 49, 18, 6, 2, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 1, 3, 3, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 3, 3, 20, 53, 118, 222, 348, 456, 498, 456, 348, 222, 118, 53, 20, 1, 2, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 2, 1, 6, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 6, 5, 8, 13, 19, 24, 25, 24, 19, 13, 8, 5, 3, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 3, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 6, 7, 11, 16, 23, 28, 31, 28, 23, 16, 11, 7, 6, 4, 9, 24, 59, 130, 242, 378, 494, 540, 494, 378, 242, 130, 59, 24, 9, 4, 2, 7, 22, 58, 130, 244, 382, 500, 547, 500, 382, 244, 130, 58, 22, 7, 2, 7, 20, 51, 113, 210, 329, 431, 471, 431, 329, 210, 113, 51, 20, 7, 4, 4, 4, 6, 9, 15, 21, 26, 29, 26, 21, 15, 9, 6, 4, 4, 4, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 4, 4, 4, 6, 9, 14, 20, 26, 28, 26, 20, 14, 9, 6, 4, 4, 4, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 25, 61, 134, 248, 387, 506, 553, 506, 387, 248, 134, 61, 25, 2, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 2, 2, 4, 7, 12, 18, 24, 26, 24, 18, 12, 7, 4, 2, 4, 7, 12, 18, 23, 26, 23, 18, 12, 7, 4, 24, 60, 132, 246, 384, 502, 549, 502, 384, 246, 132, 60, 24, 1, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 1, 3, 6, 12, 18, 23, 26, 23, 18, 12, 6, 3, 1, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 1, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 6, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 6, 7, 11, 17, 23, 29, 31, 29, 23, 17, 11, 7, 6, 9, 15, 21, 27, 29, 27, 21, 15, 9, 6, 21, 52, 114, 211, 330, 431, 471, 431, 330, 211, 114, 52, 21, 6, 18, 49, 109, 205, 321, 420, 459, 420, 321, 205, 109, 49, 18, 6, 7, 21, 55, 124, 232, 363, 476, 521, 476, 363, 232, 124, 55, 21, 7, 4, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 4, 4, 4, 4, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 4, 4, 4, 7, 10, 16, 22, 27, 29, 27, 22, 16, 10, 7, 1, 2, 3, 7, 13, 19, 25, 28, 25, 19, 13, 7, 3, 2, 1, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 3, 7, 20, 52, 114, 213, 333, 436, 477, 436, 333, 213, 114, 52, 20, 7, 3, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 3, 3, 4, 5, 9, 14, 21, 26, 28, 26, 21, 14, 9, 5, 4, 3, 3, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 5, 10, 24, 58, 126, 234, 365, 477, 521, 477, 365, 234, 126, 58, 24, 10, 5, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 4, 4, 6, 9, 15, 21, 26, 28, 26, 21, 15, 9, 6, 4, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 5, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 5, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 1, 3, 6, 12, 18, 23, 26, 23, 18, 12, 6, 3, 1, 5, 7, 10, 16, 22, 27, 29, 27, 22, 16, 10, 7, 5, 56, 124, 232, 364, 476, 521, 476, 364, 232, 124, 56, 6, 11, 25, 60, 129, 239, 372, 486, 531, 486, 372, 239, 129, 60, 25, 11, 6, 8, 22, 56, 123, 230, 360, 471, 515, 471, 360, 230, 123, 56, 22, 8, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 5, 5, 5, 7, 10, 15, 22, 27, 29, 27, 22, 15, 10, 7, 5, 5, 5, 3, 5, 8, 13, 19, 24, 27, 24, 19, 13, 8, 5, 3, 3, 6, 11, 17, 23, 25, 23, 17, 11, 6, 3, 4, 8, 21, 52, 114, 212, 331, 433, 474, 433, 331, 212, 114, 52, 21, 8, 4, 4, 7, 13, 19, 25, 27, 25, 19, 13, 7, 4, 5, 9, 14, 20, 26, 28, 26, 20, 14, 9, 5, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 56, 126, 236, 370, 485, 530, 485, 370, 236, 126, 56, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 1, 1, 3, 6, 12, 18, 23, 26, 23, 18, 12, 6, 3, 1, 1, 4, 5, 9, 15, 22, 27, 30, 27, 22, 15, 9, 5, 4, 4, 4, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 4],
                    T: [1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 4, 4, 4, 5, 6, 8, 10, 13, 14, 13, 10, 8, 6, 5, 4, 4, 4, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 6, 19, 51, 114, 213, 334, 438, 479, 438, 334, 213, 114, 51, 19, 6, 6, 19, 51, 115, 215, 336, 440, 482, 440, 336, 215, 115, 51, 19, 6, 2, 6, 19, 51, 115, 215, 337, 441, 482, 441, 337, 215, 115, 51, 19, 6, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 1, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 21, 54, 120, 224, 351, 459, 503, 459, 351, 224, 120, 54, 21, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 3, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 3, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 6, 19, 50, 111, 209, 327, 429, 469, 429, 327, 209, 111, 50, 19, 6, 5, 6, 7, 9, 12, 15, 15, 15, 12, 9, 7, 6, 5, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 1, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 2, 2, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 2, 2, 5, 9, 22, 52, 113, 210, 327, 427, 467, 427, 327, 210, 113, 52, 22, 9, 5, 57, 123, 227, 354, 462, 505, 462, 354, 227, 123, 57, 58, 125, 230, 359, 469, 512, 469, 359, 230, 125, 58, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 3, 7, 20, 52, 114, 213, 333, 436, 477, 436, 333, 213, 114, 52, 20, 7, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 2, 7, 21, 56, 125, 235, 368, 482, 527, 482, 368, 235, 125, 56, 21, 7, 2, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 3, 4, 5, 7, 10, 13, 13, 13, 10, 7, 5, 4, 3, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 9, 22, 53, 115, 214, 333, 435, 476, 435, 333, 214, 115, 53, 22, 9, 5, 10, 24, 59, 128, 238, 371, 485, 531, 485, 371, 238, 128, 59, 24, 10, 5, 56, 120, 221, 344, 450, 492, 450, 344, 221, 120, 56, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 7, 21, 55, 122, 229, 359, 470, 514, 470, 359, 229, 122, 55, 21, 7, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 3, 8, 22, 56, 125, 232, 364, 476, 521, 476, 364, 232, 125, 56, 22, 8, 3, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 5, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 5, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 2, 3, 5, 7, 10, 11, 10, 7, 5, 3, 2, 1, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 5, 5, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 5, 5, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 5, 9, 21, 52, 112, 207, 323, 422, 461, 422, 323, 207, 112, 52, 21, 9, 5, 9, 22, 54, 118, 218, 340, 445, 486, 445, 340, 218, 118, 54, 22, 9, 6, 10, 23, 53, 113, 209, 325, 425, 464, 425, 325, 209, 113, 53, 23, 10, 6, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 51, 113, 212, 331, 433, 474, 433, 331, 212, 113, 51, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 8, 21, 53, 116, 216, 338, 441, 483, 441, 338, 216, 116, 53, 21, 8, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 4, 5, 7, 10, 13, 13, 13, 10, 7, 5, 4, 3, 4, 4, 4, 5, 6, 8, 11, 14, 14, 14, 11, 8, 6, 5, 4, 4, 4],
                    peak: [7, 23, 40, 54, 66, 80, 93, 105, 117, 130, 145, 161, 178, 192, 206, 221, 235, 250, 264, 278, 292, 304, 317, 331, 344, 357, 372, 389, 405, 421, 435, 446, 460, 474, 486, 501, 516, 528, 540, 555, 569, 583, 599, 613, 625, 636, 648, 662, 677, 692, 708, 722, 735, 749, 764, 780, 796, 810, 824, 841, 857, 870, 883, 898, 912, 925, 937, 951, 967, 983, 999, 1015, 1030, 1042, 1056, 1070, 1081, 1092, 1103, 1116, 1129, 1142, 1156, 1171]
                },
                index: 3,
                counter: 6,
                offset: 51,
                measureText: 74
            }, {
                id: "R1-0000-4567",
                fill: "rgb(255,102,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 82,
                gaps: [
                    [65, 1],
                    [84, 1]
                ],
                sequence: "TAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCGGGTTTACGTACGTAAACCG",
                coordinate: 80,
                trace: {
                    A: [3, 5, 12, 25, 45, 70, 92, 100, 92, 70, 45, 25, 12, 5, 3, 4, 9, 23, 59, 129, 240, 374, 489, 535, 489, 374, 240, 129, 59, 23, 9, 4, 8, 21, 51, 112, 209, 326, 427, 467, 427, 326, 209, 112, 51, 21, 8, 21, 55, 123, 231, 363, 475, 519, 475, 363, 231, 123, 55, 21, 12, 26, 48, 74, 97, 106, 97, 74, 48, 26, 12, 1, 2, 5, 11, 25, 46, 73, 95, 104, 95, 73, 46, 25, 11, 5, 2, 1, 5, 12, 26, 49, 77, 100, 109, 100, 77, 49, 26, 12, 5, 12, 26, 48, 75, 98, 107, 98, 75, 48, 26, 12, 2, 4, 10, 22, 42, 65, 85, 93, 85, 65, 42, 22, 10, 4, 2, 14, 26, 45, 68, 87, 95, 87, 68, 45, 26, 14, 15, 28, 48, 73, 95, 103, 95, 73, 48, 28, 15, 1, 2, 5, 12, 26, 48, 75, 98, 107, 98, 75, 48, 26, 12, 5, 2, 1, 16, 29, 51, 78, 101, 110, 101, 78, 51, 29, 16, 2, 7, 20, 53, 119, 223, 349, 457, 500, 457, 349, 223, 119, 53, 20, 7, 2, 12, 25, 47, 74, 96, 105, 96, 74, 47, 25, 12, 6, 13, 25, 46, 70, 91, 99, 91, 70, 46, 25, 13, 6, 4, 7, 14, 28, 49, 76, 99, 108, 99, 76, 49, 28, 14, 7, 4, 20, 52, 117, 220, 345, 451, 494, 451, 345, 220, 117, 52, 20, 7, 14, 27, 48, 74, 95, 104, 95, 74, 48, 27, 14, 7, 8, 15, 29, 52, 79, 102, 112, 102, 79, 52, 29, 15, 8, 12, 25, 44, 68, 88, 96, 88, 68, 44, 25, 12, 7, 21, 54, 122, 228, 358, 469, 513, 469, 358, 228, 122, 54, 21, 7, 54, 117, 218, 340, 445, 487, 445, 340, 218, 117, 54, 49, 109, 204, 319, 417, 456, 417, 319, 204, 109, 49, 5, 7, 14, 27, 48, 73, 94, 103, 94, 73, 48, 27, 14, 7, 5, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 1, 2, 4, 10, 22, 41, 65, 85, 93, 85, 65, 41, 22, 10, 4, 2, 1, 6, 13, 27, 50, 78, 102, 111, 102, 78, 50, 27, 13, 6, 11, 24, 45, 70, 91, 100, 91, 70, 45, 24, 11, 5, 11, 24, 43, 67, 87, 95, 87, 67, 43, 24, 11, 5, 8, 14, 26, 45, 68, 88, 96, 88, 68, 45, 26, 14, 8, 12, 26, 47, 72, 94, 103, 94, 72, 47, 26, 12, 7, 13, 26, 45, 69, 89, 97, 89, 69, 45, 26, 13, 7, 4, 9, 24, 59, 130, 243, 379, 496, 543, 496, 379, 243, 130, 59, 24, 9, 4, 15, 29, 52, 80, 103, 113, 103, 80, 52, 29, 15, 4, 7, 14, 28, 51, 78, 102, 111, 102, 78, 51, 28, 14, 7, 4, 12, 26, 48, 75, 98, 107, 98, 75, 48, 26, 12, 23, 57, 123, 228, 356, 466, 509, 466, 356, 228, 123, 57, 23, 12, 26, 48, 74, 97, 105, 97, 74, 48, 26, 12, 8, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 8, 14, 28, 49, 75, 98, 106, 98, 75, 49, 28, 14, 56, 121, 224, 350, 458, 500, 458, 350, 224, 121, 56, 9, 21, 52, 112, 208, 324, 423, 463, 423, 324, 208, 112, 52, 21, 9, 2, 7, 20, 54, 120, 225, 353, 463, 506, 463, 353, 225, 120, 54, 20, 7, 2, 3, 4, 6, 13, 26, 46, 71, 92, 100, 92, 71, 46, 26, 13, 6, 4, 3, 4, 5, 7, 13, 25, 44, 68, 88, 95, 88, 68, 44, 25, 13, 7, 5, 4, 4, 6, 12, 25, 45, 69, 89, 97, 89, 69, 45, 25, 12, 6, 4, 1, 2, 4, 10, 22, 42, 65, 85, 93, 85, 65, 42, 22, 10, 4, 2, 1, 11, 24, 43, 67, 87, 95, 87, 67, 43, 24, 11, 4, 11, 23, 43, 68, 89, 97, 89, 68, 43, 23, 11, 4, 5, 6, 9, 16, 30, 53, 81, 104, 114, 104, 81, 53, 30, 16, 9, 6, 5, 12, 25, 44, 68, 88, 97, 88, 68, 44, 25, 12, 14, 29, 51, 79, 103, 112, 103, 79, 51, 29, 14, 10, 24, 59, 128, 237, 370, 483, 528, 483, 370, 237, 128, 59, 24, 10, 8, 15, 29, 51, 77, 100, 109, 100, 77, 51, 29, 15, 8, 15, 29, 51, 77, 99, 108, 99, 77, 51, 29, 15, 4, 6, 12, 24, 43, 66, 85, 93, 85, 66, 43, 24, 12, 6, 4, 23, 56, 119, 220, 343, 447, 489, 447, 343, 220, 119, 56, 23, 7, 13, 25, 45, 68, 88, 96, 88, 68, 45, 25, 13, 7, 8, 15, 28, 48, 73, 94, 102, 94, 73, 48, 28, 15, 8, 8, 14, 26, 45, 68, 87, 95, 87, 68, 45, 26, 14, 8, 4, 8, 21, 52, 114, 211, 330, 431, 472, 431, 330, 211, 114, 52, 21, 8, 4, 23, 58, 128, 239, 373, 488, 534, 488, 373, 239, 128, 58, 23, 11, 25, 59, 127, 234, 365, 476, 521, 476, 365, 234, 127, 59, 25, 11, 3, 6, 13, 27, 50, 78, 101, 111, 101, 78, 50, 27, 13, 6, 3, 5, 7, 14, 28, 49, 74, 96, 105, 96, 74, 49, 28, 14, 7, 5, 11, 23, 42, 65, 84, 92, 84, 65, 42, 23, 11, 6, 13, 27, 48, 75, 98, 107, 98, 75, 48, 27, 13, 6, 4, 5, 7, 14, 27, 48, 74, 96, 104, 96, 74, 48, 27, 14, 7, 5, 4, 5, 7, 13, 25, 44, 68, 87, 95, 87, 68, 44, 25, 13, 7, 5, 6, 8, 15, 28, 49, 75, 96, 105, 96, 75, 49, 28, 15, 8, 6, 1, 2, 4, 11, 23, 44, 68, 89, 97, 89, 68, 44, 23, 11, 4, 2, 1, 5, 10, 25, 61, 133, 246, 384, 502, 548, 502, 384, 246, 133, 61, 25, 10, 5, 2, 3, 5, 11, 24, 43, 67, 87, 95, 87, 67, 43, 24, 11, 5, 3, 2, 4, 5, 7, 13, 25, 44, 68, 88, 95, 88, 68, 44, 25, 13, 7, 5, 4, 4, 11, 24, 45, 71, 93, 101, 93, 71, 45, 24, 11, 4, 57, 124, 231, 361, 472, 517, 472, 361, 231, 124, 57, 3, 4, 7, 13, 27, 49, 75, 97, 106, 97, 75, 49, 27, 13, 7, 4, 3, 1, 2, 5, 11, 25, 46, 72, 94, 103, 94, 72, 46, 25, 11, 5, 2, 1, 5, 12, 25, 46, 72, 94, 102, 94, 72, 46, 25, 12, 5, 51, 112, 208, 326, 427, 467, 427, 326, 208, 112, 51, 58, 126, 233, 363, 475, 519, 475, 363, 233, 126, 58, 53, 113, 208, 324, 423, 462, 423, 324, 208, 113, 53, 11, 25, 46, 73, 95, 104, 95, 73, 46, 25, 11, 2, 4, 10, 22, 42, 65, 85, 93, 85, 65, 42, 22, 10, 4, 2, 12, 25, 46, 71, 93, 101, 93, 71, 46, 25, 12],
                    C: [2, 4, 7, 14, 26, 39, 51, 56, 51, 39, 26, 14, 7, 4, 2, 3, 3, 5, 8, 15, 27, 41, 52, 57, 52, 41, 27, 15, 8, 5, 3, 3, 3, 5, 8, 15, 26, 39, 51, 55, 51, 39, 26, 15, 8, 5, 3, 2, 5, 11, 21, 33, 43, 47, 43, 33, 21, 11, 5, 2, 51, 112, 209, 326, 427, 467, 427, 326, 209, 112, 51, 2, 7, 22, 57, 129, 241, 378, 495, 541, 495, 378, 241, 129, 57, 22, 7, 2, 22, 58, 129, 242, 380, 497, 544, 497, 380, 242, 129, 58, 22, 6, 12, 22, 34, 44, 48, 44, 34, 22, 12, 6, 1, 2, 6, 12, 23, 35, 46, 50, 46, 35, 23, 12, 6, 2, 1, 10, 17, 28, 42, 53, 58, 53, 42, 28, 17, 10, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 1, 1, 3, 6, 13, 23, 36, 48, 52, 48, 36, 23, 13, 6, 3, 1, 1, 10, 16, 26, 38, 48, 52, 48, 38, 26, 16, 10, 1, 1, 3, 6, 13, 24, 38, 50, 54, 50, 38, 24, 13, 6, 3, 1, 1, 54, 121, 226, 355, 464, 508, 464, 355, 226, 121, 54, 5, 8, 15, 27, 41, 53, 57, 53, 41, 27, 15, 8, 5, 3, 4, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 4, 3, 2, 5, 12, 21, 33, 44, 48, 44, 33, 21, 12, 5, 2, 23, 57, 124, 230, 358, 468, 512, 468, 358, 230, 124, 57, 23, 5, 9, 15, 25, 38, 48, 52, 48, 38, 25, 15, 9, 5, 7, 13, 23, 35, 45, 49, 45, 35, 23, 13, 7, 1, 2, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 2, 1, 8, 15, 26, 40, 52, 56, 52, 40, 26, 15, 8, 7, 15, 26, 40, 52, 56, 52, 40, 26, 15, 7, 9, 22, 53, 116, 214, 334, 436, 477, 436, 334, 214, 116, 53, 22, 9, 53, 114, 210, 327, 427, 467, 427, 327, 210, 114, 53, 2, 7, 21, 57, 127, 238, 373, 488, 534, 488, 373, 238, 127, 57, 21, 7, 2, 4, 7, 14, 24, 37, 48, 53, 48, 37, 24, 14, 7, 4, 6, 13, 24, 37, 49, 53, 49, 37, 24, 13, 6, 3, 7, 13, 23, 35, 46, 50, 46, 35, 23, 13, 7, 3, 6, 10, 17, 27, 40, 51, 55, 51, 40, 27, 17, 10, 6, 7, 14, 26, 39, 51, 56, 51, 39, 26, 14, 7, 5, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 3, 3, 4, 8, 15, 25, 38, 49, 53, 49, 38, 25, 15, 8, 4, 3, 3, 52, 112, 207, 323, 422, 462, 422, 323, 207, 112, 52, 3, 4, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 4, 3, 6, 13, 23, 36, 47, 52, 47, 36, 23, 13, 6, 5, 9, 15, 26, 39, 50, 54, 50, 39, 26, 15, 9, 5, 56, 123, 230, 359, 470, 515, 470, 359, 230, 123, 56, 6, 10, 16, 26, 38, 49, 53, 49, 38, 26, 16, 10, 6, 9, 16, 28, 42, 54, 58, 54, 42, 28, 16, 9, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 4, 5, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 4, 1, 1, 3, 6, 13, 24, 37, 49, 53, 49, 37, 24, 13, 6, 3, 1, 1, 4, 9, 22, 56, 123, 229, 358, 468, 512, 468, 358, 229, 123, 56, 22, 9, 4, 5, 10, 23, 56, 121, 224, 350, 457, 500, 457, 350, 224, 121, 56, 23, 10, 5, 8, 21, 51, 112, 208, 325, 425, 465, 425, 325, 208, 112, 51, 21, 8, 1, 1, 3, 6, 13, 25, 38, 50, 55, 50, 38, 25, 13, 6, 3, 1, 1, 6, 13, 23, 35, 45, 49, 45, 35, 23, 13, 6, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 5, 5, 6, 10, 16, 27, 40, 50, 55, 50, 40, 27, 16, 10, 6, 5, 5, 7, 14, 23, 35, 46, 50, 46, 35, 23, 14, 7, 8, 15, 25, 38, 49, 54, 49, 38, 25, 15, 8, 4, 5, 8, 15, 24, 36, 46, 50, 46, 36, 24, 15, 8, 5, 4, 22, 52, 113, 210, 327, 428, 468, 428, 327, 210, 113, 52, 22, 10, 16, 27, 39, 50, 55, 50, 39, 27, 16, 10, 3, 4, 8, 14, 25, 38, 49, 53, 49, 38, 25, 14, 8, 4, 3, 7, 10, 18, 29, 43, 55, 59, 55, 43, 29, 18, 10, 7, 25, 61, 133, 246, 384, 502, 549, 502, 384, 246, 133, 61, 25, 7, 10, 17, 28, 41, 53, 57, 53, 41, 28, 17, 10, 7, 6, 9, 16, 25, 37, 47, 52, 47, 37, 25, 16, 9, 6, 3, 3, 4, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 4, 3, 3, 4, 7, 13, 23, 34, 44, 48, 44, 34, 23, 13, 7, 4, 5, 7, 10, 17, 28, 41, 53, 57, 53, 41, 28, 17, 10, 7, 5, 8, 23, 59, 131, 244, 382, 500, 547, 500, 382, 244, 131, 59, 23, 8, 10, 24, 60, 130, 241, 376, 492, 538, 492, 376, 241, 130, 60, 24, 10, 7, 13, 23, 35, 45, 49, 45, 35, 23, 13, 7, 3, 6, 13, 23, 35, 45, 49, 45, 35, 23, 13, 6, 3, 4, 4, 5, 9, 15, 25, 38, 48, 52, 48, 38, 25, 15, 9, 5, 4, 4, 4, 6, 9, 16, 27, 40, 52, 56, 52, 40, 27, 16, 9, 6, 4, 5, 7, 10, 17, 28, 42, 53, 58, 53, 42, 28, 17, 10, 7, 5, 1, 1, 3, 6, 13, 25, 39, 51, 55, 51, 39, 25, 13, 6, 3, 1, 1, 4, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4, 4, 3, 7, 20, 50, 111, 207, 324, 424, 463, 424, 324, 207, 111, 50, 20, 7, 3, 4, 4, 6, 9, 16, 28, 41, 53, 58, 53, 41, 28, 16, 9, 6, 4, 4, 2, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 2, 8, 15, 27, 40, 52, 57, 52, 40, 27, 15, 8, 4, 9, 24, 59, 130, 242, 378, 495, 541, 495, 378, 242, 130, 59, 24, 9, 4, 1, 1, 2, 5, 12, 22, 33, 44, 48, 44, 33, 22, 12, 5, 2, 1, 1, 4, 7, 14, 26, 39, 51, 56, 51, 39, 26, 14, 7, 4, 6, 12, 22, 34, 44, 48, 44, 34, 22, 12, 6, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 10, 16, 26, 38, 49, 53, 49, 38, 26, 16, 10, 54, 120, 225, 353, 462, 506, 462, 353, 225, 120, 54, 7, 21, 56, 125, 234, 367, 481, 526, 481, 367, 234, 125, 56, 21, 7, 7, 13, 24, 36, 47, 51, 47, 36, 24, 13, 7],
                    G: [2, 2, 4, 7, 12, 18, 24, 26, 24, 18, 12, 7, 4, 2, 2, 3, 3, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 3, 3, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 1, 3, 6, 12, 18, 23, 26, 23, 18, 12, 6, 3, 1, 4, 8, 14, 20, 26, 29, 26, 20, 14, 8, 4, 1, 1, 2, 3, 7, 12, 19, 24, 27, 24, 19, 12, 7, 3, 2, 1, 1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 49, 109, 203, 319, 417, 456, 417, 319, 203, 109, 49, 6, 19, 50, 113, 211, 330, 433, 473, 433, 330, 211, 113, 50, 19, 6, 56, 120, 221, 344, 449, 491, 449, 344, 221, 120, 56, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 1, 1, 1, 3, 6, 12, 18, 23, 25, 23, 18, 12, 6, 3, 1, 1, 1, 7, 10, 15, 21, 27, 29, 27, 21, 15, 10, 7, 1, 1, 2, 3, 7, 13, 20, 25, 28, 25, 20, 13, 7, 3, 2, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 21, 53, 117, 218, 340, 444, 486, 444, 340, 218, 117, 53, 21, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3, 1, 3, 6, 12, 18, 24, 26, 24, 18, 12, 6, 3, 1, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 21, 52, 112, 207, 323, 422, 461, 422, 323, 207, 112, 52, 21, 5, 9, 15, 22, 27, 30, 27, 22, 15, 9, 5, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 4, 4, 6, 9, 15, 21, 27, 29, 27, 21, 15, 9, 6, 4, 4, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 1, 1, 2, 3, 7, 13, 20, 26, 28, 26, 20, 13, 7, 3, 2, 1, 1, 19, 50, 110, 205, 321, 420, 460, 420, 321, 205, 110, 50, 19, 49, 109, 204, 320, 420, 459, 420, 320, 204, 109, 49, 20, 50, 111, 208, 325, 425, 465, 425, 325, 208, 111, 50, 20, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 4, 6, 9, 15, 21, 27, 29, 27, 21, 15, 9, 6, 4, 3, 3, 3, 5, 8, 13, 18, 23, 25, 23, 18, 13, 8, 5, 3, 3, 3, 6, 10, 15, 22, 28, 30, 28, 22, 15, 10, 6, 8, 21, 52, 114, 211, 330, 432, 472, 432, 330, 211, 114, 52, 21, 8, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 4, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 4, 4, 8, 14, 20, 26, 29, 26, 20, 14, 8, 4, 24, 57, 122, 225, 350, 457, 499, 457, 350, 225, 122, 57, 24, 6, 10, 16, 22, 28, 30, 28, 22, 16, 10, 6, 6, 9, 15, 21, 27, 29, 27, 21, 15, 9, 6, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 1, 1, 2, 3, 7, 12, 19, 24, 27, 24, 19, 12, 7, 3, 2, 1, 1, 3, 3, 3, 5, 8, 14, 20, 25, 28, 25, 20, 14, 8, 5, 3, 3, 3, 4, 4, 5, 6, 10, 15, 22, 28, 30, 28, 22, 15, 10, 6, 5, 4, 4, 3, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 2, 7, 22, 58, 129, 242, 379, 496, 543, 496, 379, 242, 129, 58, 22, 7, 2, 53, 117, 219, 342, 448, 490, 448, 342, 219, 117, 53, 20, 54, 121, 226, 355, 465, 508, 465, 355, 226, 121, 54, 20, 5, 5, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 5, 5, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 5, 9, 15, 21, 27, 30, 27, 21, 15, 9, 5, 4, 4, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 53, 114, 210, 327, 426, 466, 426, 327, 210, 114, 53, 3, 4, 5, 9, 14, 21, 26, 29, 26, 21, 14, 9, 5, 4, 3, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 4, 6, 9, 15, 21, 26, 29, 26, 21, 15, 9, 6, 4, 26, 62, 134, 248, 386, 505, 552, 505, 386, 248, 134, 62, 26, 5, 7, 10, 15, 22, 27, 29, 27, 22, 15, 10, 7, 5, 3, 3, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 3, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 5, 6, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 6, 5, 2, 3, 4, 8, 14, 20, 26, 29, 26, 20, 14, 8, 4, 3, 2, 4, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 51, 112, 210, 328, 429, 469, 429, 328, 210, 112, 51, 23, 59, 130, 243, 380, 498, 545, 498, 380, 243, 130, 59, 23, 5, 9, 21, 51, 111, 206, 321, 419, 458, 419, 321, 206, 111, 51, 21, 9, 5, 4, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 5, 5, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 5, 5, 1, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 1, 4, 4, 4, 6, 9, 14, 20, 26, 28, 26, 20, 14, 9, 6, 4, 4, 4, 2, 2, 2, 4, 7, 12, 18, 24, 26, 24, 18, 12, 7, 4, 2, 2, 2, 5, 9, 22, 54, 117, 217, 339, 443, 485, 443, 339, 217, 117, 54, 22, 9, 5, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 5, 9, 14, 21, 26, 29, 26, 21, 14, 9, 5, 3, 3, 3, 5, 8, 14, 20, 26, 28, 26, 20, 14, 8, 5, 3, 3, 3, 2, 7, 20, 54, 121, 226, 354, 464, 507, 464, 354, 226, 121, 54, 20, 7, 2, 2, 4, 7, 13, 19, 24, 27, 24, 19, 13, 7, 4, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 6, 9, 15, 21, 26, 29, 26, 21, 15, 9, 6, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 50, 110, 206, 322, 422, 461, 422, 322, 206, 110, 50],
                    T: [7, 20, 51, 113, 212, 331, 433, 474, 433, 331, 212, 113, 51, 20, 7, 3, 3, 3, 4, 5, 7, 9, 12, 12, 12, 9, 7, 5, 4, 3, 3, 3, 3, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 3, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 1, 1, 1, 2, 3, 5, 8, 11, 11, 11, 8, 5, 3, 2, 1, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 2, 3, 5, 7, 10, 11, 10, 7, 5, 3, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 56, 120, 221, 343, 448, 490, 448, 343, 221, 120, 56, 2, 7, 21, 57, 127, 239, 374, 490, 536, 490, 374, 239, 127, 57, 21, 7, 2, 58, 125, 231, 360, 470, 514, 470, 360, 231, 125, 58, 1, 1, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 8, 21, 52, 113, 211, 329, 431, 471, 431, 329, 211, 113, 52, 21, 8, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 4, 5, 6, 8, 10, 13, 13, 13, 10, 8, 6, 5, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 60, 131, 244, 381, 499, 545, 499, 381, 244, 131, 60, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 4, 5, 7, 9, 12, 13, 12, 9, 7, 5, 4, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 24, 57, 123, 228, 355, 463, 506, 463, 355, 228, 123, 57, 24, 57, 126, 236, 369, 483, 528, 483, 369, 236, 126, 57, 24, 60, 130, 242, 377, 493, 539, 493, 377, 242, 130, 60, 24, 3, 3, 3, 4, 5, 7, 9, 12, 13, 12, 9, 7, 5, 4, 3, 3, 3, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 53, 119, 222, 348, 456, 499, 456, 348, 222, 119, 53, 4, 5, 6, 8, 10, 13, 13, 13, 10, 8, 6, 5, 4, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 56, 121, 224, 350, 457, 500, 457, 350, 224, 121, 56, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 3, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 3, 1, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 6, 11, 25, 59, 127, 235, 366, 478, 522, 478, 366, 235, 127, 59, 25, 11, 6, 59, 128, 239, 373, 488, 534, 488, 373, 239, 128, 59, 55, 121, 225, 351, 459, 502, 459, 351, 225, 121, 55, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 9, 22, 56, 123, 229, 358, 468, 512, 468, 358, 229, 123, 56, 22, 9, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 4, 5, 6, 8, 10, 13, 13, 13, 10, 8, 6, 5, 4, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 22, 53, 113, 208, 323, 422, 461, 422, 323, 208, 113, 53, 22, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 2, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 2, 2, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 10, 25, 61, 133, 247, 385, 504, 551, 504, 385, 247, 133, 61, 25, 10, 11, 24, 57, 123, 228, 354, 463, 506, 463, 354, 228, 123, 57, 24, 11, 2, 6, 20, 52, 116, 218, 341, 447, 489, 447, 341, 218, 116, 52, 20, 6, 2, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 4, 4, 4, 5, 6, 8, 11, 14, 14, 14, 11, 8, 6, 5, 4, 4, 4, 21, 54, 122, 228, 358, 469, 513, 469, 358, 228, 122, 54, 21, 4, 5, 7, 9, 12, 12, 12, 9, 7, 5, 4, 3, 3, 3, 4, 5, 7, 9, 12, 12, 12, 9, 7, 5, 4, 3, 3, 3, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 19, 49, 108, 202, 316, 414, 453, 414, 316, 202, 108, 49, 19, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3],
                    peak: [7, 23, 39, 53, 65, 79, 94, 106, 119, 132, 143, 157, 171, 185, 199, 211, 225, 239, 252, 265, 277, 290, 303, 314, 327, 340, 354, 369, 381, 393, 406, 418, 430, 445, 459, 472, 485, 497, 509, 521, 533, 544, 557, 573, 590, 607, 623, 639, 653, 665, 680, 694, 705, 718, 732, 744, 757, 771, 784, 797, 810, 825, 840, 854, 869, 884, 897, 909, 924, 940, 955, 971, 988, 1005, 1022, 1037, 1049, 1063, 1080, 1095, 1107, 1118, 1129, 1140, 1153, 1166]
                },
                index: 4,
                counter: 7,
                measureText: 74
            }, {
                id: "R1-0000-5678",
                fill: "rgb(51,255,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 126,
                gaps: [
                    [5, 1],
                    [58, 1]
                ],
                sequence: "CCCGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAACCCGGGTTTAAACC",
                coordinate: 150,
                trace: {
                    A: [14, 26, 46, 70, 91, 99, 91, 70, 46, 26, 14, 6, 12, 26, 47, 74, 96, 105, 96, 74, 47, 26, 12, 6, 4, 10, 23, 43, 67, 87, 95, 87, 67, 43, 23, 10, 4, 4, 10, 22, 42, 65, 85, 93, 85, 65, 42, 22, 10, 4, 13, 26, 48, 73, 95, 104, 95, 73, 48, 26, 13, 6, 9, 16, 30, 52, 78, 101, 111, 101, 78, 52, 30, 16, 9, 6, 13, 26, 46, 71, 92, 101, 92, 71, 46, 26, 13, 1, 2, 4, 11, 24, 45, 70, 92, 100, 92, 70, 45, 24, 11, 4, 2, 1, 52, 115, 213, 332, 435, 475, 435, 332, 213, 115, 52, 4, 5, 7, 13, 25, 44, 67, 87, 95, 87, 67, 44, 25, 13, 7, 5, 4, 13, 27, 49, 77, 100, 109, 100, 77, 49, 27, 13, 6, 12, 25, 44, 68, 88, 96, 88, 68, 44, 25, 12, 6, 24, 60, 130, 242, 377, 493, 539, 493, 377, 242, 130, 60, 24, 12, 25, 44, 68, 89, 97, 89, 68, 44, 25, 12, 4, 7, 13, 27, 48, 74, 96, 105, 96, 74, 48, 27, 13, 7, 4, 4, 6, 13, 25, 45, 69, 90, 98, 90, 69, 45, 25, 13, 6, 4, 3, 7, 21, 53, 117, 218, 341, 446, 488, 446, 341, 218, 117, 53, 21, 7, 3, 9, 23, 58, 127, 237, 370, 483, 529, 483, 370, 237, 127, 58, 23, 9, 57, 123, 228, 355, 464, 508, 464, 355, 228, 123, 57, 3, 5, 12, 26, 47, 73, 95, 103, 95, 73, 47, 26, 12, 5, 3, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 10, 22, 41, 63, 83, 91, 83, 63, 41, 22, 10, 1, 2, 4, 10, 22, 41, 64, 83, 91, 83, 64, 41, 22, 10, 4, 2, 1, 4, 5, 8, 14, 28, 50, 76, 99, 108, 99, 76, 50, 28, 14, 8, 5, 4, 4, 6, 13, 25, 45, 70, 90, 99, 90, 70, 45, 25, 13, 6, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 11, 24, 44, 69, 90, 99, 90, 69, 44, 24, 11, 4, 3, 6, 12, 26, 48, 74, 97, 105, 97, 74, 48, 26, 12, 6, 3, 52, 116, 216, 338, 443, 484, 443, 338, 216, 116, 52, 5, 6, 8, 15, 29, 50, 76, 98, 107, 98, 76, 50, 29, 15, 8, 6, 5, 5, 11, 25, 46, 72, 94, 103, 94, 72, 46, 25, 11, 5, 11, 25, 46, 72, 94, 103, 94, 72, 46, 25, 11, 10, 23, 56, 121, 223, 348, 455, 498, 455, 348, 223, 121, 56, 23, 10, 2, 3, 6, 13, 27, 50, 77, 100, 109, 100, 77, 50, 27, 13, 6, 3, 2, 3, 6, 13, 26, 48, 75, 98, 107, 98, 75, 48, 26, 13, 6, 3, 1, 2, 5, 11, 25, 46, 72, 95, 104, 95, 72, 46, 25, 11, 5, 2, 1, 11, 24, 58, 124, 229, 357, 466, 509, 466, 357, 229, 124, 58, 24, 11, 21, 54, 119, 223, 349, 457, 500, 457, 349, 223, 119, 54, 21, 19, 49, 109, 202, 317, 414, 453, 414, 317, 202, 109, 49, 19, 2, 3, 6, 13, 27, 50, 78, 101, 110, 101, 78, 50, 27, 13, 6, 3, 2, 1, 2, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 2, 1, 4, 5, 7, 13, 25, 44, 67, 87, 95, 87, 67, 44, 25, 13, 7, 5, 4, 6, 8, 15, 28, 48, 73, 94, 102, 94, 73, 48, 28, 15, 8, 6, 10, 23, 42, 66, 86, 94, 86, 66, 42, 23, 10, 5, 11, 23, 42, 65, 85, 93, 85, 65, 42, 23, 11, 5, 4, 6, 12, 25, 44, 68, 88, 96, 88, 68, 44, 25, 12, 6, 4, 7, 13, 27, 48, 75, 97, 106, 97, 75, 48, 27, 13, 7, 3, 6, 13, 27, 50, 77, 101, 110, 101, 77, 50, 27, 13, 6, 3, 58, 129, 241, 377, 494, 540, 494, 377, 241, 129, 58, 5, 12, 26, 48, 75, 99, 108, 99, 75, 48, 26, 12, 5, 5, 12, 25, 45, 70, 92, 100, 92, 70, 45, 25, 12, 5, 5, 6, 8, 15, 28, 49, 74, 96, 104, 96, 74, 49, 28, 15, 8, 6, 5, 59, 129, 241, 376, 492, 538, 492, 376, 241, 129, 59, 1, 2, 4, 11, 24, 44, 69, 91, 99, 91, 69, 44, 24, 11, 4, 2, 1, 6, 8, 14, 27, 46, 69, 90, 98, 90, 69, 46, 27, 14, 8, 6, 16, 29, 51, 78, 100, 109, 100, 78, 51, 29, 16, 5, 10, 24, 58, 126, 233, 363, 475, 519, 475, 363, 233, 126, 58, 24, 10, 5, 58, 129, 243, 380, 498, 545, 498, 380, 243, 129, 58, 12, 24, 45, 69, 90, 98, 90, 69, 45, 24, 12, 8, 15, 28, 48, 73, 94, 102, 94, 73, 48, 28, 15, 8, 2, 5, 12, 25, 47, 73, 96, 105, 96, 73, 47, 25, 12, 5, 2, 15, 29, 51, 78, 101, 110, 101, 78, 51, 29, 15, 8, 15, 29, 51, 78, 102, 111, 102, 78, 51, 29, 15, 8, 11, 24, 44, 67, 88, 96, 88, 67, 44, 24, 11, 10, 23, 42, 66, 86, 94, 86, 66, 42, 23, 10, 5, 6, 8, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 8, 6, 5, 8, 14, 27, 46, 70, 90, 98, 90, 70, 46, 27, 14, 8, 25, 60, 129, 239, 372, 486, 532, 486, 372, 239, 129, 60, 25, 9, 21, 51, 110, 204, 319, 416, 455, 416, 319, 204, 110, 51, 21, 9, 56, 119, 220, 343, 448, 489, 448, 343, 220, 119, 56, 3, 4, 7, 14, 28, 50, 78, 101, 110, 101, 78, 50, 28, 14, 7, 4, 3, 14, 28, 51, 79, 103, 112, 103, 79, 51, 28, 14],
                    C: [53, 114, 212, 330, 431, 472, 431, 330, 212, 114, 53, 20, 52, 115, 215, 336, 440, 481, 440, 336, 215, 115, 52, 20, 19, 49, 110, 206, 323, 423, 463, 423, 323, 206, 110, 49, 19, 2, 6, 12, 23, 35, 46, 51, 46, 35, 23, 12, 6, 2, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 5, 7, 10, 17, 28, 42, 53, 58, 53, 42, 28, 17, 10, 7, 5, 8, 14, 25, 38, 49, 53, 49, 38, 25, 14, 8, 1, 1, 2, 5, 11, 21, 32, 42, 46, 42, 32, 21, 11, 5, 2, 1, 1, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 5, 9, 22, 52, 113, 209, 326, 426, 465, 426, 326, 209, 113, 52, 22, 9, 5, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 4, 7, 13, 23, 35, 44, 48, 44, 35, 23, 13, 7, 4, 6, 9, 16, 27, 40, 52, 56, 52, 40, 27, 16, 9, 6, 50, 110, 204, 319, 417, 455, 417, 319, 204, 110, 50, 3, 5, 8, 15, 26, 40, 51, 56, 51, 40, 26, 15, 8, 5, 3, 3, 4, 8, 14, 24, 37, 48, 52, 48, 37, 24, 14, 8, 4, 3, 2, 2, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 2, 2, 3, 4, 8, 14, 25, 38, 49, 53, 49, 38, 25, 14, 8, 4, 3, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 7, 21, 53, 118, 221, 345, 452, 494, 452, 345, 221, 118, 53, 21, 7, 19, 49, 110, 205, 322, 421, 461, 421, 322, 205, 110, 49, 19, 57, 127, 238, 373, 489, 535, 489, 373, 238, 127, 57, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 4, 4, 6, 9, 16, 27, 40, 51, 56, 51, 40, 27, 16, 9, 6, 4, 4, 3, 5, 8, 15, 26, 40, 51, 56, 51, 40, 26, 15, 8, 5, 3, 6, 13, 24, 38, 50, 54, 50, 38, 24, 13, 6, 3, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 3, 2, 4, 7, 14, 25, 38, 50, 54, 50, 38, 25, 14, 7, 4, 2, 7, 13, 23, 36, 46, 50, 46, 36, 23, 13, 7, 6, 11, 26, 62, 134, 248, 387, 505, 553, 505, 387, 248, 134, 62, 26, 11, 6, 2, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 2, 6, 12, 23, 35, 46, 50, 46, 35, 23, 12, 6, 4, 5, 9, 15, 26, 38, 49, 54, 49, 38, 26, 15, 9, 5, 4, 3, 8, 22, 58, 128, 239, 374, 489, 535, 489, 374, 239, 128, 58, 22, 8, 3, 2, 3, 7, 14, 24, 37, 48, 52, 48, 37, 24, 14, 7, 3, 2, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 5, 7, 10, 17, 28, 41, 53, 57, 53, 41, 28, 17, 10, 7, 5, 3, 7, 13, 24, 37, 48, 52, 48, 37, 24, 13, 7, 3, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 3, 7, 21, 53, 118, 221, 345, 452, 494, 452, 345, 221, 118, 53, 21, 7, 3, 2, 6, 18, 49, 109, 204, 320, 419, 458, 419, 320, 204, 109, 49, 18, 6, 2, 5, 9, 21, 52, 111, 206, 321, 420, 459, 420, 321, 206, 111, 52, 21, 9, 5, 5, 7, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 7, 5, 6, 13, 25, 38, 50, 55, 50, 38, 25, 13, 6, 3, 6, 12, 22, 34, 44, 48, 44, 34, 22, 12, 6, 3, 3, 5, 8, 15, 25, 38, 50, 54, 50, 38, 25, 15, 8, 5, 3, 4, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 4, 2, 4, 7, 14, 24, 37, 48, 53, 48, 37, 24, 14, 7, 4, 2, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 22, 57, 128, 240, 376, 492, 538, 492, 376, 240, 128, 57, 22, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 5, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 5, 8, 14, 24, 36, 47, 51, 47, 36, 24, 14, 8, 2, 6, 20, 52, 116, 217, 341, 446, 488, 446, 341, 217, 116, 52, 20, 6, 2, 5, 6, 10, 16, 26, 39, 49, 53, 49, 39, 26, 16, 10, 6, 5, 9, 15, 25, 37, 47, 51, 47, 37, 25, 15, 9, 4, 4, 5, 9, 15, 25, 38, 49, 53, 49, 38, 25, 15, 9, 5, 4, 4, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 54, 119, 221, 346, 453, 496, 453, 346, 221, 119, 54, 25, 61, 131, 242, 376, 492, 538, 492, 376, 242, 131, 61, 25, 7, 21, 55, 123, 230, 361, 473, 517, 473, 361, 230, 123, 55, 21, 7, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 5, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 7, 13, 24, 36, 47, 51, 47, 36, 24, 13, 7, 6, 12, 23, 35, 46, 50, 46, 35, 23, 12, 6, 5, 5, 6, 10, 16, 27, 39, 50, 54, 50, 39, 27, 16, 10, 6, 5, 5, 6, 10, 16, 26, 39, 49, 53, 49, 39, 26, 16, 10, 6, 6, 9, 15, 25, 37, 46, 50, 46, 37, 25, 15, 9, 6, 4, 5, 9, 15, 25, 37, 47, 51, 47, 37, 25, 15, 9, 5, 4, 10, 16, 27, 40, 50, 55, 50, 40, 27, 16, 10, 4, 9, 23, 58, 128, 238, 371, 485, 531, 485, 371, 238, 128, 58, 23, 9, 4, 58, 128, 237, 371, 485, 530, 485, 371, 237, 128, 58],
                    G: [6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 3, 7, 13, 20, 26, 28, 26, 20, 13, 7, 3, 2, 20, 53, 119, 222, 349, 457, 499, 457, 349, 222, 119, 53, 20, 58, 126, 235, 367, 480, 525, 480, 367, 235, 126, 58, 5, 6, 7, 11, 16, 23, 28, 30, 28, 23, 16, 11, 7, 6, 5, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 1, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 1, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 4, 4, 5, 6, 10, 15, 22, 27, 29, 27, 22, 15, 10, 6, 5, 4, 4, 51, 113, 211, 331, 433, 473, 433, 331, 211, 113, 51, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 9, 22, 56, 123, 228, 356, 466, 510, 466, 356, 228, 123, 56, 22, 9, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3, 2, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 2, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3, 6, 10, 15, 22, 27, 29, 27, 22, 15, 10, 6, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 2, 3, 7, 13, 20, 25, 28, 25, 20, 13, 7, 3, 2, 7, 20, 53, 119, 223, 350, 459, 502, 459, 350, 223, 119, 53, 20, 7, 2, 5, 9, 21, 51, 111, 205, 319, 417, 456, 417, 319, 205, 111, 51, 21, 9, 5, 8, 21, 53, 116, 215, 336, 439, 480, 439, 336, 215, 116, 53, 21, 8, 3, 6, 11, 17, 23, 25, 23, 17, 11, 6, 3, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 2, 2, 4, 7, 13, 19, 25, 27, 25, 19, 13, 7, 4, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 5, 5, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 5, 5, 21, 56, 124, 233, 365, 478, 523, 478, 365, 233, 124, 56, 21, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 2, 2, 2, 4, 7, 13, 19, 24, 27, 24, 19, 13, 7, 4, 2, 2, 2, 7, 19, 50, 110, 205, 321, 420, 459, 420, 321, 205, 110, 50, 19, 7, 1, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 1, 5, 6, 7, 11, 16, 23, 28, 30, 28, 23, 16, 11, 7, 6, 5, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 3, 4, 8, 14, 21, 27, 29, 27, 21, 14, 8, 4, 3, 2, 2, 2, 4, 7, 13, 19, 24, 26, 24, 19, 13, 7, 4, 2, 2, 2, 1, 1, 2, 3, 7, 13, 19, 25, 28, 25, 19, 13, 7, 3, 2, 1, 1, 4, 4, 5, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 5, 4, 4, 10, 22, 52, 112, 206, 321, 419, 458, 419, 321, 206, 112, 52, 22, 10, 57, 127, 238, 373, 488, 534, 488, 373, 238, 127, 57, 20, 51, 112, 209, 327, 428, 468, 428, 327, 209, 112, 51, 20, 3, 4, 5, 9, 14, 21, 26, 28, 26, 21, 14, 9, 5, 4, 3, 3, 5, 8, 13, 19, 25, 27, 25, 19, 13, 8, 5, 3, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 4, 8, 13, 20, 25, 28, 25, 20, 13, 8, 4, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 21, 54, 119, 222, 347, 454, 496, 454, 347, 222, 119, 54, 21, 5, 5, 5, 7, 10, 15, 22, 27, 29, 27, 22, 15, 10, 7, 5, 5, 5, 5, 9, 15, 21, 27, 30, 27, 21, 15, 9, 5, 1, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 1, 11, 24, 57, 123, 227, 354, 463, 506, 463, 354, 227, 123, 57, 24, 11, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 4, 4, 4, 6, 9, 15, 21, 26, 29, 26, 21, 15, 9, 6, 4, 4, 4, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 4, 7, 12, 17, 22, 24, 22, 17, 12, 7, 4, 6, 7, 11, 17, 23, 29, 32, 29, 23, 17, 11, 7, 6, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 55, 120, 222, 346, 452, 494, 452, 346, 222, 120, 55, 23, 57, 123, 229, 357, 466, 510, 466, 357, 229, 123, 57, 23, 53, 118, 220, 344, 450, 492, 450, 344, 220, 118, 53, 3, 6, 12, 18, 24, 26, 24, 18, 12, 6, 3, 5, 5, 5, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 5, 5, 5, 5, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 5, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 4, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 4, 7, 10, 15, 22, 27, 29, 27, 22, 15, 10, 7, 3, 3, 3, 5, 9, 14, 20, 26, 28, 26, 20, 14, 9, 5, 3, 3, 3, 5, 8, 14, 20, 25, 28, 25, 20, 14, 8, 5],
                    T: [5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 10, 24, 56, 121, 223, 347, 453, 495, 453, 347, 223, 121, 56, 24, 10, 51, 112, 208, 324, 424, 463, 424, 324, 208, 112, 51, 2, 6, 19, 49, 109, 205, 321, 421, 460, 421, 321, 205, 109, 49, 19, 6, 2, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 22, 56, 122, 227, 355, 464, 508, 464, 355, 227, 122, 56, 22, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 8, 21, 52, 113, 210, 328, 429, 469, 429, 328, 210, 113, 52, 21, 8, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 48, 108, 202, 316, 414, 453, 414, 316, 202, 108, 48, 20, 52, 116, 218, 341, 446, 488, 446, 341, 218, 116, 52, 20, 7, 20, 51, 112, 209, 327, 428, 468, 428, 327, 209, 112, 51, 20, 7, 3, 4, 6, 9, 12, 12, 12, 9, 6, 4, 3, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 56, 126, 237, 371, 486, 531, 486, 371, 237, 126, 56, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 6, 19, 49, 110, 205, 322, 422, 461, 422, 322, 205, 110, 49, 19, 6, 2, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 9, 22, 55, 120, 223, 348, 455, 497, 455, 348, 223, 120, 55, 22, 9, 23, 57, 126, 234, 365, 477, 522, 477, 365, 234, 126, 57, 23, 8, 22, 58, 128, 239, 374, 490, 536, 490, 374, 239, 128, 58, 22, 8, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 6, 10, 22, 52, 111, 205, 320, 417, 456, 417, 320, 205, 111, 52, 22, 10, 6, 4, 5, 7, 9, 12, 12, 12, 9, 7, 5, 4, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 54, 117, 215, 335, 437, 478, 437, 335, 215, 117, 54, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 2, 3, 5, 8, 11, 11, 11, 8, 5, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 55, 123, 231, 363, 475, 520, 475, 363, 231, 123, 55, 6, 10, 24, 56, 121, 223, 347, 453, 495, 453, 347, 223, 121, 56, 24, 10, 6, 23, 54, 115, 213, 331, 432, 472, 432, 331, 213, 115, 54, 23, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4],
                    peak: [5, 17, 30, 43, 55, 68, 81, 95, 109, 123, 137, 149, 162, 174, 187, 202, 218, 234, 247, 260, 274, 286, 300, 317, 333, 346, 358, 372, 385, 399, 414, 426, 439, 455, 471, 487, 503, 517, 530, 545, 562, 579, 595, 608, 620, 634, 648, 662, 675, 687, 700, 715, 729, 743, 759, 772, 786, 800, 811, 823, 837, 850, 862, 874, 885, 899, 914, 927, 941, 954, 968, 982]
                },
                index: 5,
                counter: 8,
                measureText: 74
            }],
            startY: 137,
            endY: 226,
            displayedFeatures: 6,
            totalFeatures: 6
        }, {
            name: "Copy Number Variation",
            type: "heatmap",
            autowidth: true,
            height: 20,
            data: [{
                id: "Cell Line-123",
                offset: 10,
                data: [7, 5, 5, 5, 6, 7, 9, 8, 8, 8, 8, 5, 7, 9, 15, 15, 16, 9, 9, 7, 8, 10, 9, 21, 22, 22, 24, 20, 24, 26, 24, 25, 24, 31, 29, 33, 33, 33, 33, 33, 20, 17, 19, 18, 18, 18, 27, 23, 31, 26, 31, 31, 31, 34, 32, 31, 30, 30, 30, 30, 30, 24, 24, 20, 21, 17, 17, 27, 29, 25, 31, 31, 31],
                index: 0,
                counter: 9,
                measureText: 67
            }],
            startY: 281,
            endY: 281,
            displayedFeatures: 1,
            totalFeatures: 1
        }, {
            name: "Tissue Distribution (Heart, Liver, Kidney)",
            type: "heatmap",
            height: 20,
            data: [{
                id: "123456_at",
                offset: 100,
                data: [25, 35, 46],
                index: 0,
                counter: 10,
                measureText: 56
            }, {
                id: "234567_at",
                offset: 151,
                data: [80, 45, 10],
                index: 1,
                counter: 11,
                measureText: 56
            }, {
                id: "345678_at",
                offset: 181,
                data: [65, 46, 29],
                index: 2,
                counter: 12,
                measureText: 56
            }],
            startY: 336,
            endY: 386,
            displayedFeatures: 3,
            totalFeatures: 3
        }, {
            name: "Another CNV",
            type: "line",
            autowidth: true,
            height: 20,
            fill: ["rgb(255,0,0)", "rgb(0,255,0)"],
            outline: ["rgb(255,0,0)", "rgb(0,255,0)"],
            data: [{
                id: "Cell Line-124",
                offset: 10,
                data: [30, 31, 31, 33, 29, 29, 30, 31, 32, 33, 33, 31, 31, 29, 30, 30, 27, 32, 31, 31, 28, 31, 31, 29, 31, 31, 31, 26, 25, 29, 26, 26, 21, 26, 21, 31, 31, 28, 28, 23, 25, 28, 28, 31, 33, 33, 32, 31, 31, 31, 24, 28, 28, 28, 31, 32, 32, 31, 31, 28, 24, 28, 24, 29, 31, 29, 31],
                index: 0,
                counter: 13,
                measureText: 67
            }, {
                id: "Cell Line-125",
                offset: 10,
                data: [29, 31, 31, 31, 26, 25, 29, 26, 26, 21, 26, 21, 31, 31, 28, 28, 23, 25, 28, 28, 31, 33, 33, 32, 31, 31, 31, 24, 28, 28, 28, 31, 32, 32, 31, 31, 28, 24, 28, 24, 29, 31, 29, 31, 30, 31, 31, 33, 29, 29, 30, 31, 32, 33, 33, 31, 31, 29, 30, 30, 27, 32, 31, 31, 28, 31, 31],
                index: 1,
                counter: 14,
                measureText: 67
            }],
            startY: 441,
            endY: 466,
            displayedFeatures: 2,
            totalFeatures: 2
        }, {
            type: "bar",
            height: 20,
            fill: ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(255,255,0)"],
            outline: ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(255,255,0)"],
            data: [{
                id: "123456_at",
                offset: 100,
                data: [25, 35, 46],
                index: 0,
                counter: 15,
                measureText: 56
            }, {
                id: "234567_at",
                offset: 151,
                data: [80, 45, 10],
                index: 1,
                counter: 16,
                measureText: 56
            }, {
                id: "345678_at",
                offset: 181,
                data: [65, 46, 29],
                index: 2,
                counter: 17,
                measureText: 56
            }],
            startY: 501,
            endY: 551,
            displayedFeatures: 3,
            totalFeatures: 3
        }, {
            name: "Clones",
            type: "box",
            data: [{
                id: "clone-1234567",
                fill: "rgb(255,255,51)",
                outline: "rgb(0,0,0)",
                dir: "left",
                data: [
                    [121, 196]
                ],
                index: 0,
                counter: 18,
                start: 121,
                end: 196,
                measureText: 77
            }, {
                id: "clone-2345678",
                fill: "rgb(255,255,51)",
                outline: "rgb(0,0,0)",
                dir: "right",
                data: [
                    [371, 400]
                ],
                landmarks: [{
                    offset: 157,
                    text: "Gap "
                }, {
                    offset: 137,
                    text: "Insertion "
                }],
                index: 1,
                counter: 19,
                start: 371,
                end: 400,
                measureText: 77
            }],
            startY: 606,
            endY: 619,
            displayedFeatures: 2,
            totalFeatures: 2
        }, {
            name: "SNP Location",
            type: "triangle",
            data: [{
                id: "SNP123",
                fill: "rgb(100,0,0)",
                outline: "rgb(0,0,0)",
                offset: 23,
                index: 0,
                counter: 20,
                measureText: 43
            }, {
                id: "SNP234",
                fill: "rgb(100,0,0)",
                outline: "rgb(0,0,0)",
                offset: 45,
                index: 1,
                counter: 21,
                measureText: 43
            }, {
                id: "SNP345",
                fill: "rgb(100,0,0)",
                outline: "rgb(0,0,0)",
                offset: 135,
                index: 2,
                counter: 22,
                measureText: 43
            }, {
                id: "SNP456",
                fill: "rgb(100,0,0)",
                outline: "rgb(0,0,0)",
                offset: 172,
                index: 3,
                counter: 23,
                measureText: 43
            }, {
                id: "SNP567",
                fill: "rgb(100,0,0)",
                outline: "rgb(0,0,0)",
                offset: 180,
                index: 4,
                counter: 24,
                measureText: 43
            }, {
                id: "SNP678",
                fill: "rgb(100,0,0)",
                outline: "rgb(0,0,0)",
                offset: 190,
                index: 5,
                counter: 25,
                measureText: 43
            }, {
                id: "SNP789",
                fill: "rgb(100,0,0)",
                outline: "rgb(0,0,0)",
                offset: 195,
                index: 6,
                counter: 26,
                measureText: 43
            }],
            startY: 674,
            endY: 782,
            displayedFeatures: 7,
            totalFeatures: 7
        }, {
            name: "SNP Sequences",
            type: "sequence",
            subtype: "DNA",
            data: [{
                id: "SNP123",
                offset: 19,
                sequence: "CACA[AT]GCACCTTGTA",
                index: 0,
                counter: 27,
                measureText: 43
            }, {
                id: "SNP234",
                offset: 41,
                sequence: "ATCG[TG]AATA",
                index: 1,
                counter: 28,
                measureText: 43
            }, {
                id: "SNP789",
                offset: 116,
                sequence: "GCCC[CT]AGGG",
                index: 2,
                counter: 29,
                measureText: 43
            }]
        }]
    };
    this.dataSetIris = {
        x: {
            Species: ["setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "setosa", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "versicolor", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica", "virginica"]
        },
        y: {
            vars: ["Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width"],
            smps: ["s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23", "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31", "s32", "s33", "s34", "s35", "s36", "s37", "s38", "s39", "s40", "s41", "s42", "s43", "s44", "s45", "s46", "s47", "s48", "s49", "s50", "s51", "s52", "s53", "s54", "s55", "s56", "s57", "s58", "s59", "s60", "s61", "s62", "s63", "s64", "s65", "s66", "s67", "s68", "s69", "s70", "s71", "s72", "s73", "s74", "s75", "s76", "s77", "s78", "s79", "s80", "s81", "s82", "s83", "s84", "s85", "s86", "s87", "s88", "s89", "s90", "s91", "s92", "s93", "s94", "s95", "s96", "s97", "s98", "s99", "s100", "s101", "s102", "s103", "s104", "s105", "s106", "s107", "s108", "s109", "s110", "s111", "s112", "s113", "s114", "s115", "s116", "s117", "s118", "s119", "s120", "s121", "s122", "s123", "s124", "s125", "s126", "s127", "s128", "s129", "s130", "s131", "s132", "s133", "s134", "s135", "s136", "s137", "s138", "s139", "s140", "s141", "s142", "s143", "s144", "s145", "s146", "s147", "s148", "s149", "s150"],
            data: [
                [5.1, 4.9, 4.7, 4.6, 5, 5.4, 4.6, 5, 4.4, 4.9, 5.4, 4.8, 4.8, 4.3, 5.8, 5.7, 5.4, 5.1, 5.7, 5.1, 5.4, 5.1, 4.6, 5.1, 4.8, 5, 5, 5.2, 5.2, 4.7, 4.8, 5.4, 5.2, 5.5, 4.9, 5, 5.5, 4.9, 4.4, 5.1, 5, 4.5, 4.4, 5, 5.1, 4.8, 5.1, 4.6, 5.3, 5, 7, 6.4, 6.9, 5.5, 6.5, 5.7, 6.3, 4.9, 6.6, 5.2, 5, 5.9, 6, 6.1, 5.6, 6.7, 5.6, 5.8, 6.2, 5.6, 5.9, 6.1, 6.3, 6.1, 6.4, 6.6, 6.8, 6.7, 6, 5.7, 5.5, 5.5, 5.8, 6, 5.4, 6, 6.7, 6.3, 5.6, 5.5, 5.5, 6.1, 5.8, 5, 5.6, 5.7, 5.7, 6.2, 5.1, 5.7, 6.3, 5.8, 7.1, 6.3, 6.5, 7.6, 4.9, 7.3, 6.7, 7.2, 6.5, 6.4, 6.8, 5.7, 5.8, 6.4, 6.5, 7.7, 7.7, 6, 6.9, 5.6, 7.7, 6.3, 6.7, 7.2, 6.2, 6.1, 6.4, 7.2, 7.4, 7.9, 6.4, 6.3, 6.1, 7.7, 6.3, 6.4, 6, 6.9, 6.7, 6.9, 5.8, 6.8, 6.7, 6.7, 6.3, 6.5, 6.2, 5.9],
                [3.5, 3, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.4, 3, 3, 4, 4.4, 3.9, 3.5, 3.8, 3.8, 3.4, 3.7, 3.6, 3.3, 3.4, 3, 3.4, 3.5, 3.4, 3.2, 3.1, 3.4, 4.1, 4.2, 3.1, 3.2, 3.5, 3.6, 3, 3.4, 3.5, 2.3, 3.2, 3.5, 3.8, 3, 3.8, 3.2, 3.7, 3.3, 3.2, 3.2, 3.1, 2.3, 2.8, 2.8, 3.3, 2.4, 2.9, 2.7, 2, 3, 2.2, 2.9, 2.9, 3.1, 3, 2.7, 2.2, 2.5, 3.2, 2.8, 2.5, 2.8, 2.9, 3, 2.8, 3, 2.9, 2.6, 2.4, 2.4, 2.7, 2.7, 3, 3.4, 3.1, 2.3, 3, 2.5, 2.6, 3, 2.6, 2.3, 2.7, 3, 2.9, 2.9, 2.5, 2.8, 3.3, 2.7, 3, 2.9, 3, 3, 2.5, 2.9, 2.5, 3.6, 3.2, 2.7, 3, 2.5, 2.8, 3.2, 3, 3.8, 2.6, 2.2, 3.2, 2.8, 2.8, 2.7, 3.3, 3.2, 2.8, 3, 2.8, 3, 2.8, 3.8, 2.8, 2.8, 2.6, 3, 3.4, 3.1, 3, 3.1, 3.1, 3.1, 2.7, 3.2, 3.3, 3, 2.5, 3, 3.4, 3],
                [1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.6, 1.4, 1.1, 1.2, 1.5, 1.3, 1.4, 1.7, 1.5, 1.7, 1.5, 1, 1.7, 1.9, 1.6, 1.6, 1.5, 1.4, 1.6, 1.6, 1.5, 1.5, 1.4, 1.5, 1.2, 1.3, 1.4, 1.3, 1.5, 1.3, 1.3, 1.3, 1.6, 1.9, 1.4, 1.6, 1.4, 1.5, 1.4, 4.7, 4.5, 4.9, 4, 4.6, 4.5, 4.7, 3.3, 4.6, 3.9, 3.5, 4.2, 4, 4.7, 3.6, 4.4, 4.5, 4.1, 4.5, 3.9, 4.8, 4, 4.9, 4.7, 4.3, 4.4, 4.8, 5, 4.5, 3.5, 3.8, 3.7, 3.9, 5.1, 4.5, 4.5, 4.7, 4.4, 4.1, 4, 4.4, 4.6, 4, 3.3, 4.2, 4.2, 4.2, 4.3, 3, 4.1, 6, 5.1, 5.9, 5.6, 5.8, 6.6, 4.5, 6.3, 5.8, 6.1, 5.1, 5.3, 5.5, 5, 5.1, 5.3, 5.5, 6.7, 6.9, 5, 5.7, 4.9, 6.7, 4.9, 5.7, 6, 4.8, 4.9, 5.6, 5.8, 6.1, 6.4, 5.6, 5.1, 5.6, 6.1, 5.6, 5.5, 4.8, 5.4, 5.6, 5.1, 5.1, 5.9, 5.7, 5.2, 5, 5.2, 5.4, 5.1],
                [0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.2, 0.1, 0.1, 0.2, 0.4, 0.4, 0.3, 0.3, 0.3, 0.2, 0.4, 0.2, 0.5, 0.2, 0.2, 0.4, 0.2, 0.2, 0.2, 0.2, 0.4, 0.1, 0.2, 0.2, 0.2, 0.2, 0.1, 0.2, 0.2, 0.3, 0.3, 0.2, 0.6, 0.4, 0.3, 0.2, 0.2, 0.2, 0.2, 1.4, 1.5, 1.5, 1.3, 1.5, 1.3, 1.6, 1, 1.3, 1.4, 1, 1.5, 1, 1.4, 1.3, 1.4, 1.5, 1, 1.5, 1.1, 1.8, 1.3, 1.5, 1.2, 1.3, 1.4, 1.4, 1.7, 1.5, 1, 1.1, 1, 1.2, 1.6, 1.5, 1.6, 1.5, 1.3, 1.3, 1.3, 1.2, 1.4, 1.2, 1, 1.3, 1.2, 1.3, 1.3, 1.1, 1.3, 2.5, 1.9, 2.1, 1.8, 2.2, 2.1, 1.7, 1.8, 1.8, 2.5, 2, 1.9, 2.1, 2, 2.4, 2.3, 1.8, 2.2, 2.3, 1.5, 2.3, 2, 2, 1.8, 2.1, 1.8, 1.8, 1.8, 2.1, 1.6, 1.9, 2, 2.2, 1.5, 1.4, 2.3, 2.4, 1.8, 1.8, 2.1, 2.4, 2.3, 1.9, 2.3, 2.5, 2.3, 1.9, 2, 2.3, 1.8]
            ],
            desc: ["centimeters"]
        },
        m: {
            Name: "Anderson's Iris data set",
            Description: "The data set consists of 50 samples from each of three species of Iris (Iris setosa, Iris virginica and Iris versicolor). Four features were measured from each sample: the length and the width of the sepals and petals, in centimetres.",
            Reference: "R. A. Fisher (1936). The use of multiple measurements in taxonomic problems. Annals of Eugenics 7 (2): 179–188."
        }
    };
    this.dataSetScents = {
        x: {
            Sex: ["M", "F", "M", "M", "M", "F", "F", "F", "M", "F", "F", "F", "F", "M", "M", "M", "M", "M", "F", "F", "M"],
            Smoker: ["N", "Y", "N", "N", "N", "Y", "N", "N", "N", "N", "Y", "Y", "Y", "Y", "N", "N", "Y", "N", "Y", "N", "N"],
            Opinion: ["pos", "neg", "pos", "neg", "neg", "pos", "pos", "pos", "pos", "indiff", "pos", "indiff", "pos", "indiff", "indiff", "pos", "neg", "neg", "pos", "neg", "neg"],
            Age: [23, 43, 43, 32, 15, 37, 26, 35, 26, 31, 35, 55, 25, 39, 25, 26, 33, 62, 54, 38, 65],
            Order: ["1", "2", "1", "2", "1", "2", "1", "2", "1", "2", "1", "2", "1", "2", "1", "2", "1", "2", "1", "2", "1"]
        },
        y: {
            vars: ["U-Trial 1", "U-Trial 2", "U-Trial 3", "S-Trial 1", "S-Trial 2", "S-Trial 3"],
            smps: ["s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16", "s17", "s18", "s19", "s20", "s21"],
            data: [
                [38.4, 46.2, 72.5, 38, 82.8, 33.9, 50.4, 35, 32.8, 60.1, 75.1, 57.6, 55.5, 49.5, 40.9, 44.3, 93.8, 47.9, 75.2, 46.2, 56.3],
                [27.7, 57.2, 57.9, 38, 57.9, 32, 40.6, 33.1, 26.8, 53.2, 63.1, 57.7, 63.3, 45.8, 35.7, 46.8, 91.9, 59.9, 54.1, 39.3, 45.8],
                [25.7, 41.9, 51.9, 32.2, 64.7, 31.4, 40.1, 43.2, 33.9, 40.4, 58, 61.5, 44.6, 35.3, 37.2, 39.4, 77.4, 52.8, 63.6, 56.6, 58.9],
                [53.1, 54.7, 74.2, 49.6, 53.6, 51.3, 44.1, 34, 34.5, 59.1, 67.3, 75.5, 41.1, 52.2, 28.3, 74.9, 77.5, 50.9, 70.1, 60.3, 59.9],
                [30.6, 43.3, 53.4, 37.4, 48.6, 35.5, 46.9, 26.4, 25.1, 87.1, 43.8, 126.6, 41.8, 53.8, 26, 45.3, 55.8, 58.6, 44, 47.8, 36.8],
                [30.2, 56.7, 42.4, 34.4, 44.8, 42.9, 42.7, 24.8, 25.1, 59.2, 42.2, 48.4, 32, 48.1, 33.7, 42.6, 54.9, 64.5, 43.1, 52.8, 44.3]
            ],
            desc: ["time in seconds"]
        },
        m: {
            Name: "Scents",
            Description: "Data on the time subjects required to complete a pencil and paper maze when they were smelling a floral scent and when they were not.",
            Reference: "Hirsch, A. R., and Johnston, L. H. Odors and Learning, Smell & Taste Treatment and Research Foundation, Chicago."
        }
    };
    this.dataSetCancerSurvival = {
        z: {
            Description: ["Survival time in days"]
        },
        x: {
            Organ: ["Stomach", "Stomach", "Stomach", "Stomach", "Stomach", "Stomach", "Stomach", "Stomach", "Stomach", "Stomach", "Stomach", "Stomach", "Stomach", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Bronchus", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Colon", "Ovary", "Ovary", "Ovary", "Ovary", "Ovary", "Ovary", "Breast", "Breast", "Breast", "Breast", "Breast", "Breast", "Breast", "Breast", "Breast", "Breast", "Breast"]
        },
        y: {
            vars: ["Survival"],
            smps: ["s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23", "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31", "s32", "s33", "s34", "s35", "s36", "s37", "s38", "s39", "s40", "s41", "s42", "s43", "s44", "s45", "s46", "s47", "s48", "s49", "s50", "s51", "s52", "s53", "s54", "s55", "s56", "s57", "s58", "s59", "s60", "s61", "s62", "s63", "s64"],
            data: [
                [124, 42, 25, 45, 412, 51, 1112, 46, 103, 876, 146, 340, 396, 81, 461, 20, 450, 246, 166, 63, 64, 155, 859, 151, 166, 37, 223, 138, 72, 245, 248, 377, 189, 1843, 180, 537, 519, 455, 406, 365, 942, 776, 372, 163, 101, 20, 283, 1234, 89, 201, 356, 2970, 456, 1235, 24, 1581, 1166, 40, 727, 3808, 791, 1804, 3460, 719]
            ],
            desc: ["days"]
        },
        m: {
            Name: "Cancer Survival",
            Description: "Patients with advanced cancers of the stomach, bronchus, colon, ovary or breast were treated with ascorbate. The purpose of the study was to determine if the survival times differ with respect to the organ affected by the cancer.",
            Reference: "Cameron, E. and Pauling, L. (1978) Supplemental ascorbate in the supportive treatment of cancer: re-evaluation of prolongation of survival times in terminal human cancer. Proceedings of the National Academy of Science USA, 75. Also found in: Manly, B.F.J. (1986) Multivariate Statistical Methods: A Primer, New York: Chapman & Hall, 11. Also found in: Hand, D.J., et al. (1994) A Handbook of Small Data Sets, London: Chapman & Hall, 255."
        }
    };
    this.dataSetAgeHeight = {
        z: {
            Description: ["Age in months", "Mean height in centimeters for children at this age"]
        },
        y: {
            smps: ["s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12"],
            vars: ["Age", "Height"],
            data: [
                [18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
                [76.1, 77, 78.1, 78.2, 78.8, 79.7, 79.9, 81.1, 81.2, 81.8, 82.8, 83.5]
            ]
        },
        m: {
            Name: "Age Height",
            Description: "Mean heights of a group of children in Kalama, an Egyptian village that is the site of a study of nutrition in developing countries. The data were obtained by measuring the heights of all 161 children in the village each month over several years.",
            Reference: "Moore, David S., and George P. McCabe (1989). Introduction to the Practice of Statistics, p. 118"
        }
    };
    this.dataSetAlcoholTobacco = {
        z: {
            Description: ["Average weekly household spending on alcoholic beverages in pounds", "Average weekly household spending on tobacco products in pounds"]
        },
        y: {
            smps: ["North", "Yorkshire", "Northeast", "East Midlands", "West Midlands", "East Anglia", "Southeast", "Southwest", "Wales", "Scotland", "Northern Ireland"],
            vars: ["Alcohol", "Tobacco"],
            data: [
                [6.47, 6.13, 6.19, 4.89, 5.63, 4.52, 5.89, 4.79, 3.53, 6.08, 4.02],
                [4.03, 3.76, 3.77, 3.34, 3.47, 2.92, 3.2, 2.71, 3.53, 4.51, 4.56]
            ]
        },
        m: {
            Name: "Alcohol Tobacco",
            Description: "Average weekly household spending, in British pounds, on tobacco products and alcoholic beverages for each of the 11 regions of Great Britain.",
            Reference: "Moore, David S., and George P. McCabe (1989). Introduction to the Practice of Statistics, p. 179. Original source: Family Expenditure Survey, Department of Employment, 1981 (British official statistics)"
        }
    };
    this.dataSetBreastCancer = {
        z: {
            Description: ["Mortality index for neoplasms of the female breast", "Mean annual temperature (in degrees F)"]
        },
        y: {
            smps: ["s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16"],
            vars: ["Mortality", "Temperature"],
            data: [
                [102.5, 104.5, 100.4, 95.9, 87, 95, 88.6, 89.2, 78.9, 84.6, 81.7, 72.2, 65.1, 68.1, 67.3, 52.5],
                [51.3, 49.9, 50, 49.2, 48.5, 47.8, 47.3, 45.1, 46.3, 42.1, 44.2, 43.5, 42.3, 40.2, 31.8, 34]
            ]
        },
        m: {
            Name: "Breast Cancer",
            Description: "Data contains the mean annual temperature (in degrees F) and Mortality Index for neoplasms of the female breast. Data were taken from certain regions of Great Britain, Norway, and Sweden.",
            Reference: "Velleman, P. F. and Hoaglin, D. C. (1981). Applications, Basics, and Computing of Exploratory Data Analysis. Belmont. CA: Wadsworth, Inc., pp. 127-134."
        }
    };
    this.dataSetCars = {
        z: {
            Description: ["Miles per gallon, a measure of gas mileage", "Weight of vehicle", "Drive ratio of the automobile", "Horsepower", "Displacement of the car (in cubic inches)", "Number of cylinders"]
        },
        x: {
            Country: ["U.S.", "U.S.", "U.S.", "U.S.", "U.S.", "Japan", "Japan", "U.S.", "Germany", "Sweden", "Sweden", "France", "U.S.", "U.S.", "U.S.", "U.S.", "U.S.", "U.S.", "U.S.", "U.S.", "U.S.", "U.S.", "Japan", "Japan", "U.S.", "Germany", "Japan", "U.S.", "U.S.", "U.S.", "U.S.", "U.S.", "Japan", "Italy", "Germany", "Japan", "Germany", "Germany"]
        },
        y: {
            smps: ["Buick Estate Wagon", "Ford Country Squire Wagon", "Chevy Malibu Wagon", "Chrysler LeBaron Wagon", "Chevette", "Toyota Corona", "Datsun 510", "Dodge Omni", "Audi 5000", "Volvo 240 GL", "Saab 99 GLE", "Peugeot 694 SL", "Buick Century Special", "Mercury Zephyr", "Dodge Aspen", "AMC Concord D/L", "Chevy Caprice Classic", "Ford LTD", "Mercury Grand Marquis", "Dodge St Regis", "Ford Mustang 4", "Ford Mustang Ghia", "Mazda GLC", "Dodge Colt", "AMC Spirit", "VW Scirocco", "Honda Accord LX", "Buick Skylark", "Chevy Citation", "Olds Omega", "Pontiac Phoenix", "Plymouth Horizon", "Datsun 210", "Fiat Strada", "VW Dasher", "Datsun 810", "BMW 320i", "VW Rabbit"],
            vars: ["MPG", "Weight", "Drive_Ratio", "Horsepower", "Displacement", "Cylinders"],
            data: [
                [16.9, 15.5, 19.2, 18.5, 30, 27.5, 27.2, 30.9, 20.3, 17, 21.6, 16.2, 20.6, 20.8, 18.6, 18.1, 17, 17.6, 16.5, 18.2, 26.5, 21.9, 34.1, 35.1, 27.4, 31.5, 29.5, 28.4, 28.8, 26.8, 33.5, 34.2, 31.8, 37.3, 30.5, 22, 21.5, 31.9],
                [4.36, 4.054, 3.605, 3.94, 2.155, 2.56, 2.3, 2.23, 2.83, 3.14, 2.795, 3.41, 3.38, 3.07, 3.62, 3.41, 3.84, 3.725, 3.955, 3.83, 2.585, 2.91, 1.975, 1.915, 2.67, 1.99, 2.135, 2.67, 2.595, 2.7, 2.556, 2.2, 2.02, 2.13, 2.19, 2.815, 2.6, 1.925],
                [2.73, 2.26, 2.56, 2.45, 3.7, 3.05, 3.54, 3.37, 3.9, 3.5, 3.77, 3.58, 2.73, 3.08, 2.71, 2.73, 2.41, 2.26, 2.26, 2.45, 3.08, 3.08, 3.73, 2.97, 3.08, 3.78, 3.05, 2.53, 2.69, 2.84, 2.69, 3.37, 3.7, 3.1, 3.7, 3.7, 3.64, 3.78],
                [155, 142, 125, 150, 68, 95, 97, 75, 103, 125, 115, 133, 105, 85, 110, 120, 130, 129, 138, 135, 88, 109, 65, 80, 80, 71, 68, 90, 115, 115, 90, 70, 65, 69, 78, 97, 110, 71],
                [350, 351, 267, 360, 98, 134, 119, 105, 131, 163, 121, 163, 231, 200, 225, 258, 305, 302, 351, 318, 140, 171, 86, 98, 121, 89, 98, 151, 173, 173, 151, 105, 85, 91, 97, 146, 121, 89],
                [8, 8, 8, 8, 4, 4, 4, 4, 5, 6, 4, 6, 6, 6, 6, 6, 8, 8, 8, 8, 4, 6, 4, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 4, 4, 6, 4, 4]
            ]
        },
        m: {
            Name: "Cars",
            Description: "Measurements on 38 1978-79 model automobiles. The gas mileage in miles per gallon as measured by Consumers Union on a test track. Other values as reported by automobile manufacturer.",
            Reference: "Henderson, H. V. and Velleman, P. F. (1981), Building Regression Models Interactively. Biometrics, 37, 391-411. Data originally collected from Consumer Reports."
        }
    };
    this.dataSetPopularKids = {
        z: {
            Description: ["Rank of make good grades (1=most important for popularity, 4=least important)", "Rank of being good at sports (1=most important for popularity, 4=least important)", "Rank of being handsome or pretty (1=most important for popularity, 4=least important)", "Rank of having lots of money (1=most important for popularity, 4=least important)"]
        },
        x: {
            Gender: ["boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "girl", "girl", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "girl", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy", "boy"],
            Grade: ["5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "5", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "4", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "5", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6", "6"],
            Age: ["11", "10", "11", "11", "10", "11", "10", "10", "10", "10", "11", "10", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "7", "9", "10", "9", "10", "10", "10", "9", "9", "10", "11", "9", "10", "10", "10", "9", "9", "10", "9", "11", "11", "11", "11", "11", "11", "11", "10", "11", "11", "10", "10", "10", "11", "11", "10", "11", "10", "10", "11", "10", "10", "10", "10", "11", "10", "10", "10", "9", "11", "12", "10", "11", "11", "10", "10", "12", "11", "11", "10", "10", "10", "10", "10", "11", "11", "11", "11", "11", "11", "11", "11", "13", "11", "11", "11", "12", "11", "11", "11", "11", "11", "11", "11", "11", "12", "11", "12", "11", "11", "11", "11", "11", "11", "11", "12", "11", "11", "11", "12", "12", "11", "11", "12", "11", "11", "12", "12", "11", "12", "12", "12", "12", "11", "11", "11", "12", "11", "11", "12", "11", "11", "11", "12", "12", "11", "12", "11", "12", "11", "12", "11", "11", "11", "11", "11", "11", "12", "11", "12", "11", "12", "12", "12", "12", "13", "11", "12", "12", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "10", "9", "10", "9", "9", "10", "9", "9", "9", "9", "9", "10", "10", "10", "11", "10", "11", "11", "10", "10", "10", "11", "10", "10", "10", "10", "10", "10", "11", "10", "11", "11", "10", "10", "11", "10", "12", "10", "10", "10", "10", "10", "11", "10", "10", "10", "10", "10", "11", "10", "10", "10", "10", "9", "10", "10", "9", "9", "9", "10", "9", "9", "9", "9", "12", "11", "11", "11", "11", "12", "12", "11", "11", "12", "11", "11", "11", "11", "11", "11", "12", "11", "11", "11", "11", "12", "11", "12", "11", "11", "12", "13", "11", "11", "12", "11", "12", "11", "12", "11", "12", "11", "11", "12", "11", "11", "12", "12", "11", "12", "11", "13", "11", "11", "11", "11", "9", "9", "9", "9", "9", "9", "10", "10", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "10", "9", "10", "10", "11", "10", "10", "10", "11", "10", "10", "11", "10", "10", "10", "10", "10", "10", "10", "10", "10", "10", "10", "10", "11", "10", "11", "10", "10", "10", "10", "11", "9", "10", "10", "10", "10", "11", "11", "11", "9", "11", "10", "10", "9", "9", "9", "9", "9", "10", "9", "9", "9", "9", "9", "10", "11", "10", "11", "10", "10", "11", "10", "10", "10", "10", "10", "10", "11", "10", "10", "10", "10", "10", "11", "10", "10", "11", "10", "10", "11", "10", "11", "11", "11", "10", "10", "11", "10", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "9", "11", "11", "11", "11", "11", "11", "11", "11", "11", "11", "11", "11", "11", "11", "12", "11", "11", "11", "11", "12", "11", "11", "11", "11", "11", "11", "11", "11", "11", "11", "11", "11", "11", "11", "12", "11", "11", "11", "12", "11", "11", "12", "11", "11", "11", "11", "11", "11", "11"],
            Race: ["White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "Other", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "Other", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "Other", "White", "White", "White", "White", "White", "Other", "White", "Other", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "Other", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "Other", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "Other", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White", "White"],
            "Urban/Rural": ["Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Suburban", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Rural", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban", "Urban"],
            School: ["Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Elm", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Elementary", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Brentwood Middle", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Ridge", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Sand", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Brown Middle", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Main", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Portage", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle", "Westdale Middle"],
            Goals: ["Sports", "Popular", "Popular", "Popular", "Popular", "Popular", "Popular", "Grades", "Sports", "Sports", "Sports", "Grades", "Popular", "Popular", "Popular", "Grades", "Sports", "Popular", "Grades", "Sports", "Popular", "Grades", "Popular", "Grades", "Grades", "Popular", "Popular", "Grades", "Popular", "Grades", "Grades", "Grades", "Grades", "Grades", "Sports", "Sports", "Popular", "Sports", "Grades", "Sports", "Grades", "Grades", "Popular", "Grades", "Popular", "Grades", "Popular", "Sports", "Grades", "Popular", "Grades", "Sports", "Sports", "Popular", "Sports", "Sports", "Grades", "Grades", "Grades", "Grades", "Grades", "Popular", "Grades", "Grades", "Grades", "Grades", "Grades", "Popular", "Grades", "Grades", "Popular", "Popular", "Grades", "Grades", "Grades", "Grades", "Grades", "Grades", "Grades", "Popular", "Grades", "Grades", "Grades", "Grades", "Popular", "Popular", "Grades", "Sports", "Popular", "Popular", "Popular", "Grades", "Sports", "Grades", "Popular", "Grades", "Popular", "Popular", "Popular", "Grades", "Grades", "Popular", "Grades", "Grades", "Grades", "Sports", "Grades", "Popular", "Grades", "Popular", "Popular", "Popular", "Grades", "Popular", "Grades", "Grades", "Grades", "Grades", "Sports", "Popular", "Grades", "Grades", "Grades", "Grades", "Grades", "Popular", "Grades", "Popular", "Popular", "Grades", "Grades", "Popular", "Grades", "Grades", "Popular", "Grades", "Sports", "Grades", "Sports", "Grades", "Grades", "Grades", "Grades", "Grades", "Sports", "Popular", "Grades", "Popular", "Grades", "Popular", "Grades", "Grades", "Grades", "Sports", "Sports", "Grades", "Popular", "Grades", "Popular", "Grades", "Sports", "Grades", "Grades", "Grades", "Popular", "Grades", "Grades", "Sports", "Sports", "Grades", "Sports", "Grades", "Grades", "Grades", "Popular", "Popular", "Sports", "Popular", "Sports", "Grades", "Sports", "Sports", "Popular", "Popular", "Grades", "Grades", "Grades", "Grades", "Popular", "Sports", "Popular", "Sports", "Popular", "Popular", "Grades", "Grades", "Sports", "Sports", "Sports", "Popular", "Grades", "Popular", "Sports", "Sports", "Sports", "Popular", "Grades", "Popular", "Sports", "Grades", "Popular", "Popular", "Sports", "Grades", "Popular", "Grades", "Popular", "Popular", "Grades", "Grades", "Sports", "Popular", "Popular", "Sports", "Sports", "Sports", "Grades", "Grades", "Grades", "Popular", "Popular", "Popular", "Grades", "Grades", "Grades", "Popular", "Grades", "Grades", "Grades", "Grades", "Grades", "Grades", "Grades", "Popular", "Grades", "Sports", "Sports", "Grades", "Popular", "Popular", "Grades", "Grades", "Grades", "Grades", "Grades", "Popular", "Sports", "Grades", "Popular", "Popular", "Grades", "Popular", "Popular", "Popular", "Grades", "Grades", "Grades", "Grades", "Popular", "Grades", "Grades", "Sports", "Sports", "Grades", "Sports", "Sports", "Sports", "Sports", "Popular", "Sports", "Sports", "Grades", "Grades", "Sports", "Popular", "Grades", "Grades", "Sports", "Grades", "Grades", "Popular", "Sports", "Grades", "Sports", "Popular", "Sports", "Grades", "Sports", "Popular", "Sports", "Grades", "Popular", "Grades", "Sports", "Grades", "Grades", "Grades", "Grades", "Grades", "Popular", "Sports", "Grades", "Grades", "Grades", "Grades", "Grades", "Popular", "Grades", "Sports", "Grades", "Sports", "Sports", "Grades", "Grades", "Grades", "Grades", "Grades", "Grades", "Grades", "Grades", "Popular", "Popular", "Grades", "Grades", "Popular", "Sports", "Grades", "Grades", "Popular", "Grades", "Popular", "Popular", "Popular", "Grades", "Grades", "Grades", "Grades", "Grades", "Sports", "Grades", "Grades", "Grades", "Grades", "Grades", "Sports", "Grades", "Grades", "Grades", "Grades", "Grades", "Sports", "Popular", "Grades", "Popular", "Grades", "Sports", "Sports", "Grades", "Sports", "Sports", "Grades", "Grades", "Grades", "Grades", "Grades", "Popular", "Popular", "Popular", "Grades", "Grades", "Grades", "Grades", "Popular", "Grades", "Grades", "Grades", "Grades", "Popular", "Grades", "Popular", "Popular", "Grades", "Popular", "Popular", "Grades", "Grades", "Grades", "Sports", "Sports", "Grades", "Sports", "Grades", "Popular", "Grades", "Popular", "Popular", "Sports", "Popular", "Grades", "Popular", "Sports", "Popular", "Popular", "Sports", "Sports", "Grades", "Grades", "Sports", "Grades", "Sports", "Popular", "Grades", "Grades", "Grades", "Popular", "Grades", "Popular", "Grades", "Popular", "Popular", "Popular", "Popular", "Popular", "Grades", "Popular", "Popular", "Grades", "Grades", "Grades", "Grades", "Popular", "Grades", "Popular", "Popular", "Grades", "Grades", "Popular", "Popular", "Grades", "Grades", "Grades", "Grades", "Sports", "Grades", "Grades", "Popular", "Popular", "Grades", "Grades", "Grades", "Popular", "Sports", "Grades", "Grades", "Sports", "Grades", "Grades", "Grades", "Grades", "Popular", "Grades", "Grades", "Grades", "Grades", "Sports", "Grades", "Popular", "Popular"]
        },
        y: {
            smps: ["s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23", "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31", "s32", "s33", "s34", "s35", "s36", "s37", "s38", "s39", "s40", "s41", "s42", "s43", "s44", "s45", "s46", "s47", "s48", "s49", "s50", "s51", "s52", "s53", "s54", "s55", "s56", "s57", "s58", "s59", "s60", "s61", "s62", "s63", "s64", "s65", "s66", "s67", "s68", "s69", "s70", "s71", "s72", "s73", "s74", "s75", "s76", "s77", "s78", "s79", "s80", "s81", "s82", "s83", "s84", "s85", "s86", "s87", "s88", "s89", "s90", "s91", "s92", "s93", "s94", "s95", "s96", "s97", "s98", "s99", "s100", "s101", "s102", "s103", "s104", "s105", "s106", "s107", "s108", "s109", "s110", "s111", "s112", "s113", "s114", "s115", "s116", "s117", "s118", "s119", "s120", "s121", "s122", "s123", "s124", "s125", "s126", "s127", "s128", "s129", "s130", "s131", "s132", "s133", "s134", "s135", "s136", "s137", "s138", "s139", "s140", "s141", "s142", "s143", "s144", "s145", "s146", "s147", "s148", "s149", "s150", "s151", "s152", "s153", "s154", "s155", "s156", "s157", "s158", "s159", "s160", "s161", "s162", "s163", "s164", "s165", "s166", "s167", "s168", "s169", "s170", "s171", "s172", "s173", "s174", "s175", "s176", "s177", "s178", "s179", "s180", "s181", "s182", "s183", "s184", "s185", "s186", "s187", "s188", "s189", "s190", "s191", "s192", "s193", "s194", "s195", "s196", "s197", "s198", "s199", "s200", "s201", "s202", "s203", "s204", "s205", "s206", "s207", "s208", "s209", "s210", "s211", "s212", "s213", "s214", "s215", "s216", "s217", "s218", "s219", "s220", "s221", "s222", "s223", "s224", "s225", "s226", "s227", "s228", "s229", "s230", "s231", "s232", "s233", "s234", "s235", "s236", "s237", "s238", "s239", "s240", "s241", "s242", "s243", "s244", "s245", "s246", "s247", "s248", "s249", "s250", "s251", "s252", "s253", "s254", "s255", "s256", "s257", "s258", "s259", "s260", "s261", "s262", "s263", "s264", "s265", "s266", "s267", "s268", "s269", "s270", "s271", "s272", "s273", "s274", "s275", "s276", "s277", "s278", "s279", "s280", "s281", "s282", "s283", "s284", "s285", "s286", "s287", "s288", "s289", "s290", "s291", "s292", "s293", "s294", "s295", "s296", "s297", "s298", "s299", "s300", "s301", "s302", "s303", "s304", "s305", "s306", "s307", "s308", "s309", "s310", "s311", "s312", "s313", "s314", "s315", "s316", "s317", "s318", "s319", "s320", "s321", "s322", "s323", "s324", "s325", "s326", "s327", "s328", "s329", "s330", "s331", "s332", "s333", "s334", "s335", "s336", "s337", "s338", "s339", "s340", "s341", "s342", "s343", "s344", "s345", "s346", "s347", "s348", "s349", "s350", "s351", "s352", "s353", "s354", "s355", "s356", "s357", "s358", "s359", "s360", "s361", "s362", "s363", "s364", "s365", "s366", "s367", "s368", "s369", "s370", "s371", "s372", "s373", "s374", "s375", "s376", "s377", "s378", "s379", "s380", "s381", "s382", "s383", "s384", "s385", "s386", "s387", "s388", "s389", "s390", "s391", "s392", "s393", "s394", "s395", "s396", "s397", "s398", "s399", "s400", "s401", "s402", "s403", "s404", "s405", "s406", "s407", "s408", "s409", "s410", "s411", "s412", "s413", "s414", "s415", "s416", "s417", "s418", "s419", "s420", "s421", "s422", "s423", "s424", "s425", "s426", "s427", "s428", "s429", "s430", "s431", "s432", "s433", "s434", "s435", "s436", "s437", "s438", "s439", "s440", "s441", "s442", "s443", "s444", "s445", "s446", "s447", "s448", "s449", "s450", "s451", "s452", "s453", "s454", "s455", "s456", "s457", "s458", "s459", "s460", "s461", "s462", "s463", "s464", "s465", "s466", "s467", "s468", "s469", "s470", "s471", "s472", "s473", "s474", "s475", "s476", "s477", "s478"],
            vars: ["Grades", "Sports", "Looks", "Money"],
            data: [
                [1, 2, 4, 2, 4, 4, 3, 3, 3, 4, 2, 2, 2, 4, 4, 1, 3, 3, 2, 3, 4, 1, 4, 4, 1, 2, 2, 4, 2, 1, 2, 1, 3, 2, 3, 4, 3, 3, 2, 4, 2, 2, 3, 2, 2, 4, 4, 4, 2, 3, 2, 4, 3, 3, 4, 4, 2, 1, 2, 2, 2, 4, 3, 3, 2, 2, 3, 4, 1, 2, 4, 2, 3, 2, 3, 2, 2, 2, 1, 3, 1, 3, 3, 2, 2, 3, 1, 1, 2, 1, 1, 4, 1, 3, 1, 2, 4, 4, 3, 2, 4, 4, 3, 4, 4, 3, 4, 1, 3, 4, 2, 2, 2, 4, 3, 4, 3, 4, 4, 1, 4, 4, 3, 4, 4, 3, 3, 3, 4, 4, 1, 3, 1, 2, 4, 4, 3, 4, 2, 2, 2, 4, 4, 4, 2, 3, 3, 3, 3, 2, 1, 2, 1, 2, 2, 4, 3, 3, 3, 1, 2, 1, 2, 4, 4, 4, 4, 1, 1, 2, 3, 1, 1, 1, 1, 2, 1, 3, 2, 1, 3, 2, 2, 4, 1, 3, 2, 1, 2, 4, 1, 2, 4, 3, 1, 1, 3, 4, 2, 1, 1, 3, 1, 2, 3, 4, 3, 4, 3, 3, 2, 3, 4, 1, 4, 1, 4, 1, 1, 1, 2, 4, 2, 4, 2, 3, 4, 2, 1, 2, 3, 1, 2, 1, 2, 3, 2, 3, 3, 1, 2, 1, 3, 2, 1, 3, 3, 2, 4, 3, 4, 4, 1, 4, 3, 1, 4, 4, 2, 3, 1, 3, 1, 4, 4, 2, 2, 1, 4, 3, 4, 2, 2, 4, 4, 4, 3, 4, 4, 2, 3, 4, 4, 4, 2, 3, 2, 3, 3, 4, 4, 3, 1, 4, 4, 4, 4, 3, 4, 3, 1, 4, 1, 4, 2, 2, 3, 3, 1, 2, 1, 1, 1, 4, 1, 3, 1, 3, 1, 3, 2, 2, 2, 4, 2, 2, 4, 1, 2, 4, 3, 2, 1, 1, 4, 2, 1, 4, 1, 4, 2, 4, 2, 1, 1, 2, 1, 1, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, 1, 2, 2, 3, 1, 3, 3, 2, 2, 3, 4, 3, 4, 1, 1, 3, 1, 2, 4, 3, 1, 1, 1, 2, 3, 2, 3, 1, 1, 3, 1, 2, 3, 1, 3, 2, 3, 1, 2, 3, 3, 3, 3, 4, 4, 2, 2, 3, 3, 2, 2, 3, 3, 4, 3, 3, 3, 4, 1, 2, 2, 1, 4, 3, 2, 1, 3, 4, 4, 3, 3, 3, 4, 3, 4, 4, 4, 4, 3, 2, 4, 3, 3, 4, 3, 2, 4, 2, 3, 2, 2, 4, 3, 2, 4, 4, 3, 4, 3, 3, 3, 3, 4, 3, 4, 3, 3, 3, 1, 3, 2, 3, 3, 4, 3, 4, 4, 4, 4, 4],
                [2, 1, 3, 3, 2, 2, 4, 4, 2, 3, 3, 3, 3, 2, 3, 3, 1, 4, 3, 2, 3, 4, 2, 3, 2, 3, 3, 2, 3, 2, 4, 2, 1, 1, 1, 3, 2, 1, 3, 1, 1, 1, 2, 1, 1, 1, 3, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 1, 1, 4, 1, 1, 1, 2, 3, 1, 2, 3, 2, 3, 4, 4, 1, 3, 2, 4, 4, 4, 1, 1, 3, 2, 3, 3, 3, 3, 3, 1, 2, 4, 2, 4, 2, 3, 4, 3, 3, 3, 2, 3, 1, 1, 3, 2, 1, 3, 3, 1, 3, 3, 2, 2, 4, 3, 3, 3, 2, 3, 2, 2, 2, 1, 1, 2, 2, 1, 3, 1, 2, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 2, 1, 2, 3, 2, 1, 3, 1, 1, 3, 2, 2, 1, 1, 2, 3, 3, 4, 4, 2, 4, 3, 4, 2, 1, 3, 2, 2, 4, 1, 2, 3, 1, 2, 1, 3, 4, 3, 3, 1, 2, 3, 4, 2, 2, 2, 1, 1, 1, 1, 2, 1, 2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3, 1, 1, 1, 1, 2, 1, 2, 3, 2, 3, 4, 2, 4, 2, 4, 1, 1, 3, 1, 3, 4, 1, 3, 2, 2, 1, 2, 4, 2, 2, 3, 3, 2, 2, 1, 3, 1, 2, 3, 1, 2, 2, 2, 3, 3, 4, 2, 1, 2, 1, 4, 2, 3, 1, 1, 2, 2, 1, 1, 1, 2, 1, 3, 2, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 3, 1, 2, 1, 2, 3, 3, 1, 1, 4, 2, 2, 2, 1, 3, 2, 2, 3, 2, 1, 3, 1, 2, 1, 1, 3, 1, 1, 1, 1, 2, 2, 1, 3, 2, 4, 2, 2, 1, 1, 2, 3, 4, 1, 3, 3, 1, 2, 3, 4, 2, 2, 1, 1, 4, 1, 2, 1, 1, 1, 1, 4, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 3, 2, 3, 2, 2, 1, 3, 3, 1, 1, 3, 2, 3, 1, 2, 4, 1, 2, 3, 2, 2, 4, 1, 2, 1, 3, 1, 3, 1, 1, 1, 2, 1, 1, 3, 1, 4, 2, 2, 4, 4, 2, 2, 3, 2, 2, 2, 3, 4, 4, 4, 3, 3, 2, 1, 2, 1, 3, 2, 2, 2, 2, 3, 1, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 1, 4, 3, 3, 2, 3, 1, 2, 2, 3, 1, 3, 4, 2, 4, 4, 2, 2, 3, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1],
                [4, 4, 1, 4, 1, 1, 1, 2, 1, 2, 1, 4, 4, 3, 2, 2, 2, 1, 1, 1, 1, 2, 1, 2, 3, 1, 1, 1, 4, 4, 3, 4, 2, 3, 2, 2, 1, 4, 1, 3, 3, 4, 4, 3, 4, 2, 1, 1, 3, 1, 3, 2, 2, 1, 3, 3, 3, 4, 1, 3, 3, 2, 2, 1, 3, 4, 2, 1, 2, 4, 1, 1, 1, 1, 1, 1, 4, 1, 3, 1, 2, 1, 2, 4, 1, 1, 2, 2, 1, 2, 4, 2, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 2, 1, 1, 3, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 4, 2, 3, 3, 1, 2, 2, 2, 4, 4, 4, 2, 2, 2, 1, 2, 2, 2, 2, 4, 3, 4, 3, 3, 3, 3, 1, 1, 4, 3, 1, 3, 3, 2, 2, 2, 1, 3, 4, 3, 2, 3, 2, 2, 3, 1, 3, 1, 1, 2, 1, 3, 1, 1, 3, 2, 3, 3, 1, 2, 4, 4, 1, 1, 2, 2, 2, 1, 4, 3, 4, 1, 4, 3, 2, 2, 2, 1, 2, 1, 1, 1, 1, 4, 1, 4, 1, 3, 2, 3, 3, 1, 3, 2, 4, 4, 3, 3, 4, 1, 1, 2, 1, 3, 3, 1, 1, 2, 4, 2, 3, 2, 1, 3, 2, 1, 1, 3, 1, 1, 1, 1, 2, 1, 1, 3, 3, 1, 3, 1, 4, 2, 3, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 1, 1, 2, 2, 1, 3, 3, 2, 2, 1, 2, 4, 1, 3, 2, 4, 2, 2, 2, 3, 2, 1, 1, 1, 4, 1, 4, 3, 1, 2, 2, 3, 1, 1, 1, 3, 3, 2, 3, 3, 1, 4, 2, 2, 4, 4, 2, 4, 1, 4, 3, 4, 3, 1, 3, 4, 1, 1, 1, 3, 3, 2, 4, 4, 2, 2, 2, 1, 2, 3, 4, 2, 3, 3, 3, 2, 4, 2, 4, 4, 3, 3, 4, 3, 2, 3, 3, 4, 2, 3, 2, 4, 3, 3, 1, 1, 1, 1, 3, 3, 2, 2, 1, 2, 2, 2, 4, 2, 3, 1, 1, 4, 3, 2, 1, 3, 1, 2, 3, 2, 1, 2, 2, 3, 4, 2, 1, 2, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 2, 3, 1, 1, 4, 1, 1, 4, 3, 2, 2, 3, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 4, 3, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 3, 2, 3, 2, 2, 1, 1, 2, 2, 1, 3, 2],
                [3, 3, 2, 1, 3, 3, 2, 1, 4, 1, 4, 1, 1, 1, 1, 4, 4, 2, 4, 4, 2, 3, 3, 1, 4, 4, 4, 3, 1, 3, 1, 3, 4, 4, 4, 1, 4, 2, 4, 2, 4, 3, 1, 4, 3, 3, 2, 3, 4, 4, 4, 3, 4, 4, 2, 2, 4, 3, 4, 4, 4, 3, 4, 2, 4, 3, 4, 3, 4, 3, 3, 4, 4, 4, 2, 3, 3, 4, 4, 2, 3, 2, 4, 3, 4, 4, 4, 4, 4, 4, 2, 3, 4, 2, 4, 3, 3, 2, 2, 4, 2, 2, 4, 2, 3, 4, 1, 4, 4, 2, 4, 4, 4, 2, 4, 3, 2, 2, 1, 4, 3, 2, 4, 3, 3, 4, 4, 4, 3, 3, 2, 4, 4, 4, 2, 3, 4, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 3, 4, 3, 4, 4, 4, 2, 4, 4, 2, 4, 4, 4, 4, 1, 3, 3, 2, 4, 3, 4, 4, 4, 4, 4, 2, 3, 4, 2, 4, 3, 4, 4, 4, 3, 4, 1, 4, 4, 4, 3, 3, 3, 2, 2, 4, 4, 4, 3, 1, 2, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 4, 4, 3, 3, 3, 2, 2, 4, 4, 4, 4, 2, 4, 3, 3, 2, 1, 4, 3, 4, 4, 4, 3, 4, 1, 4, 3, 4, 2, 4, 4, 4, 2, 4, 4, 4, 4, 4, 3, 2, 3, 3, 4, 2, 4, 4, 2, 2, 4, 4, 2, 4, 4, 3, 3, 4, 4, 3, 3, 4, 3, 4, 3, 3, 2, 3, 4, 3, 1, 4, 4, 3, 3, 3, 1, 4, 4, 4, 2, 3, 1, 4, 4, 3, 3, 3, 2, 2, 3, 2, 4, 2, 4, 3, 4, 3, 4, 4, 4, 4, 4, 4, 4, 2, 3, 4, 4, 2, 3, 4, 3, 4, 3, 2, 3, 4, 3, 4, 3, 2, 4, 3, 4, 4, 3, 3, 3, 1, 3, 3, 4, 1, 4, 3, 4, 1, 4, 4, 4, 3, 3, 3, 3, 4, 4, 3, 4, 1, 4, 4, 3, 4, 4, 4, 2, 4, 4, 4, 2, 4, 2, 4, 4, 4, 4, 4, 3, 4, 4, 3, 4, 4, 4, 3, 2, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 2, 2, 4, 3, 4, 4, 3, 3, 4, 4, 2, 4, 1, 1, 1, 2, 3, 3, 2, 2, 4, 3, 4, 4, 1, 1, 4, 4, 4, 1, 4, 3, 3, 3, 3, 4, 4, 2, 4, 4, 3, 4, 1, 2, 4, 4, 1, 4, 3, 4, 4, 3, 2, 2, 3, 2, 2, 4, 4, 2, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 3, 3, 3, 2, 3]
            ]
        },
        m: {
            Name: "Popular Kids",
            Description: "Subjects were students in grades 4-6 from three school districts in Ingham and Clinton Counties, Michigan. Chase and Dummer stratified their sample, selecting students from urban, suburban, and rural school districts with approximately 1/3 of their sample coming from each district. Students indicated whether good grades, athletic ability, or popularity was most important to them. They also ranked four factors: grades, sports, looks, and money, in order of their importance for popularity. The questionnaire also asked for gender, grade level, and other demographic information.",
            Reference: "Chase, M. A., and Dummer, G. M. (1992), The Role of Sports as a Social Determinant for Children, Research Quarterly for Exercise and Sport, 63, 418-424"
        }
    };
    this.dataSetLesMiserables = {
        nodes: [{
            id: "Id0",
            name: "Myriel",
            group: 1
        }, {
            id: "Id1",
            name: "Napoleon",
            group: 1
        }, {
            id: "Id2",
            name: "Mlle. Baptistine",
            group: 1
        }, {
            id: "Id3",
            name: "Mme. Magloire",
            group: 1
        }, {
            id: "Id4",
            name: "Countess de Lo",
            group: 1
        }, {
            id: "Id5",
            name: "Geborand",
            group: 1
        }, {
            id: "Id6",
            name: "Champtercier",
            group: 1
        }, {
            id: "Id7",
            name: "Cravatte",
            group: 1
        }, {
            id: "Id8",
            name: "Count",
            group: 1
        }, {
            id: "Id9",
            name: "Old Man",
            group: 1
        }, {
            id: "Id10",
            name: "Labarre",
            group: 2
        }, {
            id: "Id11",
            name: "Valjean",
            group: 2
        }, {
            id: "Id12",
            name: "Marguerite",
            group: 3
        }, {
            id: "Id13",
            name: "Mme. de R",
            group: 2
        }, {
            id: "Id14",
            name: "Isabeau",
            group: 2
        }, {
            id: "Id15",
            name: "Gervais",
            group: 2
        }, {
            id: "Id16",
            name: "Tholomyes",
            group: 3
        }, {
            id: "Id17",
            name: "Listolier",
            group: 3
        }, {
            id: "Id18",
            name: "Fameuil",
            group: 3
        }, {
            id: "Id19",
            name: "Blacheville",
            group: 3
        }, {
            id: "Id20",
            name: "Favourite",
            group: 3
        }, {
            id: "Id21",
            name: "Dahlia",
            group: 3
        }, {
            id: "Id22",
            name: "Zephine",
            group: 3
        }, {
            id: "Id23",
            name: "Fantine",
            group: 3
        }, {
            id: "Id24",
            name: "Mme. Thenardier",
            group: 4
        }, {
            id: "Id25",
            name: "Thenardier",
            group: 4
        }, {
            id: "Id26",
            name: "Cosette",
            group: 5
        }, {
            id: "Id27",
            name: "Javert",
            group: 4
        }, {
            id: "Id28",
            name: "Fauchelevent",
            group: 0
        }, {
            id: "Id29",
            name: "Bamatabois",
            group: 2
        }, {
            id: "Id30",
            name: "Perpetue",
            group: 3
        }, {
            id: "Id31",
            name: "Simplice",
            group: 2
        }, {
            id: "Id32",
            name: "Scaufflaire",
            group: 2
        }, {
            id: "Id33",
            name: "Woman 1",
            group: 2
        }, {
            id: "Id34",
            name: "Judge",
            group: 2
        }, {
            id: "Id35",
            name: "Champmathieu",
            group: 2
        }, {
            id: "Id36",
            name: "Brevet",
            group: 2
        }, {
            id: "Id37",
            name: "Chenildieu",
            group: 2
        }, {
            id: "Id38",
            name: "Cochepaille",
            group: 2
        }, {
            id: "Id39",
            name: "Pontmercy",
            group: 4
        }, {
            id: "Id40",
            name: "Boulatruelle",
            group: 6
        }, {
            id: "Id41",
            name: "Eponine",
            group: 4
        }, {
            id: "Id42",
            name: "Anzelma",
            group: 4
        }, {
            id: "Id43",
            name: "Woman 2",
            group: 5
        }, {
            id: "Id44",
            name: "Mother Innocent",
            group: 0
        }, {
            id: "Id45",
            name: "Gribier",
            group: 0
        }, {
            id: "Id46",
            name: "Jondrette",
            group: 7
        }, {
            id: "Id47",
            name: "Mme. Burgon",
            group: 7
        }, {
            id: "Id48",
            name: "Gavroche",
            group: 8
        }, {
            id: "Id49",
            name: "Gillenormand",
            group: 5
        }, {
            id: "Id50",
            name: "Magnon",
            group: 5
        }, {
            id: "Id51",
            name: "Mlle. Gillenormand",
            group: 5
        }, {
            id: "Id52",
            name: "Mme. Pontmercy",
            group: 5
        }, {
            id: "Id53",
            name: "Mlle. Vaubois",
            group: 5
        }, {
            id: "Id54",
            name: "Lt. Gillenormand",
            group: 5
        }, {
            id: "Id55",
            name: "Marius",
            group: 8
        }, {
            id: "Id56",
            name: "Baroness T",
            group: 5
        }, {
            id: "Id57",
            name: "Mabeuf",
            group: 8
        }, {
            id: "Id58",
            name: "Enjolras",
            group: 8
        }, {
            id: "Id59",
            name: "Combeferre",
            group: 8
        }, {
            id: "Id60",
            name: "Prouvaire",
            group: 8
        }, {
            id: "Id61",
            name: "Feuilly",
            group: 8
        }, {
            id: "Id62",
            name: "Courfeyrac",
            group: 8
        }, {
            id: "Id63",
            name: "Bahorel",
            group: 8
        }, {
            id: "Id64",
            name: "Bossuet",
            group: 8
        }, {
            id: "Id65",
            name: "Joly",
            group: 8
        }, {
            id: "Id66",
            name: "Grantaire",
            group: 8
        }, {
            id: "Id67",
            name: "Mother Plutarch",
            group: 9
        }, {
            id: "Id68",
            name: "Gueulemer",
            group: 4
        }, {
            id: "Id69",
            name: "Babet",
            group: 4
        }, {
            id: "Id70",
            name: "Claquesous",
            group: 4
        }, {
            id: "Id71",
            name: "Montparnasse",
            group: 4
        }, {
            id: "Id72",
            name: "Toussaint",
            group: 5
        }, {
            id: "Id73",
            name: "Child 1",
            group: 10
        }, {
            id: "Id74",
            name: "Child 2",
            group: 10
        }, {
            id: "Id75",
            name: "Brujon",
            group: 4
        }, {
            id: "Id76",
            name: "Mme. Hucheloup",
            group: 8
        }],
        edges: [{
            id1: "Id1",
            id2: "Id0",
            value: 1
        }, {
            id1: "Id2",
            id2: "Id0",
            value: 8
        }, {
            id1: "Id3",
            id2: "Id0",
            value: 10
        }, {
            id1: "Id3",
            id2: "Id2",
            value: 6
        }, {
            id1: "Id4",
            id2: "Id0",
            value: 1
        }, {
            id1: "Id5",
            id2: "Id0",
            value: 1
        }, {
            id1: "Id6",
            id2: "Id0",
            value: 1
        }, {
            id1: "Id7",
            id2: "Id0",
            value: 1
        }, {
            id1: "Id8",
            id2: "Id0",
            value: 2
        }, {
            id1: "Id9",
            id2: "Id0",
            value: 1
        }, {
            id1: "Id11",
            id2: "Id10",
            value: 1
        }, {
            id1: "Id11",
            id2: "Id3",
            value: 3
        }, {
            id1: "Id11",
            id2: "Id2",
            value: 3
        }, {
            id1: "Id11",
            id2: "Id0",
            value: 5
        }, {
            id1: "Id12",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id13",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id14",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id15",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id17",
            id2: "Id16",
            value: 4
        }, {
            id1: "Id18",
            id2: "Id16",
            value: 4
        }, {
            id1: "Id18",
            id2: "Id17",
            value: 4
        }, {
            id1: "Id19",
            id2: "Id16",
            value: 4
        }, {
            id1: "Id19",
            id2: "Id17",
            value: 4
        }, {
            id1: "Id19",
            id2: "Id18",
            value: 4
        }, {
            id1: "Id20",
            id2: "Id16",
            value: 3
        }, {
            id1: "Id20",
            id2: "Id17",
            value: 3
        }, {
            id1: "Id20",
            id2: "Id18",
            value: 3
        }, {
            id1: "Id20",
            id2: "Id19",
            value: 4
        }, {
            id1: "Id21",
            id2: "Id16",
            value: 3
        }, {
            id1: "Id21",
            id2: "Id17",
            value: 3
        }, {
            id1: "Id21",
            id2: "Id18",
            value: 3
        }, {
            id1: "Id21",
            id2: "Id19",
            value: 3
        }, {
            id1: "Id21",
            id2: "Id20",
            value: 5
        }, {
            id1: "Id22",
            id2: "Id16",
            value: 3
        }, {
            id1: "Id22",
            id2: "Id17",
            value: 3
        }, {
            id1: "Id22",
            id2: "Id18",
            value: 3
        }, {
            id1: "Id22",
            id2: "Id19",
            value: 3
        }, {
            id1: "Id22",
            id2: "Id20",
            value: 4
        }, {
            id1: "Id22",
            id2: "Id21",
            value: 4
        }, {
            id1: "Id23",
            id2: "Id16",
            value: 3
        }, {
            id1: "Id23",
            id2: "Id17",
            value: 3
        }, {
            id1: "Id23",
            id2: "Id18",
            value: 3
        }, {
            id1: "Id23",
            id2: "Id19",
            value: 3
        }, {
            id1: "Id23",
            id2: "Id20",
            value: 4
        }, {
            id1: "Id23",
            id2: "Id21",
            value: 4
        }, {
            id1: "Id23",
            id2: "Id22",
            value: 4
        }, {
            id1: "Id23",
            id2: "Id12",
            value: 2
        }, {
            id1: "Id23",
            id2: "Id11",
            value: 9
        }, {
            id1: "Id24",
            id2: "Id23",
            value: 2
        }, {
            id1: "Id24",
            id2: "Id11",
            value: 7
        }, {
            id1: "Id25",
            id2: "Id24",
            value: 13
        }, {
            id1: "Id25",
            id2: "Id23",
            value: 1
        }, {
            id1: "Id25",
            id2: "Id11",
            value: 12
        }, {
            id1: "Id26",
            id2: "Id24",
            value: 4
        }, {
            id1: "Id26",
            id2: "Id11",
            value: 31
        }, {
            id1: "Id26",
            id2: "Id16",
            value: 1
        }, {
            id1: "Id26",
            id2: "Id25",
            value: 1
        }, {
            id1: "Id27",
            id2: "Id11",
            value: 17
        }, {
            id1: "Id27",
            id2: "Id23",
            value: 5
        }, {
            id1: "Id27",
            id2: "Id25",
            value: 5
        }, {
            id1: "Id27",
            id2: "Id24",
            value: 1
        }, {
            id1: "Id27",
            id2: "Id26",
            value: 1
        }, {
            id1: "Id28",
            id2: "Id11",
            value: 8
        }, {
            id1: "Id28",
            id2: "Id27",
            value: 1
        }, {
            id1: "Id29",
            id2: "Id23",
            value: 1
        }, {
            id1: "Id29",
            id2: "Id27",
            value: 1
        }, {
            id1: "Id29",
            id2: "Id11",
            value: 2
        }, {
            id1: "Id30",
            id2: "Id23",
            value: 1
        }, {
            id1: "Id31",
            id2: "Id30",
            value: 2
        }, {
            id1: "Id31",
            id2: "Id11",
            value: 3
        }, {
            id1: "Id31",
            id2: "Id23",
            value: 2
        }, {
            id1: "Id31",
            id2: "Id27",
            value: 1
        }, {
            id1: "Id32",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id33",
            id2: "Id11",
            value: 2
        }, {
            id1: "Id33",
            id2: "Id27",
            value: 1
        }, {
            id1: "Id34",
            id2: "Id11",
            value: 3
        }, {
            id1: "Id34",
            id2: "Id29",
            value: 2
        }, {
            id1: "Id35",
            id2: "Id11",
            value: 3
        }, {
            id1: "Id35",
            id2: "Id34",
            value: 3
        }, {
            id1: "Id35",
            id2: "Id29",
            value: 2
        }, {
            id1: "Id36",
            id2: "Id34",
            value: 2
        }, {
            id1: "Id36",
            id2: "Id35",
            value: 2
        }, {
            id1: "Id36",
            id2: "Id11",
            value: 2
        }, {
            id1: "Id36",
            id2: "Id29",
            value: 1
        }, {
            id1: "Id37",
            id2: "Id34",
            value: 2
        }, {
            id1: "Id37",
            id2: "Id35",
            value: 2
        }, {
            id1: "Id37",
            id2: "Id36",
            value: 2
        }, {
            id1: "Id37",
            id2: "Id11",
            value: 2
        }, {
            id1: "Id37",
            id2: "Id29",
            value: 1
        }, {
            id1: "Id38",
            id2: "Id34",
            value: 2
        }, {
            id1: "Id38",
            id2: "Id35",
            value: 2
        }, {
            id1: "Id38",
            id2: "Id36",
            value: 2
        }, {
            id1: "Id38",
            id2: "Id37",
            value: 2
        }, {
            id1: "Id38",
            id2: "Id11",
            value: 2
        }, {
            id1: "Id38",
            id2: "Id29",
            value: 1
        }, {
            id1: "Id39",
            id2: "Id25",
            value: 1
        }, {
            id1: "Id40",
            id2: "Id25",
            value: 1
        }, {
            id1: "Id41",
            id2: "Id24",
            value: 2
        }, {
            id1: "Id41",
            id2: "Id25",
            value: 3
        }, {
            id1: "Id42",
            id2: "Id41",
            value: 2
        }, {
            id1: "Id42",
            id2: "Id25",
            value: 2
        }, {
            id1: "Id42",
            id2: "Id24",
            value: 1
        }, {
            id1: "Id43",
            id2: "Id11",
            value: 3
        }, {
            id1: "Id43",
            id2: "Id26",
            value: 1
        }, {
            id1: "Id43",
            id2: "Id27",
            value: 1
        }, {
            id1: "Id44",
            id2: "Id28",
            value: 3
        }, {
            id1: "Id44",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id45",
            id2: "Id28",
            value: 2
        }, {
            id1: "Id47",
            id2: "Id46",
            value: 1
        }, {
            id1: "Id48",
            id2: "Id47",
            value: 2
        }, {
            id1: "Id48",
            id2: "Id25",
            value: 1
        }, {
            id1: "Id48",
            id2: "Id27",
            value: 1
        }, {
            id1: "Id48",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id49",
            id2: "Id26",
            value: 3
        }, {
            id1: "Id49",
            id2: "Id11",
            value: 2
        }, {
            id1: "Id50",
            id2: "Id49",
            value: 1
        }, {
            id1: "Id50",
            id2: "Id24",
            value: 1
        }, {
            id1: "Id51",
            id2: "Id49",
            value: 9
        }, {
            id1: "Id51",
            id2: "Id26",
            value: 2
        }, {
            id1: "Id51",
            id2: "Id11",
            value: 2
        }, {
            id1: "Id52",
            id2: "Id51",
            value: 1
        }, {
            id1: "Id52",
            id2: "Id39",
            value: 1
        }, {
            id1: "Id53",
            id2: "Id51",
            value: 1
        }, {
            id1: "Id54",
            id2: "Id51",
            value: 2
        }, {
            id1: "Id54",
            id2: "Id49",
            value: 1
        }, {
            id1: "Id54",
            id2: "Id26",
            value: 1
        }, {
            id1: "Id55",
            id2: "Id51",
            value: 6
        }, {
            id1: "Id55",
            id2: "Id49",
            value: 12
        }, {
            id1: "Id55",
            id2: "Id39",
            value: 1
        }, {
            id1: "Id55",
            id2: "Id54",
            value: 1
        }, {
            id1: "Id55",
            id2: "Id26",
            value: 21
        }, {
            id1: "Id55",
            id2: "Id11",
            value: 19
        }, {
            id1: "Id55",
            id2: "Id16",
            value: 1
        }, {
            id1: "Id55",
            id2: "Id25",
            value: 2
        }, {
            id1: "Id55",
            id2: "Id41",
            value: 5
        }, {
            id1: "Id55",
            id2: "Id48",
            value: 4
        }, {
            id1: "Id56",
            id2: "Id49",
            value: 1
        }, {
            id1: "Id56",
            id2: "Id55",
            value: 1
        }, {
            id1: "Id57",
            id2: "Id55",
            value: 1
        }, {
            id1: "Id57",
            id2: "Id41",
            value: 1
        }, {
            id1: "Id57",
            id2: "Id48",
            value: 1
        }, {
            id1: "Id58",
            id2: "Id55",
            value: 7
        }, {
            id1: "Id58",
            id2: "Id48",
            value: 7
        }, {
            id1: "Id58",
            id2: "Id27",
            value: 6
        }, {
            id1: "Id58",
            id2: "Id57",
            value: 1
        }, {
            id1: "Id58",
            id2: "Id11",
            value: 4
        }, {
            id1: "Id59",
            id2: "Id58",
            value: 15
        }, {
            id1: "Id59",
            id2: "Id55",
            value: 5
        }, {
            id1: "Id59",
            id2: "Id48",
            value: 6
        }, {
            id1: "Id59",
            id2: "Id57",
            value: 2
        }, {
            id1: "Id60",
            id2: "Id48",
            value: 1
        }, {
            id1: "Id60",
            id2: "Id58",
            value: 4
        }, {
            id1: "Id60",
            id2: "Id59",
            value: 2
        }, {
            id1: "Id61",
            id2: "Id48",
            value: 2
        }, {
            id1: "Id61",
            id2: "Id58",
            value: 6
        }, {
            id1: "Id61",
            id2: "Id60",
            value: 2
        }, {
            id1: "Id61",
            id2: "Id59",
            value: 5
        }, {
            id1: "Id61",
            id2: "Id57",
            value: 1
        }, {
            id1: "Id61",
            id2: "Id55",
            value: 1
        }, {
            id1: "Id62",
            id2: "Id55",
            value: 9
        }, {
            id1: "Id62",
            id2: "Id58",
            value: 17
        }, {
            id1: "Id62",
            id2: "Id59",
            value: 13
        }, {
            id1: "Id62",
            id2: "Id48",
            value: 7
        }, {
            id1: "Id62",
            id2: "Id57",
            value: 2
        }, {
            id1: "Id62",
            id2: "Id41",
            value: 1
        }, {
            id1: "Id62",
            id2: "Id61",
            value: 6
        }, {
            id1: "Id62",
            id2: "Id60",
            value: 3
        }, {
            id1: "Id63",
            id2: "Id59",
            value: 5
        }, {
            id1: "Id63",
            id2: "Id48",
            value: 5
        }, {
            id1: "Id63",
            id2: "Id62",
            value: 6
        }, {
            id1: "Id63",
            id2: "Id57",
            value: 2
        }, {
            id1: "Id63",
            id2: "Id58",
            value: 4
        }, {
            id1: "Id63",
            id2: "Id61",
            value: 3
        }, {
            id1: "Id63",
            id2: "Id60",
            value: 2
        }, {
            id1: "Id63",
            id2: "Id55",
            value: 1
        }, {
            id1: "Id64",
            id2: "Id55",
            value: 5
        }, {
            id1: "Id64",
            id2: "Id62",
            value: 12
        }, {
            id1: "Id64",
            id2: "Id48",
            value: 5
        }, {
            id1: "Id64",
            id2: "Id63",
            value: 4
        }, {
            id1: "Id64",
            id2: "Id58",
            value: 10
        }, {
            id1: "Id64",
            id2: "Id61",
            value: 6
        }, {
            id1: "Id64",
            id2: "Id60",
            value: 2
        }, {
            id1: "Id64",
            id2: "Id59",
            value: 9
        }, {
            id1: "Id64",
            id2: "Id57",
            value: 1
        }, {
            id1: "Id64",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id65",
            id2: "Id63",
            value: 5
        }, {
            id1: "Id65",
            id2: "Id64",
            value: 7
        }, {
            id1: "Id65",
            id2: "Id48",
            value: 3
        }, {
            id1: "Id65",
            id2: "Id62",
            value: 5
        }, {
            id1: "Id65",
            id2: "Id58",
            value: 5
        }, {
            id1: "Id65",
            id2: "Id61",
            value: 5
        }, {
            id1: "Id65",
            id2: "Id60",
            value: 2
        }, {
            id1: "Id65",
            id2: "Id59",
            value: 5
        }, {
            id1: "Id65",
            id2: "Id57",
            value: 1
        }, {
            id1: "Id65",
            id2: "Id55",
            value: 2
        }, {
            id1: "Id66",
            id2: "Id64",
            value: 3
        }, {
            id1: "Id66",
            id2: "Id58",
            value: 3
        }, {
            id1: "Id66",
            id2: "Id59",
            value: 1
        }, {
            id1: "Id66",
            id2: "Id62",
            value: 2
        }, {
            id1: "Id66",
            id2: "Id65",
            value: 2
        }, {
            id1: "Id66",
            id2: "Id48",
            value: 1
        }, {
            id1: "Id66",
            id2: "Id63",
            value: 1
        }, {
            id1: "Id66",
            id2: "Id61",
            value: 1
        }, {
            id1: "Id66",
            id2: "Id60",
            value: 1
        }, {
            id1: "Id67",
            id2: "Id57",
            value: 3
        }, {
            id1: "Id68",
            id2: "Id25",
            value: 5
        }, {
            id1: "Id68",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id68",
            id2: "Id24",
            value: 1
        }, {
            id1: "Id68",
            id2: "Id27",
            value: 1
        }, {
            id1: "Id68",
            id2: "Id48",
            value: 1
        }, {
            id1: "Id68",
            id2: "Id41",
            value: 1
        }, {
            id1: "Id69",
            id2: "Id25",
            value: 6
        }, {
            id1: "Id69",
            id2: "Id68",
            value: 6
        }, {
            id1: "Id69",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id69",
            id2: "Id24",
            value: 1
        }, {
            id1: "Id69",
            id2: "Id27",
            value: 2
        }, {
            id1: "Id69",
            id2: "Id48",
            value: 1
        }, {
            id1: "Id69",
            id2: "Id41",
            value: 1
        }, {
            id1: "Id70",
            id2: "Id25",
            value: 4
        }, {
            id1: "Id70",
            id2: "Id69",
            value: 4
        }, {
            id1: "Id70",
            id2: "Id68",
            value: 4
        }, {
            id1: "Id70",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id70",
            id2: "Id24",
            value: 1
        }, {
            id1: "Id70",
            id2: "Id27",
            value: 1
        }, {
            id1: "Id70",
            id2: "Id41",
            value: 1
        }, {
            id1: "Id70",
            id2: "Id58",
            value: 1
        }, {
            id1: "Id71",
            id2: "Id27",
            value: 1
        }, {
            id1: "Id71",
            id2: "Id69",
            value: 2
        }, {
            id1: "Id71",
            id2: "Id68",
            value: 2
        }, {
            id1: "Id71",
            id2: "Id70",
            value: 2
        }, {
            id1: "Id71",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id71",
            id2: "Id48",
            value: 1
        }, {
            id1: "Id71",
            id2: "Id41",
            value: 1
        }, {
            id1: "Id71",
            id2: "Id25",
            value: 1
        }, {
            id1: "Id72",
            id2: "Id26",
            value: 2
        }, {
            id1: "Id72",
            id2: "Id27",
            value: 1
        }, {
            id1: "Id72",
            id2: "Id11",
            value: 1
        }, {
            id1: "Id73",
            id2: "Id48",
            value: 2
        }, {
            id1: "Id74",
            id2: "Id48",
            value: 2
        }, {
            id1: "Id74",
            id2: "Id73",
            value: 3
        }, {
            id1: "Id75",
            id2: "Id69",
            value: 3
        }, {
            id1: "Id75",
            id2: "Id68",
            value: 3
        }, {
            id1: "Id75",
            id2: "Id25",
            value: 3
        }, {
            id1: "Id75",
            id2: "Id48",
            value: 1
        }, {
            id1: "Id75",
            id2: "Id41",
            value: 1
        }, {
            id1: "Id75",
            id2: "Id70",
            value: 1
        }, {
            id1: "Id75",
            id2: "Id71",
            value: 1
        }, {
            id1: "Id76",
            id2: "Id64",
            value: 1
        }, {
            id1: "Id76",
            id2: "Id65",
            value: 1
        }, {
            id1: "Id76",
            id2: "Id66",
            value: 1
        }, {
            id1: "Id76",
            id2: "Id63",
            value: 1
        }, {
            id1: "Id76",
            id2: "Id62",
            value: 1
        }, {
            id1: "Id76",
            id2: "Id48",
            value: 1
        }, {
            id1: "Id76",
            id2: "Id58",
            value: 1
        }],
        m: {
            Name: "Les Miserables",
            Description: "Coappearance network of characters in the novel Les Miserables",
            Reference: "D. E. Knuth, The Stanford GraphBase: A Platform for Combinatorial Computing, Addison-Wesley, Reading, MA (1993)."
        }
    };
    this.getDataSet = function(e) {
        if (e && this["dataSet" + e]) {
            return this["dataSet" + e]
        } else {
            if (e && e.match(/Random/)) {
                var c;
                var b = e.split(":");
                var a = {
                    randomDataVariables: this.randomDataVariables,
                    randomDataSamples: this.randomDataSamples,
                    randomDataVariableAnnotations: this.randomDataVariableAnnotations,
                    randomDataSampleAnnotations: this.randomDataSampleAnnotations,
                    randomDataUniform: this.randomDataUniform,
                    randomDataSymmetrical: this.randomDataSymmetrical,
                    randomDataGraphTime: this.isGraphTime,
                    randomMissingDataPercentage: this.randomMissingDataPercentage
                };
                if (b.length > 0) {
                    if (b[1] != null) {
                        this.randomDataVariables = Number(b[1])
                    }
                    if (b[2] != null) {
                        this.randomDataSamples = Number(b[2])
                    }
                    if (b[3] != null) {
                        this.randomDataVariableAnnotations = Number(b[3])
                    }
                    if (b[4] != null) {
                        this.randomDataSampleAnnotations = Number(b[4])
                    }
                    if (b[5] != null && Number(b[5]) > 0) {
                        this.randomDataUniform = true
                    } else {
                        this.randomDataUniform = false
                    } if (b[6] != null && Number(b[6]) > 0) {
                        this.randomDataSymmetrical = true
                    } else {
                        this.randomDataSymmetrical = false
                    } if (b[7] != null && Number(b[7]) > 0) {
                        this.isGraphTime = true
                    } else {
                        this.isGraphTime = false
                    } if (b[8] != null) {
                        this.randomMissingDataPercentage = Number(b[8])
                    }
                }
                c = this.createRandomData(true);
                this.randomDataVariables = a.randomDataVariables;
                this.randomDataSamples = a.randomDataSamples;
                this.randomDataVariableAnnotations = a.randomDataVariableAnnotations;
                this.randomDataSampleAnnotations = a.randomDataSampleAnnotations;
                this.randomDataUniform = a.randomDataUniform;
                this.randomDataSymmetrical = a.randomDataSymmetrical;
                this.isGraphTime = a.randomDataGraphTime;
                this.randomMissingDataPercentage = a.randomMissingDataPercentage;
                return c
            } else {
                return this.dataSetExample
            }
        }
    };
    this.getGenericDataSet = function() {
        return {
            x: this.dataSetGeneric.x,
            y: this.dataSetGeneric.y,
            z: this.dataSetGeneric.z,
            a: this.dataSetGeneric.a,
            venn: this.dataSetVenn.venn,
            market: this.dataSetMarket.market,
            nodes: this.dataSetNetworkRadial.nodes,
            edges: this.dataSetNetworkRadial.edges,
            tracks: this.dataSetGenomeAdvanced.tracks
        }
    };
    this.initializeExample = function() {
        this.dataSetExample = {
            x: this.dataSetGeneric.x,
            y: this.dataSetGeneric.y,
            z: this.dataSetGeneric.z,
            a: this.dataSetGeneric.a,
            venn: this.dataSetVenn.venn,
            market: this.dataSetMarket.market,
            nodes: this.dataSetNetworkRadial.nodes,
            edges: this.dataSetNetworkRadial.edges,
            tracks: this.dataSetGenomeAdvanced.tracks
        };
        this.dataSetSummaryExample = {
            x: this.dataSetGeneric.x,
            y: {
                vars: this.dataSetGeneric.y["vars"],
                smps: this.dataSetGeneric.y["smps"],
                mean: this.dataSetGeneric.y["data"],
                stdev: [
                    [1, 2, 3, 1, 2, 3],
                    [1, 2, 3, 1, 2, 3],
                    [1, 2, 3, 1, 2, 3],
                    [1, 2, 3, 1, 2, 3]
                ],
                n: [
                    [4, 5, 4, 5, 4, 5],
                    [4, 5, 4, 5, 4, 5],
                    [4, 5, 4, 5, 4, 5],
                    [4, 5, 4, 5, 4, 5]
                ],
                desc: this.dataSetGeneric.y["desc"]
            },
            z: this.dataSetGeneric.z,
            a: this.dataSetGeneric.a,
        }
    };
    this.initializeExample()
};
CanvasXpress.prototype.initData = function(data) {
    this.isValidPlotData = function(type) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        if (type == "cor" && level.cor) {
            return true
        } else {
            if (type == "venn" && this.data.venn) {
                return true
            } else {
                if (type == "network" && this.data.nodes) {
                    return true
                } else {
                    if (type == "genome" && this.data.tracks) {
                        return true
                    } else {
                        if (type == "sum" && level.sum && level.sum[0].length > 0) {
                            return true
                        } else {
                            if (type == "mean" && level.mean && level.mean[0].length > 0) {
                                return true
                            } else {
                                if (type == "median" && level.median && level.median[0].length > 0) {
                                    return true
                                } else {
                                    if (type == "iqr" && level.iqr1 && level.qtl1 && level.median && level.qtl3 && level.iqr3 && level.median[0].length > 0) {
                                        return true
                                    } else {
                                        if (type == "candle" && level.close && level.open && level.high && level.low && level.close[0].length > 0) {
                                            return true
                                        } else {
                                            if (type == "volume" && level.volume && level.volume[0].length > 0) {
                                                return true
                                            } else {
                                                if (type == "raw" && this.isRawData) {
                                                    return true
                                                } else {
                                                    if (type == "video" && this.data.video) {
                                                        return true
                                                    } else {
                                                        return false
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.setAllNodesVisible = function() {
        this.nodes = {};
        this.data.nodeIndices = {};
        for (var i = 0; i < this.data.nodes.length; i++) {
            var node = this.data.nodes[i];
            node.hide = false;
            this.nodes[node.id] = node;
            this.data.nodeIndices[node.id] = i
        }
        for (var i = 0; i < this.data.edges.length; i++) {
            this.data.edges[i].hide = false
        }
        this.filterData()
    };
    this.setNodeIndices = function() {
        this.nodes = {};
        this.data.nodeIndices = {};
        for (var i = 0; i < this.data.nodes.length; i++) {
            var node = this.data.nodes[i];
            this.nodes[node.id] = node;
            this.data.nodeIndices[node.id] = i
        }
    };
    this.setNodes = function() {
        if (this.data.nodeIndices) {
            this.nodes = {};
            for (var i = 0; i < this.data.nodes.length; i++) {
                var node = this.data.nodes[i];
                this.nodes[node.id] = node
            }
            this.data.nodes = [];
            for (var id in this.data.nodeIndices) {
                this.data.nodes[this.data.nodeIndices[id]] = this.nodes[id]
            }
        } else {
            this.setNodeIndices()
        }
    };
    this.hideUnhideNodes = function(nodeIds, hide) {
        hide = hide ? true : false;
        if (nodeIds) {
            if (this.isArray(nodeIds)) {
                for (var i = 0; i < nodeIds.length; i++) {
                    var nid = nodeIds[i];
                    var node = this.data.nodes[this.data.nodeIndices[nid]];
                    node.hide = hide;
                    if (this.nodes && this.nodes[nid]) {
                        this.nodes[nid].hide = hide
                    }
                }
            }
        } else {
            for (var i = 0; i < this.data.nodes.length; i++) {
                var node = this.data.nodes[i];
                node.hide = hide;
                node.hideChildren = hide;
                if (this.nodes && this.nodes[node.id]) {
                    this.nodes[node.id].hide = hide;
                    this.nodes[node.id].hideChildren = hide
                }
            }
        }
    };
    this.hideUnhideChildrenNodes = function(id, hide) {
        hide = hide ? true : false;
        if (this.nodeParentHood[id] && this.nodeParentHood[id].children) {
            for (var i = 0; i < this.nodeParentHood[id].children.length; i++) {
                var cid = this.nodeParentHood[id].children[i];
                this.data.nodes[this.data.nodeIndices[cid]].hiddenParent = hide;
                this.hideUnhideChildrenNodes(cid, hide)
            }
        }
    };
    this.resetNodeFilters = function(idx) {
        if (idx != null && this.filterNodeBy.length > 0) {
            this.filterNodeBy.splice(idx, 1);
            this.filterNodeByOp.splice(idx, 1);
            this.filterNodeByValue.splice(idx, 1);
            this.filterNodeByCase.splice(idx, 1)
        } else {
            this.filterNodeBy = [];
            this.filterNodeByOp = [];
            this.filterNodeByValue = [];
            this.filterNodeByCase = []
        }
    };
    this.resetEdgeFilters = function(idx) {
        if (idx != null && this.filterEdgeBy.length > 0) {
            this.filterEdgeBy.splice(idx, 1);
            this.filterEdgeByOp.splice(idx, 1);
            this.filterEdgeByValue.splice(idx, 1);
            this.filterEdgeByCase.splice(idx, 1)
        } else {
            this.filterEdgeBy = [];
            this.filterEdgeByOp = [];
            this.filterEdgeByValue = [];
            this.filterEdgeByCase = []
        }
    };
    this.setAllFeaturesVisible = function() {
        for (var i = 0; i < this.data.tracks.length; i++) {
            var track = this.data.tracks[i];
            track.hide = false;
            var features = track.data;
            for (var j = 0; j < features.length; j++) {
                features[j].hide = false
            }
        }
    };
    this.resetFeatureFilters = function(idx) {
        if (idx != null && this.filterFeatureBy.length > 0) {
            this.filterFeatureBy.splice(idx, 1);
            this.filterFeatureByOp.splice(idx, 1);
            this.filterFeatureByValue.splice(idx, 1);
            this.filterFeatureByCase.splice(idx, 1)
        } else {
            this.filterFeatureBy = [];
            this.filterFeatureByOp = [];
            this.filterFeatureByValue = [];
            this.filterFeatureByCase = []
        }
    };
    this.setSelectNodes = function(nodeIds) {
        this.selectNode = {};
        this.isSelectNodes = 0;
        for (var i = 0; i < nodeIds.length; i++) {
            this.selectNode[nodeIds[i]] = true;
            this.isSelectNodes++
        }
    };
    this.getAnnotations = function(isVar) {
        var ann = [];
        if (isVar) {
            if (this.data.z) {
                for (var annt in this.data.z) {
                    ann.push(annt)
                }
            }
        } else {
            if (this.data.x) {
                for (var annt in this.data.x) {
                    ann.push(annt)
                }
            }
        }
        return ann
    };
    this.getNetworkImages = function() {
        var images = [];
        if (this.graphType == "Network") {
            for (var i = 0; i < this.data.nodes.length; i++) {
                var node = this.data.nodes[i];
                if (node.imagePath) {
                    if (!node.imagePath.match(/^http:\/\//)) {
                        node.imagePath = this.imageDir + node.imagePath
                    }
                    images.push(node.imagePath)
                }
            }
        }
        return images
    };
    this.setAllVariablesVisible = function(indices) {
        if (this.data.y) {
            if (!this.data.y.vars && this.data.y.data) {
                this.data.y.vars = [];
                for (var i = 0; i < this.data.y.data.length; i++) {
                    this.data.y.vars.push("var" + (i + 1))
                }
            }
            this.varIndices = [];
            this.hiddenVars = [];
            if (indices) {
                for (var i = 0; i < indices.length; i++) {
                    this.varIndices.push(indices[i]);
                    this.hiddenVars.push(false)
                }
            } else {
                for (var i = 0; i < this.data.y.vars.length; i++) {
                    this.varIndices.push(i);
                    this.hiddenVars.push(false)
                }
            }
            this.filterData();
            var c = this.layoutComb ? this.layoutCurrent : 0;
            if (this.startingVarIndices) {
                if (this.startingVarIndices[c] && this.startingVarIndices[c].length == this.varIndices.length) {
                    this.varIndices = this.startingVarIndices[c]
                } else {
                    this.startingVarIndices[c] = []
                }
            }
        }
        if (this.data.y && this.data.a) {
            this.xAxisVarIndices = [];
            this.xAxis2VarIndices = [];
            if (this.data.a.xAxis) {
                this.xAxisVarIndices = this.getVariableIndices(this.data.a.xAxis)
            }
            if (this.data.a.xAxis2) {
                this.xAxis2VarIndices = this.getVariableIndices(this.data.a.xAxis2)
            }
        }
    };
    this.resetVariablesVisibleByAxis = function(axis) {
        if (this.data.a) {
            this.setVariablesVisibleByAxis(axis, this.getVariableIndices(this.data.a[axis]))
        }
    };
    this.setVariablesVisibleByAxis = function(axis, arr) {
        var index = axis + "VarIndices";
        this[index] = [];
        for (var i = 0; i < arr.length; i++) {
            this[index].push(arr[i])
        }
    };
    this.getVariablesVisibleByAxis = function(axis) {
        return this[axis + "VarIndices"]
    };
    this.getVariablesByAxis = function(axis) {
        if (this.data.a && this.data.a[axis]) {
            return this.data.a[axis]
        }
        return []
    };
    this.getVariablesByAnnotationLevel = function(annt, lev) {
        var v = [];
        if (annt && this.data.z[annt]) {
            if (lev) {
                for (var i = 0; i < this.varIndices.length; i++) {
                    var ii = this.varIndices[i];
                    if (this.data.z[annt][ii] == lev && !this.hiddenVars[ii]) {
                        v.push(ii)
                    }
                }
            } else {
                for (var i = 0; i < this.varIndices.length; i++) {
                    var ii = this.varIndices[i];
                    if (!this.data.z[annt][ii] && !this.hiddenVars[ii]) {
                        v.push(ii)
                    }
                }
            }
        }
        return v
    };
    this.setVariablesVisible = function(arr) {
        this.varIndices = [];
        for (var i = 0; i < arr.length; i++) {
            this.varIndices.push(arr[i])
        }
    };
    this.getVariableIndices = function(arr) {
        if (arr && this.data.y.vars) {
            var indices = [];
            if (this.isArray(arr)) {
                if (arr.length > 0) {
                    for (var i = 0; i < arr.length; i++) {
                        for (var j = 0; j < this.data.y.vars.length; j++) {
                            if (this.data.y.vars[j] == arr[i]) {
                                indices.push(j);
                                break
                            }
                        }
                    }
                    return indices
                }
            } else {
                for (var i = 0; i < this.data.y.vars.length; i++) {
                    if (this.data.y.vars[i] == arr) {
                        return i
                    }
                }
                return -1
            }
        }
    };
    this.hideUnhideVars = function(vars) {
        if (vars) {
            if (this.isArray(vars)) {
                for (var i = 0; i < vars.length; i++) {
                    for (var j = 0; j < this.data.y.vars.length; j++) {
                        if (this.data.y.vars[j] == vars[i]) {
                            if (this.hiddenVars[j]) {
                                this.hiddenVars[j] = false
                            } else {
                                this.hiddenVars[j] = true
                            }
                            break
                        }
                    }
                }
            } else {
                for (var i = 0; i < this.data.y.vars.length; i++) {
                    if (this.data.y.vars[i] == vars) {
                        if (this.hiddenVars[i]) {
                            this.hiddenVars[i] = false
                        } else {
                            this.hiddenVars[i] = true
                        }
                        break
                    }
                }
            }
            var arr = [];
            for (var i = 0; i < this.data.y.vars.length; i++) {
                if (!this.hiddenVars[i]) {
                    arr.push(i)
                }
            }
            this.setVariablesVisible(arr);
            var axes = ["xAxis", "xAxis2"];
            if (this.data.a) {
                for (var i = 0; i < axes.length; i++) {
                    var indices = this.getVariableIndices(this.data.a[axes[i]]);
                    if (indices.length > 0) {
                        var arr = [];
                        for (var j = 0; j < indices.length; j++) {
                            var jj = indices[j];
                            if (!this.hiddenVars[jj]) {
                                arr.push(jj)
                            }
                        }
                        this.setVariablesVisibleByAxis(axes[i], arr)
                    }
                }
            }
            this.draw()
        }
    };
    this.getVariables = function() {
        var variables = [];
        for (var i = 0; i < this.data.y.vars.length; i++) {
            var idx = -1;
            for (var j = 0; j < this.varIndices.length; j++) {
                if (this.varIndices[j] == i) {
                    idx = j;
                    break
                }
            }
            variables.push({
                name: this.data.y.vars[i],
                hidden: this.hiddenVars[i],
                index: idx
            })
        }
        return variables
    };
    this.resetVarFilters = function(idx) {
        if (idx != null && this.filterVarBy.length > 0) {
            this.filterVarBy.splice(idx, 1);
            this.filterVarByOp.splice(idx, 1);
            this.filterVarByValue.splice(idx, 1);
            this.filterVarByCase.splice(idx, 1);
            this.filteredVarIndices.splice(idx, 1)
        } else {
            this.filterVarBy = [];
            this.filterVarByOp = [];
            this.filterVarByValue = [];
            this.filterVarByCase = [];
            this.filteredVarIndices = []
        }
    };
    this.setAllSamplesVisible = function(indices) {
        if (this.data.y && this.data.y.smps) {
            if (!this.data.y.smps && this.data.y.data && this.data.y.vars) {
                this.data.y.smps = [];
                for (var i = 0; i < this.data.y.data.vars[0].length; i++) {
                    this.data.y.smps.push("smp" + (i + 1))
                }
            }
            this.smpIndices = [];
            this.hiddenSmps = [];
            if (indices) {
                for (var i = 0; i < indices.length; i++) {
                    this.smpIndices.push(indices[i]);
                    this.hiddenSmps.push(false)
                }
            } else {
                for (var i = 0; i < this.data.y.smps.length; i++) {
                    this.smpIndices.push(i);
                    this.hiddenSmps.push(false)
                }
            }
            this.filterData(true)
        }
        if (this.data.w && this.data.w.smps) {
            this.grpIndices = [];
            this.hiddenGrps = [];
            for (var i = 0; i < this.data.w.smps.length; i++) {
                this.grpIndices.push(i);
                this.hiddenGrps.push(false)
            }
        }
        var c = this.layoutComb ? this.layoutCurrent : 0;
        if (this.isGroupedData) {
            if (this.startingSmpIndices) {
                if (this.startingSmpIndices[c] && this.startingSmpIndices[c].length == this.grpIndices.length) {
                    this.grpIndices = this.startingSmpIndices[c]
                } else {
                    this.startingSmpIndices[c] = []
                }
            }
        } else {
            if (this.startingSmpIndices) {
                if (this.startingSmpIndices[c] && this.startingSmpIndices[c].length == this.smpIndices.length) {
                    this.smpIndices = this.startingSmpIndices[c]
                } else {
                    this.startingSmpIndices[c] = []
                }
            }
        }
    };
    this.getSamplesByAxis = function(axis) {
        if (this[axis]) {
            return this[axis]
        }
        return []
    };
    this.getSamplesByAnnotationLevel = function(annt, lev) {
        var s = [];
        if (annt && this.data.x[annt]) {
            if (lev) {
                for (var i = 0; i < this.smpIndices.length; i++) {
                    var ii = this.smpIndices[i];
                    if (this.data.x[annt][ii] == lev && !this.hiddenSmps[ii]) {
                        s.push(ii)
                    }
                }
            } else {
                for (var i = 0; i < this.smpIndices.length; i++) {
                    var ii = this.smpIndices[i];
                    if (!this.data.x[annt][ii] && !this.hiddenSmps[ii]) {
                        s.push(ii)
                    }
                }
            }
        }
        return s
    };
    this.setSamplesVisible = function(arr, status) {
        if (this.isGroupedData) {
            this.grpIndices = [];
            for (var i = 0; i < arr.length; i++) {
                this.grpIndices.push(arr[i])
            }
        } else {
            this.smpIndices = [];
            for (var i = 0; i < arr.length; i++) {
                this.smpIndices.push(arr[i])
            }
        } if (status) {
            var seen = this.getObjectArray(arr);
            var level = this.isGroupedData ? this.data.w : this.data.y;
            var hidden = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
            for (var i = 0; i < level.smps.length; i++) {
                if (seen.hasOwnProperty(i)) {
                    hidden[i] = false
                } else {
                    hidden[i] = true
                }
            }
        }
    };
    this.getSampleIndices = function(arr) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        if (arr && level.smps) {
            var indices = [];
            if (this.isArray(arr)) {
                if (arr.length > 0) {
                    for (var i = 0; i < arr.length; i++) {
                        for (var j = 0; j < level.smps.length; j++) {
                            if (level.smps[j] == arr[i]) {
                                indices.push(j);
                                break
                            }
                        }
                    }
                    return indices
                }
            } else {
                for (var i = 0; i < level.smps.length; i++) {
                    if (level.smps[i] == arr) {
                        return i
                    }
                }
                return -1
            }
        }
    };
    this.hideUnhideSmps = function(smps) {
        if (smps) {
            var level = this.isGroupedData ? this.data.w : this.data.y;
            var hidden = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
            var indices = [];
            if (this.isArray(smps)) {
                for (var i = 0; i < smps.length; i++) {
                    for (var j = 0; j < level.smps.length; j++) {
                        if (level.smps[j] == smps[i]) {
                            if (hidden[j]) {
                                hidden[j] = false
                            } else {
                                hidden[j] = true
                            }
                            break
                        }
                    }
                }
            } else {
                for (var i = 0; i < level.smps.length; i++) {
                    if (level.smps[i] == smps) {
                        if (hidden[i]) {
                            hidden[i] = false
                        } else {
                            hidden[i] = true
                        }
                        break
                    }
                }
            }
            var arr = [];
            for (var i = 0; i < level.smps.length; i++) {
                if (!hidden[i]) {
                    arr.push(i)
                }
            }
            this.setSamplesVisible(arr);
            this.draw()
        }
    };
    this.getSamples = function() {
        var samples = [];
        var smps = this.isGroupedData ? this.data.w.smps : this.data.y.smps;
        var level = this.isGroupedData ? this.data.w : this.data.y;
        var hidden = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
        var indices = this.isGroupedData ? this.grpIndices : this.smpIndices;
        for (var i = 0; i < smps.length; i++) {
            var idx = -1;
            for (var j = 0; j < indices.length; j++) {
                if (indices[j] == i) {
                    idx = j;
                    break
                }
            }
            samples.push({
                name: smps[i],
                hidden: hidden[i],
                index: idx
            })
        }
        return samples
    };
    this.resetSmpFilters = function(idx) {
        if (idx != null && this.filterSmpBy.length > 0) {
            this.filterSmpBy.splice(idx, 1);
            this.filterSmpByOp.splice(idx, 1);
            this.filterSmpByValue.splice(idx, 1);
            this.filterSmpByCase.splice(idx, 1);
            this.filteredSmpIndices.splice(idx, 1)
        } else {
            this.filterSmpBy = [];
            this.filterSmpByOp = [];
            this.filterSmpByValue = [];
            this.filterSmpByCase = [];
            this.filteredSmpIndices = []
        }
    };
    this.setIndices = function(vIndices, sIndices) {
        if (this.graphType == "Network") {
            this.setNodes()
        } else {
            if (this.graphType != "Genome" && this.graphType != "Venn") {
                this.setAllVariablesVisible(vIndices);
                this.setAllSamplesVisible(sIndices)
            }
        }
    };
    this.resetIndices = function() {
        if (this.isGroupedData) {
            this.setIndices()
        }
    };
    this.setMaxSmpStringAttr = function(str, font) {
        this.setMaxSmpStringAnnt(str, font);
        this.setMaxSmpStringLabel(str, font);
        this.setMaxSmpStringDesc(font);
        this.setMaxSmpStringName(font)
    };
    this.setMaxSmpStringAnnt = function(str, font) {
        if (!font) {
            font = this.smpLabelFont
        }
        var max = 0;
        this.maxSmpAnnt = 0;
        this.maxSmpAnntStr = "";
        if (this.data.x) {
            if (str && this.data.x[str]) {
                return str
            } else {
                for (var annt in this.data.x) {
                    var len = this.measureText(annt, font);
                    if (len > max) {
                        max = len;
                        this.maxSmpAnnt = annt.length;
                        this.maxSmpAnntStr = annt
                    }
                }
            }
        }
    };
    this.setMaxSmpStringLabel = function(str, font) {
        if (!font) {
            font = this.smpLabelFont
        }
        var max = 0;
        var seen = {};
        this.maxSmpLabel = 0;
        this.maxSmpLabelStr = "";
        if (this.data.x) {
            if (str && this.data.x[str]) {
                var maxStr = "";
                for (var i = 0; i < this.smpIndices.length; i++) {
                    var text = this.data.x[str][this.smpIndices[i]];
                    if (!seen.hasOwnProperty(text)) {
                        var len = this.measureText(text, font);
                        if (len > max) {
                            max = len;
                            maxStr = text
                        }
                        seen[text] = true
                    }
                }
                return maxStr
            } else {
                for (var annt in this.data.x) {
                    for (var i = 0; i < this.smpIndices.length; i++) {
                        var text = this.data.x[annt][this.smpIndices[i]];
                        if (text && !seen.hasOwnProperty(text)) {
                            var len = this.measureText(text, font);
                            if (len > max) {
                                max = len;
                                this.maxSmpLabel = this.data.x[annt][this.smpIndices[i]].length;
                                this.maxSmpLabelStr = this.data.x[annt][this.smpIndices[i]]
                            }
                            seen[text] = true
                        }
                    }
                }
            }
        }
    };
    this.setMaxSmpStringDesc = function(font) {
        if (!font) {
            font = this.smpLabelFont
        }
        var max = 0;
        var seen = {};
        this.maxSmpLabelDesc = 0;
        this.maxSmpLabelDescStr = "";
        if (this.data.x && this.smpLabelDescription && this.data.x[this.smpLabelDescription]) {
            for (var i = 0; i < this.smpIndices.length; i++) {
                var text = this.data.x[this.smpLabelDescription][this.smpIndices[i]];
                if (text && !seen.hasOwnProperty(text)) {
                    var len = this.measureText(text, font);
                    if (len > max) {
                        max = len;
                        this.maxSmpLabelDesc = text.length;
                        this.maxSmpLabelDescStr = text
                    }
                }
            }
        }
    };
    this.setMaxSmpStringName = function(font) {
        if (!font) {
            font = this.smpLabelFont
        }
        if (this.data.y || this.data.w) {
            var level = this.isGroupedData ? this.data.w : this.data.y;
            var max = 0;
            this.maxSmpName = 0;
            this.maxSmpNameStr = "";
            if (this.isGroupedData) {
                for (var i = 0; i < level.smps.length; i++) {
                    var len = this.measureText(level.smps[i], font);
                    if (len > max) {
                        max = len;
                        this.maxSmpName = level.smps[i].length;
                        this.maxSmpNameStr = level.smps[i]
                    }
                }
            } else {
                for (var i = 0; i < this.smpIndices.length; i++) {
                    var text = level.smps[this.smpIndices[i]];
                    var len = this.measureText(text, font);
                    if (len > max) {
                        max = len;
                        this.maxSmpName = text.length;
                        this.maxSmpNameStr = text
                    }
                }
            }
        }
    };
    this.getSmpAnnotations = function(annt, indices, str, num) {
        var seen = {};
        var arr = [];
        var nul = false;
        if (this.data.x.hasOwnProperty(annt)) {
            for (var i = 0; i < indices.length; i++) {
                var ii = indices[i];
                if (this.data.x[annt][ii] != null) {
                    seen[this.data.x[annt][ii]] = true;
                    arr.push(this.data.x[annt][ii])
                } else {
                    nul = true
                }
            }
            if (nul) {
                arr.push("")
            }
            if (num) {
                return str ? arr.join("+") : arr
            } else {
                arr = []
            }
            for (var i in seen) {
                arr.push(i)
            }
            if (nul) {
                arr.push("")
            }
            return str ? arr.join("+") : arr
        }
    };
    this.setMaxVarStringAttr = function(str, font) {
        this.setMaxVarStringAnnt(str, font);
        this.setMaxVarStringLabel(str, font);
        this.setMaxVarStringDesc(font);
        this.setMaxVarStringName(font)
    };
    this.setMaxVarStringAnnt = function(str, font) {
        if (!font) {
            font = this.varLabelFont
        }
        var max = 0;
        this.maxVarAnnt = 0;
        this.maxVarAnntStr = "";
        if (this.data.z) {
            if (str && this.data.z[str]) {
                return str
            } else {
                for (var annt in this.data.z) {
                    var len = this.measureText(annt, font);
                    if (len > max) {
                        max = len;
                        this.maxVarAnnt = annt.length;
                        this.maxVarAnntStr = annt
                    }
                }
            }
        }
    };
    this.setMaxVarStringLabel = function(str, font) {
        if (!font) {
            font = this.varLabelFont
        }
        var max = 0;
        var seen = {};
        this.maxVarLabel = 0;
        this.maxVarLabelStr = "";
        if (this.data.z) {
            if (str && this.data.z[str]) {
                var maxStr = "";
                for (var i = 0; i < this.varIndices.length; i++) {
                    var text = this.data.z[str][this.varIndices[i]];
                    if (!seen.hasOwnProperty(text)) {
                        var len = this.measureText(text, font);
                        if (len > max) {
                            max = len;
                            maxStr = text
                        }
                        seen[text] = true
                    }
                }
                return maxStr
            } else {
                for (var annt in this.data.z) {
                    for (var i = 0; i < this.varIndices.length; i++) {
                        var text = this.data.z[annt][this.varIndices[i]];
                        if (text && !seen.hasOwnProperty(text)) {
                            var len = this.measureText(text, font);
                            if (len > max) {
                                max = len;
                                this.maxVarLabel = text.length;
                                this.maxVarLabelStr = text
                            }
                            seen[text] = true
                        }
                    }
                }
            }
        }
    };
    this.setMaxVarStringDesc = function(font) {
        if (!font) {
            font = this.varLabelFont
        }
        var max = 0;
        var seen = {};
        this.maxVarLabelDesc = 0;
        this.maxVarLabelDescStr = "";
        if (this.data.z && this.varLabelDescription && this.data.z[this.varLabelDescription]) {
            for (var i = 0; i < this.varIndices.length; i++) {
                var text = this.data.z[this.varLabelDescription][this.varIndices[i]];
                if (text && !seen.hasOwnProperty(text)) {
                    var len = this.measureText(text, font);
                    if (len > max) {
                        max = len;
                        this.maxVarLabelDesc = text.length;
                        this.maxVarLabelDescStr = text
                    }
                    seen[text] = true
                }
            }
        }
    };
    this.setMaxVarStringName = function(font) {
        if (!font) {
            font = this.varLabelFont
        }
        if (this.data.y || this.data.w) {
            var level = this.graphType.match(/BarLine|StackedLine|StackedPercentLine/) ? this.data.y : this.isGroupedData ? this.data.w : this.data.y;
            var max = 0;
            this.maxVarName = 0;
            this.maxVarNameStr = "";
            if (level.vars) {
                for (var i = 0; i < this.varIndices.length; i++) {
                    var text = level.vars[this.varIndices[i]];
                    var len = this.measureText(text, font);
                    if (len > max) {
                        max = len;
                        this.maxVarName = text.length;
                        this.maxVarNameStr = text
                    }
                }
            }
        }
    };
    this.getVarAnnotations = function(annt, indices, str, num) {
        var seen = {};
        var arr = [];
        var nul = false;
        if (this.data.z.hasOwnProperty(annt)) {
            for (var i = 0; i < indices.length; i++) {
                var ii = indices[i];
                if (this.data.z[annt][ii] != null) {
                    seen[this.data.z[annt][ii]] = true;
                    arr.push(this.data.z[annt][ii])
                } else {
                    nul = true
                }
            }
            if (nul) {
                arr.push("")
            }
            if (num) {
                return str ? arr.join("+") : arr
            } else {
                arr = []
            }
            for (var i in seen) {
                arr.push(i)
            }
            if (nul) {
                arr.push("")
            }
            return str ? arr.join("+") : arr
        }
    };
    this.filterData = function() {
        var or = {};
        var and = {};
        var edgs = {};
        var re = false;
        var getValue = function(p, o, a) {
            if (o.hasOwnProperty(p)) {
                return o[p]
            } else {
                if (p.match(":::")) {
                    var arr = p.split(":::");
                    if (a[arr[1]]) {
                        arr[1] = parseInt(arr[1]);
                        for (var i = 0; i < a[arr[1]].length; i++) {
                            var j = a[arr[1]][i];
                            if (o.hasOwnProperty(j)) {
                                o = o[j]
                            } else {
                                return false
                            }
                        }
                        if (o.hasOwnProperty(arr[0])) {
                            return o[arr[0]]
                        }
                    }
                }
                return false
            }
        };
        var evaluate = function(ts, op, vl, cs) {
            if (op.match(/[\>\<\=]/)) {
                return eval(parseFloat(ts) + " " + op + " " + parseFloat(vl))
            } else {
                if (op.match("null")) {
                    return op == "not null" && ts != null ? true : op == "null" && ts == null ? true : false
                } else {
                    var r = cs ? new RegExp(vl) : new RegExp(vl, "i");
                    return op == "like" ? r.test(ts) : r.test(ts) ? false : true
                }
            }
            return false
        };
        var addEdge = function(nd) {
            if (!edgs[nd]) {
                edgs[nd] = 0
            }
            edgs[nd]++
        };
        if (this.graphType == "Genome" && this.filterFeatureBy.length > 0) {
            for (var i = 0; i < this.filterFeatureBy.length; i++) {
                if (this.filterFeatureBy[i]) {
                    for (var j = 0; j < this.data.tracks.length; j++) {
                        var track = this.data.tracks[j];
                        var features = track.data;
                        for (var k = 0; k < features.length; k++) {
                            var feature = features[k];
                            if (this.filterSkipNullKeys && !feature.hasOwnProperty(this.filterFeatureBy[i])) {
                                continue
                            }
                            var v = getValue(this.filterFeatureBy[i], feature, this.featuresProperties);
                            if (!evaluate(v, this.filterFeatureByOp[i], this.filterFeatureByValue[i], this.filterFeatureByCase[i])) {
                                feature.hide = this.filterType == "and" ? true : or[j + ":" + k] ? false : true;
                                and[j + ":" + k] = true
                            } else {
                                or[j + ":" + k] = true;
                                if (this.filterType == "or" && and[j + ":" + k]) {
                                    feature.hide = false
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if (this.graphType == "Network" && (this.filterNodeBy.length > 0 || this.filterEdgeBy.length)) {
                for (var i = 0; i < this.filterNodeBy.length; i++) {
                    if (this.filterNodeBy[i]) {
                        for (var j = 0; j < this.data.nodes.length; j++) {
                            if (this.filterSkipNullKeys && !this.data.nodes[j].hasOwnProperty(this.filterNodeBy[i])) {
                                continue
                            }
                            if (this.data.nodes[j].hide) {
                                continue
                            }
                            var v = getValue(this.filterNodeBy[i], this.data.nodes[j], this.nodesProperties);
                            if (!evaluate(v, this.filterNodeByOp[i], this.filterNodeByValue[i], this.filterNodeByCase[i])) {
                                this.data.nodes[j].hide = this.filterType == "and" ? true : or[this.data.nodes[j].id] ? false : true;
                                and[this.data.nodes[j].id] = true
                            } else {
                                or[this.data.nodes[j].id] = true;
                                if (this.filterType == "or" && and[this.data.nodes[j].id]) {
                                    this.data.nodes[j].hide = false
                                }
                            }
                        }
                    }
                }
                for (var i = 0; i < this.filterEdgeBy.length; i++) {
                    if (this.filterEdgeBy[i]) {
                        for (var j = 0; j < this.data.edges.length; j++) {
                            var n1 = this.data.nodes[this.data.nodeIndices[this.data.edges[j].id1]];
                            var n2 = this.data.nodes[this.data.nodeIndices[this.data.edges[j].id2]];
                            var id = n1.id + ":" + n2.id;
                            if (this.filterSkipNullKeys && !this.data.edges[j].hasOwnProperty(this.filterEdgeBy[i])) {
                                continue
                            }
                            var v = getValue(this.filterEdgeBy[i], this.data.edges[j], this.edgesProperties);
                            if (!evaluate(v, this.filterEdgeByOp[i], this.filterEdgeByValue[i], this.filterEdgeByCase[i])) {
                                this.data.edges[j].hide = this.filterType == "and" ? true : or[id] ? false : true;
                                and[id] = true
                            } else {
                                or[id] = true;
                                if (this.filterType == "or" && and[id]) {
                                    this.data.edges[j].hide = false
                                }
                            } if (!this.data.edges[j].hide) {
                                addEdge(n1.id);
                                addEdge(n2.id)
                            }
                        }
                    }
                }
                if (this.filterEdgeBy.length > 0) {
                    for (var i = 0; i < this.data.nodes.length; i++) {
                        var nd = this.data.nodes[i];
                        if (!edgs[nd.id]) {
                            nd.hide = true
                        } else {
                            nd.hide = false
                        }
                    }
                }
            } else {
                if (this.filterSmpBy.length > 0) {
                    for (var i = 0; i < this.filterSmpBy.length; i++) {
                        if (this.filterSmpBy[i]) {
                            re = true;
                            if (this.isGroupedData) {
                                for (var j = 0; j < this.grpIndices.length; j++) {
                                    var jj = this.grpIndices[j];
                                    var tr;
                                    if (this.filterSmpBy[i] == "smps") {
                                        var found = false;
                                        for (var k = 0; k < this.data.w.grps[jj].length; k++) {
                                            tr = this.data.y.smps[this.data.w.grps[jj][k]];
                                            if (evaluate(tr, this.filterSmpByOp[i], this.filterSmpByValue[i], this.filterSmpByCase[i])) {
                                                found = true;
                                                break
                                            }
                                        }
                                        if (!found) {
                                            this.hiddenGrps[jj] = this.filterType == "and" ? true : or[jj] ? false : true;
                                            and[jj] = true
                                        } else {
                                            or[jj] = true;
                                            if (this.filterType == "or" && and[jj]) {
                                                this.hiddenGrps[jj] = false
                                            }
                                        }
                                    } else {
                                        tr = this.data.w.factors[this.filterSmpBy[i]][jj];
                                        if (!evaluate(tr, this.filterSmpByOp[i], this.filterSmpByValue[i], this.filterSmpByCase[i])) {
                                            this.hiddenGrps[jj] = this.filterType == "and" ? true : or[jj] ? false : true;
                                            and[jj] = true
                                        } else {
                                            or[jj] = true;
                                            if (this.filterType == "or" && and[jj]) {
                                                this.hiddenGrps[jj] = false
                                            }
                                        }
                                    }
                                }
                            } else {
                                for (var j = 0; j < this.smpIndices.length; j++) {
                                    var jj = this.smpIndices[j];
                                    var tr = this.filterSmpBy[i] == "smps" ? this.data.y.smps[jj] : this.data.x[this.filterSmpBy[i]][jj];
                                    if (!evaluate(tr, this.filterSmpByOp[i], this.filterSmpByValue[i], this.filterSmpByCase[i])) {
                                        this.hiddenSmps[jj] = this.filterType == "and" ? true : or[jj] ? false : true;
                                        and[jj] = true
                                    } else {
                                        or[jj] = true;
                                        if (this.filterType == "or" && and[jj]) {
                                            this.hiddenSmps[jj] = false
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (re) {
                        var arr = [];
                        if (this.isGroupedData) {
                            for (var i = 0; i < this.grpIndices.length; i++) {
                                var ii = this.grpIndices[i];
                                if (!this.hiddenGrps[ii]) {
                                    arr.push(ii)
                                }
                            }
                            this.grpIndices = arr
                        } else {
                            for (var i = 0; i < this.smpIndices.length; i++) {
                                var ii = this.smpIndices[i];
                                if (!this.hiddenSmps[ii]) {
                                    arr.push(ii)
                                }
                            }
                            this.smpIndices = arr
                        }
                    }
                }
                if (this.filterVarBy.length > 0) {
                    for (var i = 0; i < this.filterVarBy.length; i++) {
                        if (this.filterVarBy[i]) {
                            re = true;
                            for (var j = 0; j < this.varIndices.length; j++) {
                                var jj = this.varIndices[j];
                                var tr = this.filterVarBy[i] == "vars" ? this.data.y.vars[jj] : this.data.z[this.filterVarBy[i]][jj];
                                if (!evaluate(tr, this.filterVarByOp[i], this.filterVarByValue[i], this.filterVarByCase[i])) {
                                    this.hiddenVars[jj] = this.filterType == "and" ? true : or[jj] ? false : true;
                                    and[jj] = true
                                } else {
                                    or[jj] = true;
                                    if (this.filterType == "or" && and[jj]) {
                                        this.hiddenVars[jj] = false
                                    }
                                }
                            }
                        }
                    }
                    if (re) {
                        var arr = [];
                        for (var i = 0; i < this.varIndices.length; i++) {
                            var ii = this.varIndices[i];
                            if (!this.hiddenVars[ii]) {
                                arr.push(ii)
                            }
                        }
                        this.varIndices = arr
                    }
                }
            }
        }
    };
    this.setRangeData = function(type, forceRaw, justPositive, stacked, circular) {
        var level = this.isGroupedData && !forceRaw ? this.data.w : this.data.y;
        var min = Number.MAX_VALUE;
        var max = Number.MAX_VALUE * -1;
        if (this.setMin != null && this.setMax != null) {
            this.minData = this.setMin;
            this.maxData = this.setMax;
            return
        }
        if (this.isGroupedData && !type) {
            type = this.summaryType
        }
        if (type == "genome") {
            for (var i = 0; i < this.data.tracks.length; i++) {
                for (var j = 0; j < this.data.tracks[i].data.length; j++) {
                    if (this.data.tracks[i].type == "box") {
                        for (var k = 0; k < this.data.tracks[i].data[j].data.length; k++) {
                            vals = this.data.tracks[i].data[j].data[k];
                            max = Math.max(max, Math.max(vals[0], vals[1]));
                            min = Math.min(min, Math.min(vals[0], vals[1]))
                        }
                    } else {
                        if (this.data.tracks[i].type == "sequence") {
                            vals = this.data.tracks[i].data[j].offset;
                            max = Math.max(max, vals + this.data.tracks[i].data[j].sequence.length);
                            min = Math.min(min, vals)
                        } else {
                            if (this.data.tracks[i].type.match(/bar|heatmap|line|stacked/)) {
                                vals = this.data.tracks[i].data[j].offset;
                                max = this.data.tracks[i].autowidth ? Math.max(max, vals + this.data.tracks[i].data[j].data.length) : Math.max(max, vals);
                                min = Math.min(min, vals)
                            } else {
                                vals = this.data.tracks[i].data[j].offset;
                                max = Math.max(max, vals);
                                min = Math.min(min, vals)
                            }
                        }
                    }
                }
            }
        } else {
            if (type == "circular") {
                var idx = this.getVariableIndices(this.rAxis);
                if (idx >= 0) {
                    var rng = this.range(this.data.y.data[idx]);
                    min = rng[0];
                    max = rng[1]
                } else {
                    min = 0;
                    max = 1
                }
            } else {
                if (type == "km" && !forceRaw) {
                    min = 0;
                    max = 1
                } else {
                    if (type == "video") {
                        min = 0;
                        max = 1
                    } else {
                        if (type == "percentile" && !forceRaw) {
                            min = 0;
                            max = 100
                        } else {
                            if ((type == "mean" || type == "median" || type == "sum") && !forceRaw) {
                                if (stacked) {
                                    var indices = this.isGroupedData ? this.grpIndices : this.smpIndices;
                                    var data = this.isTransformedData ? level.trans : level[this.summaryType];
                                    for (var i = 0; i < indices.length; i++) {
                                        var ii = indices[i];
                                        var tot = 0;
                                        for (var j = 0; j < this.varIndices.length; j++) {
                                            var jj = this.varIndices[j];
                                            var val = data[jj][ii];
                                            if (!isNaN(val) && val > 0) {
                                                tot += val
                                            }
                                        }
                                        max = Math.max(tot, max)
                                    }
                                    min = 0
                                } else {
                                    for (var i = 0; i < this.varIndices.length; i++) {
                                        var ii = this.varIndices[i];
                                        var vals;
                                        if (this.isTransformedData) {
                                            vals = level.trans[ii]
                                        } else {
                                            if (this.summaryType == "mean") {
                                                vals = level.mean[ii]
                                            } else {
                                                if (this.summaryType == "median") {
                                                    vals = level.median[ii]
                                                } else {
                                                    if (this.summaryType == "sum") {
                                                        vals = level.sum[ii]
                                                    }
                                                }
                                            }
                                        }
                                        for (var j = 0; j < vals.length; j++) {
                                            var std;
                                            var val = vals[j];
                                            if (level.stdev && !this.isTransformedData) {
                                                std = level.stdev[ii][j]
                                            } else {
                                                std = Number.NaN
                                            } if (!isNaN(val)) {
                                                if (!isNaN(std)) {
                                                    if (justPositive) {
                                                        if (val > 0) {
                                                            min = Math.min(val, min);
                                                            max = Math.max(val + std, max)
                                                        }
                                                    } else {
                                                        min = Math.min(val, min);
                                                        max = Math.max(val + std, max)
                                                    }
                                                } else {
                                                    if (justPositive) {
                                                        if (val > 0) {
                                                            min = Math.min(val, min);
                                                            max = Math.max(val, max)
                                                        }
                                                    } else {
                                                        min = Math.min(val, min);
                                                        max = Math.max(val, max)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (type == "iqr" && !forceRaw) {
                                    if (this.isTransformedData) {
                                        alert("Transformation not allowed");
                                        this.isTransformedData = false
                                    }
                                    for (var i = 0; i < this.varIndices.length; i++) {
                                        var ii = this.varIndices[i];
                                        for (var j = 0; j < level.iqr1[ii].length; j++) {
                                            var iqr1 = level.iqr1[ii][j];
                                            var iqr3 = level.iqr3[ii][j];
                                            var out = level.out[ii][j];
                                            if (!isNaN(iqr1) && !isNaN(iqr3)) {
                                                if (justPositive) {
                                                    if (iqr1 > 0 && iqr3 > 0) {
                                                        min = Math.min(iqr1, min);
                                                        max = Math.max(iqr3, max)
                                                    }
                                                } else {
                                                    min = Math.min(iqr1, min);
                                                    max = Math.max(iqr3, max)
                                                }
                                            }
                                            if (out) {
                                                for (var k = 0; k < out.length; k++) {
                                                    if (!isNaN(out[k])) {
                                                        if (justPositive) {
                                                            if (out[k] > 0) {
                                                                min = Math.min(out[k], min);
                                                                max = Math.max(out[k], max)
                                                            }
                                                        } else {
                                                            min = Math.min(out[k], min);
                                                            max = Math.max(out[k], max)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (type == "candle") {
                                        if (this.isTransformedData) {
                                            alert("Transformation not allowed");
                                            this.isTransformedData = false
                                        }
                                        var indices = this.isGroupedData ? this.grpIndices : this.smpIndices;
                                        for (var i = 0; i < this.varIndices.length; i++) {
                                            var ii = this.varIndices[i];
                                            for (var j = 0; j < indices.length; j++) {
                                                var jj = indices[j];
                                                var high = level.high[ii][jj];
                                                var low = level.low[ii][jj];
                                                if (!isNaN(high) && !isNaN(low)) {
                                                    min = Math.min(low, min);
                                                    max = Math.max(high, max)
                                                }
                                            }
                                        }
                                    } else {
                                        if (type == "volume") {
                                            var indices = this.isGroupedData ? this.grpIndices : this.smpIndices;
                                            for (var i = 0; i < this.varIndices.length; i++) {
                                                var ii = this.varIndices[i];
                                                for (var j = 0; j < indices.length; j++) {
                                                    var jj = indices[j];
                                                    if (!isNaN(level.volume[ii][jj])) {
                                                        min = Math.min(level.volume[ii][jj], min);
                                                        max = Math.max(level.volume[ii][jj], max)
                                                    }
                                                }
                                            }
                                        } else {
                                            if (type == "cor") {
                                                var indices = this.correlationAxis == "variables" ? this.varIndices : this.isGroupedData ? this.grpIndices : this.smpIndices;
                                                for (var i = 0; i < indices.length; i++) {
                                                    for (var j = 0; j < indices.length; j++) {
                                                        var val = this.isTransformedData ? level.trans[i][j] : level.cor[i][j];
                                                        if (!isNaN(val)) {
                                                            if (justPositive) {
                                                                if (val > 0) {
                                                                    min = Math.min(val, min);
                                                                    max = Math.max(val, max)
                                                                }
                                                            } else {
                                                                min = Math.min(val, min);
                                                                max = Math.max(val, max)
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                var data = this.isTransformedData ? level.trans : level.data;
                                                if (stacked) {
                                                    for (var i = 0; i < this.smpIndices.length; i++) {
                                                        var tot = 0;
                                                        for (var j = 0; j < this.varIndices.length; j++) {
                                                            var val = data[this.varIndices[j]][this.smpIndices[i]];
                                                            if (!isNaN(val) && val > 0) {
                                                                tot += val
                                                            }
                                                        }
                                                        max = Math.max(tot, max)
                                                    }
                                                    min = 0
                                                } else {
                                                    for (var i = 0; i < this.varIndices.length; i++) {
                                                        for (var j = 0; j < this.smpIndices.length; j++) {
                                                            var val = data[this.varIndices[i]][this.smpIndices[j]];
                                                            if (!isNaN(val)) {
                                                                if (justPositive) {
                                                                    if (val > 0) {
                                                                        min = Math.min(val, min);
                                                                        max = Math.max(val, max)
                                                                    }
                                                                } else {
                                                                    min = Math.min(val, min);
                                                                    max = Math.max(val, max)
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        this.minData = this.setMin != null ? this.setMin : min;
        this.maxData = this.setMax != null ? this.setMax : max
    };
    this.setRangeDataObject = function(data) {
        var min = Number.MAX_VALUE;
        var max = Number.MAX_VALUE * -1;
        for (var i = 0; i < this.varIndices.length; i++) {
            for (var j = 0; j < this.smpIndices.length; j++) {
                var val = data[this.varIndices[i]][this.smpIndices[j]];
                if (!isNaN(val)) {
                    min = Math.min(val, min);
                    max = Math.max(val, max)
                }
            }
        }
        return [min, max]
    };
    this.sortNetworkIndices = function(byProp) {
        var data = this.data[this.networkShowDataTable];
        var att = [byProp] ? byProp : this.networkShowDataTable == "nodes" ? "id" : "id1";
        var inds = [];
        var vals = [];
        for (var i = 0; i < data.length; i++) {
            inds.push(i);
            vals.push(data[i][att] ? data[i][att] : null)
        }
        if (this.isNumeric(vals)) {
            var m = Number.MAX_VALUE * -1;
            inds.sort(function(a, b) {
                return (vals[a] || m) - (vals[b] || m)
            })
        } else {
            inds.sort(function(a, b) {
                return vals[a] > vals[b] ? 1 : vals[a] < vals[b] ? -1 : 0
            })
        }
        var tmp = [];
        for (var i = 0; i < data.length; i++) {
            tmp.push(data[inds[i]])
        }
        if (this.sortDir == "ascending") {
            tmp.reverse()
        }
        this.data[this.networkShowDataTable] = tmp;
        if (this.networkShowDataTable == "nodes") {
            this.setNodeIndices()
        }
        this.draw()
    };
    this.sortIndices = function(type, dir, byCat, bySmp, byVar, att, own) {
        var that = this;
        this.tmpAsciiArray = [];
        this.tmpAsciiArray1 = [];
        this.tmpAsciiArray2 = [];
        this.tmpAsciiArrayAscii = false;
        this.tmpAsciiArrayAscii1 = false;
        this.tmpAsciiArrayAscii2 = false;
        if (byCat) {
            byCat = this.toArray(byCat)
        }
        if (bySmp) {
            bySmp = this.toArray(bySmp)
        }
        if (byVar) {
            byVar = this.toArray(byVar)
        }
        if (!dir) {
            dir = this.sortDir
        }
        if (byCat && type == "vars") {
            if (byCat.length == 1 && this.data.z && this.data.z[byCat[0]]) {
                this.tmpAsciiArray = this.data.z[byCat[0]];
                this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray)
            } else {
                if (byCat.length == 2 && this.data.z && this.data.z[byCat[0]] && this.data.z[byCat[1]]) {
                    this.tmpAsciiArray = this.data.z[byCat[0]];
                    this.tmpAsciiArray1 = this.data.z[byCat[1]];
                    this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
                    this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1)
                } else {
                    if (byCat.length == 3 && this.data.z && this.data.z[byCat[0]] && this.data.z[byCat[1]] && this.data.z[byCat[2]]) {
                        this.tmpAsciiArray = this.data.z[byCat[0]];
                        this.tmpAsciiArray1 = this.data.z[byCat[1]];
                        this.tmpAsciiArray2 = this.data.z[byCat[2]];
                        this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
                        this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1);
                        this.tmpAsciiArrayAscii2 = this.isAsciiArray(this.tmpAsciiArray2)
                    }
                }
            }
            this.smpSort = -1;
            this.varSort = byCat
        } else {
            if (byCat && type == "smps") {
                if (this.isGroupedData) {
                    this.isGroupedData = false;
                    this.sortIndices(type, dir, byCat, bySmp, byVar, att, own);
                    this.isGroupedData = true
                }
                if (byCat.length == 1 && this.data.x && this.data.x[byCat[0]]) {
                    this.tmpAsciiArray = this.isGroupedData ? this.data.w.factors[byCat[0]] : this.data.x[byCat[0]];
                    this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray)
                } else {
                    if (byCat.length == 2 && this.data.x && this.data.x[byCat[0]] && this.data.x[byCat[1]]) {
                        this.tmpAsciiArray = this.isGroupedData ? this.data.w.factors[byCat[0]] : this.data.x[byCat[0]];
                        this.tmpAsciiArray1 = this.isGroupedData ? this.data.w.factors[byCat[1]] : this.data.x[byCat[1]];
                        this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
                        this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1)
                    } else {
                        if (byCat.length == 3 && this.data.x && this.data.x[byCat[0]] && this.data.x[byCat[1]] && this.data.x[byCat[2]]) {
                            this.tmpAsciiArray = this.isGroupedData ? this.data.w.factors[byCat[0]] : this.data.x[byCat[0]];
                            this.tmpAsciiArray1 = this.isGroupedData ? this.data.w.factors[byCat[1]] : this.data.x[byCat[1]];
                            this.tmpAsciiArray2 = this.isGroupedData ? this.data.w.factors[byCat[2]] : this.data.x[byCat[2]];
                            this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
                            this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1);
                            this.tmpAsciiArrayAscii2 = this.isAsciiArray(this.tmpAsciiArray2)
                        }
                    }
                }
                this.varSort = -1;
                this.smpSort = byCat
            } else {
                if (att && own) {
                    var i = bySmp ? parseInt(this.getVariableIndices(bySmp[0])) : parseInt(this.getSampleIndices(byVar[0]));
                    this.tmpAsciiArray = this.data.y[att][i];
                    this.tmpAsciiArrayAscii = false;
                    this.smpSort = [i]
                } else {
                    if (bySmp) {
                        var vi = [];
                        for (var i = 0; i < this.varIndices.length; i++) {
                            vi.push(i)
                        }
                        if (bySmp.length == 1) {
                            this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(bySmp[0] - 1, vi, att);
                            this.tmpAsciiArrayAscii = false;
                            this.smpSort = [bySmp[0] - 1]
                        } else {
                            if (bySmp.length == 2) {
                                this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(bySmp[0] - 1, vi, att);
                                this.tmpAsciiArray1 = this.getDataForSmpGrpAtIndex(bySmp[1] - 1, vi, att);
                                this.tmpAsciiArrayAscii = false;
                                this.tmpAsciiArrayAscii1 = false;
                                this.smpSort = [bySmp[0] - 1, bySmp[1] - 1]
                            } else {
                                if (bySmp.length == 3) {
                                    this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(bySmp[0] - 1, vi, att);
                                    this.tmpAsciiArray1 = this.getDataForSmpGrpAtIndex(bySmp[1] - 1, vi, att);
                                    this.tmpAsciiArray2 = this.getDataForSmpGrpAtIndex(bySmp[2] - 1, vi, att);
                                    this.tmpAsciiArrayAscii = false;
                                    this.tmpAsciiArrayAscii1 = false;
                                    this.tmpAsciiArrayAscii2 = false;
                                    this.smpSort = [bySmp[0] - 1, bySmp[1] - 1, bySmp[2] - 1]
                                }
                            }
                        }
                    } else {
                        if (byVar) {
                            if (this.isGroupedData) {
                                this.isGroupedData = false;
                                this.sortIndices(type, dir, byCat, bySmp, byVar, att, own);
                                this.isGroupedData = true
                            }
                            var data = this.isGroupedData && this.summaryType == "iqr" ? this.data.w.median : this.isGroupedData ? this.data.w[this.summaryType] : att ? this.data.y[att] : this.data.y.data;
                            if (byVar.length == 1) {
                                this.tmpAsciiArray = data[byVar[0] - 1];
                                this.tmpAsciiArrayAscii = false;
                                this.smpSort = [byVar[0] - 1]
                            } else {
                                if (byVar.length == 2) {
                                    this.tmpAsciiArray = data[byVar[0] - 1];
                                    this.tmpAsciiArray1 = data[byVar[1] - 1];
                                    this.tmpAsciiArrayAscii = false;
                                    this.tmpAsciiArrayAscii1 = false;
                                    this.smpSort = [byVar[0] - 1, byVar[1] - 1]
                                } else {
                                    if (bySmp.length == 3) {
                                        this.tmpAsciiArray = data[byVar[0] - 1];
                                        this.tmpAsciiArray1 = data[byVar[1] - 1];
                                        this.tmpAsciiArray2 = data[byVar[2] - 1];
                                        this.tmpAsciiArrayAscii = false;
                                        this.tmpAsciiArrayAscii1 = false;
                                        this.tmpAsciiArrayAscii2 = false;
                                        this.smpSort = [byVar[0] - 1, byVar[1] - 1, byVar[2] - 1]
                                    }
                                }
                            }
                        } else {
                            if (this.isGroupedData) {
                                this.isGroupedData = false;
                                this.sortIndices(type, dir, byCat, bySmp, byVar, att, own);
                                this.isGroupedData = true
                            }
                            this.tmpAsciiArray = this.isGroupedData ? this.data.w.smps : type == "vars" ? this.data.y.vars : this.data.y.smps;
                            this.tmpAsciiArrayAscii = true;
                            if (type == "vars") {
                                this.varSort = false
                            } else {
                                this.smpSort = false
                            }
                        }
                    }
                }
            }
        }
        var indices = this.isGroupedData ? this.grpIndices : type == "vars" ? this.varIndices : this.smpIndices;
        if (this.tmpAsciiArrayAscii) {
            indices.sort(function(a, b) {
                return that.sortAsciibetically(a, b)
            })
        } else {
            indices.sort(function(a, b) {
                return that.sortNumerically(a, b)
            })
        } if (dir != "ascending") {
            indices.reverse()
        }
        this.tmpAsciiArray = [];
        this.tmpAsciiArray1 = [];
        this.tmpAsciiArray2 = [];
        this.tmpAsciiArrayAscii = false;
        this.tmpAsciiArrayAscii1 = false;
        this.tmpAsciiArrayAscii2 = false
    };
    this.isAsciiArray = function(arr) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] != null && isNaN(arr[i])) {
                return true
            }
        }
        return false
    };
    this.sortAsciibetically = function(a, b) {
        var that = this;
        if (this.tmpAsciiArray[a] == this.tmpAsciiArray[b] && this.tmpAsciiArray1.length > 0) {
            if (this.tmpAsciiArrayAscii1) {
                return that.sortAsciibetically1(a, b)
            } else {
                return that.sortNumerically1(a, b)
            }
        } else {
            return ((this.tmpAsciiArray[a] > this.tmpAsciiArray[b]) ? 1 : (this.tmpAsciiArray[a] < this.tmpAsciiArray[b]) ? -1 : 0)
        }
    };
    this.sortAsciibetically1 = function(a, b) {
        var that = this;
        if (this.tmpAsciiArray1[a] == this.tmpAsciiArray1[b] && this.tmpAsciiArray2.length > 0) {
            if (this.tmpAsciiArrayAscii2) {
                return that.sortAsciibetically2(a, b)
            } else {
                return that.sortNumerically2(a, b)
            }
        } else {
            return ((this.tmpAsciiArray1[a] > this.tmpAsciiArray1[b]) ? 1 : (this.tmpAsciiArray1[a] < this.tmpAsciiArray1[b]) ? -1 : 0)
        }
    };
    this.sortAsciibetically2 = function(a, b) {
        return ((this.tmpAsciiArray2[a] > this.tmpAsciiArray2[b]) ? 1 : (this.tmpAsciiArray2[a] < this.tmpAsciiArray2[b]) ? -1 : 0)
    };
    this.sortNumerically = function(a, b) {
        var that = this;
        var m = Number.MAX_VALUE * -1;
        if ((this.tmpAsciiArray[a] || m) - (this.tmpAsciiArray[b] || m) == 0 && this.tmpAsciiArray1.length > 0) {
            if (this.tmpAsciiArrayAscii1) {
                return that.sortAsciibetically1(a, b)
            } else {
                return that.sortNumerically1(a, b)
            }
        } else {
            return (this.tmpAsciiArray[a] || m) - (this.tmpAsciiArray[b] || m)
        }
    };
    this.sortNumerically1 = function(a, b) {
        var that = this;
        var m = Number.MAX_VALUE * -1;
        if ((this.tmpAsciiArray1[a] || m) - (this.tmpAsciiArray1[b] || m) == 0 && this.tmpAsciiArray2.length > 0) {
            if (this.tmpAsciiArrayAscii2) {
                return that.sortAsciibetically2(a, b)
            } else {
                return that.sortNumerically2(a, b)
            }
        } else {
            return (this.tmpAsciiArray1[a] || m) - (this.tmpAsciiArray1[b] || m)
        }
    };
    this.sortNumerically2 = function(a, b) {
        var m = Number.MAX_VALUE * -1;
        return (this.tmpAsciiArray2[a] || m) - (this.tmpAsciiArray2[b] || m)
    };
    this.radixSort = function(arr) {
        var rs = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        var cpy = new Int32Array(arr.length);
        var c4 = [].concat(rs);
        var c3 = [].concat(rs);
        var c2 = [].concat(rs);
        var c1 = [].concat(rs);
        var o4 = 0;
        var t4;
        var o3 = 0;
        var t3;
        var o2 = 0;
        var t2;
        var o1 = 0;
        var t1;
        var x;
        for (x = 0; x < arr.length; x++) {
            t4 = arr[x] & 255;
            t3 = (arr[x] >> 8) & 255;
            t2 = (arr[x] >> 16) & 255;
            t1 = (arr[x] >> 24) & 255 ^ 128;
            c4[t4]++;
            c3[t3]++;
            c2[t2]++;
            c1[t1]++
        }
        for (x = 0; x < 256; x++) {
            t4 = o4 + c4[x];
            t3 = o3 + c3[x];
            t2 = o2 + c2[x];
            t1 = o1 + c1[x];
            c4[x] = o4;
            c3[x] = o3;
            c2[x] = o2;
            c1[x] = o1;
            o4 = t4;
            o3 = t3;
            o2 = t2;
            o1 = t1
        }
        for (x = 0; x < arr.length; x++) {
            t4 = arr[x] & 255;
            cpy[c4[t4]] = arr[x];
            c4[t4]++
        }
        for (x = 0; x < arr.length; x++) {
            t3 = (cpy[x] >> 8) & 255;
            arr[c3[t3]] = cpy[x];
            c3[t3]++
        }
        for (x = 0; x < arr.length; x++) {
            t2 = (arr[x] >> 16) & 255;
            cpy[c2[t2]] = arr[x];
            c2[t2]++
        }
        for (x = 0; x < arr.length; x++) {
            t1 = (cpy[x] >> 24) & 255 ^ 128;
            arr[c1[t1]] = cpy[x];
            c1[t1]++
        }
        return arr
    };
    this.isNumeric2DArray = function(arr) {
        for (var i = 0; i < arr.length; i++) {
            for (var j = 0; j < arr[i].length; j++) {
                if (arr[i][j] && isNaN(arr[i][j])) {
                    return false
                }
            }
        }
        return true
    };
    this.isNumeric = function(arr, filterSmps, filterVars) {
        if (filterSmps) {
            for (var ii = 0; ii < this.smpIndices.length; ii++) {
                var i = this.smpIndices[ii];
                if (arr[i] && isNaN(arr[i])) {
                    return false
                }
            }
        } else {
            if (filterVars) {
                for (var ii = 0; ii < this.varIndices.length; ii++) {
                    var i = this.varIndices[ii];
                    if (arr[i] && isNaN(arr[i])) {
                        return false
                    }
                }
            } else {
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i] && isNaN(arr[i])) {
                        return false
                    }
                }
            }
        }
        return true
    };
    this.precedence = {
        sin: 16,
        cos: 16,
        tan: 16,
        sec: 16,
        csc: 16,
        cot: 16,
        asin: 16,
        acos: 16,
        atan: 16,
        asec: 16,
        acsc: 16,
        acot: 16,
        sinh: 16,
        cosh: 16,
        tanh: 16,
        sech: 16,
        csch: 16,
        coth: 16,
        asinh: 16,
        acosh: 16,
        atanh: 16,
        asech: 16,
        acsch: 16,
        acoth: 16,
        exp: 16,
        ln: 16,
        log: 16,
        logb: 16,
        pow: 16,
        sq: 16,
        sqrt: 16,
        abs: 16,
        sgn: 16,
        chs: 16,
        floor: 16,
        ceil: 16,
        ip: 16,
        fp: 16,
        inv: 16,
        min: 16,
        max: 16,
        gamma: 16,
        fact: 16,
        comb: 16,
        perm: 16,
        rand: 16,
        gcd: 16,
        lcm: 16,
        prime: 16,
        and: 16,
        or: 16,
        xor: 16,
        x: 16,
        y: 16,
        pi: 16,
        e: 16,
        neg: 15,
        not: 15,
        "^": 14,
        "*": 13,
        "/": 13,
        mod: 13,
        div: 13,
        "+": 12,
        "-": 12,
        "<": 10,
        "<=": 10,
        "==": 10,
        "!=": 10,
        ">=": 10,
        ">": 10,
        "&&": 5,
        "||": 4,
        ",": 1
    };
    this.expects = {
        sin: 1,
        cos: 1,
        tan: 1,
        sec: 1,
        csc: 1,
        cot: 1,
        asin: 1,
        acos: 1,
        atan: 1,
        asec: 1,
        acsc: 1,
        acot: 1,
        sinh: 1,
        cosh: 1,
        tanh: 1,
        sech: 1,
        csch: 1,
        coth: 1,
        asinh: 1,
        acosh: 1,
        atanh: 1,
        asech: 1,
        acsch: 1,
        acoth: 1,
        exp: 1,
        ln: 1,
        log: 1,
        logb: 2,
        pow: 2,
        sq: 1,
        sqrt: 1,
        abs: 1,
        sgn: 1,
        chs: 1,
        floor: 1,
        ceil: 1,
        ip: 1,
        fp: 1,
        inv: 1,
        min: 2,
        max: 2,
        gamma: 1,
        fact: 1,
        comb: 2,
        perm: 2,
        gcd: 2,
        lcm: 2,
        prime: 1,
        and: 2,
        or: 2,
        xor: 2,
        neg: 1,
        not: 1,
        "^": 2,
        "*": 2,
        "/": 2,
        mod: 2,
        div: 2,
        "+": 2,
        "-": 2,
        "<": 2,
        "<=": 2,
        "==": 2,
        "!=": 2,
        ">=": 2,
        ">": 2,
        "&&": 2,
        "||": 2
    };
    this.alias = {
        "+": "add",
        "-": "sub",
        "*": "mul",
        "/": "div",
        "!": "fact",
        "x^y": "pow",
        "^": "pow",
        "10^": "pow10",
        div: "idiv",
        "<": "lt",
        "<=": "le",
        "==": "eq",
        "!=": "ne",
        ">=": "ge",
        ">": "gt",
        "%": "pc",
        "%ch": "pcch"
    };
    this.add = function(y, x) {
        return new Number(x) + new Number(y)
    };
    this.sub = function(y, x) {
        return x - y
    };
    this.mul = function(y, x) {
        return x * y
    };
    this.div = function(y, x) {
        return x / y
    };
    this.sin = function(x) {
        return Math.sin(x)
    };
    this.cos = function(x) {
        return Math.cos(x)
    };
    this.tan = function(x) {
        return Math.tan(x)
    };
    this.sec = function(x) {
        return 1 / Math.cos(x)
    };
    this.csc = function(x) {
        return 1 / Math.sin(x)
    };
    this.cot = function(x) {
        return 1 / Math.tan(x)
    };
    this.asin = function(x) {
        return Math.asin(x)
    };
    this.acos = function(x) {
        return Math.acos(x)
    };
    this.atan = function(x) {
        return Math.atan(x)
    };
    this.asec = function(x) {
        return Math.acos(1 / x)
    };
    this.acsc = function(x) {
        return Math.asin(1 / x)
    };
    this.acot = function(x) {
        return Math.atan(1 / x)
    };
    this.sinh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) * 0.5
    };
    this.cosh = function(x) {
        return (Math.exp(x) + Math.exp(-x)) * 0.5
    };
    this.tanh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))
    };
    this.sech = function(x) {
        return 1 / cosh(x)
    };
    this.csch = function(x) {
        return 1 / sinh(x)
    };
    this.coth = function(x) {
        return 1 / tanh(x)
    };
    this.asinh = function(x) {
        return Math.log(x + Math.sqrt(x * x + 1))
    };
    this.acosh = function(x) {
        return Math.log(x + Math.sqrt(x * x - 1))
    };
    this.atanh = function(x) {
        return Math.log((1 + x) / (1 - x)) * 0.5
    };
    this.asech = function(x) {
        return acosh(1 / x)
    };
    this.acsch = function(x) {
        return asinh(1 / x)
    };
    this.acoth = function(x) {
        return atanh(1 / x)
    };
    this.exp = function(x) {
        return Math.exp(x)
    };
    this.ln = function(x) {
        return Math.log(x)
    };
    this.log = function(x) {
        return Math.log(x) / Math.LN10
    };
    this.logb = function(y, x) {
        return Math.log(x) / Math.log(y)
    };
    this.pow = function(y, x) {
        return Math.pow(x, y)
    };
    this.pow10 = function(x) {
        return Math.pow(10, x)
    };
    this.sq = function(x) {
        return x * x
    };
    this.sqrt = function(x) {
        return Math.sqrt(x)
    };
    this.abs = function(x) {
        return x >= 0 ? x : -x
    };
    this.sgn = function(x) {
        return x == 0 ? 0 : (x > 0 ? 1 : -1)
    };
    this.chs = function(x) {
        return -x
    };
    this.neg = function(x) {
        return -x
    };
    this.floor = function(x) {
        return Math.floor(x)
    };
    this.ceil = function(x) {
        return Math.ceil(x)
    };
    this.ip = function(x) {
        return parseInt(x)
    };
    this.fp = function(x) {
        return abs(x) - ip(abs(x))
    };
    this.inv = function(x) {
        return 1 / x
    };
    this.idiv = function(y, x) {
        return parseInt(x / y)
    };
    this.mod = function(y, x) {
        return x % y
    };
    this.and = function(y, x) {
        return x & y
    };
    this.or = function(y, x) {
        return x | y
    };
    this.xor = function(y, x) {
        return x ^ y
    };
    this.not = function(x) {
        return~ x
    };
    this.lt = function(y, x) {
        return x < y ? 1 : 0
    };
    this.le = function(y, x) {
        return x <= y ? 1 : 0
    };
    this.eq = function(y, x) {
        return x == y ? 1 : 0
    };
    this.ne = function(y, x) {
        return x != y ? 1 : 0
    };
    this.ge = function(y, x) {
        return x >= y ? 1 : 0
    };
    this.gt = function(y, x) {
        return x > y ? 1 : 0
    };
    this.Min = function(y, x) {
        return Math.min(x, y)
    };
    this.Max = function(y, x) {
        return Math.max(x, y)
    };
    this.pc = function(y, x) {
        return x * y / 100
    };
    this.pcch = function(y, x) {
        return 100 * y / x
    };
    this.parseInt = function(x) {
        return ((x + 0.5) << 1) >> 1
    };
    this.gammaConsts = new Array(76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -0.000005395239384953);
    this.gammaLn = function(x) {
        var n = new Number(x);
        var tmp = new Number(x + 5.5);
        var ser = new Number(1.000000000190015);
        tmp -= (x + 0.5) * Math.log(tmp);
        for (var i in this.gammaConsts) {
            ser += this.gammaConsts[i] / ++n
        }
        return Math.log(2.5066282746310007 * ser / x) - tmp
    };
    this.gamma = function(x) {
        return Math.exp(this.gammaLn(x))
    };
    this.fact = function(n) {
        var r = new Number(n);
        if (n <= 1) {
            return 1
        }
        if (n > 100 || (n % 1)) {
            return Math.exp(this.gammaLn(n + 1))
        }
        while (--n) {
            r *= n
        }
        return r
    };
    this.comb = function(y, x) {
        return Math.floor(0.5 + Math.exp(this.gammaLn(x + 1) - this.gammaLn(y + 1) - this.gammaLn(x - y + 1)))
    };
    this.perm = function(y, x) {
        return Math.floor(0.5 + Math.exp(this.gammaLn(x + 1) - this.gammaLn(x - y + 1)))
    };
    this.gcd = function(a, b) {
        if (a == 0) {
            return (b || 1)
        }
        return (b ? this.gcd(b, a % b) : a)
    };
    this.lcm = function(a, b) {
        return (a / this.gcd(a, b)) * b
    };
    this.prime = function(n) {
        var d = new Number(5);
        var dd = new Number(4);
        var w = parseInt(n / d);
        if (n == 2 || n == 3 || n == 5) {
            return 1
        }
        if (n < 5 || (n & 1) == 0 || (n % 3) == 0) {
            return 0
        }
        while (d * w < n && d < w) {
            w = parseInt(n / (d += (dd = 6 - dd)))
        }
        return (d * w == n ? 0 : 1)
    };
    this.degreesToArcLength = function(r, v) {
        return r * v
    };
    this.radiansToArcLength = function(r, rdn) {
        return (r * Math.PI * rdn) / 180
    };
    this.arcLengthToDegrees = function(r, l) {
        return (l * 180) / (r * Math.PI)
    };
    this.arcLengthToRadians = function(r, l) {
        return l / r
    };
    this.cleanArray = function(arr, filterSmps, filterVars) {
        var clean = [];
        if (filterSmps) {
            for (var ii = 0; ii < this.smpIndices.length; ii++) {
                var i = this.smpIndices[ii];
                if (!isNaN(arr[i])) {
                    clean.push(arr[i])
                }
            }
        } else {
            if (filterVars) {
                for (var ii = 0; ii < this.varIndices.length; ii++) {
                    var i = this.varIndices[ii];
                    if (!isNaN(arr[i])) {
                        clean.push(arr[i])
                    }
                }
            } else {
                for (var i = 0; i < arr.length; i++) {
                    if (!isNaN(arr[i])) {
                        clean.push(arr[i])
                    }
                }
            }
        }
        return clean
    };
    this.cleanArrays = function(arr1, arr2, filterSmps, filterVars) {
        var clean1 = [];
        var clean2 = [];
        if (filterSmps) {
            for (var ii = 0; ii < this.smpIndices.length; ii++) {
                var i = this.smpIndices[ii];
                if (!isNaN(arr1[i]) && !isNaN(arr2[i])) {
                    clean1.push(arr1[i]);
                    clean2.push(arr2[i])
                }
            }
        } else {
            if (filterVars) {
                for (var ii = 0; ii < this.varIndices.length; ii++) {
                    var i = this.varIndices[ii];
                    if (!isNaN(arr1[i]) && !isNaN(arr2[i])) {
                        clean1.push(arr1[i]);
                        clean2.push(arr2[i])
                    }
                }
            } else {
                for (var i = 0; i < arr1.length; i++) {
                    if (!isNaN(arr1[i]) && !isNaN(arr2[i])) {
                        clean1.push(arr1[i]);
                        clean2.push(arr2[i])
                    }
                }
            }
        }
        return [clean1, clean2]
    };
    this.sortArray = function(arr, srt) {
        var tmp = [];
        if (arr.length != srt.length) {
            return arr
        }
        for (var i = 0; i < arr.length; i++) {
            if (arr[srt[i]]) {
                tmp[i] = arr[srt[i]]
            } else {
                return arr
            }
        }
        return tmp
    };
    this.reverseArray = function(arr) {
        var tmp = [];
        var cnt = 0;
        for (var i = arr.length - 1; i >= 0; i--) {
            tmp[cnt] = arr[i];
            cnt++
        }
        return tmp
    };
    this.percentile = function(min, max, val) {
        var range = max - min;
        if (range == 0) {
            return 50
        }
        var prcnt = val - min;
        return prcnt * 100 / range
    };
    this.rank = function(arr) {
        var ranks = [];
        for (var i = 0; i < arr.length; i++) {
            ranks.push(i)
        }
        ranks.sort(function(a, b) {
            return arr[a] - arr[b]
        });
        return ranks
    };
    this.min = function(arr, filterSmps, filterVars) {
        if (this.isArray(arr)) {
            arr = this.cleanArray(arr, filterSmps, filterVars);
            var min = Number.MAX_VALUE;
            for (var i = 0; i < arr.length; i++) {
                min = Math.min(min, arr[i])
            }
            return min
        } else {
            return this.Min(arr, filterSmps)
        }
    };
    this.max = function(arr, filterSmps, filterVars) {
        if (this.isArray(arr)) {
            arr = this.cleanArray(arr, filterSmps, filterVars);
            var max = Number.MIN_VALUE;
            for (var i = 0; i < arr.length; i++) {
                max = Math.max(max, arr[i])
            }
            return max
        } else {
            return this.Max(arr, filterSmps)
        }
    };
    this.sum = function(arr, filterSmps, filterVars, justPositive) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var sum = 0;
        for (var i = 0; i < arr.length; i++) {
            if (justPositive) {
                if (arr[i] > 0) {
                    sum += arr[i]
                }
            } else {
                sum += arr[i]
            }
        }
        return sum
    };
    this.mean = function(arr, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var mean = 0;
        var n = 0;
        for (var i = 0; i < arr.length; i++) {
            if (!isNaN(arr[i])) {
                mean += arr[i];
                n++
            }
        }
        if (n > 0) {
            mean /= n
        }
        return mean
    };
    this.range = function(arr, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var min = Number.MAX_VALUE;
        var max = Number.MAX_VALUE * -1;
        for (var i = 0; i < arr.length; i++) {
            min = Math.min(arr[i], min);
            max = Math.max(arr[i], max)
        }
        return [min, max]
    };
    this.median = function(arr, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var vals = [];
        var median = [];
        var n = 0;
        vals[0] = Number.NaN;
        vals[1] = Number.NaN;
        for (var i = 0; i < arr.length; i++) {
            median.push(arr[i]);
            n++
        }
        if (n > 0) {
            vals[1] = n;
            median.sort(function(a, b) {
                return a - b
            });
            if (n % 2) {
                vals[0] = median[parseInt(n / 2)]
            } else {
                vals[0] = (median[parseInt((n - 1) / 2)] + median[n / 2]) / 2
            }
        }
        return vals
    };
    this.meanStandardDeviationN = function(arr, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var vals = [];
        var stdev = 0;
        var mean = 0;
        var n = 0;
        for (var i = 0; i < arr.length; i++) {
            mean += arr[i];
            stdev += arr[i] * arr[i];
            n++
        }
        if (n > 0) {
            mean /= n;
            stdev = Math.sqrt(stdev / n - mean * mean);
            vals.push(mean);
            vals.push(stdev);
            vals.push(n)
        } else {
            vals.push("");
            vals.push("");
            vals.push("")
        }
        return vals
    };
    this.quantiles = function(arr, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var vals = [];
        var out = [];
        var n = arr.length;
        if (n > 2) {
            var qtl1i = Math.floor(n * 0.25);
            var qtl2i = Math.floor(n * 0.5);
            var qtl3i = Math.floor(n * 0.75);
            arr.sort(function(a, b) {
                return a - b
            });
            var qtl1;
            var qtl2;
            var qtl3;
            if (n % 2) {
                qtl2 = arr[qtl2i]
            } else {
                qtl2 = this.mean([arr[qtl2i - 1], arr[qtl2i]])
            } if ((n / 2) % 2) {
                qtl1 = arr[qtl1i];
                qtl3 = arr[qtl3i]
            } else {
                qtl1 = this.mean([arr[qtl1i - 1], arr[qtl1i]]);
                qtl3 = this.mean([arr[qtl3i - 1], arr[qtl3i]])
            }
            var iqr = (qtl3 - qtl1) * 1.5;
            var iqr1;
            var iqr3;
            for (var i = 0; i <= qtl1i; i++) {
                if (arr[i] < qtl1 - iqr) {
                    out.push(arr[i])
                } else {
                    iqr1 = arr[i];
                    break
                }
            }
            for (var i = n - 1; i >= qtl3i; i--) {
                if (arr[i] > qtl3 + iqr) {
                    out.push(arr[i])
                } else {
                    iqr3 = arr[i];
                    break
                }
            }
            vals.push(qtl1);
            vals.push(qtl2);
            vals.push(qtl3);
            vals.push(iqr1);
            vals.push(iqr3);
            vals.push(out);
            vals.push(n)
        } else {
            if (n > 1) {
                vals.push(arr[0]);
                vals.push(arr[1]);
                vals.push(arr[1]);
                vals.push(arr[0]);
                vals.push(arr[1]);
                vals.push(out);
                vals.push(n)
            } else {
                if (n > 0) {
                    vals.push(arr[0]);
                    vals.push(arr[0]);
                    vals.push(arr[0]);
                    vals.push(arr[0]);
                    vals.push(arr[0]);
                    vals.push(out);
                    vals.push(n)
                } else {
                    vals.push(Number.NaN);
                    vals.push(Number.NaN);
                    vals.push(Number.NaN);
                    vals.push(Number.NaN);
                    vals.push(Number.NaN);
                    vals.push(Number.NaN)
                }
            }
        }
        return vals
    };
    this.covariance = function(arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var sxy = 0;
        var n = 0;
        var m1 = this.mean(arr1);
        var m2 = this.mean(arr2);
        for (var i = 0; i < arr1.length; i++) {
            sxy += arr1[i] * arr2[i];
            n++
        }
        if (n > 0) {
            sxy /= n;
            return sxy - (m1 * m2)
        }
        return sxy
    };
    this.correlation = function(arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var n = 0;
        var sx = 0;
        var sy = 0;
        var sx2 = 0;
        var sy2 = 0;
        var cov = this.covariance(arr1, arr2);
        var cor = 0;
        for (var i = 0; i < arr1.length; i++) {
            sx += arr1[i];
            sy += arr2[i];
            sx2 += arr1[i] * arr1[i];
            sy2 += arr2[i] * arr2[i];
            n++
        }
        if (n > 0) {
            cor = (n * n) * cov / Math.sqrt(((n * sx2) - (sx * sx)) * ((n * sy2) - (sy * sy)))
        }
        return cor
    };
    this.regression = function(arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var n = 0;
        var sx = 0;
        var sy = 0;
        var sxy = 0;
        var sx2 = 0;
        var sy2 = 0;
        var cov = this.covariance(arr1, arr2);
        var cor = 0;
        var slope = 0;
        var inter = 0;
        for (var i = 0; i < arr1.length; i++) {
            sx += arr1[i];
            sy += arr2[i];
            sxy += arr1[i] * arr2[i];
            sx2 += arr1[i] * arr1[i];
            sy2 += arr2[i] * arr2[i];
            n++
        }
        if (n > 2) {
            slope = (n * sxy - sx * sy) / (n * sx2 - sx * sx);
            inter = (sy - slope * sx) / n;
            cor = (n * n) * cov / Math.sqrt(((n * sx2) - (sx * sx)) * ((n * sy2) - (sy * sy)))
        }
        return [slope, inter, cor]
    };
    this.slope = function(x0, y0, x1, y1) {
        return y0 != y1 ? (x1 - x0) / (y1 - y0) : 0
    };
    this.intercept = function(x, y, s) {
        return y - (x * s)
    };
    this.slopeIntercept = function(x0, y0, x1, y1) {
        var s = this.slope(x0, y0, x1, y1);
        return [s, this.intercept(x0, y0, s)]
    };
    this.normalize = function(d) {
        for (var i = 0; i < d.length; i++) {
            var msd = this.meanStandardDeviationN(d[i]);
            for (var j = 0; j < d[i].length; j++) {
                d[i][j] = (d[i][j] - msd[0]) / msd[1]
            }
        }
        return d
    };
    this.euclidianDistance = function(arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var d = 0;
        if (arr1.length == arr2.length) {
            for (var i = 0; i < arr1.length; i++) {
                d += Math.pow(arr1[i] - arr2[i], 2)
            }
            d = Math.sqrt(d)
        }
        return d
    };
    this.manhattanDistance = function(arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var d = 0;
        if (arr1.length == arr2.length) {
            for (var i = 0; i < arr1.length; i++) {
                d += Math.abs(arr1[i] - arr2[i])
            }
        }
        return d
    };
    this.maxDistance = function(arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var d = 0;
        if (arr1.length == arr2.length) {
            for (var i = 0; i < arr1.length; i++) {
                d = Math.max(d, Math.abs(arr1[i] - arr2[i]))
            }
        }
        return d
    };
    this.addVectors = function(arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var arr = [];
        if (arr1.length == arr2.length) {
            for (var i = 0; i < arr1.length; i++) {
                arr.push(arr1[i] + arr2[i])
            }
        }
        return arr
    };
    this.compareVectors = function(arr1, arr2) {
        if (this.isArray(arr1) && this.isArray(arr2)) {
            if (arr1.length != arr2.length) {
                return false
            }
            for (var i = 0; i < arr1.length; i++) {
                if (this.isArray(arr1[i]) && this.isArray(arr2[i])) {
                    if (!this.compareArrays(arr1[i], arr2[i])) {
                        return false
                    }
                }
                if (arr1[i] !== arr2[i]) {
                    return false
                }
            }
            return true
        }
    };
    this.vectorDotProduct = function(arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var s = 0;
        if (arr1.length == arr2.length) {
            for (var i = 0; i < arr1.length; i++) {
                s += arr1[i] * arr2[i]
            }
        }
        return s
    };
    this.multiplyVectorByValue = function(arr, val, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        for (var i = 0; i < arr.length; i++) {
            arr[i] *= val
        }
        return arr
    };
    this.getCentroid = function(c1s, c1c, c2s, c2c) {
        var c = [];
        if (c1c.length == c2c.length) {
            var s = c1s + c2s;
            for (var i = 0; i < c1c.length; i++) {
                c.push((c1s * c1c[i] + c2s * c2c[i]) / s)
            }
        }
        return c
    };
    this.createNode = function(id, l, r, d, c, m) {
        var n = {
            id: id,
            left: l,
            right: r,
            dist: d,
            centroid: c
        };
        if (m) {
            n.mid = m
        }
        if (l == null && r == null) {
            n.size = 1;
            n.depth = 0
        } else {
            n.size = l.size + r.size;
            n.depth = 1 + Math.max(l.depth, r.depth)
        }
        return n
    };
    this.createRandomVectors = function(k, vectors) {
        var n = vectors.length;
        if (k > n) {
            return null
        }
        var sv = [];
        var si = [];
        var ti = {};
        var t = 0;
        var s = 0;
        var v, sel;
        while (s < k) {
            if (t == n) {
                return null
            }
            var ri = Math.floor(Math.random() * n);
            if (ri in ti) {
                continue
            }
            ti[ri] = 1;
            t++;
            v = vectors[ri];
            sel = true;
            for (var i = 0; i < s; i++) {
                if (this.compareVectors(v, sv[i])) {
                    sel = false;
                    break
                }
            }
            if (sel) {
                sv[s] = v;
                si[s] = ri;
                s++
            }
        }
        return {
            vectors: sv,
            indices: si
        }
    };
    this.imputeDatum = function(idx) {
        var vals = [];
        if (this.clusterAxis == "samples") {
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                vals.push(this.data.y.data[ii][idx])
            }
        } else {
            for (var i = 0; i < this.smpIndices.length; i++) {
                var ii = this.smpIndices[i];
                vals.push(this.data.y.data[idx][ii])
            }
        }
        return this[this.imputeMethod](vals)
    };
    this.getIdsForClustering = function() {
        var d = [];
        if (this.clusterAxis == "samples") {
            for (var i = 0; i < this.smpIndices.length; i++) {
                var ii = this.smpIndices[i];
                d[i] = this.useSmpVarIndexOnClustering ? ii : this.data.y.smps[ii]
            }
        } else {
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                d[i] = this.useSmpVarIndexOnClustering ? ii : this.data.y.vars[ii]
            }
        }
        return d
    };
    this.getDataForClustering = function() {
        var d = [];
        var m = [];
        if (this.clusterAxis == "samples") {
            for (var i = 0; i < this.smpIndices.length; i++) {
                d[i] = []
            }
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                for (var j = 0; j < this.smpIndices.length; j++) {
                    var jj = this.smpIndices[j];
                    var val = this.data.y.data[ii][jj];
                    if (isNaN(val)) {
                        if (!m[j]) {
                            m[j] = this.imputeDatum(jj)
                        }
                        val = m[j]
                    }
                    d[j][i] = val
                }
            }
        } else {
            for (var i = 0; i < this.varIndices.length; i++) {
                d[i] = []
            }
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                for (var j = 0; j < this.smpIndices.length; j++) {
                    var jj = this.smpIndices[j];
                    var val = this.data.y.data[ii][jj];
                    if (isNaN(val)) {
                        if (!m[i]) {
                            m[i] = this.imputeDatum(ii)
                        }
                        val = m[i]
                    }
                    d[i][j] = val
                }
            }
        } if (this.centerData) {
            d = this.normalize(d)
        }
        return d
    };
    this.cluster = function() {
        this.useSmpVarIndexOnClustering = true;
        var tree;
        var d = this.getDataForClustering();
        var l = this.getIdsForClustering();
        var dis = [];
        var minD = [];
        var cSize = [];
        var cls = [];
        for (var i = 0; i < d.length; i++) {
            dis[i] = []
        }
        for (var i = 0; i < d.length; i++) {
            dis[i][i] = Number.POSITIVE_INFINITY;
            for (var j = i + 1; j < d.length; j++) {
                dis[i][j] = this[this.distance + "Distance"](d[i], d[j]);
                dis[j][i] = dis[i][j]
            }
        }
        for (var i = 0; i < d.length; i++) {
            minD[i] = 0;
            for (var j = 0; j < d.length; j++) {
                if (dis[i][minD[i]] > dis[i][j]) {
                    minD[i] = j
                }
            }
        }
        for (var i = 0; i < d.length; i++) {
            cls[i] = [];
            cls[i][0] = this.createNode(l[i], null, null, 0, d[i]);
            cSize[i] = 1
        }
        for (var p = 0; p < d.length - 1; p++) {
            var c1 = 0;
            for (var i = 0; i < d.length; i++) {
                if (dis[i][minD[i]] < dis[c1][minD[c1]]) {
                    c1 = i
                }
            }
            var c2 = minD[c1];
            var c1c = cls[c1][0];
            var c2c = cls[c2][0];
            var newCntd = this.getCentroid(c1c.size, c1c.centroid, c2c.size, c2c.centroid);
            var newCls = this.createNode(-1, c1c, c2c, dis[c1][c2], newCntd);
            cls[c1].splice(0, 0, newCls);
            cSize[c1] += cSize[c2];
            for (var j = 0; j < d.length; j++) {
                if (this.linkage == "single") {
                    if (dis[c1][j] > dis[c2][j]) {
                        dis[j][c1] = dis[c1][j] = dis[c2][j]
                    }
                } else {
                    if (this.linkage == "complete") {
                        if (dis[c1][j] < dis[c2][j]) {
                            dis[j][c1] = dis[c1][j] = dis[c2][j]
                        }
                    } else {
                        if (this.linkage == "average") {
                            dis[j][c1] = dis[c1][j] = (cSize[c1] * dis[c1][j] + cSize[c2] * dis[c2][j]) / (cSize[c1] + cSize[j])
                        }
                    }
                }
            }
            dis[c1][c1] = Number.POSITIVE_INFINITY;
            for (var i = 0; i < d.length; i++) {
                dis[i][c2] = dis[c2][i] = Number.POSITIVE_INFINITY
            }
            for (var j = 0; j < d.length; j++) {
                if (minD[j] == c2) {
                    minD[j] = c1
                }
                if (dis[c1][j] < dis[c1][minD[c1]]) {
                    minD[c1] = j
                }
            }
            tree = newCls
        }
        return this.writeNewick(tree)
    };
    this.isLeafNode = function(node) {
        if (node.left == null && node.right == null) {
            return true
        } else {
            return false
        }
    };
    this.writeNewick = function(tree, dist) {
        var str = "";
        var str1 = "";
        if (this.isLeafNode(tree)) {
            str = tree.id
        } else {
            var m;
            var l = this.writeNewick(tree.left, dist);
            var r = this.writeNewick(tree.right, dist);
            if (tree.mid) {
                for (var i = 0; i < tree.mid.length; i++) {
                    if (dist && tree.mid[i].dist) {
                        str1 += "," + tree.mid[i].id + ":" + tree.mid[i].dist
                    } else {
                        str1 += "," + tree.mid[i].id
                    }
                    str1 += tree.mid[i].id
                }
            }
            str = "(" + l + str1 + "," + r + ")"
        } if (dist && tree.dist) {
            str += ":" + tree.dist
        }
        return str
    };
    this.kmeans = function() {
        var obj;
        var d = this.getDataForClustering();
        var l = this.getIdsForClustering();
        var assig = [];
        var cSize = [];
        var rep = true;
        var iter = 0;
        var cntd = null;
        var t = this.createRandomVectors(this.kmeansClusters, d);
        if (t == null) {
            return null
        } else {
            cntd = t.vectors
        }
        while (rep) {
            for (var i = 0; i < this.kmeansClusters; i++) {
                cSize[i] = 0
            }
            for (var i = 0; i < d.length; i++) {
                var v = d[i];
                var min = Number.MAX_VALUE;
                var best;
                for (var j = 0; j < this.kmeansClusters; j++) {
                    var dis = this.euclidianDistance(cntd[j], v);
                    if (dis < min) {
                        min = dis;
                        best = j
                    }
                }
                cSize[best]++;
                assig[i] = best
            }
            var newCntd = [];
            for (var i = 0; i < this.kmeansClusters; i++) {
                newCntd[i] = null
            }
            for (var i = 0; i < d.length; i++) {
                if (newCntd[assig[i]] == null) {
                    newCntd[assig[i]] = d[i]
                } else {
                    newCntd[assig[i]] = this.addVectors(newCntd[assig[i]], d[i])
                }
            }
            for (var i = 0; i < this.kmeansClusters; i++) {
                newCntd[i] = this.multiplyVectorByValue(newCntd[i], 1 / cSize[i])
            }
            rep = false;
            for (var i = 0; i < this.kmeansClusters; i++) {
                if (!this.compareVectors(newCntd[i], cntd[i])) {
                    rep = true;
                    break
                }
            }
            cntd = newCntd;
            iter++;
            if (iter > this.maxIterations) {
                rep = false
            }
        }
        for (var i = 0; i < assig.length; i++) {
            assig[i] = "K-" + (assig[i] + 1)
        }
        return assig
    };
    this.transpose = function(data, soft) {
        if (data) {
            var d = [];
            for (var i = 0; i < data.length; i++) {
                for (var j = 0; j < data[i].length; j++) {
                    if (!d[j]) {
                        d[j] = []
                    }
                    d[j][i] = data[i][j]
                }
            }
            return d
        } else {
            this.ungroupSamples();
            this.transform("reset");
            if (this.data.l) {
                delete(this.data.l)
            }
            if (this.data.d) {
                delete(this.data.d)
            }
            if (this.data.a) {
                delete(this.data.a)
            }
            if (this.data.t) {
                var v = this.data.t.vars;
                var s = this.data.t.smps;
                if (v) {
                    this.data.t.smps = v
                }
                if (s) {
                    this.data.t.vars = s
                }
            }
            var x = this.data.x;
            var z = this.data.z;
            if (x) {
                this.data.z = x
            }
            if (z) {
                this.data.x = z
            }
            var s = this.data.y.smps;
            this.data.y.smps = this.data.y.vars;
            this.data.y.vars = s;
            var d = this.data.y.data;
            this.data.y.data = [];
            for (var i = 0; i < this.data.y.vars.length; i++) {
                this.data.y.data[i] = [];
                for (var j = 0; j < this.data.y.smps.length; j++) {
                    this.data.y.data[i][j] = d[j][i]
                }
            }
            if (!soft) {
                this.initializeData(this.data);
                this.resetObject();
                this.draw()
            }
        }
    };
    this.checkObject = function() {
        var level = this.data.y;
        if (this.isGroupedData) {
            this.data.w = {};
            level = this.data.w
        }
        var keys = ["vars", "smps", "desc", "data", "mean", "median", "stdev", "n", "qtl1", "qtl3", "iqr1", "iqr3", "out", "trans", "cor", "sum", "grps", "close", "open", "high", "low", "volume", "factors"];
        for (var i = 0; i < keys.length; i++) {
            if (!level[keys[i]]) {
                if (keys[i] == "factors") {
                    level[keys[i]] = {}
                } else {
                    level[keys[i]] = []
                }
            }
        }
    };
    this.resetObject = function(check) {
        var keys = ["mean", "median", "stdev", "n", "qtl1", "qtl3", "iqr1", "iqr3", "out", "cor", "sum", "grps", "close", "open", "high", "low", "volume", "factors"];
        if (this.isGroupedData) {
            if (!this.isTransformedData) {
                keys.push("trans")
            }
            for (var i = 0; i < keys.length; i++) {
                delete(this.data.y[keys[i]])
            }
            delete(this.data.w)
        } else {
            if (!this.isTransformedData) {
                keys.push("trans")
            }
            if (this.isRawData) {
                for (var i = 0; i < keys.length; i++) {
                    delete(this.data.y[keys[i]])
                }
            } else {
                delete(this.data.y.data)
            }
        } if (check) {
            this.checkObject()
        }
    };
    this.getDataAtPos = function(i, j, att, transform, min, max) {
        var val = Number.NaN;
        var level = this.isGroupedData ? this.data.w : this.data.y;
        if (this.isGroupedData || !this.isRawData) {
            if (this.isTransformedData) {
                val = level.trans[i][j]
            } else {
                att = att ? att : this.summaryType;
                if (level.hasOwnProperty(att)) {
                    val = level[att][i][j]
                } else {
                    val = 0
                }
            }
        } else {
            if (att) {
                if (level[att] && level[att][i]) {
                    val = level[att][i][j]
                }
            } else {
                if (this.isTransformedData) {
                    val = level.trans[i][j]
                } else {
                    val = level.data[i][j]
                }
            }
        } if (transform) {
            if (!isNaN(val)) {
                if (transform == "log2") {
                    val = Math.log(val) / Math.LN2
                } else {
                    if (transform == "log10") {
                        val = Math.log(val) / Math.LN10
                    } else {
                        if (transform == "exp2") {
                            val = Math.pow(2, val)
                        } else {
                            if (transform == "exp10") {
                                val = Math.pow(2, val)
                            } else {
                                if (transform == "percentile") {
                                    val = this.percentile(min, max, val)
                                }
                            }
                        }
                    }
                }
            }
        }
        return val
    };
    this.getDataForSmpGrpAtIndex = function(idx, indices, att) {
        var arr = [];
        if (!indices) {
            indices = this.varIndices
        }
        if (this.isGroupedData || !this.isRawData) {
            var level = this.isGroupedData ? this.data.w : this.data.y;
            if (this.isTransformedData) {
                arr.push(level.trans[ii][idx])
            } else {
                att = this.summaryType;
                if (level.hasOwnProperty(att)) {
                    for (var i = 0; i < indices.length; i++) {
                        var ii = indices[i];
                        arr.push(level[att][ii][idx])
                    }
                }
            }
        } else {
            var data = att ? this.data.y[att] : this.data.y.data;
            if (this.isTransformedData) {
                for (var i = 0; i < indices.length; i++) {
                    var ii = indices[i];
                    arr.push(this.data.y.trans[ii][idx])
                }
            } else {
                for (var i = 0; i < indices.length; i++) {
                    var ii = indices[i];
                    arr.push(data[ii][idx])
                }
            }
        }
        return arr
    };
    this.getDataForVariableAtIndex = function(idx) {
        var arr = [];
        if (this.isTransformedData) {
            for (var i = 0; i < this.smpIndices.length; i++) {
                var ii = this.smpIndices[i];
                arr.push(this.data.y.trans[idx][ii])
            }
        } else {
            for (var i = 0; i < this.smpIndices.length; i++) {
                var ii = this.smpIndices[i];
                arr.push(this.data.y.data[idx][ii])
            }
        }
        return arr
    };
    this.getMetaDataForVariableAtIndex = function(idx) {
        var obj = {};
        if (this.data.z) {
            for (var ant in this.data.z) {
                obj[ant] = this.data.z[ant][idx]
            }
        }
        obj[name] = this.data.y.vars[idx];
        return obj
    };
    this.getMetaDataForSampleAtIndex = function(idx) {
        if (this.isGroupedData) {
            return this.getMetaDataForGrpAtIndex(idx)
        } else {
            return this.getMetaDataForSmpAtIndex(idx)
        }
    };
    this.getMetaDataForSmpAtIndex = function(idx) {
        var obj = {};
        if (this.data.x) {
            for (var ant in this.data.x) {
                obj[ant] = this.data.x[ant][idx]
            }
        }
        obj[name] = this.data.y.vars[idx];
        return obj
    };
    this.getMetaDataForGrpAtIndex = function(idx) {
        var obj = [];
        for (var i = 0; i < this.data.w.grps[idx].length; i++) {
            var ii = this.data.w.grps[idx][i];
            obj.push(this.getMetaDataForSmpAtIndex[ii])
        }
        return obj
    };
    this.summarize = function(type, arrs) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        var filterSmp = this.isGroupedData ? false : true;
        if (!this.isGroupedData) {
            this.checkObject()
        }
        if (type == "cor") {
            this.isBoxPlotCalc = false;
            if (this.correlationAxis == "samples") {
                var indices = this.isGroupedData ? this.grpIndices : this.smpIndices;
                for (var i = 0; i < indices.length; i++) {
                    var ii = indices[i];
                    var arr1 = this.getDataForSmpGrpAtIndex(ii);
                    if (!level.cor[ii]) {
                        level.cor[ii] = []
                    }
                    for (var j = i; j < indices.length; j++) {
                        var jj = indices[j];
                        if (!level.cor[jj]) {
                            level.cor[jj] = []
                        }
                        var arr2 = this.getDataForSmpGrpAtIndex(jj);
                        if (i == j) {
                            if (this.isTransformedData) {
                                level.trans[ii][jj] = 1
                            }
                            level.cor[ii][jj] = 1
                        } else {
                            level.cor[ii][jj] = this.correlation(arr1, arr2);
                            level.cor[jj][ii] = level.cor[ii][jj];
                            if (this.isTransformedData) {
                                level.trans[ii][jj] = level.cor[ii][jj];
                                level.trans[jj][ii] = level.cor[jj][ii]
                            }
                        }
                    }
                }
            } else {
                for (var i = 0; i < this.varIndices.length; i++) {
                    var ii = this.varIndices[i];
                    if (!level.cor[ii]) {
                        level.cor[ii] = []
                    }
                    for (var j = i; j < this.varIndices.length; j++) {
                        var jj = this.varIndices[j];
                        if (!level.cor[jj]) {
                            level.cor[jj] = []
                        }
                        if (i == j) {
                            level.cor[ii][jj] = 1;
                            if (this.isTransformedData) {
                                level.trans[ii][jj] = 1
                            }
                        } else {
                            level.cor[ii][jj] = this.correlation(level.data[ii], level.data[jj], filterSmp);
                            level.cor[jj][ii] = level.cor[ii][jj];
                            if (this.isTransformedData) {
                                level.trans[ii][jj] = level.cor[ii][jj];
                                level.trans[jj][ii] = level.cor[jj][ii]
                            }
                        }
                    }
                }
            }
        } else {
            this.isBoxPlotCalc = type == "iqr" ? true : false;
            for (var i = 0; i < this.varIndices.length; i++) {
                var arr;
                var ii = this.varIndices[i];
                if (!level.mean[ii]) {
                    level.trans[ii] = [];
                    level.mean[ii] = [];
                    level.median[ii] = [];
                    level.stdev[ii] = [];
                    level.qtl1[ii] = [];
                    level.qtl3[ii] = [];
                    level.iqr1[ii] = [];
                    level.iqr3[ii] = [];
                    level.out[ii] = [];
                    level.n[ii] = [];
                    level.sum[ii] = []
                }
                if (this.isGroupedData) {
                    arr = arrs[ii]
                } else {
                    level.grps = [];
                    arr = [];
                    for (var j = 0; j < this.smpIndices.length; j++) {
                        var jj = this.smpIndices[j];
                        level.grps[j] = [];
                        level.grps[j].push(jj);
                        arr[j] = [level.data[ii][jj]]
                    }
                } if (type == "iqr") {
                    this.summaryType = "iqr";
                    for (var j = 0; j < arr.length; j++) {
                        var vals = this.quantiles(arr[j], filterSmp);
                        if (this.isTransformedData) {
                            level.trans[ii][j] = vals[1]
                        }
                        level.median[ii][j] = vals[1];
                        level.qtl1[ii][j] = vals[0];
                        level.qtl3[ii][j] = vals[2];
                        level.iqr1[ii][j] = vals[3];
                        level.iqr3[ii][j] = vals[4];
                        level.out[ii][j] = vals[5];
                        level.n[ii][j] = vals[6]
                    }
                } else {
                    if (type == "median") {
                        this.summaryType = "median";
                        for (var j = 0; j < arr.length; j++) {
                            var vals = this.median(arr[j], filterSmp);
                            if (this.isTransformedData) {
                                level.trans[ii][j] = vals[1]
                            }
                            level.median[ii][j] = vals[0];
                            level.n[ii][j] = vals[1]
                        }
                    } else {
                        if (type == "mean") {
                            this.summaryType = "mean";
                            for (var j = 0; j < arr.length; j++) {
                                var vals = this.meanStandardDeviationN(arr[j], filterSmp);
                                if (this.isTransformedData) {
                                    level.trans[ii][j] = vals[1]
                                }
                                level.mean[ii][j] = vals[0];
                                level.stdev[ii][j] = vals[1];
                                level.n[ii][j] = vals[2]
                            }
                        } else {
                            if (type == "sum") {
                                this.summaryType = "sum";
                                for (var j = 0; j < arr.length; j++) {
                                    var sum = this.sum(arr[j], filterSmp);
                                    if (this.isTransformedData) {
                                        level.trans[ii][j] = sum
                                    }
                                    level.sum[ii][j] = sum;
                                    level.n[ii][j] = arr[j].length
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.copySummarizedData = function() {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        var exp;
        for (var i = 0; i < this.varIndices.length; i++) {
            var ii = this.varIndices[i];
            level.data[ii] = [];
            level.trans[ii] = [];
            if (this.summaryType == "mean") {
                for (var j = 0; j < level.mean[ii].length; j++) {
                    level.data[ii][j] = level.mean[ii][j]
                }
            } else {
                if (this.summaryType == "median" || this.summaryType == "iqr") {
                    for (var j = 0; j < level.median[ii].length; j++) {
                        level.data[ii][j] = level.median[ii][j]
                    }
                } else {
                    if (this.summaryType == "candle") {
                        for (var j = 0; j < level.close[ii].length; j++) {
                            level.data[ii][j] = level.close[ii][j]
                        }
                    } else {
                        if (this.summaryType == "volume") {
                            for (var j = 0; j < level.volume[ii].length; j++) {
                                level.data[ii][j] = level.volume[ii][j]
                            }
                        } else {
                            if (this.summaryType == "sum") {
                                for (var j = 0; j < level.volume[ii].length; j++) {
                                    level.data[ii][j] = level.sum[ii][j]
                                }
                            }
                        }
                    }
                }
            } if (!exp) {
                exp = ii
            }
        }
        return exp
    };
    this.transformValue = function(type, val, inv) {
        switch (type) {
            case "log2":
                return inv ? Math.pow(2, val) : Math.log(val) / Math.LN2;
            case "log10":
                return inv ? Math.pow(10, val) : Math.log(val) / Math.LN10;
            case "exp2":
                return inv ? Math.log(val) / Math.LN2 : Math.pow(2, val);
            case "exp10":
                return inv ? Math.log(val) / Math.LN10 : Math.pow(10, val);
            default:
                return val
        }
    };
    this.transform = function(type, axis, idx) {
        var exp = 0;
        if (!this.isGroupedData) {
            this.checkObject()
        }
        if (!this.isRawData || this.isGroupedData) {
            exp = this.copySummarizedData()
        }
        this.transformType = type;
        if (type == "reset" || type == "undo") {
            this.transformReset();
            this.transformType = false;
            this.isTransformedData = false
        } else {
            if (type == "save") {
                this.transformSave();
                this.transformType = false;
                this.isTransformedData = false
            } else {
                if (type == "log2" || type == "log10" || type == "exp2" || type == "exp10") {
                    this.transformLogExp(type);
                    this.isTransformedData = true
                } else {
                    if (type == "ratio" || type == "ratio2" || type == "ratio10") {
                        this.transformRatio(type, idx);
                        this.isTransformedData = true
                    } else {
                        this.transformRelative(type, axis, exp);
                        this.isTransformedData = true
                    }
                }
            }
        }
        this.draw()
    };
    this.transformReset = function() {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        for (var i = 0; i < this.varIndices.length; i++) {
            var ii = this.varIndices[i];
            for (var j = 0; j < level.data[ii].length; j++) {
                if (level.trans[ii] && !isNaN(level.data[ii][j])) {
                    level.trans[ii][j] = level.data[ii][j]
                }
            }
        }
    };
    this.transformSave = function() {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        for (var i = 0; i < this.varIndices.length; i++) {
            var ii = this.varIndices[i];
            for (var j = 0; j < level.data[ii].length; j++) {
                if (!isNaN(level.data[ii][j])) {
                    level.data[ii][j] = level.trans[ii][j]
                }
            }
        }
    };
    this.transformLogExp = function(type) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        if (type == "log") {
            type = this.transformBase == 2 ? "type2" : "type10"
        } else {
            if (type == "exp") {
                type = this.transformBase == 2 ? "exp2" : "exp10"
            }
        }
        for (var i = 0; i < this.varIndices.length; i++) {
            var ii = this.varIndices[i];
            if (!level.trans[ii]) {
                level.trans[ii] = []
            }
            for (var j = 0; j < level.data[ii].length; j++) {
                if (!isNaN(level.data[ii][j])) {
                    if (type == "log2") {
                        this.isLogData = true;
                        this.transformBase = 2;
                        level.trans[ii][j] = Math.log(level.data[ii][j]) / Math.LN2
                    } else {
                        if (type == "log10") {
                            this.isLogData = true;
                            this.transformBase = 10;
                            level.trans[ii][j] = Math.log(level.data[ii][j]) / Math.LN10
                        } else {
                            if (type == "exp2") {
                                this.isLogData = false;
                                this.transformBase = 2;
                                level.trans[ii][j] = Math.pow(2, level.data[ii][j])
                            } else {
                                if (type == "exp10") {
                                    this.isLogData = false;
                                    this.transformBase = 10;
                                    level.trans[ii][j] = Math.pow(10, level.data[ii][j])
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.transformRatio = function(type, idx) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        idx = idx ? idx : this.ratioReference ? this.ratioReference : 0;
        for (var i = 0; i < this.varIndices.length; i++) {
            var ii = this.varIndices[i];
            if (!level.trans[ii]) {
                level.trans[ii] = []
            }
            for (var j = 0; j < level.data[ii].length; j++) {
                if (!isNaN(level.data[ii][j]) && !isNaN(level.data[ii][idx])) {
                    if (this.isLogData) {
                        if (type == "ratio") {
                            type = this.transformBase == 2 ? "ratio2" : "ratio10"
                        }
                        var val;
                        if (level.data[ii][j] >= level.data[ii][idx]) {
                            val = level.data[ii][j] - level.data[ii][idx];
                            if (type == "ratio2") {
                                level.trans[ii][j] = Math.pow(2, val)
                            } else {
                                if (type == "ratio10") {
                                    level.trans[ii][j] = Math.pow(10, val)
                                }
                            }
                        } else {
                            val = level.data[ii][idx] / level.data[ii][i];
                            if (type == "ratio2") {
                                level.trans[ii][j] = Math.pow(2, val) * -1
                            } else {
                                level.trans[ii][j] = Math.pow(10, val) * -1
                            }
                        }
                    } else {
                        if (level.data[ii][j] >= level.data[ii][idx]) {
                            level.trans[ii][j] = level.data[ii][j] / level.data[ii][idx]
                        } else {
                            level.trans[ii][j] = level.data[ii][idx] / level.data[ii][j] * -1
                        }
                    }
                }
            }
        }
    };
    this.transformRelative = function(type, axis, exp) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        var filterSmp = this.isGroupedData ? false : true;
        axis = axis ? axis : this.zscoreAxis ? this.zscoreAxis : "samples";
        if (axis == "samples") {
            for (var i = 0; i < level.data[exp].length; i++) {
                var arr = [];
                for (var j = 0; j < this.varIndices.length; j++) {
                    var jj = this.varIndices[j];
                    arr.push(level.data[jj][i])
                }
                if (type == "percentile") {
                    var vals = this.range(arr, filterSmp)
                } else {
                    if (type == "zscore") {
                        var vals = this.meanStandardDeviationN(arr, filterSmp)
                    }
                }
                for (var j = 0; j < this.varIndices.length; j++) {
                    var jj = this.varIndices[j];
                    if (!level.trans[jj]) {
                        level.trans[jj] = []
                    }
                    if (!isNaN(level.data[jj][i])) {
                        if (type == "percentile") {
                            level.trans[jj][i] = this.percentile(vals[0], vals[1], level.data[jj][i])
                        } else {
                            if (type == "zscore") {
                                level.trans[jj][i] = (level.data[jj][i] - vals[0]) / vals[1]
                            }
                        }
                    }
                }
            }
        } else {
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                level.trans[ii] = [];
                var arr = level.data[ii];
                if (type == "percentile") {
                    var vals = this.range(arr, filterSmp)
                } else {
                    if (type == "zscore") {
                        var vals = this.meanStandardDeviationN(arr, filterSmp)
                    }
                }
                for (var j = 0; j < arr.length; j++) {
                    if (!isNaN(level.data[ii][j])) {
                        if (type == "percentile") {
                            level.trans[ii][j] = this.percentile(vals[0], vals[1], level.data[ii][j])
                        } else {
                            if (type == "zscore") {
                                level.trans[ii][j] = (level.data[ii][j] - vals[0]) / vals[1]
                            }
                        }
                    }
                }
            }
        }
    };
    this.sortSamples = function(d, c, v, a, o) {
        this.sortIndices("smps", d, c, false, v, a, o);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.sortSamplesByCategory = function(c) {
        this.sortIndices("smps", false, c);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.sortSamplesByVariable = function(v, a) {
        var i = parseInt(this.getVariableIndices(v));
        this.sortIndices("smps", false, false, false, i + 1, a);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.sortVariables = function(d, c, s, a, o) {
        this.sortIndices("vars", d, c, s, false, a, o);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.sortVariablesByCategory = function(c) {
        this.sortIndices("vars", false, c);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.sortVariablesBySample = function(v) {
        var i = parseInt(this.getSampleIndices(v));
        this.sortIndices("vars", false, false, i + 1);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.getGroupingFactors = function(asArray) {
        if (asArray) {
            return this.groupingFactors
        } else {
            return this.getObjectArray(this.groupingFactors)
        }
    };
    this.modifyGroupingFactors = function(grps, check) {
        this.modifyObjectArray(grps, check, "groupingFactors")
    };
    this.segregateSamplesVariables = function(smps, vars, snme, vnme, nd) {
        delete(this.data.l);
        this.deleteSubGraphAttributes();
        this.data.l = {};
        this.data.l.smps = smps;
        this.data.l.vars = vars;
        this.data.l.weight = [];
        this.data.l.type = [];
        this.data.l.name = [];
        this.data.l.desc = [];
        var ws = 1 / smps.length;
        var wv = 1 / vars.length;
        var desc = this.data.y.desc[0] ? this.data.y.desc[0] : "";
        for (var i = 0; i < vars.length; i++) {
            for (var j = 0; j < smps.length; j++) {
                this.data.l.weight.push([wv, ws]);
                this.data.l.type.push(this.graphType);
                this.data.l.name.push([vnme[i], snme[j]]);
                this.data.l.desc.push(desc)
            }
        }
        this.layoutComb = true;
        this.layout = smps.length + "X" + vars.length;
        this.isValidLayout();
        if (!nd) {
            this.draw()
        }
    };
    this.desegregateSamples = function(nd) {
        this.segregateSamplesBy = false;
        this.showAnimation = this.showAnimationTemp;
        this.resetLayout();
        if (this.segregateVariablesBy) {
            this.segregateVariables(this.segregateVariablesBy, nd)
        } else {
            this.isValidLayout()
        } if (!nd) {
            this.draw()
        }
    };
    this.segregateSamples = function(annt, nd) {
        if (this.data.x && this.data.x[annt]) {
            delete(this.layoutParams);
            var l = {};
            var n = 0;
            var names = [];
            var smps = [];
            for (var i = 0; i < this.data.x[annt].length; i++) {
                var s = this.data.x[annt][i];
                if (!l.hasOwnProperty(s)) {
                    l[s] = [];
                    n++
                }
                l[s].push(this.data.y.smps[i])
            }
            var w = 1 / n;
            if (this.segregateVariablesBy) {
                vars = this.data.l.vars;
                for (var s in l) {
                    names.push(s);
                    smps.push(l[s])
                }
                this.segregateSamplesBy = annt;
                this.segregateSamplesVariables(smps, this.data.l.vars, names, this.data.l.name, nd)
            } else {
                delete(this.data.l);
                this.deleteSubGraphAttributes();
                this.data.l = {};
                this.data.l.smps = [];
                this.data.l.weight = [];
                this.data.l.type = [];
                this.data.l.name = [];
                this.data.l.desc = [];
                for (var s in l) {
                    this.data.l.smps.push(l[s]);
                    this.data.l.weight.push(w);
                    this.data.l.type.push(this.graphType);
                    this.data.l.name.push(s);
                    this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "")
                }
                this.segregateSamplesBy = annt;
                this.layoutComb = true;
                this.showAnimationTemp = this.showAnimation;
                this.showAnimation = false;
                this.layout = "1X" + this.data.l.smps.length;
                this.isValidLayout()
            } if (!nd) {
                this.draw()
            }
        }
    };
    this.desegregateVariables = function(nd) {
        this.segregateVariablesBy = false;
        this.showAnimation = this.showAnimationTemp;
        this.resetLayout();
        if (this.segregateSamplesBy) {
            this.segregateSamples(this.segregateSamplesBy, nd)
        } else {
            this.isValidLayout()
        } if (!nd) {
            this.draw()
        }
    };
    this.segregateVariables = function(cat, nd) {
        if (this.data.z && this.data.z[cat]) {
            delete(this.layoutParams);
            var l = {};
            var n = 0;
            var vars = [];
            var names = [];
            for (var i = 0; i < this.data.z[cat].length; i++) {
                var g = this.data.z[cat][i];
                if (!l.hasOwnProperty(g)) {
                    l[g] = [];
                    n++
                }
                l[g].push(this.data.y.vars[i])
            }
            var w = 1 / n;
            if (this.segregateSamplesBy) {
                for (var g in l) {
                    names.push(g);
                    vars.push(l[g])
                }
                this.segregateVariablesBy = cat;
                this.segregateSamplesVariables(this.data.l.smps, vars, this.data.l.name, names, nd)
            } else {
                delete(this.data.l);
                this.deleteSubGraphAttributes();
                this.data.l = {};
                this.data.l.vars = [];
                this.data.l.weight = [];
                this.data.l.type = [];
                this.data.l.name = [];
                this.data.l.desc = [];
                for (var g in l) {
                    this.data.l.vars.push(l[g]);
                    this.data.l.weight.push(w);
                    this.data.l.type.push(this.graphType);
                    this.data.l.name.push(g);
                    this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "")
                }
                this.segregateVariablesBy = cat;
                this.layoutComb = true;
                this.showAnimationTemp = this.showAnimation;
                this.showAnimation = false;
                this.layout = "1X" + this.data.l.vars.length;
                this.isValidLayout()
            } if (!nd) {
                this.draw()
            }
        }
    };
    this.deleteSubGraphAttributes = function() {
        if (this.layoutRows && this.layoutCols) {
            var c = 0;
            for (var i = 0; i < this.layoutRows; i++) {
                for (var j = 0; j < this.layoutCols; j++) {
                    delete(this["subGraphWeight" + c]);
                    delete(this["subGraphType" + c]);
                    delete(this["subGraphSummaryType" + c]);
                    delete(this["subGraphTransformType" + c]);
                    c++
                }
            }
        }
    };
    this.unsetScatterPlotMatrix = function() {
        if (this.graphType.match(/Scatter/)) {
            if (this.xAxisTemp && this.xAxisTemp.length > 0) {
                this.xAxis = this.xAxisTemp;
                this.xAxisTmp = []
            }
            if (this.yAxisTemp && this.yAxisTemp.length > 0) {
                this.yAxis = this.yAxisTemp;
                this.yAxisTmp = []
            }
            if (this.zAxisTemp && this.zAxisTemp.length > 0) {
                this.zAxis = this.zAxisTemp;
                this.zAxisTmp = []
            }
            if (!this.xAxis || !this.yAxis) {
                this.xAxis = [];
                this.yAxis = [];
                this.xAxisIndices = [];
                this.yAxisIndices = [];
                this.xAxis = [this.data.y.smps[0]];
                for (var i = 1; i < this.data.y.smps.length; i++) {
                    this.yAxis.push(this.data.y.smps[i])
                }
                this.xAxisIndices = this.getSampleIndices(this.xAxis);
                this.yAxisIndices = this.getSampleIndices(this.yAxis);
                this.initAxes(true)
            }
            this.scatterPlotMatrix = false;
            if (this.showAnimationTemp) {
                this.showAnimation = this.showAnimationTemp
            }
            this.resetLayout();
            this.isValidLayout()
        }
    };
    this.setScatterPlotMatrix = function() {
        if (this.graphType.match(/Scatter/)) {
            var n = this.data.y.data[0].length;
            var w = 1 / n;
            this.xAxisTemp = this.xAxisTemp || this.xAxis;
            this.xAxis = [];
            this.yAxisTemp = this.yAxisTemp || this.yAxis;
            this.yAxis = [];
            this.zAxisTemp = this.zAxisTemp || this.zAxis;
            this.zAxis = [];
            this.data.l = {};
            this.data.l.smps = [];
            this.data.l.weight = [];
            this.data.l.type = [];
            this.data.l.desc = [];
            for (var i = 0; i < n; i++) {
                for (var j = 0; j < n; j++) {
                    this.data.l.weight.push(w);
                    this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "");
                    this.data.l.type.push(this.graphType);
                    if (i == j) {
                        this.data.l.smps.push({})
                    } else {
                        if (this.scatterPlotMatrixType == "upper") {
                            if (j > i) {
                                this.data.l.smps.push({
                                    xAxis: [this.data.y.smps[j]],
                                    yAxis: [this.data.y.smps[i]]
                                })
                            } else {
                                this.data.l.smps.push({})
                            }
                        } else {
                            if (this.scatterPlotMatrixType == "lower") {
                                if (i > j) {
                                    this.data.l.smps.push({
                                        xAxis: [this.data.y.smps[j]],
                                        yAxis: [this.data.y.smps[i]]
                                    })
                                } else {
                                    this.data.l.smps.push({})
                                }
                            } else {
                                this.data.l.smps.push({
                                    xAxis: [this.data.y.smps[j]],
                                    yAxis: [this.data.y.smps[i]]
                                })
                            }
                        }
                    }
                }
            }
            this.layoutComb = true;
            this.showAnimationTemp = this.showAnimation;
            this.showAnimation = false;
            this.layout = n + "X" + n;
            this.isValidLayout()
        }
    };
    this.setMultiplePies = function() {
        if (this.graphType.match(/Pie/)) {
            var r, c;
            var n = this.xAxis.length;
            if (this.layout) {
                var topo = this.layout.split(/X/i);
                r = parseInt(topo[0]);
                c = parseInt(topo[1]);
                if (r * c < n) {
                    r = Math.ceil(Math.sqrt(n));
                    c = Math.floor(Math.sqrt(n));
                    this.layout = r + "X" + c
                }
            } else {
                r = Math.ceil(Math.sqrt(n));
                c = Math.floor(Math.sqrt(n));
                this.layout = r + "X" + c
            }
            var wr = 1 / r;
            var wc = 1 / c;
            delete(this.layoutParams);
            delete(this.data.l);
            this.deleteSubGraphAttributes();
            this.data.l = {};
            this.data.l.smps = [];
            this.data.l.weight = [];
            this.data.l.type = [];
            this.data.l.desc = [];
            for (var i = 0; i < n; i++) {
                this.data.l.smps.push([this.xAxis[i]]);
                this.data.l.weight.push([wc, wr]);
                this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "");
                this.data.l.type.push(this.graphType)
            }
            this.layoutComb = true;
            this.showAnimationTemp = this.showAnimation;
            this.showAnimation = false;
            this.isValidLayout()
        }
    };
    this.ungroupSamples = function() {
        this.isGroupedData = false;
        this.groupingFactors = [];
        this.grpIndices = [];
        this.hiddenGrps = [];
        this.setMaxSmpStringName();
        this.setOriginalIndices(0, false, false, true);
        this.draw();
        return
    };
    this.createHistogram = function(axis) {
        var that = this;
        var idx, arr, range, size, bin;
        var cnt = 0;
        var indices = [];
        var xa = [];
        var ya = [];
        var data = {};
        data.y = {};
        data.y.data = [];
        data.y.vars = [];
        data.y.smps = [];
        if (!CanvasXpress.cacheImagesReady) {
            setTimeout(function() {
                that.createHistogram(axis)
            }, 10)
        } else {
            if (this.graphType.match(/Scatter/)) {
                if (this.type2D == "XYZ") {
                    idx = axis == "y" ? this.yAxisIndices[this.yAxisCurrent] : this.xAxisIndices[this.xAxisCurrent];
                    indices.push(idx)
                } else {
                    if (this.type2D == "XY") {
                        for (var i = 0; i < this.xAxisIndices.length; i++) {
                            idx = axis == "y" ? this.yAxisIndices[i] : this.xAxisIndices[i];
                            indices.push(idx)
                        }
                    } else {
                        if (this.type2D == "X") {
                            if (axis == "y") {
                                indices.push(this.yAxisIndices[this.yAxisCurrent])
                            } else {
                                for (var i = 0; i < this.xAxisIndices.length; i++) {
                                    indices.push(this.xAxisIndices[i])
                                }
                            }
                        } else {
                            if (axis == "y") {
                                for (var i = 0; i < this.yAxisIndices.length; i++) {
                                    indices.push(this.yAxisIndices[i])
                                }
                            } else {
                                indices.push(this.xAxisIndices[this.xAxisCurrent])
                            }
                        }
                    }
                }
                for (var i = 0; i < this.histogramBins; i++) {
                    data.y.vars.push("Bin" + (i + 1));
                    data.y.data[i] = []
                }
                for (var i = 0; i < indices.length; i++) {
                    data.y.smps.push(this.data.y.smps[indices[i]]);
                    data.y.smps.push(this.data.y.smps[indices[i]] + " counts");
                    xa.push(this.data.y.smps[indices[i]]);
                    ya.push(this.data.y.smps[indices[i]] + " counts");
                    var hist = [];
                    for (var j = 0; j < this.histogramBins; j++) {
                        hist[j] = 0
                    }
                    arr = this.getDataForSmpGrpAtIndex(indices[i]);
                    range = this.range(arr);
                    size = ((range[1] - range[0]) / this.histogramBins) + (range[0] / (this.histogramBins * 2));
                    for (var j = 0; j < arr.length; j++) {
                        bin = Math.floor((arr[j] - range[0]) / size);
                        hist[bin]++
                    }
                    for (var j = 0; j < this.histogramBins; j++) {
                        data.y.data[j][cnt] = size * (j + 1)
                    }
                    cnt++;
                    for (var j = 0; j < this.histogramBins; j++) {
                        data.y.data[j][cnt] = hist[j]
                    }
                    cnt++
                }
                this.dataStndBy = this.data;
                this.data = {};
                this.isHistogram = true;
                this.isCreateHistogram = size;
                this.xAxisStndBy = this.xAxis;
                this.yAxisStndBy = this.yAxis;
                this.xAxis = xa;
                this.yAxis = ya;
                this.showLegend = false;
                this.initializeData(data);
                this.draw()
            }
        }
    };
    this.removeHistogram = function() {
        this.isCreateHistogram = false;
        this.isHistogram = false;
        this.xAxis = this.xAxisStndBy;
        this.yAxis = this.yAxisStndBy;
        this.switchData();
        this.draw()
    };
    this.addRegressionLine = function() {
        var that = this;
        var xi, yi, arr1, arr2, reg, lab, col;
        if (!CanvasXpress.cacheImagesReady) {
            setTimeout(function() {
                that.addRegressionLine()
            }, 10)
        } else {
            if (this.graphType.match(/Scatter/)) {
                if (this.type2D == "XYZ") {
                    xi = this.xAxisIndices[this.xAxisCurrent];
                    yi = this.yAxisIndices[this.yAxisCurrent];
                    lab = this.data.y.smps[xi] + " vs " + this.data.y.smps[yi];
                    arr1 = this.getDataForSmpGrpAtIndex(xi);
                    arr2 = this.getDataForSmpGrpAtIndex(yi);
                    reg = this.regression(arr1, arr2);
                    this.addRegressionDecoration(reg, lab, this.foreground)
                } else {
                    if (this.type2D == "XY") {
                        for (var i = 0; i < this.xAxisIndices.length; i++) {
                            col = i % this.colors.length;
                            xi = this.xAxisIndices[i];
                            yi = this.yAxisIndices[i];
                            lab = this.data.y.smps[xi] + " vs " + this.data.y.smps[yi];
                            arr1 = this.getDataForSmpGrpAtIndex(xi);
                            arr2 = this.getDataForSmpGrpAtIndex(yi);
                            reg = this.regression(arr1, arr2);
                            this.addRegressionDecoration(reg, lab, this.colors[col])
                        }
                    } else {
                        if (this.type2D == "X") {
                            yi = this.yAxisIndices[this.yAxisCurrent];
                            arr2 = this.getDataForSmpGrpAtIndex(yi);
                            for (var i = 0; i < this.xAxisIndices.length; i++) {
                                col = i % this.colors.length;
                                xi = this.xAxisIndices[i];
                                lab = this.data.y.smps[xi] + " vs " + this.data.y.smps[yi];
                                arr1 = this.getDataForSmpGrpAtIndex(xi);
                                reg = this.regression(arr1, arr2);
                                this.addRegressionDecoration(reg, lab, this.colors[col])
                            }
                        } else {
                            xi = this.xAxisIndices[this.xAxisCurrent];
                            arr1 = this.getDataForSmpGrpAtIndex(xi);
                            for (var i = 0; i < this.yAxisIndices.length; i++) {
                                col = i % this.colors.length;
                                yi = this.yAxisIndices[i];
                                arr2 = this.getDataForSmpGrpAtIndex(yi);
                                lab = this.data.y.smps[xi] + " vs " + this.data.y.smps[yi];
                                reg = this.regression(arr1, arr2);
                                this.addRegressionDecoration(reg, lab, this.colors[col])
                            }
                        }
                    }
                }
            }
        }
    };
    this.addRegressionDecoration = function(reg, lab, col) {
        this.showDecorations = true;
        if (!this.data.d) {
            this.data.d = {}
        }
        if (!this.data.d.reg) {
            this.data.d.reg = []
        }
        this.data.d.reg.push({
            slope: reg[0],
            intercept: reg[1],
            cor: reg[2],
            label: lab,
            color: col
        })
    };
    this.addNormalDistributionLine = function(axis) {
        var that = this;
        var indices, indices1, idx, idx1, arr, arr1, max, lab, nor, lab, col, cur;
        if (!CanvasXpress.cacheImagesReady) {
            setTimeout(function() {
                that.addNormalDistributionLine(axis)
            }, 10)
        } else {
            if (this.graphType.match(/Scatter/)) {
                if (this.type2D == "XYZ") {
                    idx = axis == "y" ? this.yAxisIndices[this.yAxisCurrent] : this.xAxisIndices[this.xAxisCurrent];
                    idx1 = axis == "y" ? this.xAxisIndices[this.xAxisCurrent] : this.yAxisIndices[this.yAxisCurrent];
                    arr = this.getDataForSmpGrpAtIndex(idx);
                    arr1 = this.getDataForSmpGrpAtIndex(idx1);
                    max = this.max(arr1);
                    lab = this.data.y.smps[idx];
                    nor = this.meanStandardDeviationN(arr);
                    this.addNormalDistributionDecoration(nor, max, lab, this.foreground, axis)
                } else {
                    indices = axis == "y" ? this.yAxisIndices : this.xAxisIndices;
                    indices1 = axis == "y" ? this.xAxisIndices : this.yAxisIndices;
                    cur = axis == "y" ? this.xAxisCurrent : this.yAxisCurrent;
                    for (var i = 0; i < indices.length; i++) {
                        col = i % this.colors.length;
                        idx = indices[i];
                        idx1 = indices1[i] ? indices1[i] : indices1[cur];
                        arr = this.getDataForSmpGrpAtIndex(idx);
                        arr1 = this.getDataForSmpGrpAtIndex(idx1);
                        max = this.max(arr1);
                        lab = this.data.y.smps[idx];
                        nor = this.meanStandardDeviationN(arr);
                        this.addNormalDistributionDecoration(nor, max, lab, this.colors[col], axis)
                    }
                }
            }
        }
    };
    this.addNormalDistributionDecoration = function(nor, max, lab, col, axis) {
        this.showDecorations = true;
        if (!this.data.d) {
            this.data.d = {}
        }
        if (!this.data.d.nor) {
            this.data.d.nor = []
        }
        if (axis && axis == "y") {
            this.data.d.nor.push({
                mu: nor[0],
                sigma: nor[1],
                yAxis: true,
                max: max,
                label: lab,
                color: col
            })
        } else {
            this.data.d.nor.push({
                mu: nor[0],
                sigma: nor[1],
                max: max,
                label: lab,
                color: col
            })
        }
    };
    this.addKaplanMeyerCurve = function(time, censored, label, color) {
        var km = false;
        var tmp = {
            d: {},
            c: {}
        };
        var ts = {};
        var z = 1.95996;
        var z2 = z * z;
        var p, q, n, d, u, l;
        if (time && censored) {
            var ti = this.getSampleIndices(time);
            var ci = this.getSampleIndices(censored);
            if (ti != null && ci != null) {
                for (var i = 0; i < this.varIndices.length; i++) {
                    var t = this.data.y.data[i][ti];
                    var c = this.data.y.data[i][ci];
                    if (!isNaN(c)) {
                        if (!isNaN(c) && c == 0) {
                            tmp.d[t] = tmp.d[t] ? tmp.d[t] + 1 : 1;
                            ts[t] = true
                        } else {
                            tmp.c[t] = tmp.c[t] ? tmp.c[t] + 1 : 1;
                            ts[t] = true
                        }
                    }
                }
                ts = this.getKeys(ts);
                ts.sort(function(a, b) {
                    return a - b
                });
                km = {
                    times: ts,
                    data: []
                };
                for (var i = 0; i < ts.length; i++) {
                    km.data.push([tmp.c[ts[i]] || 0, tmp.d[ts[i]] || 0])
                }
                km.data[0].push(this.varIndices.length);
                for (var i = 1; i < ts.length; i++) {
                    km.data[i].push(km.data[i - 1][2] - (km.data[i - 1][0] + km.data[i - 1][1]))
                }
                p = 1;
                for (var i = 0; i < ts.length; i++) {
                    p = p * (1 - (km.data[i][1] / km.data[i][2]));
                    q = 1 - p;
                    n = (2 * p * this.varIndices.length) + z2 + 1 + (z * Math.sqrt(z2 + 2 - (1 / this.varIndices.length) + 4 * p * ((q * this.varIndices.length) - 1)));
                    d = 2 * (this.varIndices.length + z2);
                    u = n / d;
                    if (p == 1) {
                        u = 1
                    }
                    n = (2 * p * this.varIndices.length) + z2 - 1 - (z * Math.sqrt(z2 - 2 - (1 / this.varIndices.length) + 4 * p * ((q * this.varIndices.length) + 1)));
                    l = n / d;
                    if (p == 0) {
                        l = 0
                    }
                    km.data[i].push(p, u, l)
                }
                this.addKaplanMeyerDecoration(time, km, label, color)
            }
        }
    };
    this.addKaplanMeyerDecoration = function(time, km, label, color) {
        this.showDecorations = true;
        if (!this.data.d) {
            this.data.d = {}
        }
        if (!this.data.d.kaplanMeyer) {
            this.data.d.kaplanMeyer = []
        }
        this.data.d.kaplanMeyer.push({
            time: time,
            data: km,
            label: label || "Kaplan - Meyer " + (this.data.d.kaplanMeyer.length + 1),
            color: color || this.colors[this.data.d.kaplanMeyer.length % this.colors.length]
        })
    };
    this.addLineDecoration = function(t, c, v, l) {
        if (!this.graphType.match(/Scatter|Network|Genome|Correlation|Venn|Circular/)) {
            if (!this.data.d) {
                this.data.d = {}
            }
            if (!this.data.d.lines) {
                this.data.d.lines = []
            }
            if (t && t == "solid") {
                t = "line"
            }
            this.data.d.lines.push({
                type: t || "line",
                color: c || this.foreground,
                value: v || 0,
                label: l || false
            })
        }
    };
    this.createRandomData = function(justData) {
        var data = {};
        if (this.graphType == "Network") {
            if (this.randomDataSymmetrical) {
                data = this.createRandomNetwork();
                if (justData) {
                    return data
                }
                this.calculateLayout = true;
                this.layoutDone = false
            } else {
                data = this.createRandomNetwork();
                if (justData) {
                    return data
                }
                this.calculateLayout = true;
                this.layoutDone = false
            }
        } else {
            if (this.graphType == "Venn" || this.graphType == "Genome" || this.graphType == "Candlestick") {
                data = this.dataSetExample
            } else {
                data.y = {};
                data.y.data = [];
                data.y.vars = [];
                data.y.smps = [];
                data.y.desc = ["Magnitude 1", "Magnitude 2"];
                for (var i = 0; i < this.randomDataSamples; i++) {
                    if (this.isGraphTime) {
                        data.y.smps[i] = new Date(this.startTime + (i * this.times.day))
                    } else {
                        data.y.smps[i] = "Sample" + (i + 1)
                    }
                }
                for (var i = 0; i < this.randomDataVariables; i++) {
                    data.y.data[i] = [];
                    data.y.vars[i] = "Variable" + (i + 1);
                    for (var j = 0; j < this.randomDataSamples; j++) {
                        if (this.randomDataUniform) {
                            data.y.data[i].push(100)
                        } else {
                            if (this.randomDataSymmetrical) {
                                data.y.data[i].push((i * 10) + ((j + 1) * 5))
                            } else {
                                data.y.data[i].push(Math.floor(((Math.random() * 2 - 1) + (Math.random() * 2 - 1) + (Math.random() * 2 - 1)) * this.randomDataSigma + this.randomDataMean))
                            }
                        }
                    }
                }
                if (this.randomMissingDataPercentage > 0 && this.randomMissingDataPercentage < 1) {
                    var ms = 0;
                    var mdp = this.randomDataVariables * this.randomDataSamples * this.randomMissingDataPercentage;
                    while (ms < mdp) {
                        var i = Math.floor(Math.random() * this.randomDataVariables);
                        var j = Math.floor(Math.random() * this.randomDataSamples);
                        if (data.y.data[i][j]) {
                            delete(data.y.data[i][j]);
                            ms++
                        }
                    }
                }
                data.x = {};
                var r = Math.floor(this.randomDataSamples / this.randomDataSampleAnnotationRatio);
                for (var i = 0; i < this.randomDataSampleAnnotations; i++) {
                    data.x["Factor" + (i + 1)] = [];
                    for (var j = 0; j < this.randomDataSamples; j++) {
                        if (this.randomDataSymmetrical) {
                            data.x["Factor" + (i + 1)][j] = "Lev:" + (Math.floor(i / (j + 1)) + 1) + ":" + (i + 1)
                        } else {
                            data.x["Factor" + (i + 1)][j] = "Lev:" + (Math.floor(Math.random() * r) + 1) + ":" + (i + 1)
                        }
                    }
                }
                data.z = {};
                var r = Math.floor(this.randomDataVariables / this.randomDataVariableAnnotationRatio);
                for (var i = 0; i < this.randomDataVariableAnnotations; i++) {
                    data.z["Annt" + (i + 1)] = [];
                    for (var j = 0; j < this.randomDataVariables; j++) {
                        if (this.randomDataSymmetrical) {
                            data.z["Annt" + (i + 1)][j] = "Desc:" + (Math.floor(i / (j + 1)) + 1) + ":" + (i + 1)
                        } else {
                            data.z["Annt" + (i + 1)][j] = "Desc:" + (Math.floor(Math.random() * r) + 1) + ":" + (i + 1)
                        }
                    }
                }
                data.a = {
                    xAxis: [],
                    xAxis2: []
                };
                for (var i = 0; i < Math.floor(this.randomDataVariables / 2); i++) {
                    data.a.xAxis.push("Variable" + (i + 1))
                }
                for (var i = Math.floor(this.randomDataVariables / 2); i < this.randomDataVariables; i++) {
                    data.a.xAxis2.push("Variable" + (i + 1))
                }
            }
        } if (justData) {
            return data
        }
        this.randomData = true;
        if (this.data && !this.dataStndBy) {
            this.dataStndBy = this.data;
            this.data = {}
        }
        this.resetConfig(["graphType"]);
        this.initializeData(data);
        this.draw()
    };
    this.restoreRandomData = function() {
        this.switchData()
    };
    this.groupSamples = function(annt, stypes, gidxs) {
        if (!annt || annt.length < 1) {
            return this.ungroupSamples()
        }
        if (!this.isArray(annt)) {
            annt = [annt]
        }
        for (var i = 0; i < annt.length; i++) {
            if (!annt || !this.data.x[annt[i]]) {
                return this.ungroupSamples()
            }
        }
        if (this.layoutComb && this.data.l.comp) {
            this.varIndices = [];
            for (var i = 0; i < this.data.l.comp.length; i++) {
                for (var j = 0; j < this.data.l.comp[i].length; j++) {
                    this.varIndices.push(this.data.l.comp[i][j])
                }
            }
        }
        this.resetIndices();
        this.isGroupedData = true;
        this.groupingFactors = annt;
        this.resetObject(true);
        this.hiddenGrps = [];
        var grps = {};
        var map = [];
        var cnt = 0;
        for (var i = 0; i < this.smpIndices.length; i++) {
            var ii = this.smpIndices[i];
            var keys = [];
            var key;
            for (var j = 0; j < annt.length; j++) {
                var jj = annt[j];
                key = this.data.x[jj][ii];
                if (!key) {
                    key = "NA"
                }
                keys.push(key)
            }
            key = keys.join(" - ");
            if (!grps.hasOwnProperty(key)) {
                this.data.w.smps.push(key);
                map[cnt] = key;
                grps[key] = [];
                grps[key].push(ii);
                cnt++
            } else {
                grps[key].push(ii)
            }
        }
        for (var i = 0; i < map.length; i++) {
            var key = map[i];
            this.data.w.grps.push(grps[key])
        }
        this.grpIndices = [];
        if (gidxs) {
            for (var i = 0; i < gidxs.length; i++) {
                this.grpIndices.push(gidxs[i]);
                this.hiddenGrps.push(false)
            }
        } else {
            for (var i = 0; i < this.data.w.grps.length; i++) {
                this.grpIndices.push(i);
                this.hiddenGrps.push(false)
            }
        }
        for (var i = 0; i < this.varIndices.length; i++) {
            this.data.w.vars.push(this.data.y.vars[this.varIndices[i]])
        }
        var types = {};
        for (var key in this.data.x) {
            types[key] = this.isNumeric(this.data.x[key])
        }
        for (var i = 0; i < this.data.w.grps.length; i++) {
            for (var key in this.data.x) {
                if (!this.data.w.factors.hasOwnProperty(key)) {
                    this.data.w.factors[key] = []
                }
                var ovrl;
                if (types[key]) {
                    ovrl = [];
                    for (var j = 0; j < this.data.w.grps[i].length; j++) {
                        var val = this.data.x[key][this.data.w.grps[i][j]];
                        if (isNaN(val)) {
                            ovrl.push(val)
                        }
                    }
                    this.data.w.factors[key].push(this.mean(ovrl))
                } else {
                    ovrl = {};
                    for (var j = 0; j < this.data.w.grps[i].length; j++) {
                        var val = this.data.x[key][this.data.w.grps[i][j]];
                        if (val != null && val != "") {
                            ovrl[this.data.x[key][this.data.w.grps[i][j]]] = true
                        }
                    }
                    var arr = this.getKeys(ovrl);
                    this.data.w.factors[key].push(arr.join(" + "))
                }
            }
        }
        var types = [];
        if (stypes) {
            if (this.isArray(stypes)) {
                types = stypes
            } else {
                types.push(stypes)
            }
        } else {
            stypes = this.graphType == "Boxplot" ? "iqr" : "mean";
            types.push(stypes)
        }
        for (var t = 0; t < types.length; t++) {
            var arrs = [];
            var type = types[t];
            if (this.isTransformedData) {
                data = this.data.y.trans
            } else {
                if (this.isRawData) {
                    data = this.data.y.data
                } else {
                    if (this.summaryType == "median" || this.summaryType == "iqr") {
                        data = this.data.y.median
                    } else {
                        if (this.summaryType == "mean") {
                            data = this.data.y.mean
                        } else {
                            if (this.summaryType == "cor") {
                                data = this.data.y.cor
                            } else {
                                if (this.summaryType == "sum") {
                                    data = this.data.y.sum
                                } else {
                                    data = this.data.y[this.summaryType]
                                }
                            }
                        }
                    }
                }
            }
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                arrs[ii] = [];
                for (var j = 0; j < this.data.w.grps.length; j++) {
                    arrs[ii][j] = [];
                    for (var k = 0; k < this.data.w.grps[j].length; k++) {
                        var kk = this.data.w.grps[j][k];
                        arrs[ii][j].push(data[ii][kk])
                    }
                }
            }
            this.summarize(type, arrs)
        }
        this.setMaxVarStringName();
        this.setMaxSmpStringName();
        this.xAxisValues = [];
        this.xAxis2Values = [];
        this.yAxisValues = [];
        this.zAxisValues = [];
        if (!this.layoutComb || !this.layoutAdjust) {
            if (typeof(this.setAxes) == "function") {
                this.setAxes()
            }
        }
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.initializeDataAttributes = function(vIndices, sIndices) {
        this.setIndices(vIndices, sIndices);
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn") {
            this.setMaxVarStringAttr();
            this.setMaxSmpStringAttr()
        }
    };
    this.initializeData = function(newData) {
        if (data && !newData) {
            this.isExample = false;
            this.data = data;
            delete(data)
        } else {
            if (newData) {
                this.isExample = false;
                this.data = newData;
                delete(newData)
            } else {
                if (!this.remoteService) {
                    this.isExample = true
                }
                this.data = this.dataSetExample
            }
        }
        this.samplesData = false;
        this.variablesData = false;
        this.nodesData = false;
        this.edgesData = false;
        this.featuresData = false;
        this.validGraphTypes = [];
        if (this.data && (this.data.y || this.data.venn || this.data.nodes || this.data.tracks || this.data.market || this.data.fx || this.data.video)) {
            if (this.data.fx) {
                this.FunctionData()
            }
            if (this.data.market) {
                this.setMarketData();
                this.summaryType = "candle";
                this.validGraphTypes.push("Candlestick")
            }
            if (this.data.venn) {
                this.summaryType = "venn";
                this.validGraphTypes.push("Venn")
            }
            if (this.data.video) {
                this.summaryType = "video";
                this.validGraphTypes.push("Video")
            }
            if (this.data.nodes) {
                this.summaryType = "network";
                this.validGraphTypes.push("Network")
            }
            if (this.data.tracks) {
                this.summaryType = "genome";
                this.validGraphTypes.push("Genome")
            }
            if (this.data.y) {
                if (!this.data.y.data && !this.data.y.mean && !this.data.y.median && !this.data.y.cor && !this.data.y.sum && !this.data.y.close) {
                    alert("Dude! there is not a valid data structure");
                    return
                } else {
                    if (this.data.y.data) {
                        this.isRawData = true;
                        this.summaryType = "raw"
                    } else {
                        this.isRawData = false;
                        if (this.data.y.iqr1 && this.data.y.qtl1 && this.data.y.median && this.data.y.qtl3 && this.data.y.iqr3) {
                            this.summaryType = "iqr"
                        } else {
                            if (this.data.y.median) {
                                this.summaryType = "median"
                            } else {
                                if (this.data.y.mean) {
                                    this.summaryType = "mean"
                                } else {
                                    if (this.data.y.cor) {
                                        this.summaryType = "cor"
                                    } else {
                                        if (this.data.y.sum) {
                                            this.summaryType = "sum"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                this.validGraphTypes.push("Bar");
                this.validGraphTypes.push("Line");
                this.validGraphTypes.push("Area");
                this.validGraphTypes.push("AreaLine");
                this.validGraphTypes.push("BarLine");
                this.validGraphTypes.push("Boxplot");
                this.validGraphTypes.push("Dotplot");
                this.validGraphTypes.push("Heatmap");
                this.validGraphTypes.push("Stacked");
                this.validGraphTypes.push("StackedLine");
                this.validGraphTypes.push("StackedPercent");
                this.validGraphTypes.push("StackedPercentLine");
                this.validGraphTypes.push("Pie");
                this.validGraphTypes.push("Correlation");
                this.validGraphTypes.push("Circular");
                if (this.data.y.smps) {
                    if (this.data.y.smps.length > 2) {
                        this.validGraphTypes.push("Scatter2D");
                        this.validGraphTypes.push("ScatterBubble2D");
                        this.validGraphTypes.push("Scatter3D")
                    } else {
                        if (this.data.y.smps.length > 1) {
                            this.validGraphTypes.push("Scatter2D")
                        }
                    }
                }
            }
            this.validGraphTypes.sort()
        }
        this.initializeDataAttributes(this.data.initialVarIndices, this.data.initialSmpIndices);
        delete(this.data.initialVarIndices);
        delete(this.data.initialSmpIndices)
    };
    this.setMarketTechnicalData = function() {
        if (this.stockIndicators.length > 0) {
            var n = {};
            var e = false;
            var v = {
                Sma5: 5,
                Sma10: 10,
                Sma20: 20,
                Sma25: 25,
                Sma50: 50
            };
            var r = [];
            for (var i = 0; i < this.stockIndicators.length; i++) {
                if (v.hasOwnProperty(this.stockIndicators[i])) {
                    r.push(this.stockIndicators[i])
                }
            }
            if (r.length > 0) {
                this.stockIndicators = r;
                var t = {};
                for (var i = 0; i < this.stockIndicators.length; i++) {
                    var s = this.stockIndicators[i];
                    if (v.hasOwnProperty(s) && !this.data.y.hasOwnProperty(s)) {
                        n[s] = true;
                        e = true;
                        t[s] = [];
                        this.data.y[s] = [];
                        for (var j = 0; j < this.data.y.vars.length; j++) {
                            t[s][j] = [];
                            this.data.y[s][j] = []
                        }
                    }
                }
                if (e) {
                    for (var i = 0; i < this.data.y.smps.length; i++) {
                        for (var j = 0; j < this.data.y.vars.length; j++) {
                            for (var k = 0; k < this.stockIndicators.length; k++) {
                                var s = this.stockIndicators[k];
                                if (n.hasOwnProperty(s)) {
                                    if (!isNaN(this.data.y.close[j][i])) {
                                        t[s][j].push(this.data.y.close[j][i]);
                                        if (t[s][j].length == v[s]) {
                                            if (s.match(/Sma/)) {
                                                this.data.y[s][j][i] = this.mean(t[s][j]);
                                                t[s][j].shift()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.setMarketData = function() {
        if (this.data.market && !this.isMarketDataFormated) {
            var input = this.data.market;
            this.data.market = {};
            this.data.market.smps = [];
            this.data.market.vars = [];
            this.data.market.close = [];
            this.data.market.open = [];
            this.data.market.high = [];
            this.data.market.low = [];
            this.data.market.volume = [];
            this.data.market.desc = ["Price", "Vol"];
            var dates = {};
            var t = 0;
            for (var i = 0; i < input.length; i++) {
                this.data.market.vars.push(input[i].symbol);
                this.data.market.close[i] = [];
                this.data.market.open[i] = [];
                this.data.market.high[i] = [];
                this.data.market.low[i] = [];
                this.data.market.volume[i] = [];
                var data = input[i].data;
                for (var j = data.length - 1; j >= 0; j--) {
                    var d = this.parseDate(data[j][0]);
                    var idx = 0;
                    if (!dates.hasOwnProperty(d)) {
                        idx = t;
                        dates[d] = t;
                        this.data.market.smps.push(d);
                        t++
                    } else {
                        idx = dates[d]
                    }
                    this.data.market.open[i][idx] = data[j][1];
                    this.data.market.high[i][idx] = data[j][2];
                    this.data.market.low[i][idx] = data[j][3];
                    this.data.market.close[i][idx] = data[j][4];
                    this.data.market.volume[i][idx] = data[j][5]
                }
            }
        }
        this.isMarketDataFormated = true
    };
    this.switchToMarketData = function() {
        var market = this.data.market;
        this.dataStndBy = this.data;
        this.data = {};
        this.data.y = market;
        this.initializeDataAttributes();
        if (this.showVolume) {
            this.deleteSubGraphAttributes();
            this.data.l = {};
            this.data.l.vars = [this.data.y.vars, this.data.y.vars];
            this.data.l.weight = this.graphOrientation == "vertical" ? [0.75, 0.25] : [0.25, 0.75];
            this.data.l.type = ["Candlestick", "Candlestick"];
            this.data.l.name = this.graphOrientation == "vertical" ? ["Price", "Volume"] : ["Volume", "Price"];
            this.data.l.desc = this.graphOrientation == "vertical" ? ["Price", "Volume"] : ["Volume", "Price"];
            this.segregateSamplesBy = false;
            this.segregateVariablesBy = false;
            this.layoutComb = true;
            this.layout = "1X2";
            this.isValidLayout()
        }
    };
    this.switchFromMarketData = function() {
        this.switchData();
        if (this.showVolume) {
            this.resetLayout();
            this.isValidLayout()
        }
    };
    this.switchData = function() {
        if (this.dataStndBy) {
            this.initConfig({
                graphType: this.graphType
            });
            this.data = this.dataStndBy;
            this.initializeData(this.data)
        }
    };
    this.updateData = function(data) {
        this.initializeData(data);
        this.initializeGraph()
    };
    this.initializeData()
};
CanvasXpress.prototype.FunctionData = function() {
    this.implied = function(a) {
        if (a == "neg") {
            return false
        }
        return /^(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|\w+$/.test(a)
    };
    this.tokenize = function(f) {
        var b;
        var a = [];
        var d = new String("");
        var c = /(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|[xy]|[a-z]+|[-+*\/(),^]|<=?|>=?|==|!=|&&|\|\|/g;
        f = f.toLowerCase();
        f = f.replace(/\s/g, "");
        f = f.replace(/\+\+/g, "+");
        f = f.replace(/\+-/g, "-");
        f = f.replace(/-\+/g, "-");
        f = f.replace(/--/g, "+");
        f = f.replace(/^\+/, "");
        f = f.replace(/([(*\/&\|<>=])\+/g, "$1");
        f = f.replace(/^-/, "neg ");
        f = f.replace(/([(*\/&\|<>=])-/g, "$1neg ");
        f = f.replace(/\)(\(|\w)/g, ")*$1");
        f = f.replace(/(\d)\(/g, "$1*(");
        while (b = c.exec(f)) {
            if (this.implied(d) && this.implied(b[0].toString())) {
                a.push("*")
            }
            a.push(d = b[0])
        }
        return a
    };
    this.isValidEnd = function(a) {
        return /^(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|[)xye]|pi|rand$/.test(a)
    };
    this.toPostFx = function(d) {
        var b = new String();
        var c = new String("");
        var a = new Array();
        var e = new Array();
        while (b = d.shift()) {
            if (b == "(") {
                a.push(b)
            } else {
                if (this.precedence[b]) {
                    while (a.length && a[a.length - 1] != "(" && this.precedence[a[a.length - 1]] >= this.precedence[b]) {
                        e.push(a.pop())
                    }
                    if (b == "," && !this.isValidEnd(c)) {
                        e.push("Unexpected: " + c)
                    }
                    if (b != ",") {
                        a.push(b)
                    }
                } else {
                    if (b == ")") {
                        if (!this.isValidEnd(c)) {
                            e.push("Unexpected: " + c)
                        }
                        while (a.length && a[a.length - 1] != "(") {
                            e.push(a.pop())
                        }
                        if (a.length == 0) {
                            e.push("Unmatched: )")
                        }
                        a.pop()
                    } else {
                        if (/^[-+]?(\d+\.?|\d*\.\d+)(e[-+]?\d+)?$/.test(b)) {
                            e.push(b)
                        } else {
                            e.push("Unknown: " + b)
                        }
                    }
                }
            }
            c = b
        }
        if (!this.isValidEnd(c)) {
            e.push("Unexpected: " + c)
        }
        while (b = a.pop()) {
            if (b == "(") {
                e.push("Unmatched: (")
            }
            e.push(b)
        }
        return e
    };
    this.syntaxCheck = function(d) {
        var a = new Number(0);
        var c = new String();
        for (var b = 0; b < d.length; b++, a++) {
            if (/^Un(matched|known|expected).*/.test(c = d[b])) {
                return c
            }
            if (this.expects[c]) {
                if (a < this.expects[c]) {
                    return "Invalid use of: " + c
                }
                a -= this.expects[c]
            }
        }
        return a == 1 ? false : (d.length ? "Unused arguments" : "No function")
    };
    this.evaluate = function(e, b, f) {
        var a = new Array();
        var d = new String();
        for (var c = 0; c < e.length; c++) {
            d = e[c];
            if (d == "x") {
                a.push(b)
            } else {
                if (d == "y") {
                    a.push(f)
                } else {
                    if (d == "pi") {
                        a.push(Math.PI)
                    } else {
                        if (d == "e") {
                            a.push(Math.E)
                        } else {
                            if (d == "rand") {
                                a.push(Math.random())
                            } else {
                                if (this[this.alias[d] || d]) {
                                    a.push(this[this.alias[d] || d](a.pop(), this[this.alias[d] || d].length > 1 ? a.pop() : 0))
                                } else {
                                    a.push(d)
                                }
                            }
                        }
                    }
                }
            } if (isNaN(a[a.length - 1])) {
                return Number.NaN
            }
        }
        return parseFloat(a.pop())
    };
    this.set2DPlot = function(j, g) {
        var k = {
            vars: [],
            smps: ["X", "Y"],
            data: []
        };
        var f = this.setMinX ? this.setMinX : (0 - 1);
        var b = this.setMaxX ? this.setMaxX : (1 - 0);
        var e = this.setMinY ? this.setMinY : (0 - 1);
        var a = this.setMaxY ? this.setMaxY : (1 - 0);
        var p = (b - f) / this.functionIntervals;
        var o = (a - e) / this.functionIntervals;
        var c = 1;
        if (g == 1) {
            var m = f;
            for (var h = 0; h < this.functionIntervals; h++) {
                var l = this.evaluate(j, m, 0);
                if (isNaN(l)) {
                    l = ""
                }
                m += p;
                k.vars.push("v" + c);
                k.data.push([m, l]);
                c++
            }
        } else {
            var l = e;
            for (var h = 0; h < this.functionIntervals; h++) {
                var m = this.evaluate(j, 0, l);
                if (isNaN(m)) {
                    m = ""
                }
                l += o;
                k.vars.push("v" + c);
                k.data.push([m, l]);
                c++
            }
        }
        return k
    };
    this.set3DPlot = function(k) {
        var l = {
            vars: [],
            smps: ["X", "Y", "Z"],
            data: []
        };
        var f = this.setMinX ? this.setMinX : -Math.PI / 2;
        var b = this.setMaxX ? this.setMaxX : Math.PI / 2;
        var e = this.setMinY ? this.setMinY : -Math.PI / 2;
        var a = this.setMaxY ? this.setMaxY : Math.PI / 2;
        var c = 1;
        for (var h = 0; h <= this.functionIntervals; h++) {
            var o = e + (a - e) * h / this.functionIntervals;
            for (var g = 0; g <= this.functionIntervals; g++) {
                var p = f + (b - f) * g / this.functionIntervals;
                var m = this.evaluate(k, p, o);
                if (!isFinite(m)) {
                    m = 0
                }
                l.vars.push("v" + c);
                l.data.push([p, m, o]);
                c++
            }
        }
        return l
    };
    this.initializeFunctionData = function() {
        var e = this.toPostFx(this.tokenize(this.data.fx));
        var c = this.syntaxCheck(e);
        if (c) {
            alert(c);
            return
        }
        var a = 0;
        for (var b in e) {
            if (e[b] == "x") {
                a |= 1
            } else {
                if (e[b] == "y") {
                    a |= 2
                }
            }
        }
        var d;
        if (a == 0) {
            a = 1
        }
        if (a == 3) {
            this.data.y = this.set3DPlot(e);
            this.graphType = "Scatter3D";
            this.colorBy = "Y"
        } else {
            this.data.y = this.set2DPlot(e, a);
            this.graphType = "Scatter2D";
            this.lineType = "spline"
        }
        this.scatterType = "function"
    };
    this.initializeFunctionData()
};
CanvasXpress.prototype.initRemote = function() {
    this.ajaxRequest = function(url, params, callback, format, method) {
        var http = false;
        var pars = "";
        for (var p in params) {
            pars += p + "=" + escape(params[p]) + "&"
        }
        params = pars + "uid=" + new Date().getTime();
        format = format == "json" ? "json" : "text";
        method = method == "POST" ? "POST" : "GET";
        if (window.XMLHttpRequest) {
            try {
                http = new XMLHttpRequest()
            } catch (e) {
                http = false
            }
        } else {
            if (typeof ActiveXObject != "undefined") {
                try {
                    http = new ActiveXObject("Msxml2.XMLHTTP")
                } catch (e) {
                    try {
                        http = new ActiveXObject("Microsoft.XMLHTTP")
                    } catch (e) {
                        http = false
                    }
                }
            }
        } if (http && url) {
            if (method == "GET") {
                url += "?" + params;
                http.open(method, url, true);
                if (http.overrideMimeType) {
                    http.overrideMimeType("text/xml")
                }
            } else {
                http.open(method, url, true);
                http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                http.setRequestHeader("Content-length", params.length);
                http.setRequestHeader("Connection", "close")
            }
            http.onreadystatechange = function() {
                if (http.readyState == 4) {
                    if (http.status == 200) {
                        var result = "";
                        if (http.responseText) {
                            result = http.responseText
                        }
                        if (format == "json") {
                            result = result.replace(/[\n\r]/g, "");
                            result = eval("(" + result + ")")
                        }
                        if (callback) {
                            callback(result)
                        }
                    } else {
                        alert(http.status)
                    }
                }
            };
            http.send(params)
        }
    };
    this.requestRemoteData = function(ini) {
        this.hideViewport();
        var params = this.cloneObject(this.remoteParams);
        params.index = this.remoteDataIndex;
        params.dir = this.remoteDirection;
        if (ini) {
            params.records = true
        }
        this.ajaxRequest(this.remoteService, params, this.updateRemoteData, "json", "GET")
    };
    this.requestRemoteIds = function(d) {
        if (this.remoteUpdate) {
            var params = this.cloneObject(this.remoteParams);
            params.update = true;
            var that = this;
            var updater = function() {
                this.update = function() {
                    clearInterval(cl);
                    that.ajaxRequest(that.remoteService, params, that.updateRemoteIds, "json", "GET")
                };
                var cl = setInterval(this.update, d / 5 || 1)
            };
            updater.call()
        }
    };
    this.updateRemoteIds = function(t) {
        return function(res) {
            var that = t;
            var s = document.getElementById(t.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect");
            if (s) {
                if (res.ids) {
                    that.remoteIds = res.ids
                }
                var c = s.selectedIndex;
                var x = s.childNodes[c].text;
                var updater = function() {
                    this.update = function() {
                        if (s.childNodes.length >= that.remoteIds.length) {
                            that.remoteUpdate = false;
                            clearInterval(cl)
                        } else {
                            that.resetSelectOptionsRemoteData(s, x);
                            that.requestRemoteIds()
                        }
                    };
                    var cl = setInterval(this.update, that.remoteUpdateDelay)
                };
                updater.call()
            }
        }
    }(this);
    this.saveRemote = function(type, name) {
        var that = this;
        var params = this.cloneObject(this.remoteParams);
        params.index = this.remoteDataIndex;
        params.save = type;
        if (name) {
            params.name = JSON.stringify(name)
        }
        var config = this.cloneObject(this.userConfig);
        if (this.graphType == "Network") {
            config.calculateLayout = false
        }
        params.params = JSON.stringify(config);
        params.cxdata = JSON.stringify(this.cloneObject(this.data));
        this.ajaxRequest(this.remoteService, params, function() {
            alert("CanvasXpress data " + type + "d in the server")
        }, "json", "POST")
    };
    this.castRemoteParameters = function(o) {
        o.remoteParentId = this.remoteParentId;
        o.remoteService = this.remoteService;
        o.remoteDirection = this.remoteDirection;
        o.remoteDataIndex = this.remoteDataIndex;
        o.remoteWindow = this.remoteWindow;
        o.remoteAutoPlay = this.remoteAutoPlay;
        o.remoteAutoPlayDelay = this.remoteAutoPlayDelay;
        for (var p in this.remoteParams) {
            o.remoteParams[p] = this.remoteParams[p]
        }
        o.addRemoveNavigationTopListeners("addEvtListener");
        o.addRemoveNavigationLeftRightListeners("addEvtListener")
    };
    this.maintainIndices = function(n) {
        if (!this.graphType.match(/Network|Genome|Venn/) && !n.config.graphType.match(/Network|Genome|Venn/)) {
            if (this.data.y.vars.length == n.data.y.vars.length) {
                n.data.initialVarIndices = this.varIndices
            }
            if (this.data.y.smps.length == n.data.y.smps.length) {
                n.data.initialSmpIndices = this.smpIndices
            }
        }
    };
    this.maintainState = function(n) {
        if (!this.graphType.match(/Network|Genome|Venn/) && !n.graphType.match(/Network|Genome|Venn/)) {
            if (this.isGroupedData && n.data.x) {
                for (var i = 0; i < this.groupingFactors.length; i++) {
                    if (!n.data.x[this.groupingFactors[i]]) {
                        return
                    }
                }
                if (this.isCompatibleGraphType(this.graphType, n.graphType)) {
                    n.graphType = this.graphType
                }
                var gidxs = this.data.y.smps.length == n.data.y.smps.length ? this.grpIndices : false;
                n.groupSamples(this.groupingFactors, false, gidxs)
            }
        } else {
            if (this.graphType == "Network" && !n.calculateLayout) {
                this.calculateLayout = n.calculateLayout
            }
        }
    };
    this.updateRemoteData = function(t) {
        return function(res) {
            if (res && res.data) {
                var d = t.appendUserConfig(res.data);
                var a = t.remoteDirection == "next" ? true : false;
                var w = document.getElementById("container-" + t.target);
                if (w) {
                    var p = w.parentNode;
                    var r = w.getClientRects();
                    var o = document.getElementById(t.target);
                    var l = t.target;
                    t.insertTarget(d.renderTo, w, o.width, o.height, a);
                    d.hidden = true;
                    t.maintainIndices(d);
                    var n = new CanvasXpress(d);
                    t.castRemoteParameters(n);
                    t.maintainState(n);
                    t.addSelectOptionsRemoteData(res.ids);
                    t.resetInfoSpan(false, true);
                    t.animateTransition(p, r[0], l);
                    t.requestRemoteIds(t.remoteUpdateDelay);
                    if (t.Ext) {
                        if (!n.Ext) {
                            n.Ext = {
                                canvasId: d.renderTo,
                                canvas: n,
                                extId: t.Ext.id || t.Ext.extId
                            }
                        }
                    }
                    if (res.postprocess) {
                        for (var i = 0; i < res.postprocess.length; i++) {
                            var fn = res.postprocess[i].func;
                            var pr = res.postprocess[i].param;
                            if (fn) {
                                if (pr) {
                                    n[fn].apply(n, pr)
                                } else {
                                    n[fn]()
                                }
                            }
                        }
                    }
                    if (res.info) {
                        n.updateInfoDiv(res.info);
                        n.showInfoDiv()
                    }
                    if (t.showCode) {
                        n.updateCodeDiv()
                    }
                }
            } else {
                t.remoteDataIndex = t.remoteDirection == "next" ? t.remoteDataIndex - 1 : t.remoteDataIndex + 1;
                t.remoteUpdating = false
            }
        }
    }(this);
    this.appendUserConfig = function(d) {
        for (var i in this.userConfig) {
            if (!i.match(/decrease|remote|^calculateLayout$/)) {
                if (!d.config[i]) {
                    d.config[i] = this.userConfig[i]
                }
            }
        }
        return d
    };
    this.updateCurrentRemoteData = function(s, c) {
        if (!s) {
            s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect")
        }
        if (!c) {
            c = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarCurrent")
        }
        if (s && c) {
            s.selectedIndex = this.remoteDataIndex;
            if (this.remoteIds.length == 0) {
                for (var i = 0; i < s.childNodes.length; i++) {
                    this.remoteIds.push(s.childNodes[i].text)
                }
            }
            if (s.childNodes[s.selectedIndex]) {
                var v = s.childNodes[s.selectedIndex].text;
                c.value = v.length > 40 ? v.substring(0, 37) + "..." : v
            } else {
                this.resetSelectOptionsRemoteData(s)
            }
        }
    };
    this.resetSelectOptionsRemoteData = function(s, t) {
        if (!s) {
            s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect")
        }
        if (s) {
            if (this.remoteIds.length == 0) {
                for (var i = 0; i < s.childNodes.length; i++) {
                    this.remoteIds.push(s.childNodes[i].text)
                }
            }
            this.clearSelectOptionsRemoteData(s);
            this.addSelectOptionsRemoteData(this.remoteIds, s, t)
        }
    };
    this.clearSelectOptionsRemoteData = function(s) {
        if (!s) {
            s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect")
        }
        if (s && s.hasChildNodes()) {
            while (s.childNodes.length >= 1) {
                s.removeChild(s.firstChild)
            }
        }
    };
    this.addSelectOptionsRemoteData = function(ids, s, t) {
        if (ids) {
            this.remoteIds = ids;
            if (!s) {
                s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect")
            }
            if (s) {
                for (var i = 0; i < this.remoteIds.length; i++) {
                    var opt = document.createElement("option");
                    opt.text = this.remoteIds[i];
                    opt.value = i;
                    if (t) {
                        if (this.remoteIds[i] == t) {
                            opt.selected = "selected";
                            this.remoteDataIndex = i;
                            s.selectedIndex = this.remoteDataIndex
                        }
                    } else {
                        if (this.remoteDataIndex == i) {
                            opt.selected = "selected";
                            s.selectedIndex = this.remoteDataIndex
                        }
                    }
                    try {
                        s.add(opt, null)
                    } catch (ex) {
                        s.add(opt)
                    }
                }
                if (this.remoteIds.length == 1) {
                    this.hideNavigation()
                } else {
                    this.showNavigation()
                }
            }
        }
    };
    this.animateTransition = function(b, r, o) {
        if (b && r) {
            var that = this;
            var step = 15;
            var s = 0;
            var c1 = b.firstChild;
            var c2 = b.lastChild;
            var w = r.width;
            var h = r.height;
            b.parentNode.style.overflow = "hidden";
            if (this.isIE) {
                if (this.remoteDirection == "next") {
                    b.removeChild(c1)
                } else {
                    b.removeChild(c2)
                }
                b.parentNode.style.overflow = "visible";
                this.remoteUpdating = false
            } else {
                var updater = function() {
                    this.update = function() {
                        var n = Math.atan((s / step) * 10 - 5) * 0.5 / Math.atan(5) + 0.5;
                        var l = w * n;
                        if (s >= step) {
                            clearInterval(clearUpdateInt);
                            that.destroy(o);
                            if (that.remoteDirection == "next") {
                                c2.style.left = 0 + "px"
                            } else {
                                c1.style.left = 0 + "px"
                            }
                            b.parentNode.style.overflow = "visible";
                            that.remoteUpdating = false;
                            that.updateCurrentRemoteData()
                        } else {
                            if (that.remoteDirection == "next") {
                                c1.style.left = (l * -1) + "px";
                                c2.style.left = (l * -1) + "px"
                            } else {
                                c1.style.left = (-w + l) + "px";
                                c2.style.left = (-w + l) + "px"
                            }
                            c1.style.display = "block";
                            c2.style.display = "block"
                        }
                        s++
                    };
                    var clearUpdateInt = setInterval(this.update, 100)
                };
                updater.call()
            }
        }
    };
    this.handleRemoteSelect = function(t) {
        return function(e) {
            var s = t.getTargetEvent(e);
            var i = s.children[s.selectedIndex].value;
            var c = document.getElementById(t.remoteParentId + "-canvasXpressRemoteWindowTopBarCurrent");
            t.remoteDirection = i > t.remoteDataIndex ? "next" : "previous";
            t.remoteDataIndex = i;
            var v = s.children[s.selectedIndex].text;
            if (c && s) {
                s.style.display = "none";
                t.resetSelectOptionsRemoteData(s);
                c.value = v.length > 40 ? v.substring(0, 37) + "..." : v
            }
            t.requestRemoteData()
        }
    }(this);
    this.handleRemoteClickStop = function(t) {
        return function(e) {
            t.remoteStop = true
        }
    }(this);
    this.handleRemoteClickPlay = function(t) {
        return function(e) {
            var r = t.getTargetEvent(e);
            t.remoteDirection = "next";
            t.remoteStop = false;
            t.playRemoteData(r.parentNode.lastChild)
        }
    }(this);
    this.playRemoteData = function(s) {
        var updater = function() {
            that = CanvasXpress.references[0];
            if (that) {
                if (!that.remoteUpdating && !that.remoteStop) {
                    that.remoteUpdating = true;
                    that.showInfoSpan(false, "Updating ...", true);
                    if (s && s.tagName.match(/select/i) && that.remoteDataIndex >= s.length - 1) {
                        that.remoteDataIndex = 0
                    } else {
                        that.remoteDataIndex++
                    }
                    that.requestRemoteData()
                }
            }
            this.update = function() {
                that = CanvasXpress.references[0];
                if (that) {
                    if (!that.remoteUpdating && !that.remoteStop) {
                        that.remoteUpdating = true;
                        that.showInfoSpan(false, "Updating ...", true);
                        if (s && s.tagName.match(/select/i) && that.remoteDataIndex >= s.length - 1) {
                            that.remoteDataIndex = 0
                        } else {
                            that.remoteDataIndex++
                        }
                        that.requestRemoteData()
                    }
                    if (that.remoteStop) {
                        clearInterval(cl)
                    }
                } else {
                    clearInterval(cl)
                }
            };
            var cl = setInterval(this.update, that.remoteAutoPlayDelay)
        };
        updater.call()
    };
    this.handleRemoteClickPrev = function(t) {
        return function(e) {
            if (!t.remoteUpdating) {
                var r = t.getTargetEvent(e);
                var s = r.parentNode.lastChild;
                t.remoteUpdating = true;
                t.showInfoSpan(false, "Updating ...", true);
                t.remoteDirection = "previous";
                if (s && s.tagName.match(/select/i) && t.remoteDataIndex <= 0) {
                    t.remoteDataIndex = s.length - 1
                } else {
                    t.remoteDataIndex--
                }
                t.requestRemoteData()
            }
        }
    }(this);
    this.handleRemoteClickNext = function(t) {
        return function(e) {
            if (!t.remoteUpdating) {
                var r = t.getTargetEvent(e);
                var s = r.parentNode.lastChild;
                t.remoteUpdating = true;
                t.showInfoSpan(false, "Updating ...", true);
                t.remoteDirection = "next";
                if (s && s.tagName.match(/select/i) && t.remoteDataIndex >= s.length - 1) {
                    t.remoteDataIndex = 0
                } else {
                    t.remoteDataIndex++
                }
                t.requestRemoteData()
            }
        }
    }(this);
    this.handleRemoteClickDown = function(t) {
        return function(e) {
            if (!t.remoteUpdating) {
                var s = document.getElementById(t.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect");
                if (s) {
                    if (s.style.display == "none") {
                        s.style.display = "block";
                        s.options[s.selectedIndex].selected = true
                    } else {
                        s.style.display = "none"
                    }
                }
            }
        }
    }(this);
    this.addRemoteNavigationTop = function(w) {
        var m = "5px";
        var n = document.createElement("div");
        n.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBar";
        n.style.padding = "2px";
        n.style.color = this.skinColor;
        n.style.border = "1px solid " + this.skinBorderColor;
        n.style.backgroundColor = this.skinBackgroundColor;
        n.style.boxShadow = "2px 2px 2px " + this.skinShadowColor;
        n.style.MozBoxShadow = "2px 2px 2px " + this.skinShadowColor;
        n.style.borderRadius = "4px";
        n.style.width = "435px";
        n.style.position = "absolute";
        n.style.marginLeft = w + "px";
        n.style.zIndex = 9500;
        n.style.display = "none";
        var r = document.createElement("img");
        r.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarPrev";
        r.src = this.imageDir + this.previousButton;
        r.alt = "Previous graph";
        r.title = "Previous graph";
        r.style.margin = m;
        n.appendChild(r);
        var p = document.createElement("img");
        p.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarPlay";
        p.src = this.imageDir + this.playButton;
        p.alt = "Iterate over graphs";
        p.title = "Iterate over graphs";
        p.style.margin = m;
        n.appendChild(p);
        var e = document.createElement("img");
        e.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarStop";
        e.src = this.imageDir + this.stopButton;
        e.alt = "Stop iteration";
        e.title = "Stop iteration";
        e.style.margin = m;
        n.appendChild(e);
        var f = document.createElement("img");
        f.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarNext";
        f.src = this.imageDir + this.nextButton;
        f.alt = "Next graph";
        f.title = "Next graph";
        f.style.margin = m;
        n.appendChild(f);
        var c = document.createElement("input");
        c.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarCurrent";
        c.type = "text";
        c.style.padding = "1px 1px 2px 1px";
        c.style.position = "absolute";
        c.style.cursor = "default";
        c.style.display = "block";
        c.style.left = "102px";
        c.style.top = "0px";
        c.style.margin = "5px";
        c.style.width = "322px";
        c.style.borderRadius = "4px";
        c.style.MozBorderRadius = "4px";
        n.appendChild(c);
        var d = document.createElement("img");
        d.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarDown";
        d.src = this.imageDir + this.dropdownButton;
        d.alt = "Select graph";
        d.title = "Select graph";
        d.style.margin = m;
        d.style.position = "absolute";
        d.style.top = "3px";
        d.style.right = "4px";
        n.appendChild(d);
        var s = document.createElement("select");
        s.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect";
        s.style.position = "absolute";
        s.style.margin = "5px";
        s.style.color = this.skinColor;
        s.style.backgroundColor = this.skinBackgroundColor;
        s.style.border = "1px solid " + this.skinBorderColor;
        s.style.marginTop = "1px";
        s.style.left = "102px";
        s.style.top = "26px";
        s.style.maxWidth = "800px";
        s.style.display = "none";
        s.size = 10;
        n.appendChild(s);
        return n
    };
    this.addRemoveNavigationTopListeners = function(t) {
        var r = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarPrev");
        var p = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarPlay");
        var e = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarStop");
        var f = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarNext");
        var d = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarDown");
        var s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect");
        if (r) {
            this[t](r, "click", this.handleRemoteClickPrev, false)
        }
        if (p) {
            this[t](p, "click", this.handleRemoteClickPlay, false)
        }
        if (e) {
            this[t](e, "click", this.handleRemoteClickStop, false)
        }
        if (f) {
            this[t](f, "click", this.handleRemoteClickNext, false)
        }
        if (d) {
            this[t](d, "click", this.handleRemoteClickDown, false)
        }
        if (s) {
            this[t](s, "change", this.handleRemoteSelect, false)
        }
    };
    this.selectDataSet = function(e) {
        var t = document.activeElement;
        if (t.id == this.remoteParentId + "-canvasXpressRemoteWindowTopBarCurrent") {
            var s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect");
            var p = [];
            if (s && t.value.length > 0) {
                if (this.remoteIds.length == 0) {
                    for (var i = 0; i < s.childNodes.length; i++) {
                        this.remoteIds.push(s.childNodes[i].text)
                    }
                }
                this.clearSelectOptionsRemoteData(s);
                for (var i = 0; i < this.remoteIds.length; i++) {
                    if (this.remoteIds[i].toLowerCase().indexOf(t.value.toLowerCase()) >= 0) {
                        p.push(i)
                    }
                }
                for (var i = 0; i < p.length; i++) {
                    var o = document.createElement("option");
                    o.text = this.remoteIds[p[i]];
                    o.value = p[i];
                    try {
                        s.add(o, null)
                    } catch (ex) {
                        s.add(o)
                    }
                }
                s.style.display = "block"
            }
        }
    };
    this.addRemoteNavigationBottom = function(w) {
        var n = document.createElement("div");
        n.id = this.remoteParentId + "-canvasXpressRemoteWindowBottomBar";
        n.style.position = "absolute";
        n.style.marginLeft = w + "px";
        n.style.display = "none";
        n.style.height = "18px";
        return n
    };
    this.addRemoteNavigationLeftRight = function(d, w, h, m, q) {
        var n = document.createElement("div");
        var i = document.createElement("img");
        n.style.height = (h + q) + "px";
        n.style.width = m + "px";
        n.style.marginLeft = "3px";
        n.style.marginRight = "3px";
        n.style.top = "0px";
        i.style.position = "absolute";
        i.style.top = (h / 2) + "px";
        i.style.left = "1px";
        if (d == "l") {
            n.style.position = "relative";
            n.id = this.remoteParentId + "-canvasXpressRemoteWindowPrevBar";
            n.style.left = "0px";
            n.style.display = "none";
            i.src = this.imageDir + this.previousButton
        } else {
            n.style.position = "absolute";
            n.id = this.remoteParentId + "-canvasXpressRemoteWindowNextBar";
            n.style.left = (m + w + 14) + "px";
            n.style.display = "none";
            i.src = this.imageDir + this.nextButton
        }
        i.style.margin = "auto";
        n.appendChild(i);
        return n
    };
    this.addRemoveNavigationLeftRightListeners = function(t) {
        var p = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowPrevBar");
        var n = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowNextBar");
        if (p) {
            this[t](p, "click", this.handleRemoteClickPrev, false)
        }
        if (n) {
            this[t](n, "click", this.handleRemoteClickNext, false)
        }
    };
    this.updateRemoteNavigationWindow = function() {
        var c = document.getElementById(this.target);
        var x = 24;
        var y = 36;
        var l = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowPrevBar");
        var r = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowNextBar");
        var w = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindow");
        var b = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowBuffer");
        if (c && l && r && w && b) {
            var il = l.childNodes[0];
            l.style.left = "7px";
            l.style.height = (c.height + y + 7) + "px";
            il.style.top = (c.height / 2) + "px";
            var ir = r.childNodes[0];
            r.style.left = (c.width + x + 7) + "px";
            r.style.height = (c.height + y + 7) + "px";
            ir.style.top = (c.height / 2) + "px";
            w.style.height = ((y * 2) + c.height) + "px";
            w.style.width = ((x * 2) + c.width) + "px";
            b.style.width = (parseInt(c.parentNode.parentNode.clientWidth) * 2) + "px";
            b.style.left = (x + 7) + "px";
            b.style.top = (y + 7) + "px";
            this.resizeExtContainer((x * 2) + c.width)
        }
    };
    this.addRemoteWindow = function() {
        var w = document.getElementById("container-" + this.target);
        var c = document.getElementById(this.target);
        var p = w.parentNode;
        var x = 24;
        var y = 36;
        if (p.id && !p.id.match(/canvasXpressRemoteWindow/)) {
            this.remoteParentId = p.id;
            var d = document.createElement("div");
            var t = this.addRemoteNavigationTop(x + 7);
            var l = this.addRemoteNavigationLeftRight("l", c.width, c.height, x, y + 14);
            var v = document.createElement("div");
            var r = this.addRemoteNavigationLeftRight("r", c.width, c.height, x, y + 14);
            var b = this.addRemoteNavigationBottom(x + 7);
            d.id = this.remoteParentId + "-canvasXpressRemoteWindow";
            d.style.marginTop = "3px";
            d.style.height = (y + 18 + c.height + 14) + "px";
            d.style.width = ((x * 2) + c.width + 14) + "px";
            d.style.position = "relative";
            v.id = this.remoteParentId + "-canvasXpressRemoteWindowBuffer";
            v.style.width = ((parseInt(c.parentNode.parentNode.clientWidth) + 7) * 2) + "px";
            v.style.position = "absolute";
            v.style.left = x + "px";
            v.style.top = y + "px";
            v.style.overflow = "hidden";
            d.appendChild(t);
            d.appendChild(l);
            d.appendChild(v);
            d.appendChild(r);
            d.appendChild(b);
            p.insertBefore(d, w);
            v.appendChild(w.parentNode.appendChild(w));
            this.addRemoveNavigationTopListeners("addEvtListener");
            this.addRemoveNavigationLeftRightListeners("addEvtListener");
            this.requestRemoteData(true);
            this.initialRemoteDataRequest = true;
            if (this.remoteAutoPlay) {
                this.remoteUpdating = true;
                this.remoteDirection = "next";
                this.remoteStop = false;
                this.playRemoteData(t.lastChild)
            }
        } else {
            this.initialRemoteDataRequest = false
        }
    };
    this.resizeExtContainer = function(w, h) {
        if (this.Ext && this.Ext.extId && Ext) {
            var cont = Ext.getCmp(this.Ext.extId);
            var rw = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindow");
            if (cont && rw) {
                var wc = cont.getWidth();
                var hc = cont.getHeight();
                var parent = cont.ownerCt;
                if (parent) {
                    var cl = parent.getXType();
                    var wp = parent.getWidth();
                    var hp = parent.getHeight();
                    var ad = 0;
                    if (cl == "window") {} else {
                        if (cl == "panel") {
                            ad = wp >= w ? 0 : 15;
                            if (wc <= wp && w < wp) {
                                w = wp;
                                ad = -15
                            }
                        }
                    }
                    cont.setWidth(w + ad);
                    cont.doLayout();
                    parent.doLayout();
                    parent.ownerCt.doLayout()
                }
            }
        }
    };
    this.hideNavigation = function() {
        var t = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBar");
        var p = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowPrevBar");
        var n = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowNextBar");
        var b = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowBottomBar");
        if (t) {
            t.style.display = "none"
        }
        if (p) {
            p.style.display = "none"
        }
        if (n) {
            n.style.display = "none"
        }
        if (b) {
            b.style.display = "none"
        }
    };
    this.showNavigation = function() {
        var t = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBar");
        var p = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowPrevBar");
        var n = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowNextBar");
        var b = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowBottomBar");
        if (t) {
            t.style.display = "block"
        }
        if (p) {
            p.style.display = "block"
        }
        if (n) {
            n.style.display = "block"
        }
        if (b) {
            b.style.display = "block"
        }
    };
    this.initializeRemote = function() {
        if (this.remoteService) {
            this.addRemoteWindow()
        }
    };
    this.addRemoteDataSaveForm = function(c) {
        var d = this.$cX("div", {
            id: this.target + "-cX-SaveForm",
            className: "CanvasXpressSaveForm"
        }, {
            left: c.x + "px",
            top: c.y + "px",
            zIndex: 10001
        });
        var n = this.$cX("input", {
            id: this.target + "-cX-SaveFormInput",
            className: "CanvasXpressSaveForm",
            type: "text"
        }, {
            display: "block",
            margin: "8px",
            width: "300px"
        });
        var s = this.$cX("input", {
            id: this.target + "-cX-SaveFormSaveButton",
            value: "Save",
            type: "button"
        }, {
            cssFloat: "left",
            borderRadius: "5px",
            margin: "5px",
            width: "150px"
        });
        var x = this.$cX("input", {
            id: this.target + "-cX-SaveFormCancelButton",
            value: "Cancel",
            type: "button"
        }, {
            cssFloat: "left",
            borderRadius: "5px",
            margin: "5px",
            width: "150px"
        });
        d.appendChild(document.createTextNode("Save current view as:"));
        d.appendChild(n);
        d.appendChild(s);
        d.appendChild(x);
        document.body.appendChild(d);
        this.addRemoveRemoteSaveListeners("addEvtListener")
    };
    this.addRemoveRemoteSaveListeners = function(t) {
        var s = this.$(this.target + "-cX-SaveFormSaveButton");
        var x = this.$(this.target + "-cX-SaveFormCancelButton");
        if (s && x) {
            this[t](s, "click", this.submitRemoteSave, false);
            this[t](x, "click", this.cancelRemoteSave, false)
        }
    };
    this.submitRemoteSave = function(t) {
        return function(e) {
            if (!e) {
                e = window.event
            }
            var d = t.$(t.target + "-cX-SaveForm");
            var n = t.$(t.target + "-cX-SaveFormInput");
            if (d && n) {
                t.saveRemote("save", n.value);
                t.addRemoveRemoteSaveListeners("removeEvtListener");
                document.body.removeChild(d)
            }
        }
    }(this);
    this.cancelRemoteSave = function(t) {
        return function(e) {
            if (!e) {
                e = window.event
            }
            var d = t.$(t.target + "-cX-SaveForm");
            if (d) {
                t.addRemoveRemoteSaveListeners("removeEvtListener");
                document.body.removeChild(d)
            }
        }
    }(this);
    this.initializeRemote()
};
CanvasXpress.prototype.initGraph = function() {
    this.draw = function(b, d, a, c) {
        this.setUserEvents();
        this.initializeGraph(true, b, d, a, c);
        if (this.userEvents.enddraw) {
            this.userEvents.enddraw.call(this)
        }
    };
    this.isValidGraphType = function(a) {
        switch (a) {
            case "Bar":
            case "Line":
            case "Area":
            case "AreaLine":
            case "Dotplot":
            case "Heatmap":
            case "Stacked":
            case "StackedPercent":
            case "Boxplot":
            case "Correlation":
            case "Treemap":
            case "Pie":
            case "Circular":
                if (this.data.y) {
                    return true
                } else {
                    return false
                }
            case "BarLine":
            case "StackedLine":
            case "StackedPercentLine":
                if (this.data.y && this.data.a && this.data.a.xAxis && this.data.a.xAxis2) {
                    return true
                } else {
                    return false
                }
            case "Scatter2D":
                if (this.data.y && this.data.y.smps && this.data.y.smps.length > 1) {
                    return true
                } else {
                    return false
                }
            case "ScatterBubble2D":
            case "Scatter3D":
                if (this.data.y && this.data.y.smps && this.data.y.smps.length > 2) {
                    return true
                } else {
                    return false
                }
            case "Candlestick":
                if (this.data.market) {
                    return true
                } else {
                    return false
                }
            case "Venn":
                if (this.data.venn) {
                    return true
                } else {
                    return false
                }
            case "Network":
                if (this.data.nodes) {
                    return true
                } else {
                    return false
                }
            case "Genome":
                if (this.data.tracks) {
                    return true
                } else {
                    return false
                }
            case "Video":
                if (this.data.video) {
                    return true
                } else {
                    return false
                }
        }
        return false
    };
    this.setColorScheme = function() {
        switch (this.colorScheme) {
            case "reset":
                this.colors = this.colors0;
                break;
            case "basic":
                this.colors = this.colors1;
                break;
            case "dark":
                this.colors = this.colors2;
                break;
            case "strong":
                this.colors = this.colors3;
                break;
            case "light":
                this.colors = this.colors4;
                break;
            case "pastel":
                this.colors = this.colors5;
                break;
            case "balanced":
                this.colors = this.colors6;
                break;
            case "user":
                this.colors = this.colors;
                break
        }
    };
    this.reinitializeGraph = function() {
        if (this.graphType == "Candlestick") {
            this.isGraphTime = true;
            if (!this.isMarketSwitched) {
                this.switchToMarketData();
                this.initAxes();
                this.summaryType = "candle";
                this.initializeDataAttributes();
                this.isMarketSwitched = true
            }
            this.setMarketTechnicalData()
        } else {
            if (this.isExample && this.isMarketSwitched) {
                this.switchFromMarketData();
                this.isMarketSwitched = false;
                this.summaryType = this.data.y.data ? "raw" : "mean";
                this.initializeDataAttributes();
                this.isGraphTime = false;
                if (this.showVolume) {
                    this.layoutComb = false
                }
            } else {
                if (this.graphType.match(/Scatter/) && this.scatterPlotMatrix) {
                    this.setScatterPlotMatrix()
                } else {
                    if (this.graphType.match(/Pie/) && this.xAxis.length > 1) {
                        this.setMultiplePies()
                    }
                }
            }
        }
    };
    this.initializeGraph = function(p, a, o, j, d) {
        var f = this;
        var k = 5;
        var n = 0;
        var c = 0;
        var g = [];
        var b = {};
        var m = function() {
            for (var q = 0; q < g.length; q++) {
                if (!CanvasXpress.cacheImages.hasOwnProperty(g[q])) {
                    return false
                }
            }
            return true
        };
        if (this.patternImages) {
            if (this.patternImages.length != this.patternNames.length) {
                alert("Length of arrays patternImages and patternNames are different. Funny things may happen")
            }
            for (var e = 0; e < this.patternImages.length; e++) {
                g.push(this.imageDir + this.patternImages[e]);
                b[this.imageDir + this.patternImages[e]] = this.patternNames[e]
            }
        }
        if (this.graphType == "Network") {
            g = this.getNetworkImages()
        }
        if (this.graphType.match(/scatter/i)) {
            for (var e = 0; e < this.images.length; e++) {
                if (!this.images[e].match(/^http:\/\//)) {
                    this.images[e] = this.imageDir + this.images[e]
                }
                g.push(this.images[e])
            }
        }
        if (this.backgroundImage) {
            if (!this.backgroundImage.match(/^http:\/\//)) {
                this.backgroundImage = this.imageDir + this.backgroundImage
            }
            g.push(this.backgroundImage)
        }
        if (g.length > 0) {
            if (this.graphType == "Network") {
                this.Network(true)
            } else {
                if (this.graphType == "Scatter3D") {
                    this.Scatter3D(true)
                } else {
                    if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
                        this.Scatter2D(true)
                    }
                }
            }
        }
        if (g.length > 0 && !m()) {
            for (var e = 0; e < g.length; e++) {
                if (!CanvasXpress.cacheImages.hasOwnProperty(g[e])) {
                    CanvasXpress.cacheImages[g[e]] = true;
                    var h = new Image;
                    h.onload = function() {
                        CanvasXpress.cacheImages[this.src] = this;
                        CanvasXpress.cachePatterns[b[this.src]] = f.ctx.createPattern(this, "repeat");
                        if (n < (k * g.length)) {
                            if (m()) {
                                c++;
                                CanvasXpress.cacheImagesReady = c == g.length;
                                if (CanvasXpress.cacheImagesReady) {
                                    f.renderGraph(p, a, o, j, d)
                                }
                            } else {
                                n++
                            }
                        } else {
                            alert("Problem loading images")
                        }
                    };
                    h.src = g[e]
                }
            }
        } else {
            if (CanvasXpress.cacheImagesReady) {
                f.renderGraph(p, a, o, j, d)
            } else {
                var l = new Date().getTime();
                if (l - this.startTime > this.loadImagesTimeOut) {
                    f.renderGraph(p, a, o, j, d)
                } else {
                    setTimeout(function() {
                        f.initializeGraph(p, a, o, j, d)
                    }, 10)
                }
            }
        }
    };
    this.renderGraph = function(g, d, a, c, f) {
        if (this.initialRemoteDataRequest) {
            return
        }
        this.setColorScheme();
        this.reinitializeGraph();
        if ((!this.layoutComb || !this.layoutAdjust) && !c) {
            if (this.graphType != "Candlestick" || (this.graphType == "Candlestick" && !this.showVolume)) {
                this.initAxes(g)
            }
        }
        if (g) {
            this.resizeCanvas(true, d, a)
        } else {
            this.resizeCanvas(false, d, a)
        } if (this.isVML) {
            this.showShadow = false
        }
        if (this.isValidAnimation() && this.showAnimation && !this.isAnimation) {
            this.createAnimation(this.animationType)
        } else {
            var e = this.layoutComb ? true : false;
            switch (this.graphType) {
                case "Bar":
                case "Dotplot":
                    if (this.isBoxPlotCalc && this.isGroupedData) {
                        this.groupSamples(this.getGroupingFactors(true))
                    }
                    if (this.is3DPlot) {
                        this.Scatter3D()
                    } else {
                        this.oneDPlot()
                    }
                    break;
                case "Line":
                case "Area":
                case "AreaLine":
                case "BarLine":
                case "Heatmap":
                case "Treemap":
                case "Stacked":
                case "StackedLine":
                case "StackedPercent":
                case "StackedPercentLine":
                case "Candlestick":
                    if (this.isBoxPlotCalc && this.isGroupedData) {
                        this.groupSamples(this.getGroupingFactors(true))
                    }
                    this.oneDPlot();
                    break;
                case "Boxplot":
                    if (!this.isBoxPlotCalc && this.isGroupedData) {
                        this.groupSamples(this.getGroupingFactors(true))
                    }
                    this.oneDPlot();
                    break;
                case "Scatter2D":
                case "ScatterBubble2D":
                    this.Scatter2D();
                    break;
                case "Scatter3D":
                    this.Scatter3D();
                    break;
                case "Correlation":
                    this.Correlation();
                    break;
                case "Venn":
                    this.Venn();
                    break;
                case "Pie":
                    this.Pie();
                    break;
                case "Circular":
                    this.Circular();
                    break;
                case "Network":
                    if (f) {
                        var b = this.calculateLayout;
                        var e = this.randomNetwork;
                        this.calculateLayout = false;
                        this.randomNetwork = false;
                        this.Network();
                        this.calculateLayout = b;
                        this.randomNetwork = e
                    } else {
                        this.Network()
                    }
                    break;
                case "Genome":
                    this.Genome();
                    break;
                case "Video":
                    this.Video();
                    break
            }
            this.drawCanvasBox();
            if (this.showCode) {
                this.updateCodeDiv()
            }
            if (this.showDataTable) {
                this.updateDataTable()
            } else {
                if (this.dataTableLastState && this.dataTableLastState != "docked") {
                    this.hideUnhideDataTable(true)
                }
            }
            this.setAcknowledgmentVisibility();
            if (this.graphType != "Network") {
                this.drawCitation()
            }
            this.setVideoControls()
        }
    };
    this.initializeGraph()
};
CanvasXpress.prototype.initAxes = function(b, a) {
    this.getValidAxes = function(c) {
        var d = [];
        if (this.graphType == "Scatter2D") {
            d.push("xAxis");
            d.push("yAxis")
        } else {
            if (this.graphType == "ScatterBubble2D" || this.graphType == "Scatter3D") {
                d.push("xAxis");
                d.push("yAxis");
                d.push("zAxis")
            } else {
                if (this.graphType.match(/Network|Genome|Correlation|Venn|Heatmap|Pie|Video/)) {
                    if (c) {
                        d.push("xAxis")
                    } else {
                        return false
                    }
                } else {
                    if (this.graphType.match(/BarLine|AreaLine|StackedLine|StackedPercentLine/) || (this.graphType == "Candlestick" && this.showVolume)) {
                        d.push("xAxis");
                        d.push("xAxis2")
                    } else {
                        if (this.graphType == "Circular") {
                            d.push("xAxis");
                            d.push("rAxis")
                        } else {
                            d.push("xAxis")
                        }
                    }
                }
            }
        }
        return d
    };
    this.addRemoveSamplesInAxis = function(e, d, c) {
        if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
            if (c) {
                return this.removeSamplesFromAxis(e, d)
            } else {
                return this.addSamplesToAxis(e, d)
            }
        } else {
            if (this.graphType == "Scatter3D" || this.graphType == "Pie") {
                return this.switchSampleInAxis(e, d)
            }
        }
    };
    this.addSamplesToAxis = function(e, d) {
        if (this[d]) {
            if (this.isArray(e)) {
                for (var c = 0; c < e.length; c++) {
                    this[d].push(e[c])
                }
            } else {
                this[d].push(e)
            }
            return false
        } else {
            return "Not a valid axis"
        }
    };
    this.removeSamplesFromAxis = function(g, f) {
        if (this[f]) {
            if (this[f].length > 1) {
                var d = {};
                var c = [];
                if (this.isArray(g)) {
                    for (var e = 0; e < g.length; e++) {
                        d[g[e]] = 1
                    }
                } else {
                    d[g] = 1
                }
                for (var e = 0; e < this[f].length; e++) {
                    if (!d.hasOwnProperty(this[f][e])) {
                        c.push(this[f][e])
                    }
                }
                this[f] = c;
                return false
            } else {
                return f + " cannot be null"
            }
        } else {
            return "Not a valid axis"
        }
    };
    this.switchSampleInAxis = function(d, c) {
        if (this[c]) {
            this[c][0] = d;
            return false
        } else {
            return "Not a valid axis"
        }
    };
    this.addRemoveVariablesInAxis = function(e, d, c) {
        if (c) {
            return this.removeVariablesFromAxis(e, d)
        } else {
            return this.addVariablesToAxis(e, d)
        }
    };
    this.addVariablesToAxis = function(e, d) {
        if (!this.data.a) {
            this.data.a = {}
        }
        if (!this.data.a[d]) {
            this.data.a[d] = []
        }
        if (this.isArray(e)) {
            for (var c = 0; c < e.length; c++) {
                this.data.a[d].push(e[c])
            }
        } else {
            this.data.a[d].push(e)
        }
        this.resetVariablesVisibleByAxis(d);
        return false
    };
    this.removeVariablesFromAxis = function(g, f) {
        if (this.data.a && this.data.a[f]) {
            var d = {};
            var c = [];
            if (this.isArray(g)) {
                for (var e = 0; e < g.length; e++) {
                    d[g[e]] = 1
                }
            } else {
                d[g] = 1
            }
            for (var e = 0; e < this.data.a[f].length; e++) {
                if (!d.hasOwnProperty(this.data.a[f][e])) {
                    c.push(this.data.a[f][e])
                }
            }
            this.data.a[f] = c
        }
        this.resetVariablesVisibleByAxis(f);
        return false
    };
    this.formatAxisValue = function(d, c) {
        if (this[c + "TickFormat"]) {
            if (this.graphType == "Candlestick" && this.summaryType == "volume") {
                if (this.xAxis2TickFormat) {
                    return sprintf(this.xAxis2TickFormat, d)
                } else {
                    return sprintf(this[c + "TickFormat"], d)
                }
            } else {
                return sprintf(this[c + "TickFormat"], d)
            }
        } else {
            if (this.graphType == "Candlestick" && this.summaryType == "volume") {
                return sprintf("%." + this.xAxis2Decs + "f", d)
            } else {
                if (d >= 0 && d % 1 === 0) {
                    return parseInt(d).toString()
                } else {
                    d = sprintf("%." + this[c + "Decs"] + "f", d);
                    var e = d.length;
                    while (d.substring(e - 1, e) == "0") {
                        d = d.substring(0, e - 1);
                        e = d.length
                    }
                    return d
                }
            }
        }
    };
    this.getAxisRangeBySample = function(c) {
        var g = [];
        if (this.isArray(c)) {
            for (var e = 0; e < this.varIndices.length; e++) {
                var f = this.varIndices[e];
                for (var d = 0; d < c.length; d++) {
                    g.push(this.getDataAtPos(f, d))
                }
            }
        } else {
            for (var e = 0; e < this.varIndices.length; e++) {
                var f = this.varIndices[e];
                g.push(this.getDataAtPos(f, c))
            }
        }
        return this.range(g)
    };
    this.getAxisIncrements = function(f, n, o, j, p) {
        if (n - f <= Number.MIN_VALUE) {
            return 0.1
        }
        var l;
        var m = ((p || n) - f) * this.axisExtension;
        var d = f - m;
        var h = (p || n) + m;
        var i = h - d;
        var k = -Math.floor(Math.log(i / o) / Math.LN10);
        var e = Math.pow(10, -k);
        var g = this.getAxisDecimals(e);
        var c = ((i / o) / e);
        if (j) {
            return parseFloat(this.formatNumber((n - f) / o, g))
        } else {
            if (c < 1.5) {
                l = e
            } else {
                if (c < 2) {
                    l = e * 2
                } else {
                    if (c < 2.5) {
                        l = e * 2.5
                    } else {
                        if (c < 5) {
                            l = e * 5
                        } else {
                            if (c < 7.5) {
                                l = e * 7.5
                            } else {
                                l = e * 10
                            }
                        }
                    }
                }
            }
        } if (this.getAxisMin(f, l) + (l * o) < n) {
            return this.getAxisIncrements(f, n, o, j, (p || n) + l)
        } else {
            return l
        }
    };
    this.getAxisMin = function(c, d) {
        var e = d * Math.floor(c / d);
        return isNaN(e) ? 0 : e < 0 && this.minData >= 0 ? 0 : e
    };
    this.getAxisDecimals = function(d) {
        var c = 1000000;
        var e = (((d * c) - (parseInt(d) * c)) / c).toString().replace(/\./, "").length - 1;
        return e
    };
    this.setAxis = function(c) {
        var d = this.isGroupedData ? this.data.w : this.data.y;
        if (this[c].length == 0) {
            if (c == "xAxis") {
                this[c].push(d.smps[this.smpIndices[0]])
            } else {
                if (c == "yAxis") {
                    if (d.smps.length > 1) {
                        this[c].push(d.smps[this.smpIndices[1]])
                    } else {
                        this[c].push(d.smps[this.smpIndices[0]])
                    }
                } else {
                    if (c == "zAxis") {
                        if (d.smps.length > 2) {
                            this[c].push(d.smps[this.smpIndices[2]])
                        } else {
                            if (d.smps.length > 1) {
                                this[c].push(d.smps[this.smpIndices[1]])
                            } else {
                                this[c].push(d.smps[this.smpIndices[0]])
                            }
                        }
                    }
                }
            }
        } else {
            if (this.graphType == "Scatter3D" && this[c].length > 1) {
                this[c] = [this[c][0]]
            }
        }
    };
    this.setAxisValues = function(e) {
        var z, p, m, n, o, x, k, f;
        var d = {};
        var h = e + "MinorValues";
        var l = e + "Values";
        var v = e + "Ticks";
        var w = e + "TickFormat";
        var u = e + "Incr";
        var c = e + "Decs";
        var q = e + "Min";
        var g = e + "Transform";
        var t = e + "MaxStrLength";
        if (this[g] == "percentile") {
            this[c] = 0;
            this[l] = [];
            this[h] = [];
            var y = [0, 25, 50, 75, 100];
            for (var s = 0; s < y.length; s++) {
                this[l].push(y[s])
            }
            for (var s = 5; s < 100; s += 5) {
                this[h].push(s)
            }
        } else {
            if (this[l].length == 0 || b) {
                if (b) {
                    this[l] = [];
                    this[h] = []
                }
                z = this[q];
                o = this[u] / this[v];
                for (var s = 1; s <= this[v]; s++) {
                    for (var r = 1; r < this[v]; r++) {
                        this[h].push(z + (o * r))
                    }
                    z += this[u];
                    if (this[c] == 0 && z.toString().match(/\.5$/)) {
                        this[c] = 1
                    }
                    if (this[w]) {
                        p = sprintf(this[w], z)
                    } else {
                        p = this.formatNumber(sprintf("%." + this[c] + "f", z), this[c])
                    } if (d.hasOwnProperty(p) && !this[w]) {
                        k = true
                    } else {
                        d[p] = 1
                    }
                    this[l].push(p)
                }
            } else {
                m = this[l];
                this[l] = [];
                for (var s = 0; s < m.length; s++) {
                    z = m[s];
                    n = parseFloat(z);
                    if (this[w]) {
                        p = sprintf(this[w], n)
                    } else {
                        p = this.formatNumber(sprintf("%." + this[c] + "f", n), this[c])
                    } if (d.hasOwnProperty(p) && !this[w]) {
                        k = true
                    } else {
                        d[p] = 1
                    }
                    this[l].push(p)
                }
            }
        } if (k) {
            this[c]++;
            this[l] = [];
            this[h] = [];
            this.setAxisValues(e)
        } else {
            f = this.getMaxText(this[l]);
            if (!this[t]) {
                this[t] = f
            } else {
                this[t] = this.getMaxText([this[t], f])
            }
        }
    };
    this.setAxisAttributes = function(h, o, r, e, n) {
        var q = e && e.match(/log/) ? true : false;
        var l = h + "Ticks";
        var d = h + "Incr";
        var g = h + "Exact";
        var c = h + "AbsMin";
        var k = h + "AbsMax";
        var i = h + "Min";
        var p = h + "Max";
        var m = h + "Range";
        var j = h + "Decs";
        var f = h + "Transform";
        this.setRangeData(o, r, q, n);
        if (e) {
            if (e == "log2") {
                this.minData = Math.log(this.minData) / Math.LN2;
                this.maxData = Math.log(this.maxData) / Math.LN2
            } else {
                if (e == "log10") {
                    this.minData = Math.log(this.minData) / Math.LN10;
                    this.maxData = Math.log(this.maxData) / Math.LN10
                } else {
                    if (e == "exp2") {
                        this.minData = Math.pow(2, this.minData);
                        this.maxData = Math.pow(2, this.maxData)
                    } else {
                        if (e == "exp10") {
                            this.minData = Math.pow(10, this.minData);
                            this.maxData = Math.pow(10, this.maxData)
                        } else {
                            if (e == "percentile") {
                                this.minData = -12.5;
                                this.maxData = 112.5
                            }
                        }
                    }
                }
            }
        }
        this[c] = this.setMin == null ? this.minData : this[c];
        this[k] = this.setMax == null ? this.maxData : this[k];
        this[d] = this.getAxisIncrements(this.minData, this.maxData, this[l], this[g]);
        this[j] = this.getAxisDecimals(this[d]);
        if (n) {
            this[i] = 0;
            if (this.graphType.match(/Percent/)) {
                this[p] = 100;
                this[l] = 5;
                this[g] = true;
                this[d] = 20;
                this[j] = 0
            } else {
                this[p] = this[i] + (this[d] * this[l])
            }
        } else {
            if (this[g] || (e && e == "percentile")) {
                this[i] = this.minData;
                this[p] = this.maxData
            } else {
                this[i] = this.getAxisMin(this.minData, this[d]);
                this[p] = this[i] + (this[d] * this[l]);
                if (this[p] - (this[d] * 2) > this.maxData) {
                    if (this[i] - this[d] > 0) {
                        this[i] -= this[d];
                        this[p] -= this[d]
                    }
                    if (this.minData > 0 && this[i] < 0) {
                        this[i] += this[d];
                        this[p] += this[d]
                    }
                }
            }
        }
        this[m] = this[p] - this[i];
        this.setAxisValues(h)
    };
    this.setAxes = function(d) {
        if (this.graphType.match(/Correlation/)) {
            var f = this.isGroupedData ? this.data.w : this.data.y;
            this.setMin = null;
            this.setMax = null;
            if (this.correlationAnchorLegend) {
                this.setAxisAttributes("xAxis")
            }
            if (!f.cor || f.cor.length == 0) {
                this.summarize("cor");
                this.setRangeData("cor")
            }
            if (!this.yAxisTitle) {
                this.yAxisTitle = "Correlation"
            }
        } else {
            if (this.graphType.match(/Scatter|Pie/)) {
                var t = this.smpIndices;
                var p = ["xAxis"];
                var c = ["X"];
                if (this.graphType.match(/Scatter/)) {
                    p.push("yAxis");
                    c.push("Y")
                }
                if (this.graphType.match(/ScatterBubble2D|Scatter3D/)) {
                    p.push("zAxis");
                    c.push("Z")
                }
                if (this.graphType == "Scatter3D") {
                    this.xAxisTicks = 10;
                    this.yAxisTicks = 10;
                    this.zAxisTicks = 10
                }
                for (var k = 0; k < p.length; k++) {
                    var l = p[k] + "Indices";
                    var j = "setMin" + c[k];
                    var r = "setMax" + c[k];
                    this.setMin = null;
                    this.setMax = null;
                    this.setAxis(p[k]);
                    this[l] = this.getSampleIndices(this[p[k]]);
                    this.setSamplesVisible(this[l]);
                    if (this[j] != null) {
                        this.setMin = this[j]
                    }
                    if (this[r] != null) {
                        this.setMax = this[r]
                    }
                    this.setAxisAttributes(p[k], k > 0 ? d : false, false, this[p[k] + "Transform"]);
                    this.setSamplesVisible(t)
                }
                if (!this.xAxisTitle) {
                    this.xAxisTitle = this.xAxis.length == 1 ? this.xAxis[0] : " "
                }
                if (this.graphType.match(/Scatter/)) {
                    if (!this.yAxisTitle) {
                        this.yAxisTitle = this.yAxis.length == 1 ? this.yAxis[0] : " "
                    }
                    if (this.graphType.match(/ScatterBubble2D|Scatter3D/)) {
                        if (!this.zAxisTitle) {
                            this.zAxisTitle = this.zAxis.length == 1 ? this.zAxis[0] : " "
                        }
                    }
                }
            } else {
                if (this.graphType.match(/Genome/)) {
                    this.setMax = this.setMaxX != null ? this.setMaxX : null;
                    this.setMin = this.setMinX != null ? this.setMinX : null;
                    this.setRangeData("genome");
                    this.xAxisExact = true;
                    this.xAxisTransform = false;
                    this.xAxisAbsMin = this.minData;
                    this.xAxisAbsMax = this.maxData;
                    this.xAxisMin = this.minData - 1;
                    this.xAxisMax = this.maxData + 1;
                    this.xAxisDecs = 0;
                    this.xAxisRange = this.xAxisMax - this.xAxisMin;
                    this.xAxisTicks = this.genomeTicks;
                    this.xAxisIncr = this.xAxisRange / this.xAxisTicks;
                    this.setAxisValues("xAxis")
                } else {
                    var o = this.smpIndices;
                    var e = this.varIndices;
                    var h = this.grpIndices;
                    var m = this.varIndices;
                    var s = this.graphType == "Dotplot" && this.isGroupedData ? true : false;
                    var g = this.graphType.match(/Percent/) ? "percentile" : false;
                    var n = this.graphType.match(/Stacked/) || (this.graphType.match(/Area/) && this.areaIsCumulative) ? true : false;
                    var q = this.graphType == "Candlestick" ? "candle" : g ? g : false;
                    if (this.varIndicesStart > -1 || this.smpIndicesStart > -1) {
                        this.setAllVariablesVisible();
                        this.setAllSamplesVisible();
                        if (this.graphType == "Heatmap") {
                            this.graphOrientation = "horizontal"
                        }
                    } else {
                        if (this.graphType == "StackedPercent" || this.graphType == "StackedPercentLine") {
                            this.setMinX = null;
                            this.setMaxX = null;
                            this.xAxisExact = true
                        } else {
                            if (this.graphType == "Boxplot" && !this.isGroupedData) {
                                if (!this.data.y.median) {
                                    this.summarize("iqr")
                                }
                            }
                        }
                    }
                    this.xAxis2Ticks = this.xAxisTicks;
                    if (this.graphType.match(/BarLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a) {
                        this.setVariablesVisible(this.getVariablesVisibleByAxis("xAxis"))
                    }
                    this.setMax = this.setMaxX != null ? this.setMaxX : null;
                    this.setMin = this.setMinX != null ? this.setMinX : null;
                    this.setAxisAttributes("xAxis", q, s, g, n);
                    this.xAxisTitle = this.xAxisTitle ? this.xAxisTitle : this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "";
                    if ((this.graphType.match(/BarLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a) || (this.graphType == "Candlestick" && this.showVolume)) {
                        q = this.graphType == "Candlestick" ? "volume" : false;
                        if (this.graphType.match(/BarLine|AreaLine|StackedLine|StackedPercentLine/)) {
                            this.setVariablesVisible(m);
                            this.setVariablesVisible(this.getVariablesVisibleByAxis("xAxis2"))
                        }
                        this.setMax = this.setMaxX2 != null ? this.setMaxX2 : null;
                        this.setMin = this.setMinX2 != null ? this.setMinX2 : null;
                        this.setAxisAttributes("xAxis2", q, s);
                        this.xAxis2Title = this.xAxis2Title ? this.xAxis2Title : this.data.y.desc && this.data.y.desc[1] ? this.data.y.desc[1] : ""
                    }
                    this.setMax = this.setMaxR != null ? this.setMaxR : null;
                    this.setMin = this.setMinR != null ? this.setMinR : null;
                    if (this.graphType == "Circular" && this.rAxis) {
                        this.setAxisAttributes("rAxis", "circular", s, g, false, true)
                    }
                    this.setVariablesVisible(m);
                    this.smpIndices = o;
                    this.varIndices = e;
                    this.grpIndices = h
                }
            }
        }
    };
    this.setScatterPointSize = function() {
        this.scatterPointSize = this.varIndices.length > 50 ? this.sizes[1] : this.varIndices.length > 20 ? this.sizes[2] : this.sizes[3];
        if (this.layoutComb) {
            this.scatterPointSize = Math.ceil(this.scatterPointSize / this.layoutRows)
        }
    };
    this.setAxisUnits = function(e, g) {
        var f = e + "Unit";
        var d = e + "Range";
        var c = g ? g : e.substring(0, 1);
        this[f] = this[c] / this[d]
    };
    this.setAxisFont = function(h, g) {
        var f = this.graphType == "Venn" ? 16 : 12;
        if (this.autoScaleFont || !this.axisTickFont || !this.decorationFont || !this.axisTitleFont) {
            var c, e, d;
            if (g >= 600) {
                c = 12 * this.axisTickScaleFontFactor;
                d = 10 * this.decorationScaleFontFactor;
                e = this.getFontPt(this.scaleTextToFont(h, f, g - 2)) * this.axisTitleScaleFontFactor
            } else {
                if (g >= 400) {
                    c = 10 * this.axisTickScaleFontFactor;
                    d = 8 * this.decorationScaleFontFactor;
                    e = this.getFontPt(this.scaleTextToFont(h, f, g - 2)) * this.axisTitleScaleFontFactor
                } else {
                    if (g >= 200) {
                        c = 8 * this.axisTickScaleFontFactor;
                        d = 6 * this.decorationScaleFontFactor;
                        e = 8 * this.axisTitleScaleFontFactor
                    } else {
                        if (g >= 100) {
                            c = 6 * this.axisTickScaleFontFactor;
                            d = 4 * this.decorationScaleFontFactor;
                            e = 6 * this.axisTitleScaleFontFactor
                        } else {
                            c = 4 * this.axisTickScaleFontFactor;
                            d = 2 * this.decorationScaleFontFactor;
                            e = 4 * this.axisTitleScaleFontFactor
                        }
                    }
                }
            }
            this.axisTickFont = this.axisTickFontStyle + " " + (parseInt(c)) + "Pt " + this.fontName;
            this.decorationFont = this.decorationFontStyle + " " + (parseInt(d)) + "Pt " + this.fontName;
            this.axisTitleFont = this.axisTitleFontStyle + " " + (parseInt(e)) + "Pt " + this.fontName
        } else {
            this.axisTickFont = this.axisTickFontStyle + " " + parseInt(this.axisTickFontSize) + "Pt " + this.fontName;
            this.decorationFont = this.decorationFontStyle + " " + parseInt(this.decorationFontSize) + "Pt " + this.fontName;
            this.axisTitleFont = this.axisTitleFontStyle + " " + parseInt(this.axisTitleFontSize) + "Pt " + this.fontName
        }
    };
    this.getAxisFont = function(c) {
        if (c >= 600) {
            return 12
        } else {
            if (c >= 400) {
                return 10
            } else {
                if (c >= 200) {
                    return 8
                } else {
                    return 6
                }
            }
        }
    };
    this.getHeatmapShades = function(d, c) {
        switch (d) {
            case "white":
            case "black":
                if (c && c != "white" && c != "black") {
                    return this.getHeatmapShades(c)
                } else {
                    return this.greys
                }
            case "grey":
                return this.greys;
            case "green":
                return this.greens;
            case "red":
                return this.reds;
            case "blue":
                return this.blues;
            case "yellow":
                return this.yellows;
            case "cyan":
                return this.cyans;
            case "purple":
                return this.purples
        }
    };
    this.setHeatmapColors = function(c) {
        this.setRGB();
        var k = c ? c : this.maxData - this.minData;
        var d = this.heatmapType.split("-");
        var m = 256 / this.indicatorBins;
        var l = this.getHeatmapShades(d[0], d[1]);
        this.heatmapColors = [];
        this.heatmapBin = (k ? k : 1) / this.indicatorBins;
        if (this.indicatorCenter.match("rainbow") && d.length > 1) {
            var e = ["red", "purple", "blue", "cyan", "green", "yellow"];
            if (this.indicatorCenter == "rainbow-green") {
                e.reverse()
            }
            var n = null;
            for (var h = 0; h < e.length; h++) {
                if (e[h] == d[0]) {
                    n = h
                }
            }
            if (n == null) {
                alert("Dude! " + d[0] + " ain't a valid color ... This is not looking good ...");
                this.heatmapColors = this.blues;
                return
            }
            var f = [e[n]];
            n++;
            while (f.length < 6) {
                if (n > 5) {
                    n = 0
                }
                f.push(e[n]);
                n++
            }
            n = null;
            for (var h = 0; h < f.length; h++) {
                if (f[h] == d[1]) {
                    n = h
                }
            }
            if (n == null) {
                alert("Dude! " + d[1] + " ain't a valid color ... This is not looking good ...");
                this.heatmapColors = this.blues;
                return
            }
            for (var h = 0; h < n; h++) {
                l = this.getHeatmapShades(f[h]);
                for (var g = 0; g < m; g++) {
                    this.heatmapColors.push(l[g])
                }
            }
        } else {
            if (d.length > 1) {
                if ((d[0] == "white" && d[1] != "black") || (d[0] == "black" && d[1] != "white")) {
                    this.heatmapType = d[1];
                    this.setHeatmapColors(c)
                } else {
                    if (d[1] == "white") {
                        if (d[0] == "black") {
                            this.heatmapColors.push("rgb(0,0,0)");
                            for (var h = m - 1; h >= 0; h--) {
                                this.heatmapColors.push(l[h]);
                                this.heatmapColors.push(l[h])
                            }
                        } else {
                            for (var h = 0; h < m; h++) {
                                this.heatmapColors.push(l[h]);
                                this.heatmapColors.push(l[h])
                            }
                            this.heatmapColors.push("rgb(255,255,255)")
                        }
                    } else {
                        if (d[1] == "black") {
                            if (d[0] == "white") {
                                this.heatmapColors.push("rgb(255,255,255)");
                                for (var h = 0; h < m; h++) {
                                    this.heatmapColors.push(l[h]);
                                    this.heatmapColors.push(l[h])
                                }
                            } else {
                                for (var h = 0; h < m; h++) {
                                    this.heatmapColors.push(l[h]);
                                    this.heatmapColors.push(l[h])
                                }
                                this.heatmapColors.push("rgb(0,0,0)")
                            }
                        } else {
                            for (var h = 0; h < m; h++) {
                                this.heatmapColors.push(l[h])
                            }
                            if (this.indicatorCenter == "black") {
                                this.heatmapColors.push("rgb(0,0,0)")
                            } else {
                                this.heatmapColors.push("rgb(255,255,255)")
                            }
                            l = this.getHeatmapShades(d[1]);
                            for (var h = m - 1; h >= 0; h--) {
                                this.heatmapColors.push(l[h])
                            }
                        }
                    }
                }
            } else {
                if (this.indicatorCenter == "black" && color[0] != "grey") {
                    this.heatmapColors.push("rgb(0,0,0)")
                } else {
                    this.heatmapColors.push("rgb(255,255,255)")
                }
                for (var h = m - 1; h >= 0; h--) {
                    this.heatmapColors.push(l[h]);
                    this.heatmapColors.push(l[h])
                }
            }
        }
    };
    this.initializeAxis = function() {
        if (!this.graphType.match(/Venn|Network|Video/)) {
            if (!a) {
                this.setAxes();
                this.setHeatmapColors()
            }
        }
    };
    this.initializeAxis()
};
CanvasXpress.prototype.Pie = function() {
    this.setVarPie = function() {
        var f = [];
        var a = this.smpIndices[0];
        if (this.varIndices.length >= this.maxPieSectors - 1) {
            var e = this;
            this.varIndices.sort(function(g, d) {
                return e.data.y.data[d][a] - e.data.y.data[g][a]
            })
        }
        for (var b = 0; b < this.varIndices.length; b++) {
            var c = this.varIndices[b];
            f.push(this.getDataAtPos(c, a))
        }
        this.varPie = this.setPieData(f, true)
    };
    this.getPieLegendDimensions = function() {
        this.setLegendFont();
        var e = this.getFontPt(this.legendFont);
        var d = this.shortenText(this.maxVarNameStr, this.maxVarStringLen);
        var b = this.measureText(d, this.legendFont);
        if (b > this.width / 2) {
            this.legendFont = this.scaleTextToFont(b, e, this.width / 2)
        }
        var c = e + this.measureText(d, this.legendFont) + (this.margin * 5);
        var f = this.varIndices.length > this.maxPieSectors ? this.maxPieSectors : this.varIndices.length;
        var a = (f * (e + this.margin)) + (this.margin * 3);
        return ([c, a])
    };
    this.setPieXYDimensions = function() {
        var a = this.getPieLegendDimensions();
        if (this.showLegend) {
            if (this.legendPosition == "right") {
                this.right = this.layoutComb ? this.layoutRight : a[0]
            } else {
                this.bottom = this.layoutComb ? this.layoutBottom : a[1]
            }
        }
        this.x = this.layoutComb ? this.layoutWidth : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
        this.y = this.layoutComb ? this.layoutHeight : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
        this.setAxisFont("Pie", this.x)
    };
    this.drawPieDataPoints = function() {
        var b = Math.min(this.x, this.y);
        var c = (b - (b / 5)) / 2;
        var a = this.marginLeft + this.offsetX + this.left + (this.x / 2);
        var d = this.marginTop + this.offsetY + this.top + (this.y / 2);
        this.setVarPie();
        this.drawPie(this.varPie, a, d, c, true)
    };
    this.drawPieLegend = function() {
        if (this.showLegend) {
            var b, g;
            var k = this.getPieLegendDimensions();
            var l = this.getFontPt(this.legendFont);
            var j = l / 2;
            if (this.legendPosition == "right") {
                b = this.layoutComb ? (this.width - (this.marginRight + k[0])) + this.marginLeft + this.left : this.marginLeft + this.left + this.x + (this.margin * 2) + j;
                g = this.layoutComb ? (this.layoutTop + (this.margin * 3) + ((this.height - (this.layoutTop + this.layoutBottom)) / 2)) - (k[1] / 2) : this.marginTop + this.top + ((this.y / 2) - (k[1] / 2)) + this.margin
            } else {
                b = this.layoutComb ? (this.layoutLeft + (this.margin * 3) + ((this.width - (this.layoutLeft + this.layoutRight)) / 2)) - (k[0] / 2) : this.marginLeft + this.left + ((this.x / 2) - (k[0] / 2)) + this.margin;
                g = this.layoutComb ? (this.height - (this.marginBottom + k[1])) + this.marginTop + this.top : this.marginTop + this.top + this.y + (this.margin * 2) + j
            }
            var a = b + j + this.margin;
            var f = g;
            for (var d = 0; d < this.varPie.ids.length; d++) {
                var h = this.varPie.ids[d];
                var c = d % this.colors.length;
                var e = h > -1 ? this.shortenText(this.data.y.vars[h], this.maxVarStringLen) : "Other";
                this.drawShape("square", b, f, l, l, this.colors[c], this.foreground, "closed");
                this.drawText(e, a, f, this.legendFont, this.legendColor, "left", "middle");
                f += l + this.margin
            }
            if (this.legendBox) {
                this.rectangle(b - (this.margin * 2), g - (this.margin * 2), k[0] - l, k[1] - l, false, this.legendBoxColor, "open")
            }
        }
    };
    this.drawPiePlot = function() {
        this.setPieXYDimensions();
        this.drawTitle();
        this.drawPieDataPoints();
        this.drawPieLegend()
    };
    this.initializePiePlot = function() {
        if (this.xAxisMin < 0) {
            alert("Dude you can't draw a pie chart with negative numbers!");
            return
        }
        if (this.layoutValid) {
            this.drawLayoutCompartments(this.drawPiePlot)
        } else {
            this.drawPiePlot()
        }
    };
    this.initializePiePlot()
};
CanvasXpress.prototype.Venn = function() {
    this.setVennXYDimensions = function() {
        var a;
        this.vennMarginLeft = 0;
        this.vennMarginTop = 0;
        this.setLegendFont();
        this.setAxisFont("Venn", this.width);
        if (this.showLegend) {
            this.bottom = this.margin + ((this.getFontPt(this.legendFont) + this.margin) * this.vennGroups)
        }
        if (this.width <= this.height) {
            this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
        } else {
            this.x = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
        }
        this.y = this.vennGroups == 4 ? this.x * 0.8 : this.vennGroups == 3 ? this.x * 0.95 : this.vennGroups == 2 ? this.x * 0.65 : this.x;
        this.vennMarginTop = (this.height - (this.marginTop + this.top + this.y + this.bottom + this.marginBottom)) / 2;
        this.vennMarginLeft = (this.width - (this.marginLeft + this.left + this.x + this.right + this.marginRight)) / 2;
        if (this.x < 400) {
            var b = this.getFontPt(this.axisTickFont) - 2;
            if (this.x < 200) {
                b -= 1
            }
            this.axisTickFont = b + "Pt " + this.fontName
        }
        this.resizeCanvas()
    };
    this.drawVennBubble = function(b, c, a) {
        if (this.vennGroups == 4) {
            if (this.isIE && !this.useFlashIE) {
                a = a.replace("rgb", "rgba");
                a = a.replace(")", ",0.5)");
                this.drawShape("ellipse2", 0, 0, this.x / 1.4, this.x / 1.4, a, this.foreground, "closed")
            } else {
                this.drawShape("ellipse2", 0, 0, this.x / 1.4, this.x / 1.4, a, this.foreground, "closed");
                this.ctx.globalCompositeOperation = "lighter"
            }
        } else {
            if (this.isIE && !this.useFlashIE) {
                a = a.replace("rgb", "rgba");
                a = a.replace(")", ",0.5)");
                this.drawShape("circle", b, c, this.x / 2, this.x / 2, a, this.foreground, "closed")
            } else {
                this.drawShape("circle", b, c, this.x / 2, this.x / 2, a, this.foreground, "closed");
                this.ctx.globalCompositeOperation = "lighter"
            }
        }
    };
    this.drawVennLayout = function() {
        var g, h, b, e;
        var a = ["A", "B", "C", "D"];
        this.ctx.clearRect(0, 0, this.width, this.height);
        if (this.vennGroups == 4) {
            this.ctx.save();
            g = this.vennMarginLeft + this.marginLeft + this.margin + (this.x / 4.94);
            h = this.vennMarginTop + this.marginTop + this.top + (this.x / 13);
            this.ctx.translate(g, h);
            this.ctx.rotate(Math.PI / 4);
            this.drawVennBubble(0, 0, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)");
            g = this.x / 22.4;
            h = this.x / -5.32;
            this.ctx.translate(g, h);
            this.drawVennBubble(0, 0, this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,153,51)");
            g = this.x / 1.84;
            h = this.x / -5.32;
            this.ctx.translate(g, h);
            this.ctx.rotate(Math.PI / 2);
            g = this.x / -22.4;
            h = this.x / -5.32;
            this.ctx.translate(g, h);
            this.drawVennBubble(0, 0, this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)");
            g = this.x / 22.4;
            h = this.x / 5.32;
            this.ctx.translate(g, h);
            this.drawVennBubble(0, 0, this.vennColors.length > 3 && this.validateColor(this.vennColors[3]) ? this.validateColor(this.vennColors[3]) : "rgb(153,204,0)");
            this.ctx.restore();
            b = [11.2, 3.05, 1.46, 1.08];
            e = [7, 42, 42, 7]
        } else {
            if (this.vennGroups == 3) {
                this.ctx.save();
                g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 2);
                h = this.vennMarginTop + this.marginTop + this.top + (this.x / 2.86);
                this.drawVennBubble(g, h, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)");
                h += (this.x / 3.33);
                g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 3);
                this.drawVennBubble(g, h, this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,255,0)");
                g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 1.5);
                this.drawVennBubble(g, h, this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)");
                this.ctx.restore();
                b = [2, 8.66, 1.13];
                e = [20, 2.3, 2.3]
            } else {
                if (this.vennGroups == 2) {
                    this.ctx.save();
                    g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 3);
                    h = this.vennMarginTop + this.marginTop + this.top + (this.x / 2.67);
                    this.drawVennBubble(g, h, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(0,0,255)");
                    g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 1.5);
                    h = this.vennMarginTop + this.marginTop + this.top + (this.x / 2.67);
                    this.drawVennBubble(g, h, this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(255,0,0)");
                    this.ctx.restore();
                    b = [3, 1.5];
                    e = [16, 16]
                } else {
                    if (this.vennGroups == 1) {
                        g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 2);
                        h = this.vennMarginTop + this.marginTop + this.top + (this.x / 2);
                        this.drawShape("circle", g, h, this.x, this.x, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)", this.foreground, "closed");
                        b = [100];
                        e = [100]
                    }
                }
            }
        } if (!this.vennLegendColors) {
            for (var d = 0; d < this.vennGroups; d++) {
                var c = this.vennMarginLeft + this.marginLeft + this.left + (this.x / b[d]);
                var f = this.vennMarginTop + this.marginTop + this.top + (this.x / e[d]);
                this.drawText(a[d], c, f, this.axisTickFont, this.axisTickColor, "center", "middle")
            }
        }
    };
    this.drawVennDataPoints = function() {
        var a, e;
        if (this.vennGroups == 4) {
            a = [5.6, 2.94, 3.5, 1.54, 3.29, 2, 2.59, 1.212, 2, 1.442, 1.4, 1.757, 2.31, 1.624, 2];
            e = [2.94, 7, 3.92, 7, 1.89, 4.06, 2.66, 2.94, 1.54, 1.89, 3.92, 1.729, 1.729, 2.66, 2.03];
            this.y = (this.x * 1.1) / 1.4
        } else {
            if (this.vennGroups == 3) {
                a = [2, 3.5, 2.55, 1.4, 1.6, 2, 2];
                e = [3.6, 1.54, 2.07, 1.54, 2.07, 1.54, 1.83];
                this.y = this.x * 0.95
            } else {
                if (this.vennGroups == 2) {
                    a = [3.5, 1.4, 2];
                    e = [2.66, 2.66, 2.66];
                    this.y = this.x * 0.65
                } else {
                    if (this.vennGroups == 1) {
                        a = [2];
                        e = [2]
                    }
                }
            }
        }
        for (var d = 0; d < a.length; d++) {
            var c = this.vennMarginLeft + this.marginLeft + this.left + (this.x / a[d]);
            var f = this.vennMarginTop + this.marginTop + this.top + (this.x / e[d]);
            var b = this.getFontPt(this.axisTickFont);
            var g = this.data.venn.data[this.vennCompartments[d]] ? this.data.venn.data[this.vennCompartments[d]] : 0;
            this.drawText(g, c, f, this.axisTickFont, this.axisTickColor, "center", "middle");
            this.addArea(["circle", c, f, b], [d])
        }
    };
    this.drawVennLegend = function() {
        if (this.showLegend) {
            var a = ["A", "B", "C", "D"];
            var j = this.getFontPt(this.legendFont);
            var d = this.vennMarginLeft + this.marginLeft + this.left;
            var c = d + (j * 2);
            var g = this.vennMarginTop + this.marginTop + this.top + this.y + this.margin + (j / 2);
            var h = [];
            if (this.vennGroups == 4) {
                h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)");
                h.push(this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,153,51)");
                h.push(this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[3]) : "rgb(153,204,0)");
                h.push(this.vennColors.length > 3 && this.validateColor(this.vennColors[3]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)")
            } else {
                if (this.vennGroups == 3) {
                    h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)");
                    h.push(this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,255,0)");
                    h.push(this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)")
                } else {
                    if (this.vennGroups == 2) {
                        h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(0,0,255)");
                        h.push(this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(255,0,0)")
                    } else {
                        h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)")
                    }
                }
            }
            for (var f = 0; f < this.vennGroups; f++) {
                if (!this.vennLegendColors) {
                    this.drawText(a[f] + ": ", d, g, this.legendFont, this.legendColor, "left", "middle")
                }
                var b = this.data.venn.legend && this.data.venn.legend[a[f]] ? this.data.venn.legend[a[f]] : "N/A";
                var e = (this.measureText(b, this.legendFont) > this.x) ? this.scaleTextToFont(b, j, this.x - this.margin) : this.legendFont;
                if (!this.vennLegendColors) {
                    this.drawText(b, c, g, e, this.legendColor, "left", "middle")
                } else {
                    this.drawText(b, d, g, e, h[f], "left", "middle")
                }
                g += this.margin + j
            }
        }
    };
    this.drawVennPlot = function() {
        this.setVennXYDimensions();
        this.drawTitle();
        this.showShadow = false;
        this.drawVennLayout();
        this.showShadow = this.tmpshowShadow;
        this.drawVennDataPoints();
        this.drawVennLegend()
    };
    this.initializeVennPlot = function() {
        this.transparency = null;
        this.tmpshowShadow = this.showShadow;
        this.background = "rgb(255,255,255)";
        this.foreground = "rgb(0,0,0)";
        this.drawVennPlot()
    };
    this.initializeVennPlot()
};
CanvasXpress.prototype.Correlation = function() {
    this.setCorrelationVarSmpLabelFont = function(b) {
        var a = this.scaleTextToSize(b);
        a = this.correlationAxis == "samples" ? a * this.smpLabelScaleFontFactor : a * this.varLabelScaleFontFactor;
        a = Math.min(a, this.maxTextSize);
        this.smpLabelFont = (a) + "Pt " + this.fontName;
        this.varLabelFont = (a) + "Pt " + this.fontName
    };
    this.getCorrelationLabelsHeight = function() {
        var a = 0;
        if (this.correlationAxis == "samples") {
            if (this.maxSmpName > this.maxSmpStringLen) {
                a += this.measureText(this.maxSmpNameStr.substring(0, this.maxSmpStringLen), this.smpLabelFont)
            } else {
                a += this.measureText(this.maxSmpNameStr, this.smpLabelFont)
            }
        } else {
            if (this.maxVarName > this.maxVarStringLen) {
                a += this.measureText(this.maxVarNameStr.substring(0, this.maxVarStringLen), this.varLabelFont)
            } else {
                a += this.measureText(this.maxVarNameStr, this.varLabelFont)
            }
        } if (this.correlationAnchorLegend) {
            a += this.correlationAnchorLegendAlignWidth + this.margin
        }
        return a
    };
    this.setCorrelationXYDimensions = function() {
        this.corMarginLeft = 0;
        this.corMarginTop = 0;
        if (this.yAxisShow) {
            this.setAxisFont(this.yAxisTitle, this.height);
            this.left = this.margin + this.getFontPt(this.axisTitleFont) + this.margin
        }
        if (this.width <= this.height) {
            this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
        } else {
            this.x = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
        }
        var a = this.correlationAxis == "variables" ? this.varIndices.length : this.isGroupedData ? this.grpIndices.length : this.smpIndices.length;
        this.diamondSize = this.x / a;
        this.setCorrelationVarSmpLabelFont(a);
        this.y = this.x / 2 + (this.diamondSize / 2);
        if (this.xAxisShow) {
            this.top += this.margin + this.getCorrelationLabelsHeight() + this.margin
        }
        if (this.autoAdjust) {
            this.height = this.marginTop + this.top + this.y + this.bottom + this.marginBottom;
            this.width = this.marginLeft + this.left + this.x + this.right + this.marginRight
        } else {
            this.corMarginTop = (this.height - (this.marginTop + this.top + this.y + this.bottom + this.marginBottom)) / 2;
            this.corMarginLeft = (this.width - (this.marginLeft + this.left + this.x + this.right + this.marginRight)) / 2
        }
        this.resizeCanvas()
    };
    this.drawCorrelationLayout = function() {
        if (this.yAxisShow) {
            this.drawText(this.yAxisTitle, this.corMarginLeft + this.marginLeft + this.left / 2, this.marginTop + this.top + (this.y / 2), this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2)
        }
        if (this.xAxisShow) {
            var c = this.corMarginLeft + this.marginLeft + this.left + (this.diamondSize / 2);
            var p = (this.corMarginTop + this.marginTop + this.top) - this.margin;
            var o = (this.corMarginTop + this.marginTop + this.top) - (this.getCorrelationLabelsHeight() + this.margin);
            var n = o + this.correlationAnchorLegendAlignWidth;
            var k, f, h;
            var a = this.isGroupedData ? this.data.w : this.data.y;
            var r = this.correlationAxis == "variables" ? this.varIndices : this.isGroupedData ? this.grpIndices : this.smpIndices;
            var m = this.correlationAxis == "samples" ? this.maxSmpStringLen : this.maxVarStringLen;
            if (this.correlationAnchorLegend) {
                h = this.correlationAxis == "samples" ? a.data[0] : this.getDataForSmpGrpAtIndex(0);
                r.sort(function(s, i) {
                    return h[s] - h[i]
                });
                this.setAxisUnits("xAxis")
            }
            if (this.correlationAxis == "samples") {
                k = a.smps;
                f = this.smpLabelFont
            } else {
                k = a.vars;
                f = this.varLabelFont
            }
            for (var g = 0; g < r.length; g++) {
                var q = r[g];
                var j = this.shortenText(k[q], m);
                var e = this.correlationAxis == "samples" ? this.getSmpColor(k[q]) : this.getVarColor(k[q]);
                var l = g / this.correlationLabelInterval;
                if (parseInt(l) == parseFloat(l)) {
                    this.drawText(j, c, p, f, e, "left", "middle", -Math.PI / 2)
                }
                if (this.correlationAnchorLegend) {
                    var d = h[q];
                    var b = this.corMarginLeft + this.marginLeft + this.left + ((d - this.xAxisMin) * this.xAxisUnit);
                    this.drawLine("line", b, o - this.margin, b, o, e);
                    this.drawLine("line", b, o, c, n, e)
                }
                c += this.diamondSize
            }
        }
        c = (this.corMarginLeft + this.marginLeft + this.left + (this.x / 3)) - (this.heatmapColors.length * this.indicatorWidth);
        p = this.corMarginTop + this.marginTop + this.top + (this.y * 7 / 8);
        if (this.correlationAnchorLegend) {
            this.setRangeData("cor")
        }
        if (this.minData == null || this.maxData == null) {
            this.setRangeData("cor")
        }
        this.drawColorIndicator(c, p, this.minData, this.maxData, 2)
    };
    this.drawCorrelationDataPoints = function() {
        var c, o, b, n;
        var r = this.diamondSize / 2;
        var h = this.isGroupedData ? this.data.w.cor : this.data.y.cor;
        var q = this.correlationAxis == "variables" ? this.varIndices : this.isGroupedData ? this.grpIndices : this.smpIndices;
        c = this.corMarginLeft + this.marginLeft + this.left + r;
        o = this.corMarginTop + this.marginTop + this.top + r;
        for (var l = 0; l < Math.ceil(q.length / 2); l++) {
            var p = q[l];
            b = c + (this.diamondSize * l);
            n = o;
            for (var g = l; g < q.length - l; g++) {
                var m = q[g];
                var e = h[p][m];
                var d = this.getHeatmapColor(this.minData, this.maxData, e);
                if (isNaN(e)) {
                    this.addArea(this.drawShape("diamond", b, n, this.diamondSize, this.diamondSize, this.missingDataColor, this.missingDataColor, "closed"), [p, m])
                } else {
                    this.addArea(this.drawShape("diamond", b, n, this.diamondSize, this.diamondSize, d, d, "closed"), [p, m])
                }
                b += r;
                n += r
            }
            n -= this.diamondSize;
            for (var f = g - 2; f >= l; f--) {
                var a = q[(q.length - f) - 1];
                var e = h[a][m];
                var d = this.getHeatmapColor(this.minData, this.maxData, e);
                if (isNaN(e)) {
                    this.addArea(this.drawShape("diamond", b, n, this.diamondSize, this.diamondSize, this.missingDataColor, this.missingDataColor, "closed"), [a, m])
                } else {
                    this.addArea(this.drawShape("diamond", b, n, this.diamondSize, this.diamondSize, d, d, "closed"), [a, m])
                }
                b += r;
                n -= r
            }
        }
        this.drawLine("line", this.corMarginLeft + this.marginLeft + this.left, this.corMarginTop + this.marginTop + this.top + r, this.corMarginLeft + this.marginLeft + this.left + (this.x / 2), this.corMarginTop + this.marginTop + this.top + this.y, this.foreground, false, "butt");
        this.drawLine("line", this.corMarginLeft + this.marginLeft + this.left + this.x, this.corMarginTop + this.marginTop + this.top + r, this.corMarginLeft + this.marginLeft + this.left + (this.x / 2), this.corMarginTop + this.marginTop + this.top + this.y, this.foreground, false, "butt");
        c = this.corMarginLeft + this.marginLeft + this.left + r;
        o = this.corMarginTop + this.marginTop + this.top;
        b = c + (this.x / 2);
        n = (this.corMarginTop + this.marginTop + this.top + this.y) - r;
        for (var l = 0; l < q.length; l++) {
            this.drawLine("line", c, o, b, n, this.foreground, false, "butt");
            c += this.diamondSize;
            b += r;
            n -= r
        }
        c = (this.corMarginLeft + this.marginLeft + this.left + this.x) - r;
        o = this.corMarginTop + this.marginTop + this.top;
        b = (this.corMarginLeft + this.marginLeft + this.left + (this.x / 2)) - r;
        n = (this.corMarginTop + this.marginTop + this.top + this.y) - r;
        for (var l = 0; l < q.length; l++) {
            this.drawLine("line", c, o, b, n, this.foreground, false, "butt");
            c -= this.diamondSize;
            b -= r;
            n -= r
        }
    };
    this.drawCorrelationPlot = function() {
        this.setCorrelationXYDimensions();
        this.drawCorrelationLayout();
        this.drawTitle();
        this.drawCorrelationDataPoints()
    };
    this.initializeCorrelationPlot = function() {
        this.drawCorrelationPlot()
    };
    this.initializeCorrelationPlot()
};
CanvasXpress.prototype.Scatter2D = function(a) {
    this.get2DYAxisWidth = function() {
        if (this.scatterPlotMatrix) {
            return this.yAxisShow ? this.measureText(this.yAxisMaxStrLength, this.axisTickFont) + (this.margin * 3) : this.margin
        } else {
            return this.yAxisShow ? this.getFontPt(this.axisTitleFont) + this.measureText(this.yAxisMaxStrLength, this.axisTickFont) + (this.margin * 5) : this.margin
        }
    };
    this.get2DXAxisHeight = function() {
        if (this.scatterPlotMatrix) {
            return this.xAxisShow ? this.getFontPt(this.axisTitleFont) + (this.margin * 5) : this.margin
        } else {
            return this.xAxisShow ? this.getFontPt(this.axisTickFont) + this.getFontPt(this.axisTitleFont) + (this.margin * 5) : this.margin
        }
    };
    this.set2DType = function() {
        if (this.isValidKaplanMeyer()) {
            this.type2D = "KM"
        } else {
            if (this.graphType == "ScatterBubble2D" && this.xAxisIndices.length > 1 && this.xAxisIndices.length == this.yAxisIndices.length && this.xAxisIndices.length == this.zAxisIndices.length) {
                this.type2D = "XYZ"
            } else {
                if (this.xAxisIndices.length > 1 && this.xAxisIndices.length == this.yAxisIndices.length) {
                    this.type2D = "XY"
                } else {
                    if (this.xAxisIndices.length > this.yAxisIndices.length) {
                        this.type2D = "X"
                    } else {
                        this.type2D = "Y"
                    }
                }
            }
        }
    };
    this.set2DText = function() {
        var c = this.xAxisTitle.length > this.yAxisTitle.length ? this.xAxisTitle : this.yAxisTitle;
        var b = this.layoutComb ? Math.min(this.layoutWidth, this.layoutHeight) : Math.min(this.width, this.height);
        this.setAxisFont(c, b)
    };
    this.setDecorationsLegendPositions = function() {
        if (this.showDecorations) {
            this.setDecorationLegendDimension();
            if (this.showLegend) {
                if (this.legendPosition == "bottom") {
                    this.decorationsPosition = "right"
                } else {
                    this.decorationsPosition = "bottom"
                }
            }
        }
    };
    this.reRangeData = function() {
        this.xAxis = [];
        for (var b = 0; b < this.data.d.kaplanMeyer.length; b++) {
            this.xAxis.push(this.data.d.kaplanMeyer[b].time);
            this.xAxisTitle = this.data.d.kaplanMeyer[b].time
        }
        this.yAxisTitle = "Probability of Survival";
        this.setAxes("km")
    };
    this.set2DXYDimensions = function() {
        this.setDecorationsLegendPositions();
        this.setLegendDimensions();
        this.right = 0;
        if (this.showLegend || this.showIndicators) {
            this.right = this.legendWidth
        }
        if (this.showDecorations && this.decorationsPosition == "right") {
            this.right += this.legendDecorationWidth + (this.margin * 2)
        }
        if (this.graphType == "ScatterBubble2D" && this.zAxisShow) {
            this.right += this.getFontPt(this.axisTitleFont) + this.margin
        } else {
            this.right += this.margin
        }
        this.left = this.get2DYAxisWidth();
        this.bottom = this.get2DXAxisHeight();
        if (this.showLegend || this.showIndicators) {
            this.bottom += this.legendHeight
        }
        if (this.showDecorations && this.decorationsPosition == "bottom") {
            this.bottom += this.legendDecorationHeight + (this.margin * 2)
        }
        this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
        this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
        this.setScatterPointSize();
        if (this.isValidKaplanMeyer()) {
            this.reRangeData()
        }
        this.setAxisUnits("xAxis");
        this.setAxisUnits("yAxis")
    };
    this.set2DWireFrame = function() {
        var e, g, c, f, b, h;
        this.disableGradientTransparencyShadow();
        e = this.marginLeft + this.offsetX + this.left;
        c = e + this.x;
        b = this.yAxisTickStyle == "dotted" ? "dottedLine" : "line";
        if (this.yAxisMinorTicks) {
            for (var d = 0; d < this.yAxisMinorValues.length; d++) {
                h = parseFloat(this.yAxisMinorValues[d]);
                g = (this.marginTop + this.offsetY + this.top + this.y) - ((h - this.yAxisMin) * this.yAxisUnit);
                this.drawLine(b, e, g, c, g, this.yAxisTickColor, this.outlineWidth / 3, "butt")
            }
        }
        for (var d = 0; d < this.yAxisValues.length; d++) {
            h = parseFloat(this.yAxisValues[d]);
            g = (this.marginTop + this.offsetY + this.top + this.y) - ((h - this.yAxisMin) * this.yAxisUnit);
            this.drawLine(b, e, g, c, g, this.yAxisTickColor, false, "butt")
        }
        g = this.marginTop + this.offsetY + this.top;
        f = g + this.y;
        b = this.xAxisTickStyle == "dotted" ? "dottedLine" : "line";
        if (this.xAxisMinorTicks) {
            for (var d = 0; d < this.xAxisMinorValues.length; d++) {
                h = parseFloat(this.xAxisMinorValues[d]);
                e = (this.marginLeft + this.offsetX + this.left) + ((h - this.xAxisMin) * this.xAxisUnit);
                this.drawLine(b, e, g, e, f, this.xAxisTickColor, this.outlineWidth / 3, "butt")
            }
        }
        for (var d = 0; d < this.xAxisValues.length; d++) {
            h = parseFloat(this.xAxisValues[d]);
            e = (this.marginLeft + this.offsetX + this.left) + ((h - this.xAxisMin) * this.xAxisUnit);
            this.drawLine(b, e, g, e, f, this.xAxisTickColor, false, "butt")
        }
        this.enableGradientTransparencyShadow()
    };
    this.set2DLayout = function() {
        var c = this.marginLeft + this.offsetX + this.margin + (this.getFontPt(this.axisTitleFont) / 2);
        var d = this.marginTop + this.offsetY + this.top + (this.y / 2);
        if (this.yAxisShow && !this.scatterPlotMatrix) {
            this.drawText(this.yAxisTitle, c, d, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2, false, false, true)
        }
        c = this.marginLeft + this.offsetX + this.left - this.margin;
        if (this.yAxisTransform && this.yAxisTransform.match(/log/) && !this.yAxisTransformTicks) {
            this.yAxisDecs = parseInt(Math.abs(this.yAxisMin))
        }
        var g = this.yAxisTransform && this.yAxisTransform == "percentile" ? this.yAxisValues.length : this.yAxisValues.length - 1;
        for (var b = 0; b < g; b++) {
            var f = parseFloat(this.yAxisValues[b]);
            var e = this.yAxisTransform && !this.yAxisTransformTicks ? this.formatAxisValue(this.transformValue(this.yAxisTransform, f, true), "yAxis") : this.formatAxisValue(f, "yAxis");
            d = (this.marginTop + this.offsetY + this.top + this.y) - ((f - this.yAxisMin) * this.yAxisUnit);
            if (this.yAxisShow) {
                this.drawText(e, c, d, this.axisTickFont, this.axisTickColor, "right", "middle")
            }
        }
        c = this.marginLeft + this.offsetX + this.left + (this.x / 2);
        d = this.marginTop + this.offsetY + this.top + this.y + this.margin + this.margin + this.getFontPt(this.axisTickFont) + this.margin + this.margin + (this.getFontPt(this.axisTitleFont) / 2);
        if (this.xAxisShow && !this.scatterPlotMatrix) {
            this.drawText(this.xAxisTitle, c, d, this.axisTitleFont, this.axisTitleColor, "center", "middle", false, false, false, true)
        }
        d = this.marginTop + this.offsetY + this.top + this.y + this.margin + this.margin + (this.getFontPt(this.axisTickFont) / 2);
        if (this.xAxisTransform && this.xAxisTransform.match(/log/) && !this.xAxisTransformTicks) {
            this.xAxisDecs = parseInt(Math.abs(this.xAxisMin))
        }
        var g = this.xAxisTransform && this.xAxisTransform == "percentile" ? this.xAxisValues.length : this.xAxisValues.length - 1;
        for (var b = 0; b < g; b++) {
            var f = parseFloat(this.xAxisValues[b]);
            var e = this.xAxisTransform && !this.xAxisTransformTicks ? this.formatAxisValue(this.transformValue(this.xAxisTransform, f, true), "xAxis") : this.formatAxisValue(f, "xAxis");
            c = (this.marginLeft + this.offsetX + this.left) + ((f - this.xAxisMin) * this.xAxisUnit);
            if (this.xAxisShow) {
                this.drawText(e, c, d, this.axisTickFont, this.axisTickColor, "center", "middle")
            }
        }
        if (this.graphType == "ScatterBubble2D") {
            if (this.zAxisShow) {
                c = this.marginLeft + this.offsetX + this.left + this.x + this.margin;
                d = this.marginTop + this.offsetY + this.top + (this.y / 2);
                this.drawText(this.zAxisTitle, c, d, this.axisTitleFont, this.axisTitleColor, "center", "bottom", Math.PI / 2, false, false, true)
            }
        }
        this.disableGradientTransparencyShadow();
        this.rectangle(this.marginLeft + this.offsetX + this.left, this.marginTop + this.offsetY + this.top, this.x, this.y, false, this.foreground, "open");
        this.enableGradientTransparencyShadow()
    };
    this.draw2DDataPoints = function() {
        var n, b, m, P;
        var M, t, N;
        var s, J, o;
        var O, h, H;
        var q = [];
        var k = [];
        var g = false;
        if (this.type2D == "KM") {
            return
        } else {
            if (this.type2D == "XYZ") {
                var F = this.xAxisIndices[this.xAxisCurrent];
                var r = this.yAxisIndices[this.yAxisCurrent];
                var c = this.zAxisIndices[this.zAxisCurrent];
                var p = F + ":" + r;
                if (this.xAxisTransform == "percentile") {
                    M = this.getAxisRangeBySample(this.xAxisIndices);
                    N = M[0];
                    t = M[1]
                }
                if (this.yAxisTransform == "percentile") {
                    s = this.getAxisRangeBySample(this.yAxisIndices);
                    o = s[0];
                    J = s[1]
                }
                O = this.getAxisRangeBySample(this.zAxisIndices);
                H = O[0];
                h = O[1];
                for (var K = 0; K < this.varIndices.length; K++) {
                    var l = this.varIndices[K];
                    var G = this.getDataAtPos(l, F, false, this.xAxisTransform, N, t);
                    var E = this.getDataAtPos(l, r, false, this.yAxisTransform, o, J);
                    var D = this.getDataAtPos(l, c, false, "percentile", H, h);
                    var I = this.getDataAtPos(l, F, "stdev");
                    var u = this.getDataAtPos(l, r, "stdev");
                    var d = this.sizeBy ? this.dataSizes[K] : this.sizes[Math.floor(D / 10) + 1];
                    var e = this.colorBy ? this.dataColors[K] : this.colors[0];
                    var w = this.shapeBy ? this.dataShapes[K] : this.shapes[0];
                    var f = this.scatterType && this.scatterType.match(/image/i) ? this.images[K] : false;
                    var C = f ? "image" : w;
                    n = (this.marginLeft + this.offsetX + this.left) + ((G - this.xAxisMin) * this.xAxisUnit);
                    b = (this.marginTop + this.offsetY + this.top + this.y) - ((E - this.yAxisMin) * this.yAxisUnit);
                    if (this.isVisibleSelectedDataPoint(l, p)) {
                        if (!this.scatterType || !this.scatterType.match(/functio|lineStep/)) {
                            this.drawSelectedBackground(l, p, w, n, b, d, d, false, true);
                            if (I && !isNaN(I)) {
                                m = (I / 2) * this.xAxisUnit;
                                this.errorBar(n, b, n + m, b, this.margin, e);
                                this.errorBar(n, b, n - m, b, this.margin, e)
                            }
                            if (u && !isNaN(u)) {
                                P = (u / 2) * this.yAxisUnit;
                                this.errorBar(n, b, n, b + P, -this.margin, e);
                                this.errorBar(n, b, n, b - P, -this.margin, e)
                            }
                            this.addArea(this.drawShape(C, n, b, d, d, e, this.foreground, "closed", false, false, true, false, false, false, f), [l, F, r, c]);
                            this.drawSelectedBackgroundLabel(l, p, n, b)
                        }
                        if (this.scatterType && this.scatterType.match(/line|functio/i) && K < this.varIndices.length - 1 && this.isVisibleSelectedDataPoint(this.varIndices[K + 1], p)) {
                            l = this.varIndices[K + 1];
                            G = this.getDataAtPos(l, F, false, this.xAxisTransform, N, t);
                            E = this.getDataAtPos(l, r, false, this.yAxisTransform, o, J);
                            m = (this.marginLeft + this.offsetX + this.left) + ((G - this.xAxisMin) * this.xAxisUnit);
                            P = (this.marginTop + this.offsetY + this.top + this.y) - ((E - this.yAxisMin) * this.yAxisUnit);
                            if (this.scatterType == "lineStep") {
                                this.drawLine("line", n, b, m, b, this.colors[0]);
                                this.drawLine("line", m, b, m, P, this.colors[0])
                            } else {
                                if (this.lineType == "spline") {
                                    q.push(n);
                                    k.push(b)
                                } else {
                                    this.drawLine("line", n, b, m, P, this.colors[0])
                                }
                            }
                        }
                    }
                }
                if (this.scatterType && this.scatterType.match(/line|functio/i) && this.lineType == "spline") {
                    q.push(m);
                    k.push(P);
                    this.drawLine("spline", q, k, false, false, this.colors[0]);
                    q = [];
                    k = []
                }
            } else {
                if (this.type2D == "XY") {
                    for (var L = 0; L < this.xAxisIndices.length; L++) {
                        var e = L % this.colors.length;
                        var F = this.xAxisIndices[L];
                        var r = this.yAxisIndices[L];
                        var c;
                        var p = F + ":" + r;
                        if (this.xAxisTransform == "percentile") {
                            M = this.getAxisRangeBySample(F);
                            N = M[0];
                            t = M[1]
                        }
                        if (this.yAxisTransform == "percentile") {
                            s = this.getAxisRangeBySample(r);
                            o = s[0];
                            J = s[1]
                        }
                        if (this.graphType == "ScatterBubble2D" && !this.sizeBy) {
                            if (this.zAxisIndices[this.zAxisCurrent]) {
                                c = this.zAxisIndices[this.zAxisCurrent];
                                O = this.getAxisRangeBySample(c);
                                H = O[0];
                                h = O[1]
                            }
                        }
                        for (var K = 0; K < this.varIndices.length; K++) {
                            var l = this.varIndices[K];
                            var G = this.getDataAtPos(l, F, false, this.xAxisTransform, N, t);
                            var E = this.getDataAtPos(l, r, false, this.yAxisTransform, o, J);
                            var D;
                            var I = this.getDataAtPos(l, F, "stdev");
                            var u = this.getDataAtPos(l, r, "stdev");
                            var w = this.shapeBy ? this.dataShapes[K] : this.shapes[0];
                            var d = this.scatterPointSize;
                            var f = this.scatterType && this.scatterType.match(/image/i) ? this.images[K] : false;
                            var C = f ? "image" : w;
                            if (this.sizeBy) {
                                d = this.dataSizes[K]
                            } else {
                                if (this.graphType == "ScatterBubble2D") {
                                    if (this.zAxisIndices[L]) {
                                        D = this.getDataAtPos(l, c, false, "percentile", H, h);
                                        d = this.sizes[Math.floor(D / 10) + 1]
                                    }
                                }
                            }
                            n = (this.marginLeft + this.offsetX + this.left) + ((G - this.xAxisMin) * this.xAxisUnit);
                            b = (this.marginTop + this.offsetY + this.top + this.y) - ((E - this.yAxisMin) * this.yAxisUnit);
                            if (this.isHistogram || (this.scatterType && this.scatterType == "bar")) {
                                if (this.isCreateHistogram) {
                                    this.histogramBarWidth = this.isCreateHistogram * this.xAxisUnit * 0.5
                                }
                                P = (this.marginTop + this.offsetY + this.top + this.y) - b;
                                if (this.isVisibleSelectedDataPoint(l, p)) {
                                    this.drawSelectedBackground(l, p, "rectangle", n - this.histogramBarWidth, b - this.histogramBarWidth, this.histogramBarWidth * 2, P, false, true);
                                    this.addArea(this.rectangle(n - this.histogramBarWidth, b, this.histogramBarWidth * 2, P, this.colors[e], false, "closed", false, false, true), [l, F, r]);
                                    this.drawSelectedBackgroundLabel(l, p, n, b)
                                }
                            } else {
                                if (this.isVisibleSelectedDataPoint(l, p)) {
                                    if (!this.scatterType || !this.scatterType.match(/functio|lineStep/)) {
                                        this.drawSelectedBackground(l, p, w, n, b, d, d, false, true);
                                        if (I && !isNaN(I)) {
                                            m = (I / 2) * this.xAxisUnit;
                                            this.errorBar(n, b, n + m, b, this.margin, this.colorBy ? this.dataColors[K] : this.colors[e]);
                                            this.errorBar(n, b, n - m, b, this.margin, this.colorBy ? this.dataColors[K] : this.colors[e])
                                        }
                                        if (u && !isNaN(u)) {
                                            P = (u / 2) * this.yAxisUnit;
                                            this.errorBar(n, b, n, b + P, -this.margin, this.colorBy ? this.dataColors[K] : this.colors[e]);
                                            this.errorBar(n, b, n, b - P, -this.margin, this.colorBy ? this.dataColors[K] : this.colors[e])
                                        }
                                        if (this.graphType == "ScatterBubble2D") {
                                            if (this.colorBy) {
                                                this.addArea(this.drawShape(C, n, b, d, d, this.dataColors[K], this.colors[e], "closed", false, false, true, false, false, false, f), [l, F, r, c])
                                            } else {
                                                this.addArea(this.drawShape(C, n, b, d, d, this.colors[e], this.foreground, "closed", false, false, true, false, false, false, f), [l, F, r, c])
                                            }
                                        } else {
                                            if (this.colorBy) {
                                                this.addArea(this.drawShape(C, n, b, d, d, this.dataColors[K], this.colors[e], "closed", false, false, true, false, false, false, f), [l, F, r])
                                            } else {
                                                this.addArea(this.drawShape(C, n, b, d, d, this.colors[e], this.foreground, "closed", false, false, true, false, false, false, f), [l, F, r])
                                            }
                                        }
                                        this.drawSelectedBackgroundLabel(l, p, n, b)
                                    }
                                    if (this.scatterType && this.scatterType.match(/line|functio/i) && K < this.varIndices.length - 1 && this.isVisibleSelectedDataPoint(this.varIndices[K + 1], p)) {
                                        l = this.varIndices[K + 1];
                                        g = true
                                    }
                                    if (g) {
                                        G = this.getDataAtPos(l, F, false, this.xAxisTransform, N, t);
                                        E = this.getDataAtPos(l, r, false, this.yAxisTransform, o, J);
                                        m = (this.marginLeft + this.offsetX + this.left) + ((G - this.xAxisMin) * this.xAxisUnit);
                                        P = (this.marginTop + this.offsetY + this.top + this.y) - ((E - this.yAxisMin) * this.yAxisUnit);
                                        if (this.scatterType == "lineStep") {
                                            this.drawLine("line", n, b, m, b, this.colors[0]);
                                            this.drawLine("line", m, b, m, P, this.colors[0])
                                        } else {
                                            if (this.lineType == "spline") {
                                                q.push(n);
                                                k.push(b)
                                            } else {
                                                this.drawLine("line", n, b, m, P, this.colors[e])
                                            }
                                        }
                                        g = false
                                    }
                                }
                            }
                        }
                        if (this.scatterType && this.scatterType.match(/line|functio/i) && this.lineType == "spline") {
                            q.push(m);
                            k.push(P);
                            this.drawLine("spline", q, k, false, false, this.colors[e]);
                            q = [];
                            k = []
                        }
                    }
                } else {
                    if (this.type2D == "X") {
                        var v = this.yAxisIndices[this.yAxisCurrent];
                        if (this.yAxisTransform == "percentile") {
                            s = this.getAxisRangeBySample(v);
                            o = s[0];
                            J = s[1]
                        }
                        var A;
                        if (this.graphType == "ScatterBubble2D" && !this.sizeBy) {
                            if (this.zAxisIndices[this.zAxisCurrent]) {
                                A = this.zAxisIndices[this.zAxisCurrent];
                                O = this.getAxisRangeBySample(A);
                                H = O[0];
                                h = O[1]
                            }
                        }
                        for (var L = 0; L < this.xAxisIndices.length; L++) {
                            var e = L % this.colors.length;
                            var B = this.xAxisIndices[L];
                            var p = B + ":" + v;
                            if (this.xAxisTransform == "percentile") {
                                M = this.getAxisRangeBySample(B);
                                N = M[0];
                                t = M[1]
                            }
                            for (var K = 0; K < this.varIndices.length; K++) {
                                var l = this.varIndices[K];
                                var G = this.getDataAtPos(l, B, false, this.xAxisTransform, N, t);
                                var E = this.getDataAtPos(l, v, false, this.yAxisTransform, o, J);
                                var I = this.getDataAtPos(l, B, "stdev");
                                var u = this.getDataAtPos(l, v, "stdev");
                                var D;
                                var d = this.scatterPointSize;
                                var w = this.shapeBy ? this.dataShapes[K] : this.shapes[0];
                                var f = this.scatterType && this.scatterType.match(/image/i) ? this.images[K] : false;
                                var C = f ? "image" : w;
                                if (this.sizeBy) {
                                    d = this.dataSizes[K]
                                } else {
                                    if (this.graphType == "ScatterBubble2D") {
                                        if (this.zAxisIndices[this.zAxisCurrent]) {
                                            D = this.getDataAtPos(l, A, false, "percentile", H, h);
                                            d = this.sizes[Math.floor(D / 10) + 1]
                                        }
                                    }
                                }
                                n = (this.marginLeft + this.offsetX + this.left) + ((G - this.xAxisMin) * this.xAxisUnit);
                                b = (this.marginTop + this.offsetY + this.top + this.y) - ((E - this.yAxisMin) * this.yAxisUnit);
                                if (this.isHistogram || (this.scatterType && this.scatterType == "bar")) {
                                    if (this.isCreateHistogram) {
                                        this.histogramBarWidth = this.isCreateHistogram * this.xAxisUnit * 0.5
                                    }
                                    P = (this.marginTop + this.offsetY + this.top + this.y) - b;
                                    if (this.isVisibleSelectedDataPoint(l, p)) {
                                        this.drawSelectedBackground(l, p, "rectangle", n - this.histogramBarWidth, b - this.histogramBarWidth, this.histogramBarWidth * 2, P, false, true);
                                        this.addArea(this.rectangle(n - this.histogramBarWidth, b, this.histogramBarWidth * 2, P, this.colors[e], false, "closed", false, false, true), [l, B, v]);
                                        this.drawSelectedBackgroundLabel(l, p, n, b)
                                    }
                                } else {
                                    if (this.isVisibleSelectedDataPoint(l, p)) {
                                        if (!this.scatterType || !this.scatterType.match(/functio|lineStep/)) {
                                            this.drawSelectedBackground(l, p, w, n, b, d, d, false, true);
                                            if (I && !isNaN(I)) {
                                                m = (I / 2) * this.xAxisUnit;
                                                this.errorBar(n, b, n + m, b, this.margin, this.colorBy ? this.dataColors[K] : this.colors[e]);
                                                this.errorBar(n, b, n - m, b, this.margin, this.colorBy ? this.dataColors[K] : this.colors[e])
                                            }
                                            if (u && !isNaN(u)) {
                                                P = (u / 2) * this.yAxisUnit;
                                                this.errorBar(n, b, n, b + P, -this.margin, this.colorBy ? this.dataColors[K] : this.colors[e]);
                                                this.errorBar(n, b, n, b - P, -this.margin, this.colorBy ? this.dataColors[K] : this.colors[e])
                                            }
                                            if (this.graphType == "ScatterBubble2D") {
                                                if (this.colorBy) {
                                                    this.addArea(this.drawShape(C, n, b, d, d, this.dataColors[K], this.colors[e], "closed", false, false, true, false, false, false, f), [l, B, v, A])
                                                } else {
                                                    this.addArea(this.drawShape(C, n, b, d, d, this.colors[e], this.foreground, "closed", false, false, true, false, false, false, f), [l, B, v, A])
                                                }
                                            } else {
                                                if (this.colorBy) {
                                                    this.addArea(this.drawShape(C, n, b, d, d, this.dataColors[K], this.colors[e], "closed", false, false, true, false, false, false, f), [l, B, v])
                                                } else {
                                                    this.addArea(this.drawShape(C, n, b, d, d, this.colors[e], this.foreground, "closed", false, false, true, false, false, false, f), [l, B, v])
                                                }
                                            }
                                            this.drawSelectedBackgroundLabel(l, p, n, b)
                                        }
                                        if (this.scatterType && this.scatterType.match(/line|functio/i) && K < this.varIndices.length - 1 && this.isVisibleSelectedDataPoint(this.varIndices[K + 1], p)) {
                                            l = this.varIndices[K + 1];
                                            g = true
                                        }
                                        if (g) {
                                            G = this.getDataAtPos(l, B, false, this.xAxisTransform, N, t);
                                            E = this.getDataAtPos(l, v, false, this.yAxisTransform, o, J);
                                            m = (this.marginLeft + this.offsetX + this.left) + ((G - this.xAxisMin) * this.xAxisUnit);
                                            P = (this.marginTop + this.offsetY + this.top + this.y) - ((E - this.yAxisMin) * this.yAxisUnit);
                                            if (this.scatterType == "lineStep") {
                                                this.drawLine("line", n, b, m, b, this.colors[0]);
                                                this.drawLine("line", m, b, m, P, this.colors[0])
                                            } else {
                                                if (this.lineType == "spline") {
                                                    q.push(n);
                                                    k.push(b)
                                                } else {
                                                    this.drawLine("line", n, b, m, P, this.colors[e])
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (this.scatterType && this.scatterType.match(/line|functio/i) && this.lineType == "spline") {
                                q.push(m);
                                k.push(P);
                                this.drawLine("spline", q, k, false, false, this.colors[e]);
                                q = [];
                                k = []
                            }
                        }
                    } else {
                        var v = this.xAxisIndices[this.xAxisCurrent];
                        if (this.xAxisTransform == "percentile") {
                            M = this.getAxisRangeBySample(v);
                            N = M[0];
                            t = M[1]
                        }
                        var A;
                        if (this.graphType == "ScatterBubble2D" && !this.sizeBy) {
                            if (this.zAxisIndices[this.zAxisCurrent]) {
                                A = this.zAxisIndices[this.zAxisCurrent];
                                O = this.getAxisRangeBySample(A);
                                H = O[0];
                                h = O[1]
                            }
                        }
                        for (var L = 0; L < this.yAxisIndices.length; L++) {
                            var e = this.colors[L % this.colors.length];
                            var B = this.yAxisIndices[L];
                            var p = v + ":" + B;
                            if (this.yAxisTransform == "percentile") {
                                s = this.getAxisRangeBySample(B);
                                o = s[0];
                                J = s[1]
                            }
                            for (var K = 0; K < this.varIndices.length; K++) {
                                var l = this.varIndices[K];
                                var G = this.getDataAtPos(l, v, false, this.xAxisTransform, N, t);
                                var E = this.getDataAtPos(l, B, false, this.yAxisTransform, o, J);
                                var D;
                                var I = this.getDataAtPos(l, v, "stdev");
                                var u = this.getDataAtPos(l, B, "stdev");
                                var w = this.shapeBy ? this.dataShapes[K] : this.shapes[0];
                                var d = this.scatterPointSize;
                                var f = this.scatterType && this.scatterType.match(/image/i) ? this.images[K] : false;
                                var C = f ? "image" : w;
                                if (this.colorBy) {
                                    e = this.dataColors[K]
                                }
                                if (this.sizeBy) {
                                    d = this.dataSizes[K]
                                } else {
                                    if (this.graphType == "ScatterBubble2D") {
                                        if (this.zAxisIndices[this.yAxisCurrent]) {
                                            D = this.getDataAtPos(l, A, false, "percentile", H, h);
                                            d = this.sizes[Math.floor(D / 10) + 1]
                                        }
                                    }
                                }
                                n = (this.marginLeft + this.offsetX + this.left) + ((G - this.xAxisMin) * this.xAxisUnit);
                                b = (this.marginTop + this.offsetY + this.top + this.y) - ((E - this.yAxisMin) * this.yAxisUnit);
                                if (this.isHistogram || (this.scatterType && this.scatterType == "bar")) {
                                    if (this.isCreateHistogram) {
                                        this.histogramBarWidth = this.isCreateHistogram * this.xAxisUnit * 0.5
                                    }
                                    P = (this.marginTop + this.offsetY + this.top + this.y) - b;
                                    if (this.isVisibleSelectedDataPoint(l, p)) {
                                        this.drawSelectedBackground(l, p, "rectangle", n - this.histogramBarWidth, b - this.histogramBarWidth, this.histogramBarWidth * 2, P, false, true);
                                        this.addArea(this.rectangle(n - this.histogramBarWidth, b, this.histogramBarWidth * 2, P, e, false, "closed", false, false, true), [l, v, B]);
                                        this.drawSelectedBackgroundLabel(l, p, n, b)
                                    }
                                } else {
                                    if (this.isVisibleSelectedDataPoint(l, p)) {
                                        if (!this.scatterType || !this.scatterType.match(/functio|lineStep/)) {
                                            this.drawSelectedBackground(l, p, w, n, b, d, d, false, true);
                                            if (I && !isNaN(I)) {
                                                m = (I / 2) * this.xAxisUnit;
                                                this.errorBar(n, b, n + m, b, this.margin, e);
                                                this.errorBar(n, b, n - m, b, this.margin, e)
                                            }
                                            if (u && !isNaN(u)) {
                                                P = (u / 2) * this.yAxisUnit;
                                                this.errorBar(n, b, n, b + P, -this.margin, e);
                                                this.errorBar(n, b, n, b - P, -this.margin, e)
                                            }
                                            if (this.graphType == "ScatterBubble2D") {
                                                this.addArea(this.drawShape(C, n, b, d, d, e, this.foreground, "closed", false, false, true, false, false, false, f), [l, v, B, A])
                                            } else {
                                                this.addArea(this.drawShape(C, n, b, d, d, e, this.foreground, "closed", false, false, true, false, false, false, f), [l, v, B])
                                            }
                                            this.drawSelectedBackgroundLabel(l, p, n, b)
                                        }
                                        if (this.scatterType && this.scatterType.match(/line|functio/i) && K < this.varIndices.length - 1 && this.isVisibleSelectedDataPoint(this.varIndices[K + 1], p)) {
                                            l = this.varIndices[K + 1];
                                            g = true
                                        }
                                        if (g) {
                                            G = this.getDataAtPos(l, v, false, this.xAxisTransform, N, t);
                                            E = this.getDataAtPos(l, B, false, this.yAxisTransform, o, J);
                                            m = (this.marginLeft + this.offsetX + this.left) + ((G - this.xAxisMin) * this.xAxisUnit);
                                            P = (this.marginTop + this.offsetY + this.top + this.y) - ((E - this.yAxisMin) * this.yAxisUnit);
                                            if (this.scatterType == "lineStep") {
                                                this.drawLine("line", n, b, m, b, this.colors[0]);
                                                this.drawLine("line", m, b, m, P, this.colors[0])
                                            } else {
                                                if (this.lineType == "spline") {
                                                    q.push(n);
                                                    k.push(b)
                                                } else {
                                                    this.drawLine("line", n, b, m, P, this.colors[L % this.colors.length])
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (this.scatterType && this.scatterType.match(/line|functio/i) && this.lineType == "spline") {
                                q.push(m);
                                k.push(P);
                                this.drawLine("spline", q, k, false, false, this.colors[L % this.colors.length]);
                                q = [];
                                k = []
                            }
                        }
                    }
                }
            }
        }
    };
    this.draw2DLegend = function() {
        if (this.showLegend) {
            this.drawScatterLegend()
        }
        if (this.showDecorations) {
            this.drawDecorationLegend()
        }
    };
    this.set2DprivateParams = function() {
        this.set2DType();
        this.set2DText()
    };
    this.isValidKaplanMeyer = function() {
        if (this.data.d && this.data.d.kaplanMeyer) {
            return true
        } else {
            return false
        }
    };
    this.draw2DPlot = function() {
        if (this.xAxis && this.yAxis) {
            this.setDataColorShapeSize()
        }
        this.set2DprivateParams();
        this.set2DXYDimensions();
        if (this.xAxis && this.yAxis) {
            this.drawPlotWindow();
            this.set2DWireFrame();
            this.drawDecorationData();
            this.maskPlotArea();
            this.set2DLayout();
            this.draw2DDataPoints();
            this.drawTitle();
            this.draw2DLegend()
        }
    };
    this.initializeScatter2D = function() {
        if (this.layoutValid && this.scatterPlotMatrix) {
            this.drawLayoutCompartments(this.draw2DPlot)
        } else {
            if (!this.scatterPlotMatrix) {
                this.unsetScatterPlotMatrix()
            }
            this.draw2DPlot()
        }
    };
    if (!a) {
        this.initializeScatter2D()
    }
};
CanvasXpress.prototype.Scatter3D = function(a) {
    this.set3DText = function() {
        this.setAxisFont(false, this.x)
    };
    this.equalizeMargins = function() {
        var b = Math.max(this.marginLeft, Math.max(this.marginRight, Math.max(this.marginTop, this.marginBottom)));
        this.marginLeft = b;
        this.marginRight = b;
        this.marginTop = b;
        this.marginBottom = b
    };
    this.set3DXYDimensions = function() {
        this.equalizeMargins();
        if (this.tmpHeight) {
            this.height = this.tmpHeight
        }
        if (this.tmpWidth) {
            this.width = this.tmpWidth
        }
        var b = Math.min(this.height, this.width) - 40;
        this.tmpHeight = this.height;
        this.tmpWidth = this.width;
        this.height = b;
        this.width = b;
        this.x = this.width - (this.marginTop + this.top);
        this.y = this.height - (this.marginTop + this.top);
        this.left = this.top;
        if (this.showLegend || this.showIndicators) {
            this.setLegendDimensions();
            var b = Math.max(this.legendWidth, this.legendHeight) / 2;
            this.x -= b;
            this.y -= b;
            this.width = this.x + this.legendWidth + this.marginLeft + this.marginRight;
            this.height = this.y + this.legendHeight + this.marginTop + this.marginBottom
        }
        this.resizeCanvas();
        this.resizeViewport();
        this.setScatterPointSize()
    };
    this.draw3DLayout = function(j, b, o, k, c, p, g, d) {
        var f, r, e, q, n;
        var h = this.marginLeft + this.offsetX + this.left;
        var s = this.marginTop + this.offsetY + this.top;
        this.disableGradientTransparencyShadow();
        for (var m = 0; m < j.length; m++) {
            n = this.get3DTransfrom(j[m], b[m], o[m]);
            f = n[0] + h;
            r = n[1] + s;
            n = this.get3DTransfrom(k[m], c[m], p[m]);
            e = n[0] + h;
            q = n[1] + s;
            if (d == "dotted") {
                this.drawLine("dottedLine", f, r, e, q, g[m], false, "butt")
            } else {
                this.drawLine("line", f, r, e, q, g[m], false, "butt")
            }
        }
        this.enableGradientTransparencyShadow()
    };
    this.draw3DBar = function(q, o, n, v, Q, S) {
        var I = this.marginLeft + this.offsetX + this.left;
        var E = this.marginTop + this.offsetY + this.top;
        var k = I + (this.x / 2);
        var g = E + (this.y / 2);
        var M = v / 2;
        var N = [
            [
                [q - v, o, n - v],
                [q + v, o, n - v],
                [q + v, M, n - v],
                [q - v, M, n - v]
            ],
            [
                [q + v, o, n - v],
                [q + v, o, n + v],
                [q + v, M, n + v],
                [q + v, M, n - v]
            ],
            [
                [q - v, o, n + v],
                [q + v, o, n + v],
                [q + v, M, n + v],
                [q - v, M, n + v]
            ],
            [
                [q - v, o, n - v],
                [q - v, o, n + v],
                [q - v, M, n + v],
                [q - v, M, n - v]
            ],
            [
                [q - v, o, n - v],
                [q + v, o, n - v],
                [q + v, o, n + v],
                [q - v, o, n + v]
            ]
        ];
        var P = [];
        var R = [];
        var O = [];
        var H = [];
        for (var L = 0; L < N.length; L++) {
            P[L] = [];
            for (var K = 0; K < N[L].length; K++) {
                var G = this.xAxisMin < 0 ? 0 : this.xAxisMin;
                var D = this.yAxisMin < 0 ? 0 : this.yAxisMin;
                var C = this.zAxisMin < 0 ? 0 : this.zAxisMin;
                var A = ((N[L][K][0] - G) * this.xAxisUnit) - this.xAxisOffset;
                var u = this.yAxisOffset - ((N[L][K][1] - D) * this.yAxisUnit);
                var p = ((N[L][K][2] - C) * this.zAxisUnit) - this.zAxisOffset;
                P[L].push(this.get3DTransfrom(A, u, p))
            }
            H.push(L);
            O.push(this.euclidianDistance([(P[L][0][0] + P[L][2][0]) / 2, (P[L][0][1] + P[L][2][1]) / 2, (P[L][0][2] + P[L][2][2]) / 2], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]))
        }
        H.sort(function(d, c) {
            return O[c] - O[d]
        });
        for (var B = 1; B < P.length; B++) {
            var L = H[B];
            var F = B < 3 ? this.darkenLightenColor(Q, -B * 30) : Q;
            var m = [];
            var J = [];
            for (var K = 0; K < P[L].length; K++) {
                m.push(P[L][K][0] + I);
                J.push(P[L][K][1] + E)
            }
            this.addArea(this.drawShape("polygon", m, J, false, false, F, this.foreground, "closed"), S)
        }
    };
    this.set3DXLayout = function() {
        var z = [],
            d = [],
            n = [],
            w = [],
            c = [],
            k = [],
            e = [];
        var v, m, p, b, A, r, j, h;
        var f = this.lenX / 15;
        var q = (15 * -f) + f;
        var g = this.xAxisTitle ? this.xAxisTitle : this.is3DPlot ? "Samples" : this.data.y.smps[this.xAxisIndex];
        var u = this.marginLeft + this.offsetX + this.left;
        var o = this.marginTop + this.offsetY + this.top;
        if (this.show3DGrid) {
            p = q;
            v = 0;
            m = 0;
            while (p < this.lenX) {
                if ((v + 1) % 3) {
                    if (!this.is3DPlot) {
                        z[m] = p;
                        d[m] = -this.lenY;
                        n[m] = this.lenZ;
                        w[m] = p;
                        c[m] = this.lenY;
                        k[m] = this.lenZ;
                        e.push(this.xAxisTickColor);
                        m++
                    }
                    z[m] = -this.lenX;
                    d[m] = p * this.lenY / this.lenX;
                    n[m] = this.lenZ;
                    w[m] = this.lenX;
                    c[m] = p * this.lenY / this.lenX;
                    k[m] = this.lenZ;
                    e.push(this.xAxisTickColor);
                    m++
                }
                p += f;
                v++
            }
            this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle);
            z = [], d = [], n = [], w = [], c = [], k = [], e = [];
            p = q;
            v = 0;
            m = 0;
            A = this.xAxisIncr;
            while (p < this.lenX) {
                if (!((v + 1) % 3)) {
                    if (!this.is3DPlot) {
                        z[m] = p;
                        d[m] = -this.lenY;
                        n[m] = this.lenZ;
                        w[m] = p;
                        c[m] = this.lenY;
                        k[m] = this.lenZ;
                        e.push(this.foreground);
                        m++
                    }
                    z[m] = -this.lenX;
                    d[m] = p * this.lenY / this.lenX;
                    n[m] = this.lenZ;
                    w[m] = this.lenX;
                    c[m] = p * this.lenY / this.lenX;
                    k[m] = this.lenZ;
                    e.push(this.foreground);
                    b = this.get3DTransfrom(p, this.lenY, -this.lenZ);
                    j = b[0] + u;
                    h = b[1] + o;
                    r = this.formatAxisValue(this.xAxisMin + A, "xAxis");
                    A += this.xAxisIncr;
                    if (this.xAxisShow && !this.is3DPlot) {
                        this.drawText(r, j, h + 5, this.axisTickFont, this.axisTickColor, "right", false, -Math.PI / 2)
                    }
                    m++
                }
                p += f;
                v++
            }
            this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle)
        }
        if (this.xAxisShow && !this.is3DPlot) {
            this.draw3DAxisTitle(q - (f * 2), this.lenX + f, this.lenY + (f * 4), this.lenY + (f * 4), -this.lenZ - (f * 4), -this.lenZ - (f * 4), g, "x")
        }
        z = [-this.lenX, -this.lenX, this.lenX, -this.lenX];
        d = [-this.lenY, -this.lenY, -this.lenY, this.lenY];
        n = [this.lenZ, this.lenZ, this.lenZ, this.lenZ];
        w = [-this.lenX, this.lenX, this.lenX, this.lenX];
        c = [this.lenY, -this.lenY, this.lenY, this.lenY];
        k = [this.lenZ, this.lenZ, this.lenZ, this.lenZ];
        e = [this.foreground, this.foreground, this.foreground, this.foreground];
        this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle)
    };
    this.set3DYLayout = function() {
        var B = [],
            d = [],
            n = [],
            A = [],
            c = [],
            k = [],
            e = [];
        var w, m, q, b, C, u, j, h;
        var f = this.lenY / 15;
        var z = this.yAxisLen / 30;
        var r = (15 * -f) + f;
        var g = this.yAxisTitle ? this.yAxisTitle : this.is3DPlot ? "Value" : this.data.y.smps[this.yAxisIndex];
        var v = this.marginLeft + this.offsetX + this.left;
        var o = this.marginTop + this.offsetY + this.top;
        var p = [];
        if (this.show3DGrid) {
            q = r;
            w = 0;
            m = 0;
            while (q < this.lenY) {
                if ((w + 1) % 3) {
                    if (!this.is3DPlot) {
                        B[m] = -this.lenX;
                        d[m] = -this.lenY;
                        n[m] = q * this.lenZ / this.lenY;
                        A[m] = -this.lenX;
                        c[m] = this.lenY;
                        k[m] = q * this.lenZ / this.lenY;
                        e.push(this.yAxisTickColor);
                        m++
                    }
                    B[m] = -this.lenX;
                    d[m] = q;
                    n[m] = -this.lenZ;
                    A[m] = -this.lenX;
                    c[m] = q;
                    k[m] = this.lenZ;
                    e.push(this.yAxisTickColor);
                    m++
                }
                q += f;
                w++
            }
            this.draw3DLayout(B, d, n, A, c, k, e, this.yAxisTickStyle);
            B = [], d = [], n = [], A = [], c = [], k = [], e = [];
            q = r;
            w = 0;
            m = 0;
            C = this.is3DPlot ? this.yAxisIncr * this.xAxisTicks * 9 / 10 : this.yAxisIncr * 9;
            while (q < this.lenY) {
                if (!((w + 1) % 3)) {
                    if (!this.is3DPlot) {
                        B[m] = -this.lenX;
                        d[m] = -this.lenY;
                        n[m] = q * this.lenZ / this.lenY;
                        A[m] = -this.lenX;
                        c[m] = this.lenY;
                        k[m] = q * this.lenZ / this.lenY;
                        e.push(this.foreground);
                        m++
                    }
                    B[m] = -this.lenX;
                    d[m] = q;
                    n[m] = -this.lenZ;
                    A[m] = -this.lenX;
                    c[m] = q;
                    k[m] = this.lenZ;
                    e.push(this.foreground);
                    b = this.get3DTransfrom(-this.lenX, q, -this.lenZ);
                    j = b[0] + v;
                    h = b[1] + o;
                    u = this.formatAxisValue(this.yAxisMin + C, "yAxis");
                    C -= this.is3DPlot ? this.yAxisIncr * this.xAxisTicks / 10 : this.yAxisIncr;
                    if (this.yAxisShow) {
                        if (this.yRotate >= 45 && this.xRotate >= 45) {
                            this.drawText(u, j, h + 5, this.axisTickFont, this.axisTickColor, "right", false, -Math.PI / 2)
                        } else {
                            this.drawText(u, j - 5, h, this.axisTickFont, this.axisTickColor, "right")
                        }
                    }
                    m++
                }
                q += f;
                w++
            }
            this.draw3DLayout(B, d, n, A, c, k, e, this.yAxisTickStyle)
        }
        if (this.yAxisShow) {
            this.draw3DAxisTitle(-this.lenX - (f * 4), -this.lenX - (f * 4), r - (f * 2), this.lenY + f, -this.lenZ - (f * 4), -this.lenZ - (f * 4), g, "y")
        }
        B = [-this.lenX, -this.lenX, -this.lenX, -this.lenX];
        d = [-this.lenY, -this.lenY, -this.lenY, this.lenY];
        n = [-this.lenZ, this.lenZ, this.lenZ, this.lenZ];
        A = [-this.lenX, -this.lenX, -this.lenX, -this.lenX];
        c = [this.lenY, -this.lenY, this.lenY, this.lenY];
        k = [-this.lenZ, -this.lenZ, this.lenZ, -this.lenZ];
        e = [this.foreground, this.foreground, this.foreground, this.foreground];
        this.draw3DLayout(B, d, n, A, c, k, e, this.yAxisTickStyle)
    };
    this.set3DZLayout = function() {
        var F = [],
            d = [],
            q = [],
            E = [],
            c = [],
            n = [],
            f = [];
        var C, o, v, p, b, H, A, m, k;
        var g = this.is3DPlot ? this.lenZ / (this.varIndices.length * 0.5) : this.lenZ / 15;
        var e = this.is3DPlot ? this.lenZ / (this.smpIndices.length * 0.5) : false;
        var z = this.is3DPlot ? ((this.varIndices.length * 0.5) * -g) + g : (15 * -g) + g;
        var w = this.is3DPlot ? ((this.smpIndices.length * 0.5) * -e) + e : false;
        var j = this.zAxisTitle ? this.zAxisTitle : this.is3DPlot ? "Variables" : this.data.y.smps[this.zAxisIndex];
        var B = this.marginLeft + this.offsetX + this.left;
        var r = this.marginTop + this.offsetY + this.top;
        if (this.show3DGrid && !this.is3DPlot) {
            v = z;
            C = 0;
            o = 0;
            while (v < this.lenZ) {
                if ((C + 1) % 3) {
                    F[o] = -this.lenX;
                    d[o] = this.lenY;
                    q[o] = v;
                    E[o] = this.lenX;
                    c[o] = this.lenY;
                    n[o] = v;
                    f.push(this.zAxisTickColor);
                    o++;
                    F[o] = v * this.lenX / this.lenZ;
                    d[o] = this.lenY;
                    q[o] = -this.lenZ;
                    E[o] = v * this.lenX / this.lenZ;
                    c[o] = this.lenY;
                    n[o] = this.lenZ;
                    f.push(this.zAxisTickColor);
                    o++
                }
                v += g;
                C++
            }
            this.draw3DLayout(F, d, q, E, c, n, f, this.zAxisTickStyle);
            F = [], d = [], q = [], E = [], c = [], n = [], f = [];
            v = z;
            C = 0;
            o = 0;
            H = this.zAxisIncr;
            while (v < this.lenZ) {
                if (!((C + 1) % 3)) {
                    F[o] = -this.lenX;
                    d[o] = this.lenY;
                    q[o] = v;
                    E[o] = this.lenX;
                    c[o] = this.lenY;
                    n[o] = v;
                    f.push(this.foreground);
                    o++;
                    F[o] = v * this.lenX / this.lenZ;
                    d[o] = this.lenY;
                    q[o] = -this.lenZ;
                    E[o] = v * this.lenX / this.lenZ;
                    c[o] = this.lenY;
                    n[o] = this.lenZ;
                    f.push(this.foreground);
                    b = this.get3DTransfrom(this.lenX, this.lenY, v);
                    m = b[0] + B;
                    k = b[1] + r;
                    A = this.formatAxisValue(this.zAxisMin + H, "zAxis");
                    H += this.zAxisIncr;
                    if (this.zAxisShow) {
                        if (this.xRotate >= 45) {
                            if (this.yRotate >= 45) {
                                this.drawText(A, m + 5, k, this.axisTickFont, this.axisTickColor, "left")
                            } else {
                                this.drawText(A, m, k + 5, this.axisTickFont, this.axisTickColor, "right", false, -Math.PI / 2)
                            }
                        } else {
                            this.drawText(A, m + 5, k, this.axisTickFont, this.axisTickColor, "left")
                        }
                    }
                    o++
                }
                v += g;
                C++
            }
            this.draw3DLayout(F, d, q, E, c, n, f, this.zAxisTickStyle)
        } else {
            if (this.is3DPlot) {
                var h = this;
                var D = function() {
                    var l = C / h.varLabelInterval;
                    if (parseInt(l) == parseFloat(l)) {
                        b = h.get3DTransfrom(h.lenX, h.lenY, v - (g / 2));
                        m = b[0] + B;
                        k = b[1] + r;
                        A = h.data.y.vars[h.varIndices[C]];
                        if (h.xRotate >= 45) {
                            if (h.yRotate >= 45) {
                                h.drawText(A, m + 5, k, h.axisTickFont, h.axisTickColor, "left")
                            } else {
                                h.drawText(A, m, k + 5, h.axisTickFont, h.axisTickColor, "right", false, -Math.PI / 2)
                            }
                        } else {
                            h.drawText(A, m + 5, k, h.axisTickFont, h.axisTickColor, "left")
                        }
                    }
                };
                var G = function() {
                    var l = C / h.smpLabelInterval;
                    if (parseInt(l) == parseFloat(l)) {
                        b = h.get3DTransfrom((p * h.lenX / h.lenZ) - (e / 4), h.lenY, -h.lenZ);
                        m = b[0] + B;
                        k = b[1] + r;
                        A = h.data.y.smps[h.smpIndices[C]];
                        h.drawText(A, m, k + 5, h.axisTickFont, h.axisTickColor, "right", false, -Math.PI / 2)
                    }
                };
                v = z;
                C = 0;
                o = 0;
                while (v < this.lenZ) {
                    F[o] = -this.lenX;
                    d[o] = this.lenY;
                    q[o] = v;
                    E[o] = this.lenX;
                    c[o] = this.lenY;
                    n[o] = v;
                    f.push(this.zAxisTickColor);
                    D();
                    o++;
                    C++;
                    v += g
                }
                D();
                C = 0;
                p = w;
                while (p < this.lenZ) {
                    F[o] = p * this.lenX / this.lenZ;
                    d[o] = this.lenY;
                    q[o] = -this.lenZ;
                    E[o] = p * this.lenX / this.lenZ;
                    c[o] = this.lenY;
                    n[o] = this.lenZ;
                    f.push(this.zAxisTickColor);
                    G();
                    o++;
                    C++;
                    p += e
                }
                this.draw3DLayout(F, d, q, E, c, n, f, this.zAxisTickStyle);
                G()
            }
        } if (this.zAxisShow && !this.is3DPlot) {
            this.draw3DAxisTitle(this.lenX + (g * 6), this.lenX + (g * 6), this.lenY + (g * 6), this.lenY + (g * 6), z - (g * 2), this.lenZ + g, j, "z")
        }
        F = [-this.lenX, -this.lenX, this.lenX, -this.lenX];
        d = [this.lenY, this.lenY, this.lenY, this.lenY];
        q = [-this.lenZ, this.lenZ, -this.lenZ, -this.lenZ];
        E = [-this.lenX, this.lenX, this.lenX, this.lenX];
        c = [this.lenY, this.lenY, this.lenY, this.lenY];
        n = [this.lenZ, this.lenZ, this.lenZ, -this.lenZ];
        f = [this.foreground, this.foreground, this.foreground, this.foreground];
        this.draw3DLayout(F, d, q, E, c, n, f, this.zAxisTickStyle)
    };
    this.draw3DAxisTitle = function(v, u, e, d, k, j, n, c) {
        var p = this.measureText(n);
        var r = p / 2;
        var w = n.split("");
        var h = (v + u) / 2;
        var g = (e + d) / 2;
        var f = (k + j) / 2;
        var q = this.marginLeft + this.offsetX;
        var m = this.marginTop + this.offsetY;
        var o = this.xRotate >= 45 || this.yRotate >= 45 ? 4 : 0;
        if (this.xRotate >= 45 || this.yRotate >= 45) {
            p += w.length * 4;
            r = p / 2
        }
        if (c == "x") {
            h -= r;
            for (var s = 0; s < w.length; s++) {
                var b = this.get3DTransfrom(h, g, f);
                this.drawText(w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "top");
                h += this.measureText(w[s]) + o
            }
        } else {
            if (c == "y") {
                g += r;
                for (var s = 0; s < w.length; s++) {
                    var b = this.get3DTransfrom(h, g, f);
                    this.drawText(w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "bottom", -Math.PI / 2);
                    g -= this.measureText(w[s]) + o
                }
            } else {
                if (c == "z") {
                    f -= r;
                    for (var s = 0; s < w.length; s++) {
                        var b = this.get3DTransfrom(h, g, f);
                        this.drawText(w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "bottom");
                        f += this.measureText(w[s]) + o
                    }
                }
            }
        }
    };
    this.set3DLayout = function() {
        this.set3DXLayout();
        this.set3DYLayout();
        this.set3DZLayout()
    };
    this.set3DAxes = function() {
        var e = ["x", "y", "z"];
        this.setMin = null;
        this.setMax = null;
        if (this.is3DPlot) {
            if (this.xAxisTitle) {
                var c = this.yAxisTitle;
                this.yAxisTitle = this.xAxisTitle;
                this.xAxisTitle = c
            }
            this.yAxisMin = this.xAxisMin;
            this.yAxisMax = this.xAxisMax;
            this.yAxisIncr = this.xAxisIncr;
            this.yAxisDecs = this.xAxisDecs;
            this.yAxisRange = this.xAxisRange;
            this.yAxisUnit = this.lenY * 2 / this.yAxisRange;
            this.yAxisOffset = Math.min(this.lenY, (this.yAxisMin + (this.yAxisRange / 2)) * this.yAxisUnit);
            this.xAxisMin = 0;
            this.xAxisMax = 9;
            this.xAxisIncr = this.isGroupedData ? 10 / (this.grpIndices.length + 1) : 10 / (this.smpIndices.length + 1);
            this.xAxisDecs = 0;
            this.xAxisRange = this.xAxisMax - this.xAxisMin;
            this.xAxisUnit = this.lenX * 2 / this.xAxisRange;
            this.xAxisOffset = Math.min(this.lenX, (this.xAxisMin + (this.xAxisRange / 2)) * this.xAxisUnit);
            this.zAxisMin = 0;
            this.zAxisMax = 9;
            this.zAxisIncr = 10 / (this.varIndices.length + 1);
            this.zAxisDecs = 0;
            this.zAxisRange = this.zAxisMax - this.zAxisMin;
            this.zAxisUnit = this.lenZ * 2 / this.zAxisRange;
            this.zAxisOffset = Math.min(this.lenZ, (this.zAxisMin + (this.zAxisRange / 2)) * this.zAxisUnit)
        } else {
            for (var b = 0; b < e.length; b++) {
                var f = this.smpIndices;
                var d = e[b].toUpperCase();
                this[e[b] + "AxisIndex"] = this.getSampleIndices([this[e[b] + "Axis"]])[0];
                this.setSamplesVisible([this[e[b] + "AxisIndex"]]);
                this.setRangeData();
                this[e[b] + "AxisMin"] = this["setMin" + d] != null ? this["setMin" + d] : this.minData;
                this[e[b] + "AxisMax"] = this["setMax" + d] != null ? this["setMax" + d] : this.maxData;
                this[e[b] + "AxisIncr"] = this.getAxisIncrements(this[e[b] + "AxisMin"], this[e[b] + "AxisMax"], 10, this[e[b] + "AxisExact"]);
                this[e[b] + "AxisDecs"] = this.getAxisDecimals(this[e[b] + "AxisIncr"]);
                if (!this[e[b] + "AxisExact"]) {
                    this[e[b] + "AxisMin"] = this.getAxisMin(this[e[b] + "AxisMin"], this[e[b] + "AxisIncr"]);
                    this[e[b] + "AxisMax"] = this[e[b] + "AxisMin"] + (this[e[b] + "AxisIncr"] * 10)
                }
                this[e[b] + "AxisRange"] = this[e[b] + "AxisMax"] - this[e[b] + "AxisMin"];
                this[e[b] + "AxisUnit"] = this["len" + d] * 2 / this[e[b] + "AxisRange"];
                this[e[b] + "AxisOffset"] = Math.min(this["len" + d], (this[e[b] + "AxisMin"] + (this[e[b] + "AxisRange"] / 2)) * this[e[b] + "AxisUnit"]);
                this.setSamplesVisible(f)
            }
        }
        this.set3DCenter()
    };
    this.set3DCenter = function() {
        var f = this.xAxisMin < 0 ? 0 : this.xAxisMin;
        var d = this.yAxisMin < 0 ? 0 : this.yAxisMin;
        var c = this.zAxisMin < 0 ? 0 : this.zAxisMin;
        var b = ((((this.xAxisMin + this.xAxisMax) / 2) - f) * this.xAxisUnit) - this.xAxisOffset;
        var g = this.yAxisOffset - ((((this.yAxisMin + this.yAxisMax) / 2) - d) * this.yAxisUnit);
        var e = ((((this.zAxisMin + this.zAxisMax) / 2) - c) * this.zAxisUnit) - this.zAxisOffset;
        this.zero3DPoint = this.get3DTransfrom(b, g, e)
    };
    this.is3DVisibleDataPoint = function(b, d, c) {
        if (b >= this.xAxisMin && b <= this.xAxisMax) {
            if (d >= this.yAxisMin && d <= this.yAxisMax) {
                if (c >= this.zAxisMin && c <= this.zAxisMax) {
                    return true
                }
            }
        }
        return false
    };
    this.isCulled = function(b, h, e, g) {
        for (i = 0; i < g; i++) {
            var f = this.cull3D[i];
            var d = f[2];
            if (e <= d && b >= f[0] - d && b <= f[0] + d && h >= f[1] - d && h <= f[1] + d) {
                return true
            }
        }
        return false
    };
    this.draw3DDataPoints = function() {
        var ab = this.marginLeft + this.offsetX + this.left;
        var T = this.marginTop + this.offsetY + this.top;
        var F = this.xAxisIndex + ":" + this.yAxisIndex + ":" + this.zAxisIndex;
        var E = [];
        var o = [];
        var J = [];
        var G = [];
        var U = [];
        var f = [];
        var ac = [];
        var ak = [];
        var e = [];
        var Q = 0;
        if (this.is3DPlot) {
            var W = 0;
            for (var af = 0; af < this.varIndices.length; af++) {
                var N = this.varIndices[af];
                for (var ad = 0; ad < this.smpIndices.length; ad++) {
                    var A = this.smpIndices[ad];
                    var S = (ad * this.xAxisIncr) + (this.xAxisIncr / 2);
                    var R = this.getDataAtPos(N, A);
                    var P = (af * this.zAxisIncr) + (this.zAxisIncr / 2);
                    var w = 0;
                    var v = this.yAxisMin < 0 ? 0 : this.yAxisMin;
                    var u = 0;
                    var m = ((S - w) * this.xAxisUnit) - this.xAxisOffset;
                    var k = this.scatterType && this.scatterType.match(/bar/) ? 0 : this.yAxisOffset - ((R - v) * this.yAxisUnit);
                    var h = ((P - u) * this.zAxisUnit) - this.zAxisOffset;
                    ac.push(true);
                    E.push([S, R, P]);
                    var I = this.get3DTransfrom(m, k, h);
                    o.push(I);
                    J.push(I[2]);
                    f.push(this.euclidianDistance([o[W][0], o[W][1], o[W][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]));
                    e.push([N, A]);
                    U.push(W++)
                }
            }
        } else {
            for (var af = 0; af < this.varIndices.length; af++) {
                var N = this.varIndices[af];
                var S = this.getDataAtPos(N, this.xAxisIndex);
                var R = this.getDataAtPos(N, this.yAxisIndex);
                var P = this.getDataAtPos(N, this.zAxisIndex);
                var w = this.xAxisMin < 0 ? 0 : this.xAxisMin;
                var v = this.yAxisMin < 0 ? 0 : this.yAxisMin;
                var u = this.zAxisMin < 0 ? 0 : this.zAxisMin;
                var m = ((S - w) * this.xAxisUnit) - this.xAxisOffset;
                var k = this.scatterType && this.scatterType.match(/bar/) ? 0 : this.yAxisOffset - ((R - v) * this.yAxisUnit);
                var h = ((P - u) * this.zAxisUnit) - this.zAxisOffset;
                ac.push(this.is3DVisibleDataPoint(S, R, P));
                E.push([S, R, P]);
                var I = this.get3DTransfrom(m, k, h);
                o.push(I);
                J.push(I[2]);
                if (this.scatterType != "function") {
                    U.push(af);
                    f.push(this.euclidianDistance([o[af][0], o[af][1], o[af][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]))
                }
            }
        }
        var L = this.range(J);
        if (this.scatterType && this.scatterType == "function") {
            var aa = Math.sqrt(o.length);
            var N = 0;
            var K = [];
            for (var af = 1; af < aa; af++) {
                for (var ad = 0; ad < aa - 1; ad++) {
                    var ae = ((af - 1) * aa) + ad;
                    var d = (af * aa) + ad;
                    var Z = ((af - 1) * aa) + ad + 1;
                    var ai = (af * aa) + ad + 1;
                    var M = [o[ae][0], o[d][0], o[ai][0], o[Z][0]];
                    var B = [o[ae][1], o[d][1], o[ai][1], o[Z][1]];
                    var am = [o[ae][2], o[d][2], o[ai][2], o[Z][2]];
                    var O = this.colorBy ? this.legendColorRange : false;
                    var H = this.colorBy ? this.getHeatmapColor(O[0], O[1], this.mean([E[ae][1], E[d][1], E[ai][1], E[Z][1]])) : false;
                    U.push(N++);
                    f.push(this.euclidianDistance([this.mean(M), this.mean(B), this.mean(am)], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]));
                    K.push([M, B, H])
                }
            }
            U.sort(function(g, c) {
                return f[c] - f[g]
            });
            for (var N = 0; N < K.length; N++) {
                var af = U[N];
                if (ac[af]) {
                    var al = [af, this.xAxisIndex, this.yAxisIndex, this.zAxisIndex];
                    if (this.colorBy) {
                        this.addArea(this.drawShape("polygon", K[af][0], K[af][1], false, false, K[af][2], this.foreground, "closed"), al)
                    } else {
                        this.addArea(this.drawShape("polygon", K[af][0], K[af][1], false, false, false, this.foreground, "open"), al)
                    }
                }
            }
        } else {
            U.sort(function(g, c) {
                return f[c] - f[g]
            });
            var ah = this.is3DPlot ? this.scatterPointSize / (30 * this.bar3DInverseWeight) : this.scatterPointSize / (3 * this.bar3DInverseWeight);
            for (var N = 0; N < o.length; N++) {
                var af = U[N];
                var aj = this.colorBy ? this.dataColors[af] : this.colors[0];
                var ag = this.scatterType && this.scatterType.match(/image/i) ? this.images[af] : false;
                var al = this.is3DPlot ? [e[af][0], e[af][1]] : [af, this.xAxisIndex, this.yAxisIndex, this.zAxisIndex];
                if (ac[af] && this.isVisibleSelectedDataPoint(af, F)) {
                    if (this.scatterType && this.scatterType.match(/bar/)) {
                        var V = this.isInSelectedDataPoints(af, F) ? this.selectedBackgroundColor : aj;
                        this.draw3DBar(E[af][0], E[af][1], E[af][2], ah, V, al)
                    } else {
                        var Y = this.shapeBy ? this.dataShapes[af] : this.shapes[0];
                        var X = ag ? "image" : Y;
                        var V = this.sizeBy ? this.dataSizes[af] : this.scatterPointSize;
                        var S = ab + o[af][0];
                        var R = T + o[af][1];
                        var P = Math.floor(this.percentile(L[0], L[1], o[af][2]));
                        V = V - ((V * (P / 100)) / 3);
                        this.drawSelectedBackground(af, F, Y, S, R, V, V);
                        this.addArea(this.drawShape(X, S, R, V, V, aj, this.foreground, "closed", false, false, false, false, false, false, ag), al);
                        this.drawSelectedBackgroundLabel(af, F, S, R);
                        if (this.scatterType && this.scatterType.match(/line/)) {
                            G[af] = [o[af][0], o[af][1]]
                        }
                    }
                }
            }
            if (this.scatterType && this.scatterType.match(/line/) && G.length > 0) {
                for (var af = 0; af < G.length - 1; af++) {
                    if (ac[af] && this.isVisibleSelectedDataPoint(af, F) && ac[af + 1] && this.isVisibleSelectedDataPoint(af + 1, F)) {
                        var D = ab + G[af][0];
                        var b = T + G[af][1];
                        var C = ab + G[af + 1][0];
                        var an = T + G[af + 1][1];
                        this.drawLine("line", D, b, C, an, this.colors[0])
                    }
                }
            }
        }
    };
    this.set3DprivateParams = function() {
        this.set3DText();
        this.set3DParams()
    };
    this.draw3DPlot = function() {
        this.setDataColorShapeSize();
        this.set3DXYDimensions();
        this.set3DprivateParams();
        this.set3DRotation();
        this.set3DAxes();
        this.set3DLayout();
        this.drawTitle();
        this.draw3DDataPoints();
        this.drawScatterLegend()
    };
    this.initializeScatter3D = function() {
        if (this.layoutValid) {
            this.drawLayoutCompartments(this.draw3DPlot)
        } else {
            this.draw3DPlot()
        }
    };
    if (!a) {
        this.initializeScatter3D()
    }
};
CanvasXpress.prototype.oneDPlot = function() {
    this.getShapeSize = function() {
        if (this.x < 100 || this.y < 100) {
            return this.rowBlockSize / 6
        } else {
            if (this.x < 200 || this.y < 200) {
                return this.rowBlockSize / 3
            } else {
                return this.rowBlockSize / 1.5
            }
        }
    };
    this.setRowColBlocks = function() {
        var c = this.isGroupedData ? this.grpIndices.length : this.smpIndices.length;
        this.rowBlocks = 0;
        if (this.graphType == "Line" || this.graphType == "Area" || this.graphType == "AreaLine" || this.graphType == "Heatmap" || this.graphType == "Stacked" || this.graphType == "StackedLine" || this.graphType == "StackedPercent" || this.graphType == "StackedPercentLine") {
            this.rowBlocks = c;
            if (this.graphType == "Heatmap") {
                this.colBlocks = this.varIndices.length
            } else {
                this.colBlocks = 1
            }
        } else {
            if (this.graphType == "BarLine" && this.data.a) {
                var b = this.getVariablesVisibleByAxis("xAxis");
                this.rowBlocks = b.length * c;
                this.colBlocks = 1
            } else {
                if (this.graphType == "Treemap") {
                    this.rowBlocks = 1;
                    this.colBlocks = 1
                } else {
                    this.rowBlocks = this.varIndices.length * c;
                    this.colBlocks = 1
                }
            }
        }
    };
    this.set1DVarSmpLabelFont = function() {
        var b, a;
        if (this.autoScaleFont) {
            if (this.data.l && this.data.l.vars && this.data.l.smps && this.graphOrientation == "vertical") {
                b = this.scaleTextToSize(this.layoutMaxSamples * 2)
            } else {
                var c = Math.abs(this.smpLabelRotate == 90) ? 6 : 1.5;
                b = this.isGraphTime ? this.scaleTextToSize(this.timeValues.length * c) : this.scaleTextToSize(this.isGroupedData ? this.grpIndices.length : this.smpIndices.length * c)
            }
            a = this.scaleTextToSize(this.varIndices.length * 2);
            if (this.graphType == "Heatmap" && this.adjustAspectRatio) {
                if (this.smpLabelDescription && parseInt(b * this.smpLabelScaleFontFactor) > this.maxTextSize) {
                    b = this.maxTextSize
                }
                if (this.varLabelDescription && parseInt(a * this.varLabelScaleFontFactor) > this.maxTextSize) {
                    a = this.maxTextSize
                }
                b = Math.min(b, a);
                a = b
            }
            if (this.graphType == "Treemap" && b >= 4) {
                b = parseInt(b * 2 / 3);
                a = b
            }
        } else {
            b = this.smpLabelFontSize;
            a = this.varLabelFontSize
        }
        this.smpLabelFont = this.smpLabelFontStyle + " " + parseInt(b * this.smpLabelScaleFontFactor) + "Pt " + this.fontName;
        this.varLabelFont = this.varLabelFontStyle + " " + parseInt(a * this.varLabelScaleFontFactor) + "Pt " + this.fontName
    };
    this.set1DText = function() {
        var a;
        if (!this.layoutComb) {
            if (this.data.y.desc) {
                if (this.data.y.desc.length > 1) {
                    if (this.data.y.desc[0].length > this.data.y.desc[1].length) {
                        a = this.data.y.desc[0]
                    } else {
                        a = this.data.y.desc[1]
                    }
                } else {
                    a = this.data.y.desc[0]
                }
            } else {
                a = "NA"
            }
        }
        if (this.layoutComb) {
            this.setAxisFont(this.minLayoutAxisTitle, this.minLayoutAxis)
        } else {
            if (this.graphOrientation == "vertical") {
                this.setAxisFont(a, this.y)
            } else {
                this.setAxisFont(a, this.x)
            }
        }
    };
    this.getVariableTitleHeight = function() {
        if (this.varTitle && this.graphType != "Treemap") {
            return parseInt(this.varTitleFontSize * this.varTitleScaleFontFactor) + this.margin
        } else {
            return 0
        }
    };
    this.getVariableLabelLength = function() {
        if (this.showVariableNames && this.graphType != "Treemap") {
            if (this.varLabelRotate && Math.abs(this.varLabelRotate) == 90) {
                return this.getFontPt(this.varLabelFont) + this.margin
            } else {
                return this.measureText(this.maxVarNameStr, this.varLabelFont) + this.margin
            }
        } else {
            return 0
        }
    };
    this.getVariableLabelDescLength = function() {
        if (this.showVariableNames && this.varLabelDescription && this.graphType != "Treemap") {
            if (this.maxVarLabelDesc > this.maxVarStringLen) {
                return this.measureText(this.maxVarLabelDescStr.substring(0, this.maxVarStringLen), this.varLabelFont) + (this.margin * 2)
            } else {
                return this.measureText(this.maxVarLabelDescStr, this.varLabelFont) + (this.margin * 2)
            }
        } else {
            return 0
        }
    };
    this.getSampleTitleHeight = function() {
        if (this.smpTitle && this.graphType != "Treemap") {
            return parseInt(this.smpTitleFontSize * this.smpTitleScaleFontFactor) + this.margin
        } else {
            return 0
        }
    };
    this.getSampleLabelLength = function() {
        if (this.showSampleNames && this.graphType != "Treemap") {
            if (this.smpLabelRotate && Math.abs(this.smpLabelRotate) == 90) {
                return this.getFontPt(this.smpLabelFont) + (this.margin * 2)
            } else {
                if (this.isGraphTime) {
                    return this.measureText(this.getMaxText(this.timeValues), this.smpLabelFont) + (this.margin * 2)
                } else {
                    if (this.maxSmpName > this.maxSmpStringLen) {
                        return this.measureText(this.maxSmpNameStr.substring(0, this.maxSmpStringLen), this.smpLabelFont) + (this.margin * 2)
                    } else {
                        return this.measureText(this.maxSmpNameStr, this.smpLabelFont) + (this.margin * 2)
                    }
                }
            }
        } else {
            return 0
        }
    };
    this.getSampleLabelDescLength = function() {
        if (this.showSampleNames && this.smpLabelDescription && this.graphType != "Treemap") {
            if (this.maxSmpLabelDesc > this.maxSmpStringLen) {
                return this.measureText(this.maxSmpLabelDescStr.substring(0, this.maxSmpStringLen), this.smpLabelFont) + (this.margin * 2)
            } else {
                return this.measureText(this.maxSmpLabelDescStr, this.smpLabelFont) + (this.margin * 2)
            }
        } else {
            return 0
        }
    };
    this.getSmpOverlaysLength = function() {
        var b = 0;
        if (this.showOverlays && this.graphType != "Treemap") {
            for (var a = 0; a < this.smpOverlays.length; a++) {
                if (this.data.x.hasOwnProperty(this.smpOverlays[a]) || this.smpOverlays[a] == "-") {
                    b++
                }
            }
            if (b > 0) {
                b = (b * this.overlaysWidth) + this.margin
            }
        }
        return b
    };
    this.getSmpOverlaysStrLength = function() {
        var b = 0;
        if (this.showOverlays && this.graphType != "Treemap") {
            if (this.graphType == "Heatmap") {
                for (var a = 0; a < this.smpOverlays.length; a++) {
                    if (this.data.x.hasOwnProperty(this.smpOverlays[a])) {
                        b = Math.max(b, this.measureText(this.smpOverlays[a], this.overlayFont) + this.margin)
                    }
                }
            }
        }
        return b
    };
    this.getVarOverlaysHeight = function() {
        var b = 0;
        if (this.showOverlays && this.graphType != "Treemap") {
            if (this.graphType == "Heatmap") {
                for (var a = 0; a < this.varOverlays.length; a++) {
                    if (this.data.z.hasOwnProperty(this.varOverlays[a]) || this.varOverlays[a] == "-") {
                        b++
                    }
                }
                if (b > 0) {
                    b = (b * this.overlaysWidth) + this.margin
                }
            }
        }
        return b
    };
    this.getVarOverlaysLength = function() {
        var b = 0;
        if (this.showOverlays && this.graphType != "Treemap") {
            if (this.graphType == "Heatmap") {
                for (var a = 0; a < this.varOverlays.length; a++) {
                    if (this.data.z.hasOwnProperty(this.varOverlays[a])) {
                        b = Math.max(b, this.measureText(this.varOverlays[a], this.overlayFont) + this.margin)
                    }
                }
            }
        }
        return b
    };
    this.getAxisTitleTickLength = function(b) {
        if (this.graphType == "Treemap") {
            return 0
        } else {
            if (this.graphOrientation == "vertical") {
                var a;
                if (this.tickRotate && Math.abs(this.tickRotate) == 90) {
                    a = this.getFontPt(this.axisTickFont)
                } else {
                    if (this.graphType == "Candlestick") {
                        if (this.showVolume) {
                            a = Math.max(this.measureText(this.xAxisMaxStrLength, this.axisTickFont), this.measureText(this.xAxis2MaxStrLength, this.axisTickFont))
                        } else {
                            if (this.summaryType == "candle") {
                                a = this.measureText(this.xAxisMaxStrLength, this.axisTickFont)
                            } else {
                                a = this.measureText(this.xAxis2MaxStrLength, this.axisTickFont)
                            }
                        }
                    } else {
                        if (this.graphType == "BarLine") {
                            a = b ? this.measureText(this.xAxis2MaxStrLength, this.axisTickFont) : this.measureText(this.xAxisMaxStrLength, this.axisTickFont)
                        } else {
                            a = this.measureText(this.xAxisMaxStrLength, this.axisTickFont)
                        }
                    }
                } if (b) {
                    return this.xAxis2Show ? this.getFontPt(this.axisTitleFont) + a + (this.margin * 3) : 0
                } else {
                    return this.xAxisShow ? this.getFontPt(this.axisTitleFont) + a + (this.margin * 3) : 0
                }
            } else {
                if (b) {
                    return this.xAxis2Show ? this.getFontPt(this.axisTitleFont) + this.getFontPt(this.axisTickFont) + (this.margin * 5) : 0
                } else {
                    return this.xAxisShow ? this.getFontPt(this.axisTitleFont) + this.getFontPt(this.axisTickFont) + (this.margin * 5) : 0
                }
            }
        }
    };
    this.getHeatmapIndicatorHeight = function(a) {
        var b = this.data.y.desc && this.data.y.desc[0] ? (this.margin * 2) + this.getFontPt(this.legendFont) : 0;
        if (a && this.isMultidimensionalHeatmap && this.indicatorsPosition == "bottom") {
            return this.legendHeight
        } else {
            return this.indicatorHeight + (this.margin * 4) + this.getFontPt(this.legendFont) + b
        }
    };
    this.getLegendHeight = function(c) {
        if (this.graphType == "Heatmap" && !this.isMultidimensionalHeatmap) {
            return 0
        } else {
            if (this.isMultidimensionalHeatmap || ((this.colorBy || this.shapeBy || this.sizeBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap/))) {
                return this.legendPosition == "right" ? this.legendWidth : this.legendHeight
            } else {
                if (this.graphType == "Treemap") {
                    return 0
                } else {
                    var a = Math.min(this.getFontPt(this.legendFont), this.maxTextSize);
                    var b = this.layoutComb && !c ? this.layoutMaxVarLegend : this.varIndices.length;
                    return (b * a * 1.5) + (a / 2) + this.margin
                }
            }
        }
    };
    this.getLegendWidth = function() {
        if (this.graphType == "Heatmap" && !this.isMultidimensionalHeatmap) {
            return 0
        } else {
            if (this.isMultidimensionalHeatmap || ((this.colorBy || this.shapeBy || this.sizeBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap/))) {
                return this.legendPosition == "right" ? this.legendWidth : this.legendHeight
            } else {
                if (this.graphType == "Treemap") {
                    return 0
                } else {
                    var b = Math.min(this.getFontPt(this.legendFont), this.maxTextSize);
                    var a = this.layoutComb ? this.layoutMaxVarLegendLabel : this.maxVarNameStr;
                    var c = a.length > this.maxVarStringLen ? a.substring(0, this.maxVarStringLen) : a;
                    return (b * 2) + this.measureText(c, this.legendFont) + (this.margin * 6)
                }
            }
        }
    };
    this.getVarTreeHeight = function() {
        var a = 0;
        if (this.graphType == "Heatmap" && this.showVarDendrogram && this.varDendrogram && this.graphType != "Treemap") {
            a = ((this.varDendrogram.depth + 1) * this.dendrogramSpace) + this.margin
        }
        return a
    };
    this.getSmpTreeWidthHeight = function() {
        var a = 0;
        if (this.showSmpDendrogram && this.smpDendrogram && !this.isGroupedData && this.graphType != "Treemap") {
            a = ((this.smpDendrogram.depth + 1) * this.dendrogramSpace) + this.margin
        }
        return a
    };
    this.set1DXYDimensionsLeft = function() {
        if (this.graphOrientation == "vertical") {
            this.left = this.margin + this.getAxisTitleTickLength()
        } else {
            if (this.smpDendrogramPosition == "right") {
                this.left = this.margin + this.getSampleTitleHeight() + this.getSampleLabelLength() + this.getSmpOverlaysLength()
            } else {
                this.left = this.margin + this.getSampleTitleHeight() + this.getSmpTreeWidthHeight() + this.getSampleLabelLength() + this.getSmpOverlaysLength()
            }
        }
    };
    this.set1DXYDimensionsRight = function() {
        if (this.graphOrientation == "vertical") {
            this.right = this.margin + this.getAxisTitleTickLength(true)
        } else {
            if (this.smpDendrogramPosition == "right") {
                this.right = this.margin + this.getSmpTreeWidthHeight()
            } else {
                this.right = this.margin
            }
        } if (this.showLegend && this.legendPosition == "right") {
            this.right += this.getLegendWidth()
        }
        if (this.graphType == "Heatmap") {
            var b = this.getSampleLabelDescLength();
            var a = 0;
            if (this.showOverlays) {
                a = this.getVarOverlaysLength()
            }
            this.right += Math.max(b, a)
        }
    };
    this.set1DXYDimensionsTop = function() {
        this.top = this.margin;
        if (this.title) {
            this.top += this.titleHeight + this.margin;
            if (this.subtitle) {
                this.top += this.subtitleHeight + this.margin
            }
        }
        if (this.graphOrientation == "vertical") {
            if (this.smpDendrogramPosition != "bottom") {
                this.top += this.getSmpTreeWidthHeight()
            }
        } else {
            if (this.graphType == "Heatmap") {
                this.top += this.getHeatmapIndicatorHeight();
                if (this.varDendrogramPosition != "bottom") {
                    this.top += this.getVarTreeHeight()
                }
                if (this.varTitleLabelOverlayPosition != "bottom") {
                    this.top += this.getVariableTitleHeight();
                    this.top += this.getVariableLabelLength();
                    this.top += this.getVarOverlaysHeight()
                } else {
                    this.top += this.getVariableLabelDescLength()
                }
            } else {
                this.top += this.getAxisTitleTickLength()
            }
        }
    };
    this.set1DXYDimensionsBottom = function() {
        this.bottom = this.margin;
        if (this.graphOrientation == "vertical") {
            this.bottom += this.getSampleTitleHeight() + this.getSampleLabelLength() + this.getSmpOverlaysLength();
            if (this.smpDendrogramPosition == "bottom") {
                this.bottom += this.getSmpTreeWidthHeight()
            }
            if (this.showLegend && this.legendPosition == "bottom") {
                this.bottom += this.getLegendHeight()
            }
        } else {
            if (this.graphType == "Heatmap") {
                if (this.varTitleLabelOverlayPosition == "bottom") {
                    this.bottom += this.getVarOverlaysHeight();
                    this.bottom += this.getVariableLabelLength();
                    this.bottom += this.getVariableTitleHeight()
                } else {
                    this.bottom += Math.max(this.getVariableLabelDescLength(), this.getSmpOverlaysStrLength())
                } if (this.varDendrogramPosition == "bottom") {
                    this.bottom += this.getVarTreeHeight()
                }
                if (this.showIndicators && this.indicatorsPosition == "bottom" && this.isMultidimensionalHeatmap) {
                    this.bottom += this.getHeatmapIndicatorHeight(true)
                }
            } else {
                this.bottom += this.getAxisTitleTickLength(true);
                if (this.showLegend && this.legendPosition == "bottom") {
                    this.bottom += this.getLegendHeight()
                }
            }
        }
    };
    this.adjustLegendFontSize = function() {
        if (!this.tmpLegendFontSize && this.adjustAspectRatio) {
            this.tmpLegendFontSize = this.legendFontSize
        }
        if (this.legendFontSize > 3) {
            this.legendFontSize -= 2
        }
    };
    this.adjustSmpVarScaleFontFactor = function() {
        if (this.graphType == "Heatmap" && this.adjustAspectRatio) {
            if (!this.tmpSmpLabelScaleFontFactor) {
                this.tmpSmpLabelScaleFontFactor = this.smpLabelScaleFontFactor
            }
            if (!this.tmpVarLabelScaleFontFactor) {
                this.tmpVarLabelScaleFontFactor = this.varLabelScaleFontFactor
            }
            this.smpLabelScaleFontFactor *= 0.8;
            this.varLabelScaleFontFactor *= 0.8;
            this.set1DVarSmpLabelFont()
        }
    };
    this.adjustDendrogramSpace = function() {
        if (this.graphType == "Heatmap" && this.adjustAspectRatio) {
            if (!this.tmpDendrogramSpace) {
                this.tmpDendrogramSpace = this.dendrogramSpace
            }
            if (this.dendrogramSpace > 1) {
                this.dendrogramSpace -= 1
            }
        }
    };
    this.adjust1DYDimension = function() {
        while (this.adjustAspectRatioYTries <= this.adjustAspectRatioMax && this.y < 10) {
            this.adjustLegendFontSize();
            this.adjustSmpVarScaleFontFactor();
            this.adjustDendrogramSpace();
            this.set1DXYDimensionsTop();
            this.set1DXYDimensionsBottom();
            this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
            if (this.adjustAspectRatioYTries == this.adjustAspectRatioMax && this.y < 10) {
                if (this.showLegend && this.legendPosition == "bottom") {
                    this.tmpShowLegend = this.showLegend;
                    this.showLegend = false
                }
                if (this.varLabelDescription) {
                    this.tmpVarLabelDescription = this.varLabelDescription;
                    this.varLabelDescription = false
                }
                this.set1DXYDimensionsTop();
                this.set1DXYDimensionsBottom();
                this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
                if (this.y < 10) {
                    this.errors.push("The text size doesn't fit in the graph. Either make it smaller or make the graph bigger!\nYou can also reduce the maximum length for the text string!")
                }
            }
            this.adjustAspectRatioYTries++
        }
    };
    this.adjust1DXDimension = function() {
        while (this.adjustAspectRatioXTries <= this.adjustAspectRatioMax && this.x < 10) {
            this.adjustLegendFontSize();
            this.adjustSmpVarScaleFontFactor();
            this.adjustDendrogramSpace();
            this.set1DXYDimensionsLeft();
            this.set1DXYDimensionsRight();
            this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
            if (this.adjustAspectRatioXTries == this.adjustAspectRatioMax && this.x < 10) {
                if (this.showLegend && this.legendPosition != "bottom") {
                    this.tmpShowLegend = this.showLegend;
                    this.showLegend = false
                }
                if (this.smpLabelDescription) {
                    this.tmpSmpLabelDescription = this.smpLabelDescription;
                    this.smpLabelDescription = false
                }
                this.set1DXYDimensionsLeft();
                this.set1DXYDimensionsRight();
                this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
                if (this.x < 10) {
                    this.errors.push("The text size doesn't fit in the graph. Either make it smaller or make the graph bigger!\nYou can also reduce the maximum length for the text string!")
                }
            }
            this.adjustAspectRatioXTries++
        }
    };
    this.set1DXYDimensions = function() {
        if (this.isGraphTime) {
            if (!this.showVolume || (this.layoutComb && this.layoutCurrent == 0)) {
                this.setTimeAxis()
            }
        }
        if (this.isMultidimensionalHeatmap || ((this.colorBy || this.shapeBy || this.sizeBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap/))) {
            this.setLegendDimensions()
        }
        this.setRowColBlocks();
        this.set1DVarSmpLabelFont();
        if (this.graphOrientation == "vertical") {
            this.set1DXYDimensionsTop();
            this.set1DXYDimensionsBottom();
            if (this.adjustAspectRatio) {
                this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
                if (this.y < 10) {
                    this.adjust1DYDimension()
                }
            }
            this.set1DText();
            this.set1DXYDimensionsLeft();
            this.set1DXYDimensionsRight();
            if (this.adjustAspectRatio) {
                this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
                if (this.x < 10) {
                    this.adjust1DXDimension()
                }
            }
        } else {
            this.set1DXYDimensionsLeft();
            this.set1DXYDimensionsRight();
            if (this.adjustAspectRatio) {
                this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
                if (this.x < 10) {
                    this.adjust1DXDimension()
                }
            }
            this.set1DText();
            this.set1DXYDimensionsTop();
            this.set1DXYDimensionsBottom();
            if (this.adjustAspectRatio) {
                this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
                if (this.y < 10) {
                    this.adjust1DYDimension()
                }
            }
        }
    };
    this.set1DPrivateParams = function() {
        var c = this.isGroupedData ? this.grpIndices.length : this.smpIndices.length;
        if (!this.adjustAspectRatio) {
            this.rowBlockSize = this.scaleTextToSize(this.rowBlocks) + this.scaleTextConstantAdd;
            this.rowBlockSize *= this.widthFactor;
            if (this.graphType == "Heatmap") {
                if (this.colBlocks < 20) {
                    this.colBlockSize = this.scaleTextToSize(this.colBlocks) + this.scaleTextConstantAdd + (this.scaleTextConstantAdd * 3)
                } else {
                    this.colBlockSize = (parseInt(1 / Math.sqrt(this.colBlocks) * this.scaleTextConstantMult)) + 1
                }
                this.colBlockSize *= this.widthFactor;
                this.blockSeparation = this.rowBlockSize / 2;
                this.y = this.rowBlockSize * this.rowBlocks;
                this.x = this.colBlockSize * this.colBlocks
            } else {
                this.blockSeparation = this.rowBlockSize * this.sampleSeparationFactor;
                if (this.graphOrientation == "vertical") {
                    if (this.graphType.match(/Area/)) {
                        this.x = (this.rowBlockSize * (this.rowBlocks - 1)) + (this.blockSeparation * (c - 1))
                    } else {
                        if (this.plotByVariable) {
                            this.x = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * this.varIndices.length) + this.blockSeparation
                        } else {
                            this.x = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * c) + this.blockSeparation
                        }
                    }
                    this.y = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
                } else {
                    if (this.graphType.match(/Area/)) {
                        this.y = (this.rowBlockSize * (this.rowBlocks - 1)) + (this.blockSeparation * (c - 1))
                    } else {
                        if (this.plotByVariable) {
                            this.y = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * this.varIndices.length) + this.blockSeparation
                        } else {
                            this.y = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * c) + this.blockSeparation
                        }
                    }
                    this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
                }
                this.colBlockSize = 1
            }
            this.width = this.marginLeft + ((this.left + this.x + this.right) * this.layoutCols) + this.marginRight;
            this.height = this.marginTop + ((this.top + this.y + this.bottom) * this.layoutRows) + this.marginBottom;
            this.resizeCanvas()
        } else {
            if (this.graphType == "Heatmap") {
                this.rowBlockSize = this.y / this.rowBlocks;
                this.blockSeparation = this.rowBlockSize;
                this.colBlockSize = this.x / this.varIndices.length
            } else {
                if (this.graphType.match(/Area/)) {
                    this.rowBlockSize = this.graphOrientation == "vertical" ? this.x / (this.rowBlocks + c - 2) : this.y / (this.rowBlocks + c - 2)
                } else {
                    if (this.plotByVariable) {
                        this.rowBlockSize = this.graphOrientation == "vertical" ? this.x / (this.rowBlocks + this.varIndices.length) : this.y / (this.rowBlocks + this.varIndices.length)
                    } else {
                        this.rowBlockSize = this.graphOrientation == "vertical" ? this.x / (this.rowBlocks + c) : this.y / (this.rowBlocks + c)
                    }
                }
                var b = this.widthFactor + this.sampleSeparationFactor;
                var a = this.graphType.match(/Stacked/) ? 1 : this.varIndices.length;
                if (this.widthFactor > this.sampleSeparationFactor) {
                    this.blockSeparation = this.rowBlockSize * (this.sampleSeparationFactor / b);
                    this.rowBlockSize *= 1 + (this.widthFactor / (b * a))
                } else {
                    if (this.sampleSeparationFactor > this.widthFactor) {
                        this.blockSeparation = this.rowBlockSize * (1 + (this.sampleSeparationFactor / b));
                        this.rowBlockSize -= ((this.blockSeparation - this.rowBlockSize) / a)
                    } else {
                        this.blockSeparation = this.rowBlockSize
                    }
                }
                this.colBlockSize = 1
            }
        }
    };
    this.set1DAttributes = function() {
        this.setLegendFont();
        this.setTrees();
        this.setOverlayColors();
        this.setOverlayFont();
        this.setValidDataColorShapeSize();
        this.setDataColorShapeSize()
    };
    this.getTreemap = function() {
        this.drawDendrogram("smpDendrogram");
        var j = this.varIndices[0];
        var a = [];
        var f = this;
        var b = function(d) {
            if (f.colorBy) {
                for (var k = 0; k < f.smpIndices.length; k++) {
                    if (f.smpIndices[k] == d) {
                        return f.dataColors[k]
                    }
                }
            } else {
                return f.colors[d % f.colors.length]
            }
        };
        var h = function(m, i) {
            if (!m.left && !m.right) {
                var k = f.getSampleIndices(m.id);
                var n = f.getDataAtPos(j, k);
                i.push({
                    area: n,
                    label: f.data.y.smps[k],
                    color: b(k),
                    index: [j, k]
                })
            } else {
                var l = [];
                h(m.left, l);
                h(m.right, l);
                i.push({
                    area: l[0].area + l[1].area,
                    index: -1,
                    children: l
                })
            }
            return i
        };
        if (this.smpDendrogram) {
            a = h(this.smpDendrogram.object, [])
        } else {
            for (var e = 0; e < this.smpIndices.length; e++) {
                var c = this.smpIndices[e];
                var g = this.getDataAtPos(j, c);
                a.push({
                    area: g,
                    label: this.data.y.smps[c],
                    color: this.colorBy ? this.dataColors[e] : this.colors[e % this.colors.length],
                    index: [j, c]
                })
            }
        }
        return this.processTreemap(a, {
            width: this.x,
            height: this.y,
            left: 0,
            top: 0
        })
    };
    this.set1DXAxis = function() {
        var a = this.graphOrientation == "vertical" ? "y" : "x";
        this.setAxisUnits("xAxis", a);
        if ((this.graphType.match(/BarLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a) || (this.graphType == "Candlestick" && this.showVolume)) {
            this.setAxisUnits("xAxis2", a)
        }
    };
    this.draw1DWireFrame = function() {
        var s, e, r, d, q, b, a, f, j, p;
        var g = this.isGroupedData ? this.grpIndices : this.smpIndices;
        var u = this.xAxisTickStyle == "dotted" || this.yAxisTickStyle == "dotted" ? "dottedLine" : "line";
        var v = this.smpHairline == "dotted" ? "dottedLine" : "line";
        var n = this.marginLeft + this.offsetX + this.left;
        var m = this.marginTop + this.offsetY + this.top;
        if (this.graphType == "Treemap") {
            return
        }
        this.disableGradientTransparencyShadow();
        if (this.graphType != "Heatmap") {
            if (this.graphType == "BarLine" && this.data.a && this.data.y.desc[1]) {
                var c = this.getVariablesVisibleByAxis("xAxis");
                p = c.length
            } else {
                if (this.graphType.match(/Stacked|Line|Area/)) {
                    p = 1
                } else {
                    p = this.varIndices.length
                }
            }
            j = p * this.rowBlockSize;
            if (this.graphOrientation == "vertical") {
                if (this.isGraphTime) {
                    var h = this.x / g.length;
                    var k = this.graphType.match(/Area/) ? 0 : n + ((this.blockSeparation + j) / 2);
                    e = m;
                    d = m + this.y;
                    for (var o = 0; o < this.timeValueIndices.length; o++) {
                        s = (this.timeValueIndices[o] * h) + k;
                        if (this.smpHairline) {
                            this.drawLine(v, s, e, s, d, this.smpHairlineColor, this.smpHairlineWidth, "butt")
                        }
                    }
                } else {
                    if (!this.plotByVariable) {
                        s = this.graphType.match(/Area/) ? n : n + this.blockSeparation + j;
                        r = n;
                        q = n + this.blockSeparation + j;
                        e = m;
                        d = m + this.y;
                        for (var o = 0; o < g.length; o++) {
                            if (this.blockContrast) {
                                f = o % 2 ? this.evenColor : this.oddColor;
                                this.ctx.save();
                                this.rectangle(r, e, q, d, f, f);
                                this.ctx.restore();
                                r = q;
                                q = r + this.blockSeparation + j
                            }
                            if (this.smpHairline) {
                                if (this.graphType.match(/Area/) && (o == 0 || o == g.length - 1)) {
                                    s += this.blockSeparation + j;
                                    continue
                                }
                                this.drawLine(v, s, e, s, d, this.smpHairlineColor, this.smpHairlineWidth, "butt")
                            }
                            s += this.blockSeparation + j
                        }
                    }
                } if (this.xAxisMinorTicks && this.summaryType != "volume") {
                    for (var o = 0; o < this.xAxisMinorValues.length; o++) {
                        var w = parseFloat(this.xAxisMinorValues[o]);
                        e = this.marginTop + this.offsetY + this.top + this.y - ((w - this.xAxisMin) * this.xAxisUnit);
                        this.drawLine(u, n, e, n + this.x, e, this.xAxisTickColor, this.outlineWidth / 3, "butt")
                    }
                }
                s = this.marginLeft + this.offsetX + this.left - (this.margin * 2);
                for (var o = 0; o < this.xAxisValues.length; o++) {
                    var w = parseFloat(this.xAxisValues[o]);
                    e = this.marginTop + this.offsetY + this.top + this.y - ((w - this.xAxisMin) * this.xAxisUnit);
                    this.drawLine(u, n, e, n + this.x, e, this.xAxisTickColor, false, "butt")
                }
            } else {
                if (this.isGraphTime) {
                    var h = this.y / g.length;
                    var k = this.graphType.match(/Area/) ? 0 : m + ((this.blockSeparation + j) / 2);
                    s = n;
                    r = this.x;
                    for (var o = 0; o < this.timeValueIndices.length; o++) {
                        e = (this.timeValueIndices[o] * h) + k;
                        if (this.smpHairline) {
                            this.drawLine(v, s, e, r, e, this.smpHairlineColor, this.smpHairlineWidth, "butt")
                        }
                    }
                } else {
                    if (!this.plotByVariable) {
                        s = n;
                        r = this.x;
                        e = this.graphType.match(/Area/) ? m : m + this.blockSeparation + j;
                        d = m;
                        b = m + this.blockSeparation + j;
                        for (var o = 0; o < g.length; o++) {
                            if (this.blockContrast) {
                                a = o == 0 || o == g.length - 1 ? (this.blockSeparation * 1.5) + j : this.blockSeparation + j;
                                f = o % 2 ? this.evenColor : this.oddColor;
                                this.ctx.save();
                                this.rectangle(s, d, r, a, f, f);
                                this.ctx.restore();
                                d = b;
                                b = d + this.blockSeparation + j
                            }
                            if (this.smpHairline) {
                                if (this.graphType.match(/Area/) && (o == 0 || o == g.length - 1)) {
                                    e += this.blockSeparation + j;
                                    continue
                                }
                                this.drawLine(v, s, e, n + r, e, this.smpHairlineColor, this.smpHairlineWidth, "butt")
                            }
                            e += this.blockSeparation + j
                        }
                    }
                } if (this.xAxisMinorTicks && this.summaryType != "volume") {
                    for (var o = 0; o < this.xAxisMinorValues.length; o++) {
                        var w = parseFloat(this.xAxisMinorValues[o]);
                        s = n + ((w - this.xAxisMin) * this.xAxisUnit);
                        this.drawLine(u, s, m, s, m + this.y, this.xAxisTickColor, this.outlineWidth / 3, "butt")
                    }
                }
                e = this.marginTop + this.offsetY + this.top - ((this.margin * 2) + (this.getFontPt(this.axisTickFont) / 2));
                for (var o = 0; o < this.xAxisValues.length; o++) {
                    var w = parseFloat(this.xAxisValues[o]);
                    s = n + ((w - this.xAxisMin) * this.xAxisUnit);
                    this.drawLine(u, s, m, s, m + this.y, this.xAxisTickColor, false, "butt")
                }
            }
        }
        this.enableGradientTransparencyShadow()
    };
    this.drawTrees = function() {
        if (this.graphType == "Treemap") {
            return
        } else {
            if (!this.isGroupedData) {
                this.drawDendrogram("smpDendrogram");
                if (this.graphType == "Heatmap") {
                    this.drawDendrogram("varDendrogram")
                }
                this.maskTreeArea()
            }
        }
    };
    this.getMaxDepthDendrogramXYs = function(c) {
        if (c.length > 0) {
            var a = [];
            for (var b = 0; b < c.length; b++) {
                a.push(c[b][1])
            }
            a.sort(function(e, d) {
                return d - e
            });
            for (var b = 0; b < c.length; b++) {
                if (c[b][1] == a[0]) {
                    return b
                }
            }
        } else {
            return -1
        }
    };
    this.drawDendrogram = function(E) {
        var X = this.marginLeft + this.offsetX + this.left;
        var S = this.marginTop + this.offsetY + this.top;
        var J = E == "varDendrogram" ? "showVarDendrogram" : "showSmpDendrogram";
        var f = E == "varDendrogram" ? this.varIndices : this.smpIndices;
        var B, a, A, af, ad, F;
        var V = this.dendrogramSpace / 2;
        this.disableGradientTransparencyShadow();
        if (this.graphType != "Heatmap") {
            if (this.graphType == "BarLine" && this.data.a && this.data.y.desc[1]) {
                var E = this.getVariablesVisibleByAxis("xAxis");
                F = E.length
            } else {
                if (this.graphType.match(/Stacked|Line|Area/)) {
                    F = 1
                } else {
                    F = this.varIndices.length
                }
            }
            ad = F * this.rowBlockSize
        } else {
            ad = 0
        } if (this[J] && this[E]) {
            var D = this[E].data;
            var ae = this[E].idxs;
            var F = this[E].depth;
            var o = this.getMaxDepthDendrogramXYs(D);
            var g = this[E].heights;
            var e = this[E].max;
            var m = {};
            var v = {};
            var d = [];
            if (E == "varDendrogram") {
                for (var ac = 0; ac < D.length; ac++) {
                    d[ac] = this.createNode(this.data.y.vars[ae[ac]], null, null, 0, null)
                }
            } else {
                for (var ac = 0; ac < D.length; ac++) {
                    d[ac] = this.createNode(this.data.y.smps[ae[ac]], null, null, 0, null)
                }
            }
            while (D.length > 1) {
                ac = o;
                var k = [ac];
                var O = D[ac][0];
                var N = D[ac][1];
                var M = D[ac][2];
                var Q = D[ac][3];
                var q = [O];
                var p = [N];
                var n = [M];
                var s = [Q];
                var G = {};
                var U = "";
                var C = M;
                G[ac] = 1;
                for (var aa = ac + 1; aa < D.length; aa++) {
                    var Z = D[aa][0];
                    var Y = D[aa][1];
                    var W = D[aa][2];
                    var ab = D[aa][3];
                    if (Y == N && ((W == 0 && ab <= Q) || (ab < Q))) {
                        q.push(Z);
                        p.push(Y);
                        n.push(W);
                        s.push(ab);
                        C += W;
                        G[aa] = 1;
                        k.push(aa)
                    } else {
                        break
                    }
                }
                if (q.length > 1) {
                    if (E == "varDendrogram") {
                        var h = this.colBlockSize / 2;
                        var P;
                        if (this.varDendrogramPosition == "bottom") {
                            if (this.varTitleLabelOverlayPosition != "bottom") {
                                P = (S + this.y + this.bottom) - (this.margin + (this.dendrogramSpace * (F + 1)))
                            } else {
                                P = (S + this.y + this.bottom) - (this.margin + (this.dendrogramSpace * (F + 1)) + this.getVariableTitleHeight())
                            }
                        } else {
                            if (this.varTitleLabelOverlayPosition != "bottom") {
                                P = S - (this.getVarOverlaysHeight() + this.getVariableLabelLength() + this.getVarTreeHeight())
                            } else {
                                P = S - (this.margin + this.getVarTreeHeight() + this.getVariableLabelDescLength())
                            }
                        }
                        for (var ac = 0; ac < q.length; ac++) {
                            d[k[ac]].dist = g[k[ac]];
                            if (this.graphType != "Treemap") {
                                B = (X + h) + (this.colBlockSize * (q[ac] - 1));
                                B = this.varIndicesStart > -1 ? B - (this.colBlockSize * this.varIndicesStart) : B;
                                if (this.varDendrogramPosition == "bottom") {
                                    if (this.varTitleLabelOverlayPosition != "bottom") {
                                        af = this.height - (this.marginBottom + this.margin + (this.dendrogramSpace * p[ac]))
                                    } else {
                                        af = this.height - (this.marginBottom + this.margin + (this.dendrogramSpace * p[ac]) + this.getVariableTitleHeight())
                                    } if (this.dendrogramHeight) {} else {
                                        if (this.isLeafNode(d[k[ac]]) && !this.dendrogramHang) {
                                            a = P
                                        } else {
                                            a = af - this.dendrogramSpace
                                        }
                                    }
                                } else {
                                    a = P + (this.dendrogramSpace * p[ac]);
                                    if (this.dendrogramHeight) {} else {
                                        if (this.isLeafNode(d[k[ac]]) && !this.dendrogramHang) {
                                            af = P + (this.dendrogramSpace * (F + 1))
                                        } else {
                                            af = a + this.dendrogramSpace
                                        }
                                    }
                                }
                                this.drawLine("line", B, a, B, af, this.dendrogramColor, false, "butt", false, false, true, [0, 0, this.width, this.height]);
                                if (!m.hasOwnProperty(Q)) {
                                    m[Q] = 0
                                }
                                if (!this.isLeafNode(d[k[ac]])) {
                                    this.addArea(["rect", B - V, af - V, B + V, af + V], [-Q], "-" + m[Q] + "-varDendrogram");
                                    m[Q]++
                                }
                                if (ac < q.length - 1) {
                                    A = (X + h) + (this.colBlockSize * (q[ac + 1] - 1));
                                    A = this.varIndicesStart > -1 ? A - (this.colBlockSize * this.varIndicesStart) : A;
                                    if (this.varDendrogramPosition == "bottom") {
                                        this.drawLine("line", B, af, A, af, this.dendrogramColor, false, "butt", false, false, true, [0, 0, this.width, this.height])
                                    } else {
                                        this.drawLine("line", B, a, A, a, this.dendrogramColor, false, "butt", false, false, true, [0, 0, this.width, this.height])
                                    }
                                }
                            }
                        }
                    } else {
                        if (this.graphOrientation == "vertical") {
                            var P;
                            if (this.smpDendrogramPosition == "bottom") {
                                P = (S + this.y + this.bottom) - (this.margin + this.getSampleTitleHeight() + (this.dendrogramSpace * (F + 1)));
                                if (this.showLegend && this.legendPosition == "bottom") {
                                    P -= this.getLegendHeight()
                                }
                            } else {
                                P = S - this.getSmpTreeWidthHeight()
                            }
                            for (var ac = 0; ac < q.length; ac++) {
                                d[k[ac]].dist = g[k[ac]];
                                if (this.graphType != "Treemap") {
                                    B = (X + this.blockSeparation + (ad / 2)) + ((this.blockSeparation + ad) * (q[ac] - 1));
                                    B = this.smpIndicesStart > -1 ? B - ((this.blockSeparation + ad) * this.smpIndicesStart) : B;
                                    if (this.smpDendrogramPosition == "bottom") {
                                        af = this.height - (this.marginBottom + this.margin + (this.dendrogramSpace * p[ac]));
                                        if (this.showLegend && this.legendPosition == "bottom") {
                                            af -= this.getLegendHeight()
                                        }
                                        if (this.dendrogramHeight) {} else {
                                            if (this.isLeafNode(d[k[ac]]) && !this.dendrogramHang) {
                                                a = P
                                            } else {
                                                a = af - this.dendrogramSpace
                                            }
                                        }
                                    } else {
                                        a = P + (this.dendrogramSpace * p[ac]);
                                        if (this.dendrogramHeight) {} else {
                                            if (this.isLeafNode(d[k[ac]]) && !this.dendrogramHang) {
                                                af = P + (this.dendrogramSpace * (F + 1))
                                            } else {
                                                af = a + this.dendrogramSpace
                                            }
                                        }
                                    }
                                    this.drawLine("line", B, a, B, af, this.dendrogramColor, false, "butt", false, false, true, [0, 0, this.width, this.height]);
                                    if (!m.hasOwnProperty(Q)) {
                                        m[Q] = 0
                                    }
                                    if (!this.isLeafNode(d[k[ac]])) {
                                        this.addArea(["rect", B - V, af - V, B + V, af + V], [-Q], "-" + m[Q] + "-smpDendrogram");
                                        m[Q]++
                                    }
                                    if (ac < q.length - 1) {
                                        A = (X + this.blockSeparation + (ad / 2)) + ((this.blockSeparation + ad) * (q[ac + 1] - 1));
                                        A = this.smpIndicesStart > -1 ? A - ((this.blockSeparation + ad) * this.smpIndicesStart) : A;
                                        if (this.smpDendrogramPosition == "bottom") {
                                            this.drawLine("line", B, af, A, af, this.dendrogramColor, false, "butt", false, false, true, [0, 0, this.width, this.height])
                                        } else {
                                            this.drawLine("line", B, a, A, a, this.dendrogramColor, false, "butt", false, false, true, [0, 0, this.width, this.height])
                                        }
                                    }
                                }
                            }
                        } else {
                            if (this.smpDendrogramPosition == "right") {
                                P = X + this.x + this.getSampleLabelDescLength() + this.margin
                            } else {
                                P = this.marginLeft + this.offsetX + this.margin + this.getSampleTitleHeight()
                            }
                            for (var ac = 0; ac < q.length; ac++) {
                                d[k[ac]].dist = g[k[ac]];
                                if (this.graphType != "Treemap") {
                                    if (this.smpDendrogramPosition == "right") {
                                        A = (X + this.x + this.getSampleLabelDescLength() + this.margin) + ((this.dendrogramSpace * (F + 1)) - (this.dendrogramSpace * p[ac]))
                                    } else {
                                        B = this.marginLeft + this.offsetX + this.margin + this.getSampleTitleHeight() + (this.dendrogramSpace * p[ac])
                                    } if (this.graphType == "Heatmap") {
                                        a = (S + this.blockSeparation) + (this.rowBlockSize * (q[ac] - 1));
                                        a = this.smpIndicesStart > -1 ? a - (this.rowBlockSize * this.smpIndicesStart) : a;
                                        if (this.adjustAspectRatio) {
                                            a -= this.blockSeparation / 2
                                        }
                                    } else {
                                        a = (S + this.blockSeparation + (ad / 2)) + ((this.blockSeparation + ad) * (q[ac] - 1));
                                        a = this.smpIndicesStart > -1 ? a - ((this.blockSeparation + ad) * this.smpIndicesStart) : a
                                    } if (this.smpDendrogramPosition == "right") {
                                        if (this.dendrogramHeight) {} else {
                                            if (this.isLeafNode(d[k[ac]]) && !this.dendrogramHang) {
                                                B = X + this.x + this.getSampleLabelDescLength() + this.margin
                                            } else {
                                                B = A - this.dendrogramSpace
                                            }
                                        }
                                    } else {
                                        if (this.dendrogramHeight) {} else {
                                            if (this.isLeafNode(d[k[ac]]) && !this.dendrogramHang) {
                                                A = this.marginLeft + this.offsetX + this.margin + this.getSampleTitleHeight() + (this.dendrogramSpace * (F + 1))
                                            } else {
                                                A = B + this.dendrogramSpace
                                            }
                                        }
                                    }
                                    this.drawLine("line", B, a, A, a, this.dendrogramColor, false, "butt", false, false, true, [0, 0, this.width, this.height]);
                                    if (!m.hasOwnProperty(Q)) {
                                        m[Q] = 0
                                    }
                                    if (!this.isLeafNode(d[k[ac]])) {
                                        this.addArea(["rect", A - V, a - V, A + V, a + V], [-Q], "-" + m[Q] + "-smpDendrogram");
                                        m[Q]++
                                    }
                                    if (ac < q.length - 1) {
                                        if (this.graphType == "Heatmap") {
                                            af = (S + this.blockSeparation) + (this.rowBlockSize * (q[ac + 1] - 1));
                                            af = this.smpIndicesStart > -1 ? af - (this.rowBlockSize * this.smpIndicesStart) : af;
                                            if (this.adjustAspectRatio) {
                                                af -= this.blockSeparation / 2
                                            }
                                        } else {
                                            af = (S + this.blockSeparation + (ad / 2)) + ((this.blockSeparation + ad) * (q[ac + 1] - 1));
                                            af = this.smpIndicesStart > -1 ? af - ((this.blockSeparation + ad) * this.smpIndicesStart) : af
                                        } if (this.smpDendrogramPosition == "right") {
                                            this.drawLine("line", A, a, A, af, this.dendrogramColor, false, "butt", false, false, true, [0, 0, this.width, this.height])
                                        } else {
                                            this.drawLine("line", B, a, B, af, this.dendrogramColor, false, "butt", false, false, true, [0, 0, this.width, this.height])
                                        }
                                    }
                                }
                            }
                        }
                    }
                    var I, L;
                    var b = [];
                    var H = [];
                    var R = [];
                    var K = [];
                    var u = this.mean(q);
                    var c = false;
                    if (!v.hasOwnProperty(Q)) {
                        v[Q] = 0
                    }
                    U = (Q - 1) + "-" + v[Q];
                    for (var T in G) {
                        K.push(d[T])
                    }
                    for (var aa = 0; aa < D.length; aa++) {
                        if (!G.hasOwnProperty(aa)) {
                            b.push(D[aa]);
                            H.push(d[aa])
                        } else {
                            if (!c) {
                                b.push([u, N - 1, C, s[s.length - 1]]);
                                I = K.shift();
                                L = K.pop();
                                if (K.length > 0) {
                                    H.push(this.createNode(U, I, L, 0, null, K))
                                } else {
                                    H.push(this.createNode(U, I, L, 0, null))
                                }
                                v[Q]++;
                                c = true
                            }
                        }
                    }
                    for (var aa = 0; aa < g.length; aa++) {
                        if (!G.hasOwnProperty(aa)) {
                            R.push(g[aa])
                        }
                    }
                    D = b;
                    d = H;
                    g = R;
                    o = this.getMaxDepthDendrogramXYs(D)
                }
            }
            this[E].object = d[0]
        }
        this.enableGradientTransparencyShadow()
    };
    this.draw1DYLayout = function() {
        var F, d, D, c, C, b, n, A;
        var v = this.marginLeft + this.offsetX + this.left;
        var q = this.marginTop + this.offsetY + this.top;
        this.smpInfo = [];
        this.varInfo = [];
        if (this.graphType == "Treemap") {
            return
        }
        if (this.smpTitle) {
            var s = this.smpTitleFontStyle + " " + (parseInt(this.smpTitleFontSize * this.smpTitleScaleFontFactor)) + "Pt " + this.fontName;
            if (this.graphOrientation == "vertical") {
                F = v + (this.x / 2);
                d = (q + this.y + this.bottom) - (this.margin + (parseInt(this.smpTitleFontSize * this.smpTitleScaleFontFactor) / 2));
                if (this.legendPosition == "bottom") {
                    d -= this.getLegendHeight()
                }
                this.drawText(this.smpTitle, F, d, s, this.smpTitleFontColor, "center", "middle")
            } else {
                F = this.marginLeft + this.offsetX + (parseInt(this.smpTitleFontSize * this.smpTitleScaleFontFactor) / 2);
                d = q + (this.y / 2);
                this.drawText(this.smpTitle, F, d, s, this.smpTitleFontColor, "center", "middle", -Math.PI / 2)
            }
        }
        var g = this.isGroupedData ? this.grpIndices : this.smpIndices;
        var r = this.isGroupedData ? this.data.w.smps : this.data.y.smps;
        if (this.graphType == "Heatmap") {
            if (this.showSampleNames) {
                var y = Math.abs(this.smpLabelRotate) == 90 ? "center" : "right";
                if (this.isGraphTime) {
                    var k = this.y / g.length;
                    var x = k / 2;
                    var o = q + x;
                    F = (v) - (this.margin * 2);
                    D = v + this.x + this.margin;
                    for (var z = 0; z < this.timeValueIndices.length; z++) {
                        d = (this.timeValueIndices[z] * k) + o;
                        this.smpInfo[z] = d;
                        if (this.smpLabelRotate) {
                            this.addArea(this.drawText(this.timeValues[z], F - this.margin, d, this.smpLabelFont, e, y, "middle", this.smpLabelRotate * Math.PI / 180), ["Smp-" + z])
                        } else {
                            this.addArea(this.drawText(this.timeValues[z], F, d, this.smpLabelFont, e, "right", "middle"), ["Smp-" + z])
                        } if (this.smpLabelDescription) {
                            var m = this.shortenText(this.data.x[this.smpLabelDescription][g[z]], this.maxSmpStringLen);
                            this.drawText(m, D, d, this.smpLabelFont, e, "right", "middle")
                        }
                    }
                } else {
                    F = v;
                    D = v + this.x + this.margin;
                    d = q + this.blockSeparation;
                    d -= this.blockSeparation / 2;
                    A = 1;
                    var f = this.getSmpOverlaysLength();
                    for (var z = 0; z < g.length; z++) {
                        var h = z / this.smpLabelInterval;
                        if (parseInt(h) == parseFloat(h)) {
                            var p = g[z];
                            var m = this.shortenText(r[p], this.maxSmpStringLen);
                            var B = (this.margin * 2) + f;
                            var e = this.getSmpColor(r[p]);
                            this.smpInfo[z] = d;
                            if (this.smpLabelRotate) {
                                this.addArea(this.drawText(m, F - (B + this.margin), d, this.smpLabelFont, e, y, "middle", this.smpLabelRotate * Math.PI / 180, false, false, true), ["Smp-" + p])
                            } else {
                                this.addArea(this.drawText(m, F - B, d, this.smpLabelFont, e, "right", "middle", false, false, false, true), ["Smp-" + p])
                            } if (this.smpLabelDescription) {
                                var m = this.shortenText(this.data.x[this.smpLabelDescription][p], this.maxSmpStringLen);
                                this.drawText(m, D, d, this.smpLabelFont, e, "left", "middle")
                            }
                        }
                        d += this.rowBlockSize
                    }
                }
            }
            if (this.showVariableNames) {
                var x = this.colBlockSize / 2;
                F = v + x;
                if (this.varTitleLabelOverlayPosition != "bottom") {
                    var y = Math.abs(this.varLabelRotate) == 90 ? "center" : "left";
                    d = q;
                    d -= (this.margin + this.getVarOverlaysHeight() + this.margin);
                    c = q + this.y + this.margin;
                    for (var z = 0; z < this.varIndices.length; z++) {
                        var h = z / this.varLabelInterval;
                        if (parseInt(h) == parseFloat(h)) {
                            var p = this.varIndices[z];
                            var u = this.shortenText(this.data.y.vars[p], this.maxVarStringLen);
                            var e = this.getVarColor(this.data.y.vars[p]);
                            this.varInfo[z] = F;
                            if (this.varLabelRotate) {
                                this.addArea(this.drawText(u, F, d + this.margin, this.varLabelFont, e, y, "middle", -Math.PI / 2 + (this.varLabelRotate * Math.PI / 180), false, false, true), ["Var-" + p])
                            } else {
                                this.addArea(this.drawText(u, F, d, this.varLabelFont, e, "left", "middle", -Math.PI / 2, false, false, true), ["Var-" + p])
                            } if (this.varLabelDescription) {
                                var u = this.shortenText(this.data.z[this.varLabelDescription][p], this.maxVarStringLen);
                                this.drawText(u, F, c, this.varLabelFont, e, "right", "middle", -Math.PI / 2)
                            }
                        }
                        F += this.colBlockSize
                    }
                } else {
                    var y = Math.abs(this.varLabelRotate) == 90 ? "center" : "right";
                    d = q + this.y + this.margin;
                    if (this.varOverlays.length > 0 && this.showOverlays) {
                        d += (this.varOverlays.length * this.overlaysWidth) + (this.margin * 2)
                    }
                    c = q - this.margin;
                    for (var z = 0; z < this.varIndices.length; z++) {
                        var h = z / this.varLabelInterval;
                        if (parseInt(h) == parseFloat(h)) {
                            var p = this.varIndices[z];
                            var u = this.shortenText(this.data.y.vars[p], this.maxVarStringLen);
                            var e = this.getVarColor(this.data.y.vars[p]);
                            this.varInfo[z] = F;
                            if (this.varLabelRotate) {
                                this.addArea(this.drawText(u, F, d, this.varLabelFont, e, y, "top", -Math.PI / 2 + (this.varLabelRotate * Math.PI / 180), false, false, true), ["Var-" + p])
                            } else {
                                this.addArea(this.drawText(u, F, d, this.varLabelFont, e, "right", "middle", -Math.PI / 2, false, false, true), ["Var-" + p])
                            } if (this.varLabelDescription) {
                                var u = this.shortenText(this.data.z[this.varLabelDescription][p], this.maxVarStringLen);
                                this.drawText(u, F, c, this.varLabelFont, e, "left", "middle", -Math.PI / 2)
                            }
                        }
                        F += this.colBlockSize
                    }
                } if (this.varTitle) {
                    var s = this.varTitleFontStyle + " " + (parseInt(this.varTitleFontSize * this.varTitleScaleFontFactor)) + "Pt " + this.fontName;
                    F = v + (this.x / 2);
                    if (this.varTitleLabelOverlayPosition != "bottom") {
                        d = this.offsetY + (this.margin * 2) + this.top;
                        d -= this.getVariableLabelLength();
                        d -= this.getVarOverlaysHeight();
                        if (this.varDendrogramPosition == "top") {
                            d -= this.getVarTreeHeight()
                        }
                    } else {
                        d = q + this.y + this.bottom
                    }
                    this.drawText(this.varTitle, F, d, s, this.varTitleFontColor, "center", "bottom")
                }
            }
        } else {
            if (this.showSampleNames) {
                if (this.graphType == "BarLine" && this.data.a && this.data.y.desc[1]) {
                    var a = this.getVariablesVisibleByAxis("xAxis");
                    A = a.length
                } else {
                    if (this.graphType.match(/Stacked|Line|Area/)) {
                        A = 1
                    } else {
                        A = this.plotByVariable ? g.length : this.varIndices.length
                    }
                }
                n = A * this.rowBlockSize;
                if (this.graphOrientation == "vertical") {
                    var y = Math.abs(this.smpLabelRotate) == 90 ? "center" : "right";
                    if (this.isGraphTime) {
                        var k = this.plotByVariable ? this.x / this.varIndices.length : this.x / g.length;
                        var x = this.rowBlockSize / 2;
                        var o = this.graphType.match(/Area/) ? 0 : v + ((this.blockSeparation + n) / 2);
                        d = q + this.y + this.getSmpOverlaysLength() + this.margin + this.margin;
                        if (this.plotByVariable) {
                            F = o + x;
                            for (var z = 0; z < this.varIndices.length; z++) {
                                for (var w = 0; w < this.timeValueIndices.length; w++) {
                                    this.smpInfo[w] = F;
                                    if (this.smpLabelRotate) {
                                        this.addArea(this.drawText(this.timeValues[w], F, d + this.margin, this.smpLabelFont, e, y, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)), ["Smp-" + w])
                                    } else {
                                        this.addArea(this.drawText(this.timeValues[w], F, d, this.smpLabelFont, e, "right", "middle", -Math.PI / 2), ["Smp-" + w])
                                    }
                                    F += this.rowBlockSize
                                }
                                F += this.blockSeparation
                            }
                        } else {
                            for (var z = 0; z < this.timeValueIndices.length; z++) {
                                F = (this.timeValueIndices[z] * k) + o;
                                this.smpInfo[z] = F;
                                if (this.smpLabelRotate) {
                                    this.addArea(this.drawText(this.timeValues[z], F, d + this.margin, this.smpLabelFont, e, y, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)), ["Smp-" + z])
                                } else {
                                    this.addArea(this.drawText(this.timeValues[z], F, d, this.smpLabelFont, e, "right", "middle", -Math.PI / 2), ["Smp-" + z])
                                }
                            }
                        }
                    } else {
                        F = this.plotByVariable ? v + ((this.blockSeparation + this.rowBlockSize) / 2) : this.graphType.match(/Area/) ? v : v + ((this.blockSeparation + n) / 2);
                        d = q;
                        c = q + this.y;
                        b = c + this.getSmpOverlaysLength() + this.margin + this.margin;
                        if (this.plotByVariable) {
                            for (var z = 0; z < this.varIndices.length; z++) {
                                for (var w = 0; w < g.length; w++) {
                                    var h = w / this.smpLabelInterval;
                                    if (parseInt(h) == parseFloat(h)) {
                                        var E = g[w];
                                        var m = this.shortenText(r[E], this.maxSmpStringLen);
                                        var e = this.getSmpColor(r[E]);
                                        this.smpInfo[w] = F;
                                        if (this.smpLabelRotate) {
                                            this.addArea(this.drawText(m, F, b + this.margin, this.smpLabelFont, e, y, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180), false, false, true), ["Smp-" + E])
                                        } else {
                                            this.addArea(this.drawText(m, F, b, this.smpLabelFont, e, "right", "middle", -Math.PI / 2, false, false, true), ["Smp-" + E])
                                        }
                                    }
                                    F += this.rowBlockSize
                                }
                                F += this.blockSeparation
                            }
                        } else {
                            for (var z = 0; z < g.length; z++) {
                                var h = z / this.smpLabelInterval;
                                if (parseInt(h) == parseFloat(h)) {
                                    var p = g[z];
                                    var m = this.shortenText(r[p], this.maxSmpStringLen);
                                    var e = this.getSmpColor(r[p]);
                                    this.smpInfo[z] = F;
                                    if (this.smpLabelRotate) {
                                        this.addArea(this.drawText(m, F, b + this.margin, this.smpLabelFont, e, y, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180), false, false, true), ["Smp-" + p])
                                    } else {
                                        this.addArea(this.drawText(m, F, b, this.smpLabelFont, e, "right", "middle", -Math.PI / 2, false, false, true), ["Smp-" + p])
                                    }
                                }
                                F += this.blockSeparation + n
                            }
                        }
                    }
                } else {
                    var y = Math.abs(this.smpLabelRotate) == 90 ? "center" : "right";
                    if (this.isGraphTime) {
                        var k = this.plotByVariable ? this.y / this.varIndices.length : this.y / g.length;
                        var x = this.plotByVariable ? this.rowBlockSize / 2 : k / 2;
                        var o = this.graphType.match(/Area/) ? 0 : q + ((this.blockSeparation + n) / 2);
                        F = (v) - (this.margin * 2);
                        if (this.plotByVariable) {
                            d = o + x;
                            for (var z = 0; z < this.varIndices.length; z++) {
                                for (var w = 0; w < this.timeValueIndices.length; w++) {
                                    this.smpInfo[w] = F;
                                    if (this.smpLabelRotate) {
                                        this.addArea(this.drawText(this.timeValues[w], F - this.margin, d, this.smpLabelFont, e, y, "middle", this.smpLabelRotate * Math.PI / 180), ["Smp-" + w])
                                    } else {
                                        this.addArea(this.drawText(this.timeValues[w], F, d, this.smpLabelFont, e, "right", "middle"), ["Smp-" + w])
                                    }
                                    d += this.rowBlockSize
                                }
                                d += this.blockSeparation
                            }
                        } else {
                            for (var z = 0; z < this.timeValueIndices.length; z++) {
                                d = (this.timeValueIndices[z] * k) + o;
                                this.smpInfo[z] = d;
                                if (this.smpLabelRotate) {
                                    this.addArea(this.drawText(this.timeValues[z], F - this.margin, d, this.smpLabelFont, e, y, "middle", this.smpLabelRotate * Math.PI / 180), ["Smp-" + z])
                                } else {
                                    this.addArea(this.drawText(this.timeValues[z], F, d, this.smpLabelFont, e, "right", "middle"), ["Smp-" + z])
                                }
                            }
                        }
                    } else {
                        F = v;
                        D = v + this.x;
                        C = F - (this.getSmpOverlaysLength() + (this.margin * 2));
                        d = this.plotByVariable ? q + ((this.blockSeparation + this.rowBlockSize) / 2) : this.graphType.match(/Area/) ? q : q + ((this.blockSeparation + n) / 2);
                        if (this.plotByVariable) {
                            for (var z = 0; z < this.varIndices.length; z++) {
                                for (var w = 0; w < g.length; w++) {
                                    var h = w / this.smpLabelInterval;
                                    if (parseInt(h) == parseFloat(h)) {
                                        var E = g[w];
                                        var m = this.shortenText(r[E], this.maxSmpStringLen);
                                        var e = this.getSmpColor(r[E]);
                                        this.smpInfo[w] = d;
                                        if (this.smpLabelRotate) {
                                            this.addArea(this.drawText(m, C - this.margin, d, this.smpLabelFont, e, y, "middle", this.smpLabelRotate * Math.PI / 180, false, false, true), ["Smp-" + p])
                                        } else {
                                            this.addArea(this.drawText(m, C, d, this.smpLabelFont, e, "right", "middle", false, false, false, true), ["Smp-" + p])
                                        }
                                    }
                                    d += this.rowBlockSize
                                }
                                d += this.blockSeparation
                            }
                        } else {
                            for (var z = 0; z < g.length; z++) {
                                var h = z / this.smpLabelInterval;
                                if (parseInt(h) == parseFloat(h)) {
                                    var p = g[z];
                                    var m = this.shortenText(r[p], this.maxSmpStringLen);
                                    var e = this.getSmpColor(r[p]);
                                    this.smpInfo[z] = d;
                                    if (this.smpLabelRotate) {
                                        this.addArea(this.drawText(m, C - this.margin, d, this.smpLabelFont, e, y, "middle", this.smpLabelRotate * Math.PI / 180, false, false, true), ["Smp-" + p])
                                    } else {
                                        this.addArea(this.drawText(m, C, d, this.smpLabelFont, e, "right", "middle", false, false, false, true), ["Smp-" + p])
                                    }
                                }
                                d += this.blockSeparation + n
                            }
                        }
                    }
                }
            }
        } if (this.showOverlays) {
            this.validateOverlays();
            if (this.smpOverlays.length > 0) {
                var g = this.isGroupedData ? this.grpIndices : this.smpIndices;
                n = A * this.rowBlockSize;
                if (this.graphOrientation == "vertical") {
                    F = v;
                    D = n;
                    c = this.overlaysWidth;
                    if (this.graphType != "Heatmap") {
                        D += this.blockSeparation
                    }
                    for (var z = 0; z < g.length; z++) {
                        var p = g[z];
                        d = q + this.y + this.margin;
                        for (var w = 0; w < this.smpOverlays.length; w++) {
                            var f = this.smpOverlays[w];
                            if (f != "-") {
                                var G = this.isGroupedData ? this.data.w.factors[f][g[z]] : this.data.x[f][g[z]];
                                var e = G != null ? this.smpOverlayColors[f][G.toString()] : this.missingDataColor;
                                this.addArea(this.rectangle(F, d, D, c, e), ["SmpOvr-" + p + "-" + w]);
                                if (n > this.overlaysWidth) {
                                    this.drawText(this.shortenText(G, this.overlayFontSize, n), F + (D / 2), d + (c / 2), this.overlayFont, this.overlayFontColor, "center", "middle", false, n - 2)
                                } else {
                                    this.drawText(this.shortenText(G, this.overlayFontSize, this.overlaysWidth), F + (D / 2), d + (c / 2), this.overlayFont, this.overlayFontColor, "center", "middle", -Math.PI / 2, this.overlaysWidth - 2)
                                }
                            }
                            d += c
                        }
                        F += D
                    }
                    F = v + this.x + this.margin;
                    d = q + this.y + this.margin + (c / 2);
                    for (var z = 0; z < this.smpOverlays.length; z++) {
                        if (this.smpOverlays[z] != "-") {
                            this.drawText(this.smpOverlays[z], F, d, this.overlayFont, this.overlayFontColor, "left", "middle", false, n * 2)
                        }
                        d += c
                    }
                } else {
                    D = this.overlaysWidth;
                    d = q;
                    c = n;
                    if (this.graphType != "Heatmap") {
                        c += this.blockSeparation
                    }
                    for (var z = 0; z < g.length; z++) {
                        var p = g[z];
                        F = v - (this.margin + (this.smpOverlays.length * this.overlaysWidth) + this.margin);
                        for (var w = 0; w < this.smpOverlays.length; w++) {
                            var f = this.smpOverlays[w];
                            if (f != "-") {
                                var G = this.isGroupedData ? this.data.w.factors[f][g[z]] : this.data.x[f][g[z]];
                                var e = G != null ? this.smpOverlayColors[f][G.toString()] : this.missingDataColor;
                                this.addArea(this.rectangle(F, d, D, c, e), ["SmpOvr-" + p + "-" + w]);
                                if (this.showLevelOverlays) {
                                    if (n > this.overlaysWidth) {
                                        this.drawText(this.shortenText(G, this.overlayFontSize, n), F + (D / 2), d + (c / 2), this.overlayFont, this.overlayFontColor, "center", "middle", -Math.PI / 2, n - 2)
                                    } else {
                                        this.drawText(this.shortenText(G, this.overlayFontSize, this.overlaysWidth), F + (D / 2), d + (c / 2), this.overlayFont, this.overlayFontColor, "center", "middle", false, this.overlaysWidth - 2)
                                    }
                                }
                            }
                            F += D
                        }
                        d += c
                    }
                    F = (v + (D / 2)) - (this.margin + (this.smpOverlays.length * this.overlaysWidth) + this.margin);
                    d = q + this.y + this.margin;
                    if (this.graphType == "Heatmap") {
                        d += this.margin
                    }
                    for (var z = 0; z < this.smpOverlays.length; z++) {
                        if (this.smpOverlays[z] != "-") {
                            this.drawText(this.smpOverlays[z], F, d, this.overlayFont, this.overlayFontColor, "right", "middle", -Math.PI / 2, n * 2)
                        }
                        F += D
                    }
                }
            }
            if (this.varOverlays.length > 0 && this.graphType == "Heatmap") {
                F = v + (this.colBlockSize / 2);
                c = this.overlaysWidth;
                for (var z = 0; z < this.varIndices.length; z++) {
                    var p = this.varIndices[z];
                    if (this.varTitleLabelOverlayPosition != "bottom") {
                        d = q - (this.margin + (this.overlaysWidth * this.varOverlays.length))
                    } else {
                        d = q + this.y + this.margin
                    }
                    for (var w = 0; w < this.varOverlays.length; w++) {
                        var f = this.varOverlays[w];
                        if (f != "-") {
                            var G = this.data.z[f][this.varIndices[z]];
                            var e = G != null ? this.varOverlayColors[f][G.toString()] : this.missingDataColor;
                            this.addArea(this.rectangle(F - (this.colBlockSize / 2), d, this.colBlockSize, c, e), ["VarOvr-" + p + "-" + w]);
                            if (this.showLevelOverlays) {
                                if (this.colBlockSize > this.overlaysWidth) {
                                    this.drawText(this.shortenText(G, this.overlayFontSize, this.colBlockSize), F, d + (c / 2), this.overlayFont, this.overlayFontColor, "center", "middle", false, this.colBlockSize - 2)
                                } else {
                                    this.drawText(this.shortenText(G, this.overlayFontSize, this.overlaysWidth), F, d + (c / 2), this.overlayFont, this.overlayFontColor, "center", "middle", -Math.PI / 2, this.overlaysWidth - 2)
                                }
                            }
                        }
                        d += this.overlaysWidth
                    }
                    F += this.colBlockSize
                }
                F = v + this.x + this.margin;
                if (this.varTitleLabelOverlayPosition != "bottom") {
                    d = (q + (c / 2)) - (this.margin + (this.overlaysWidth * this.varOverlays.length))
                } else {
                    d = q + this.y + this.margin + (c / 2)
                }
                for (var z = 0; z < this.varOverlays.length; z++) {
                    if (this.varOverlays[z] != "-") {
                        this.drawText(this.varOverlays[z], F, d, this.overlayFont, this.overlayFontColor, "left", "middle", false, this.colBlockSize * 2)
                    }
                    d += c
                }
            }
        }
    };
    this.validateOverlays = function() {
        var c = [];
        if (this.smpOverlays.length > 0) {
            for (var b = 0; b < this.smpOverlays.length; b++) {
                if (this.data.x.hasOwnProperty(this.smpOverlays[b]) || this.smpOverlays[b] == "-") {
                    c.push(this.smpOverlays[b])
                }
            }
            this.smpOverlays = c
        }
        var a = [];
        if (this.varOverlays.length > 0 && !this.isGroupedData) {
            for (var b = 0; b < this.varOverlays.length; b++) {
                if (this.data.z.hasOwnProperty(this.varOverlays[b]) || this.varOverlays[b] == "-") {
                    a.push(this.varOverlays[b])
                }
            }
            this.varOverlays = a
        }
    };
    this.draw1DXLayout = function() {
        var d = this.marginLeft + this.offsetX + this.left;
        var m = this.marginTop + this.offsetY + this.top;
        if (this.graphType == "Treemap") {
            return
        }
        if (!this.layoutValid) {
            this.layoutAxis = 3
        }
        if (this.graphType == "Heatmap") {
            var b = (d + (this.x / 2)) - (this.heatmapColors.length * this.indicatorWidth / 2);
            var k = m - this.getHeatmapIndicatorHeight();
            if (this.varDendrogramPosition == "top") {
                k -= this.getVarTreeHeight()
            }
            if (this.varTitleLabelOverlayPosition != "bottom") {
                k -= this.getVariableTitleHeight();
                k -= this.getVariableLabelLength();
                k -= this.getVarOverlaysHeight()
            } else {
                k -= this.getVariableLabelDescLength()
            }
            this.drawColorIndicator(b, k, this.minData, this.maxData, this.xAxisDecs, true);
            if (this.data.y.desc && this.data.y.desc[0]) {
                b = (d + (this.x / 2));
                k += (this.margin * 2) + (this.getFontPt(this.legendFont) * 1.5) + this.indicatorHeight;
                this.drawText(this.data.y.desc[0], b, k, this.legendFont, this.legendFontColor, "center", "middle")
            }
        } else {
            var f;
            var j;
            if (this.graphOrientation == "vertical") {
                if (this.xAxisShow && (this.layoutAxis == 1 || this.layoutAxis == 3)) {
                    var b = this.marginLeft + this.offsetX + this.margin + (this.getFontPt(this.axisTitleFont) / 2);
                    var k = m + (this.y / 2);
                    f = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Title : this.xAxisTitle ? this.xAxisTitle : this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "";
                    if (this.graphType.match(/BarLine|StackedLine|StackedPercentLine/) && this.data.a && this.data.y.desc && this.data.y.desc[1]) {
                        this.drawText(f + " (Bars)", b, k, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2)
                    } else {
                        if (this.graphType == "AreaLine" && this.data.a && this.data.y.desc && this.data.y.desc[1]) {
                            this.drawText(f + " (Area)", b, k, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2)
                        } else {
                            this.drawText(f, b, k, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2)
                        }
                    }
                    var g = Math.abs(this.tickRotate) == 90 ? "center" : "right";
                    j = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Values : this.xAxisValues;
                    b = d - (this.margin * 2);
                    for (var e = 0; e < j.length - 1; e++) {
                        var c = parseFloat(j[e]);
                        var h = this.formatAxisValue(c, "xAxis");
                        k = this.graphType == "Candlestick" && this.summaryType == "volume" ? m + this.y - ((c - this.xAxis2Min) * this.xAxis2Unit) : m + this.y - ((c - this.xAxisMin) * this.xAxisUnit);
                        if (this.tickRotate) {
                            this.drawText(h, b, k, this.axisTickFont, this.axisTickColor, g, "middle", this.tickRotate * Math.PI / 180)
                        } else {
                            this.drawText(h, b, k, this.axisTickFont, this.axisTickColor, "right", "middle")
                        }
                    }
                }
                if (this.xAxis2Show && (this.layoutAxis == 2 || this.layoutAxis == 3)) {
                    var g = Math.abs(this.tickRotate) == 90 ? "center" : "left";
                    b = d + this.x + (this.margin * 2);
                    if (this.graphType.match(/BarLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a && this.data.y.desc && this.data.y.desc[1]) {
                        for (var e = 0; e < this.xAxis2Values.length - 1; e++) {
                            var c = parseFloat(this.xAxis2Values[e]);
                            var h = this.formatAxisValue(c, "xAxis2");
                            k = m + this.y - ((c - this.xAxis2Min) * this.xAxis2Unit);
                            if (this.tickRotate) {
                                this.drawText(h, b, k, this.axisTickFont, this.axisTickColor, g, "middle", this.tickRotate * Math.PI / 180)
                            } else {
                                this.drawText(h, b, k, this.axisTickFont, this.axisTickColor, "left", "middle")
                            }
                        }
                        f = this.xAxis2Title ? this.xAxis2Title + " (Lines)" : this.data.y.desc && this.data.y.desc[1] ? this.data.y.desc[1] + " (Lines)" : ""
                    } else {
                        j = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Values : this.xAxisValues;
                        for (var e = 0; e < j.length - 1; e++) {
                            var c = parseFloat(j[e]);
                            var h = this.formatAxisValue(c, "xAxis");
                            k = this.graphType == "Candlestick" && this.summaryType == "volume" ? m + this.y - ((c - this.xAxis2Min) * this.xAxis2Unit) : m + this.y - ((c - this.xAxisMin) * this.xAxisUnit);
                            if (this.tickRotate) {
                                this.drawText(h, b, k, this.axisTickFont, this.axisTickColor, g, "middle", this.tickRotate * Math.PI / 180)
                            } else {
                                this.drawText(h, b, k, this.axisTickFont, this.axisTickColor, "left", "middle")
                            }
                        }
                        f = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Title : this.xAxisTitle ? this.xAxisTitle : this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : ""
                    }
                    b = (d + this.x + this.right) - (this.margin + (this.getFontPt(this.axisTitleFont) / 2));
                    if (this.showLegend && this.legendPosition == "right") {
                        b -= this.getLegendWidth()
                    }
                    k = m + (this.y / 2);
                    this.drawText(f, b, k, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2)
                }
            } else {
                if (this.xAxisShow && (this.layoutAxis == 1 || this.layoutAxis == 3)) {
                    var b = d + (this.x / 2);
                    var k = m - ((this.margin * 4) + this.getFontPt(this.axisTickFont) + (this.getFontPt(this.axisTitleFont) / 2));
                    f = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Title : this.xAxisTitle ? this.xAxisTitle : this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "";
                    if (this.graphType.match(/BarLine|StackedLine|StackedPercentLine/) && this.data.a && this.data.y.desc && this.data.y.desc[1]) {
                        this.drawText(f + " (Bars)", b, k, this.axisTitleFont, this.axisTitleColor, "center", "middle")
                    } else {
                        if (this.graphType == "AreaLine" && this.data.a && this.data.y.desc && this.data.y.desc[1]) {
                            this.drawText(f + " (Area)", b, k, this.axisTitleFont, this.axisTitleColor, "center", "middle")
                        } else {
                            this.drawText(f, b, k, this.axisTitleFont, this.axisTitleColor, "center", "middle")
                        }
                    }
                    j = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Values : this.xAxisValues;
                    k = m - ((this.margin * 2) + (this.getFontPt(this.axisTickFont) / 2));
                    for (var e = 0; e < j.length - 1; e++) {
                        var c = parseFloat(j[e]);
                        var h = this.formatAxisValue(c, "xAxis");
                        b = this.graphType == "Candlestick" && this.summaryType == "volume" ? d + ((c - this.xAxis2Min) * this.xAxis2Unit) : d + ((c - this.xAxisMin) * this.xAxisUnit);
                        if (this.tickRotate) {
                            this.drawText(h, b, k, this.axisTickFont, this.axisTickColor, "center", "middle", this.tickRotate * Math.PI / 180)
                        } else {
                            this.drawText(h, b, k, this.axisTickFont, this.axisTickColor, "center", "middle")
                        }
                    }
                }
                if (this.xAxis2Show && (this.layoutAxis == 2 || this.layoutAxis == 3)) {
                    k = m + this.y + (this.margin * 2) + (this.getFontPt(this.axisTickFont) / 2);
                    if (this.graphType.match(/BarLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a && this.data.y.desc && this.data.y.desc[1]) {
                        for (var e = 0; e < this.xAxis2Values.length - 1; e++) {
                            var c = parseFloat(this.xAxis2Values[e]);
                            var h = this.formatAxisValue(c, "xAxis2");
                            b = d + ((c - this.xAxis2Min) * this.xAxis2Unit);
                            this.drawText(h, b, k, this.axisTickFont, this.axisTickColor, "center", "middle")
                        }
                        f = this.xAxis2Title ? this.xAxis2Title + " (Lines)" : this.data.y.desc && this.data.y.desc[1] ? this.data.y.desc[1] + " (Lines)" : ""
                    } else {
                        j = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Values : this.xAxisValues;
                        for (var e = 0; e < j.length - 1; e++) {
                            var c = parseFloat(j[e]);
                            var h = this.formatAxisValue(c, "xAxis");
                            b = this.graphType == "Candlestick" && this.summaryType == "volume" ? d + ((c - this.xAxis2Min) * this.xAxis2Unit) : d + ((c - this.xAxisMin) * this.xAxisUnit);
                            if (this.tickRotate) {
                                this.drawText(h, b, k, this.axisTickFont, this.axisTickColor, "center", "middle", this.tickRotate * Math.PI / 180)
                            } else {
                                this.drawText(h, b, k, this.axisTickFont, this.axisTickColor, "center", "middle")
                            }
                        }
                        f = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Title : this.xAxisTitle ? this.xAxisTitle : this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : this.yAxisTitle ? this.yAxisTitle : ""
                    }
                    b = d + (this.x / 2);
                    k = m + this.y + (this.margin * 4) + this.getFontPt(this.axisTickFont) + (this.getFontPt(this.axisTitleFont) / 2);
                    this.drawText(f, b, k, this.axisTitleFont, this.axisTitleColor, "center", "middle")
                }
            }
            var a = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.xAxisTickColor;
            this.disableGradientTransparencyShadow();
            this.rectangle(d, m, this.x, this.y, false, a, "open", false, this.outlineWidth);
            this.enableGradientTransparencyShadow()
        }
    };
    this.draw1DDataPoints = function() {
        switch (this.graphType) {
            case "Bar":
                this.draw1DBarDataPoints(this.varIndices, "xAxis");
                return true;
            case "Line":
                this.draw1DLineDataPoints(this.varIndices, "xAxis");
                return true;
            case "BarLine":
                this.draw1DBarDataPoints(this.xAxisVarIndices, "xAxis");
                this.draw1DLineDataPoints(this.xAxis2VarIndices, "xAxis2");
                return true;
            case "Stacked":
            case "StackedPercent":
                this.draw1DStackedDataPoints();
                return true;
            case "StackedLine":
            case "StackedPercentLine":
                this.draw1DStackedDataPoints();
                this.draw1DLineDataPoints(this.xAxis2VarIndices, "xAxis2");
                return true;
            case "Area":
                this.draw1DAreaDataPoints(this.varIndices, "xAxis");
                return true;
            case "AreaLine":
                this.draw1DAreaDataPoints(this.xAxisVarIndices, "xAxis");
                this.draw1DAreaDataPoints(this.xAxis2VarIndices, "xAxis2", true);
                return true;
            case "Boxplot":
                if (this.showBoxplotOriginalData) {
                    this.draw1DDotplotDataPoints(true, true);
                    this.draw1DBoxplotDataPoints(true, true)
                } else {
                    this.draw1DBoxplotDataPoints()
                }
                return true;
            case "Candlestick":
                this.draw1DCandlestickDataPoints();
                return true;
            case "Dotplot":
                this.draw1DDotplotDataPoints();
                return true;
            case "Heatmap":
                this.draw1DHeatmapDataPoints();
                return true;
            case "Treemap":
                this.draw1DTreemapDataPoints();
                return true
        }
        throw 'Illegal graph type "' + this.graphType + '"'
    };
    this.draw1DBarDataPoints = function(B, A) {
        var f = this.isGroupedData ? this.grpIndices : this.smpIndices;
        var D = f.length;
        var w = this.xAxisMin < 0 ? Math.abs(this.xAxisMin) * this.xAxisUnit : 0;
        var h = this.marginLeft + this.offsetX + this.left;
        var C = this.marginTop + this.offsetY + this.top;
        var g = this.plotByVariable ? this.rowBlockSize : this.blockSeparation + (this.rowBlockSize * B.length);
        if (this.graphOrientation == "vertical") {
            h += this.blockSeparation / 2;
            C = (C + this.y) - w
        } else {
            h += w;
            C += this.blockSeparation / 2
        }
        for (var o = 0; o < B.length; o++) {
            var r = [];
            var q = [];
            var u = [];
            var y = [];
            var b = [];
            for (var k = 0; k < D; k++) {
                u.push(this.colorBy && this.legendColorsN ? this.dataColors[this.colorByType == "x" ? k : o] : this.getColor(this.data.y.vars[B[o]]));
                b.push(this.colorBy && this.legendColorsN ? "closed" : this.coordinateLineColor ? "closed" : this.getPattern(this.data.y.vars[B[o]]));
                r.push(this.getDataAtPos(B[o], f[k]));
                if (this.isGroupedData || this.data.y.hasOwnProperty("stdev")) {
                    q.push(this.getDataAtPos(B[o], f[k], "stdev"))
                }
                y.push([B[o], f[k]])
            }
            this.drawBarPlot(r, q, h, C, this.rowBlockSize, g, this[A + "Unit"], w, this[A + "Min"], this.graphOrientation, u, b, y);
            if (this.graphOrientation == "vertical") {
                h = this.plotByVariable ? h + (this.blockSeparation + (this.rowBlockSize * D)) : h + this.rowBlockSize
            } else {
                C = this.plotByVariable ? C + (this.blockSeparation + (this.rowBlockSize * D)) : C + this.rowBlockSize
            }
        }
    };
    this.draw1DLineDataPoints = function(F, E) {
        var k = this.isGroupedData ? this.grpIndices : this.smpIndices;
        var H = k.length;
        var w = this.marginLeft + this.offsetX + this.left;
        var G = this.marginTop + this.offsetY + this.top;
        var b = this.graphType == "BarLine" ? true : false;
        var h = b ? this.blockSeparation + (this.xAxisVarIndices.length * this.rowBlockSize) : this.blockSeparation + this.rowBlockSize;
        var u = ((this.blockSeparation + this.rowBlockSize) / 2);
        if (this.graphOrientation == "vertical") {
            w += u;
            G += this.y
        } else {
            G += u
        }
        for (var z = 0; z < F.length; z++) {
            var B = [];
            var A = [];
            var C = this.coordinateLineColor ? this.colors[z % this.colors.length] : this.getColor(this.data.y.vars[F[z]]);
            var g = this.lineDecoration == "symbol" ? this.shapes[z % this.shapes.length] : "sphere";
            var f = this.coordinateLineColor ? "closed" : this.getPattern(this.data.y.vars[F[z]]);
            var D = [];
            for (var y = 0; y < H; y++) {
                B.push(this.getDataAtPos(F[z], k[y]));
                if (this.isGroupedData || this.data.y.hasOwnProperty("stdev")) {
                    A.push(this.getDataAtPos(F[z], k[y], "stdev"))
                }
                D.push([F[z], k[y]])
            }
            this.drawLinePlot(B, A, w, G, this.rowBlockSize, h, this[E + "Unit"], this[E + "Min"], this.graphOrientation, C, f, g, D);
            if (b && this.xAxisVarIndices.length == this.xAxis2VarIndices.length) {
                if (this.graphOrientation == "vertical") {
                    w += this.rowBlockSize
                } else {
                    G += this.rowBlockSize
                }
            }
        }
    };
    this.draw1DStackedDataPoints = function() {
        var f = this.isGroupedData ? this.grpIndices : this.smpIndices;
        var D = f.length;
        var k = this.marginLeft + this.offsetX + this.left;
        var C = this.marginTop + this.offsetY + this.top;
        var h = this.blockSeparation + this.rowBlockSize;
        var B = this.graphType.match(/Line/) ? this.xAxisVarIndices : this.varIndices;
        var A = this.graphType == "StackedPercentLine" ? this.xAxisVarIndices : false;
        var e = this.graphType.match(/Percent/) ? true : false;
        if (this.graphOrientation == "vertical") {
            k += this.blockSeparation / 2;
            C += this.y
        } else {
            C += this.blockSeparation / 2
        }
        for (var r = 0; r < D; r++) {
            var u = this.sum(this.getDataForSmpGrpAtIndex(f[r], A));
            var x = [];
            var y = [];
            var b = [];
            var z = [];
            for (var o = 0; o < B.length; o++) {
                x.push(this.getDataAtPos(B[o], f[r]));
                y.push(this.getColor(this.data.y.vars[B[o]]));
                b.push(this.getPattern(this.data.y.vars[B[o]]));
                z.push([B[o], f[r]])
            }
            this.drawStackedPlot(x, k, C, this.rowBlockSize, e, u, this.xAxisUnit, this.graphOrientation, y, b, z);
            if (this.graphOrientation == "vertical") {
                k += h
            } else {
                C += h
            }
        }
    };
    this.draw1DAreaDataPoints = function(D, C, u) {
        var g = this.isGroupedData ? this.grpIndices : this.smpIndices;
        var F = g.length;
        var k = this.marginLeft + this.offsetX + this.left;
        var E = this.marginTop + this.offsetY + this.top;
        var h = this.rowBlockSize + this.blockSeparation;
        var w = [];
        var A = [];
        var e = [];
        var B = [];
        if (this.graphOrientation == "vertical") {
            E += this.y
        }
        for (var r = 0; r < D.length; r++) {
            var y = [];
            var b = C == "xAxis" || this.coordinateLineColor ? this.colors[r % this.colors.length] : this.getColor(this.data.y.vars[D[r]]);
            for (var o = 0; o < F; o++) {
                y.push(this.getDataAtPos(D[r], g[o]))
            }
            w.push(y);
            A.push(b);
            e.push(this.coordinateLineColor || this.gradient ? "closed" : this.getPattern(this.data.y.vars[D[r]]));
            B.push([D[r]])
        }
        this.drawAreaPlot(w, k, E, this.x, this.y, h, this[C + "Unit"], this[C + "Min"], this.graphOrientation, u, A, e, B)
    };
    this.draw1DBoxplotDataPoints = function(g, D) {
        var x = this.isGroupedData ? this.grpIndices : this.smpIndices;
        var h = x.length;
        var e = this.varIndices;
        var A = this.marginLeft + this.offsetX + this.left;
        var f = this.marginTop + this.offsetY + this.top;
        var y = this.plotByVariable ? this.rowBlockSize : this.blockSeparation + (this.rowBlockSize * e.length);
        if (this.graphOrientation == "vertical") {
            A += this.blockSeparation / 2;
            f += this.y
        } else {
            f += this.blockSeparation / 2
        }
        for (var E = 0; E < e.length; E++) {
            var F = [];
            var G = [];
            var u = [];
            var H = [];
            for (var C = 0; C < h; C++) {
                var q = ["iqr1", "iqr3", "qtl1", "qtl3", "median", "out"];
                var b = [];
                var w = this.colorBy && this.legendColorsN ? this.dataColors[this.colorByType == "x" ? C : E] : this.getColor(this.data.y.vars[e[E]]);
                for (var B = 0; B < q.length; B++) {
                    b.push(this.getDataAtPos(e[E], x[C], q[B]))
                }
                if (D) {
                    b[5] = false
                }
                F.push(b);
                G.push(g ? this.foreground : w);
                u.push(g ? "open" : this.getPattern(this.data.y.vars[e[E]]));
                H.push([e[E], x[C]])
            }
            this.drawBoxPlot(F, A, f, this.rowBlockSize, y, this.xAxisUnit, this.xAxisMin, this.graphOrientation, G, u, H);
            if (this.graphOrientation == "vertical") {
                A = this.plotByVariable ? A + (this.blockSeparation + (this.rowBlockSize * h)) : A + this.rowBlockSize
            } else {
                f = this.plotByVariable ? f + (this.blockSeparation + (this.rowBlockSize * h)) : f + this.rowBlockSize
            }
        }
    };
    this.draw1DCandlestickDataPoints = function() {
        var B = this.isGroupedData ? this.grpIndices : this.smpIndices;
        var w = B.length;
        var g = this.varIndices;
        var D = this.marginLeft + this.offsetX + this.left;
        var q = this.marginTop + this.offsetY + this.top;
        var C = this.blockSeparation + (this.rowBlockSize * g.length);
        var A = this.summaryType == "candle" ? true : false;
        var o = A ? this.xAxisUnit : this.xAxis2Unit;
        var f = A ? this.xAxisMin : this.xAxis2Min;
        var H = this.rowBlockSize / 2;
        if (this.graphOrientation == "vertical") {
            D += this.blockSeparation / 2;
            q += this.y
        } else {
            q += this.blockSeparation / 2
        }
        for (var G = 0; G < g.length; G++) {
            var I = [];
            var J = this.colors[G % this.colors.length];
            var L = [];
            for (var F = 0; F < w; F++) {
                var y = A ? ["open", "close", "high", "low"] : ["volume"];
                var e = [];
                for (var E = 0; E < y.length; E++) {
                    e.push(this.getDataAtPos(g[G], B[F], y[E]))
                }
                I.push(e);
                L.push([g[G], B[F]])
            }
            this.drawCandlestickPlot(I, D, q, this.rowBlockSize, C, o, f, A, this.graphOrientation, J, L);
            if (this.stockIndicators.length > 0) {
                for (var F = 0; F < this.stockIndicators.length; F++) {
                    var K = this.getTechnicalIndicatorColor(this.stockIndicators[F]);
                    var I = [];
                    for (var E = 0; E < w; E++) {
                        I.push(this.getDataAtPos(g[G], B[E], this.stockIndicators[F]))
                    }
                    if (this.graphOrientation == "vertical") {
                        this.drawLinePlot(I, [], D + H, q, this.rowBlockSize, C, o, f, this.graphOrientation, K)
                    } else {
                        this.drawLinePlot(I, [], D, q + H, this.rowBlockSize, C, o, f, this.graphOrientation, K)
                    }
                }
            }
            if (this.graphOrientation == "vertical") {
                D += this.rowBlockSize
            } else {
                q += this.rowBlockSize
            }
        }
    };
    this.draw1DDotplotDataPoints = function(O, B) {
        var N = this.isGroupedData ? this.grpIndices : this.smpIndices;
        var I = N.length;
        var F = this.varIndices;
        var Q = this.marginLeft + this.offsetX + this.left;
        var H = this.marginTop + this.offsetY + this.top;
        var aa = ((this.blockSeparation + this.rowBlockSize) / 2);
        var P = this.plotByVariable ? this.rowBlockSize : this.blockSeparation + (this.rowBlockSize * F.length);
        var K = O ? this.getShapeSize() / this.boxplotDataPointRatio : this.getShapeSize();
        if (this.graphOrientation == "vertical") {
            Q += aa;
            H += this.y
        } else {
            H += aa
        }
        for (var T = 0; T < F.length; T++) {
            var Y = [];
            var X = [];
            var Z = [];
            var U = [];
            var L = [];
            var W = [];
            var ab = [];
            var V = 0;
            var M;
            for (var S = 0; S < I; S++) {
                if (this.isGroupedData) {
                    var A = [];
                    var C = [];
                    var D = [];
                    var J = [];
                    var E = [];
                    var G = [];
                    for (var R = 0; R < this.data.w.grps[N[S]].length; R++) {
                        M = this.colorBy && this.legendColorsN ? this.dataColors[this.colorByType == "x" ? V : T] : this.getColor(this.data.y.vars[F[T]]);
                        A.push(this.data.y.data[F[T]][this.data.w.grps[N[S]][R]]);
                        E.push(this.shapeBy && this.legendShapesN ? this.dataShapes[this.shapeByType == "x" ? V : T] : this.shapes[parseInt(T / this.colors.length)]);
                        C.push(this.sizeBy && this.legendSizesN ? this.dataSizes[this.sizeByType == "x" ? V : T] : K);
                        D.push(O ? this.addColorTransparency(M, this.boxplotDataPointTransparency) : M);
                        J.push(B ? "closed" : this.getPattern(this.data.y.vars[F[T]]));
                        G.push([F[T], N[S], this.data.w.grps[N[S]][R]]);
                        V++
                    }
                    Y.push(A);
                    L.push(E);
                    W.push(C);
                    Z.push(D);
                    U.push(J);
                    ab.push(G)
                } else {
                    M = this.colorBy && this.legendColorsN ? this.dataColors[this.colorByType == "x" ? S : T] : this.getColor(this.data.y.vars[F[T]]);
                    Y.push([this.getDataAtPos(F[T], N[S])]);
                    if (this.data.y.hasOwnProperty("stdev")) {
                        X.push(this.getDataAtPos(F[T], N[S], "stdev"))
                    }
                    L.push(this.shapeBy && this.legendShapesN ? [this.dataShapes[this.shapeByType == "x" ? S : T]] : [this.shapes[parseInt(T / this.colors.length)]]);
                    W.push(this.sizeBy && this.legendSizesN ? [this.dataSizes[this.sizeByType == "x" ? S : T]] : [K]);
                    Z.push([O ? this.addColorTransparency(M, this.boxplotDataPointTransparency) : M]);
                    U.push([B ? "closed" : this.getPattern(this.data.y.vars[F[T]])]);
                    ab.push([
                        [F[T], N[S]]
                    ])
                }
            }
            if (this.plotByVariable) {
                this.drawDotPlot(Y, X, Q, H, this.rowBlockSize, this.rowBlockSize, P, this.xAxisUnit, this.xAxisMin, W, this.graphOrientation, Z, U, L, K, ab)
            } else {
                this.drawDotPlot(Y, X, Q, H, this.rowBlockSize, this.blockSeparation, P, this.xAxisUnit, this.xAxisMin, W, this.graphOrientation, Z, U, L, K, ab)
            } if (this.graphOrientation == "vertical") {
                Q = this.plotByVariable ? Q + (this.blockSeparation + (this.rowBlockSize * I)) : Q + this.rowBlockSize
            } else {
                H = this.plotByVariable ? H + (this.blockSeparation + (this.rowBlockSize * I)) : H + this.rowBlockSize
            }
        }
    };
    this.draw1DHeatmapDataPoints = function() {
        var C = this.isGroupedData ? this.grpIndices : this.smpIndices;
        var z = C.length;
        var E = this.marginLeft + this.offsetX + this.left;
        var r = this.marginTop + this.offsetY + this.top;
        var I = this.varIndices.length * 5 > this.x ? true : false;
        var D = Math.max(Math.min(this.colBlockSize, this.rowBlockSize) - 10, 3);
        var F = this.dataSizes && this.dataSizes.length > 0 ? D / this.max(this.dataSizes) : 1;
        var A = this.outlineWidth;
        if (this.dataColors && this.dataColors.length > 0) {
            this.outlineWidth = 4
        }
        if (this.isMultidimensionalHeatmap) {
            var B = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
            for (var H = 0; H < this.varIndices.length; H++) {
                for (var G = 0; G < z; G++) {
                    var f = E + (H * this.colBlockSize) + (this.colBlockSize / 2);
                    var b = r + (G * this.rowBlockSize) + (this.rowBlockSize / 2);
                    var h = this.getDataAtPos(this.varIndices[H], C[G]);
                    var K = !isNaN(h) ? this.getHeatmapColor(this.minData, this.maxData, h) : this.missingDataColor;
                    B = this.dataColors && this.dataColors.length > 0 ? this.dataColors.shift() : I ? K : B;
                    var p = this.dataShapes && this.dataShapes.length > 0 ? this.dataShapes.shift() : this.shapeByShape ? this.shapeByShape : "rectangleHM";
                    var g = this.dataSizes && this.dataSizes.length > 0 ? (this.dataSizes.shift() * F) : D;
                    this.addArea(this.drawShape(p, f, b, g, g, K, B, "closed", false, false, true), [this.varIndices[H], C[G]]);
                    if (this.showDataValues) {
                        this.drawText(h, (f + (this.colBlockSize / 2)) - 2, (b + (this.rowBlockSize / 2)) - 2, this.overlayFont, this.foreground, "right", "bottom")
                    }
                }
            }
            this.outlineWidth = A;
            this.ctx.save()
        } else {
            for (var H = 0; H < z; H++) {
                var J = [];
                var L = [];
                for (var G = 0; G < this.varIndices.length; G++) {
                    J.push(this.getDataAtPos(this.varIndices[G], C[H]));
                    L.push([this.varIndices[G], C[H]])
                }
                this.drawHeatmap(J, E, r, this.colBlockSize, this.rowBlockSize, this.minData, this.maxData, I, L);
                r += this.rowBlockSize
            }
        }
    };
    this.draw1DTreemapDataPoints = function() {
        var b = this.marginLeft + this.offsetX + this.left;
        var c = this.marginTop + this.offsetY + this.top;
        var a = this.getTreemap();
        this.drawTreemap(a, b, c)
    };
    this.drawStockIndicatorsLegend = function() {
        var d = this.marginLeft + this.offsetX + this.left;
        var n = this.marginTop + this.offsetY + this.top;
        if (this.summaryType == "candle" && this.stockIndicators.length > 0) {
            var a = this.getFontPt(this.legendFont);
            var f = a / 2;
            var b = this.measureText(this.getMaxText(this.stockIndicators), this.legendFont) + a + (this.margin * 2);
            var k = this.graphOrientation == "vertical" ? d + (this.margin * 2) : d + this.x - b;
            var j = n + this.margin + a;
            for (var e = 0; e < this.stockIndicators.length; e++) {
                var g = this.getTechnicalIndicatorColor(this.stockIndicators[e]);
                this.drawLine("line", k + f, j + f, k + f + a, j + f, g, false, "butt", false, false, true);
                this.drawText(this.stockIndicators[e], k + a + this.margin, j + f, this.legendFont, g, "left", "middle");
                j += this.margin + a
            }
        }
    };
    this.draw1DLegend = function() {
        var r = this.marginLeft + this.offsetX + this.left;
        var k = this.marginTop + this.offsetY + this.top;
        var C = this.getFontPt(this.legendFont);
        var x = C / 2;
        var f = C * 2;
        if (this.layoutValid) {
            if (this.legendPosition == "bottom") {
                k += this.margin
            } else {
                r += this.margin
            }
        }
        this.drawStockIndicatorsLegend();
        if (this.showLegend && ((this.graphType != "Heatmap") || (this.graphType == "Heatmap" && this.isMultidimensionalHeatmap))) {
            if (this.isMultidimensionalHeatmap || ((this.colorBy || this.shapeBy || this.sizeBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap/))) {
                if (this.graphOrientation == "vertical") {
                    if (this.legendPosition == "right") {
                        var v = this.getAxisTitleTickLength();
                        var u = this.getAxisTitleTickLength(true);
                        r = Math.max(v, u);
                        k = 0;
                        if (r && !this.xAxis2Show) {
                            r = ((r / 2) - this.getFontPt(this.axisTitleFont)) - (this.margin * 0.5)
                        } else {
                            if (!this.xAxis2Show) {
                                r = this.margin * 1.5
                            } else {
                                r += this.margin
                            }
                        }
                    } else {
                        r = 0;
                        k = this.getSampleTitleHeight() + this.getSampleLabelLength() + this.getSmpOverlaysLength() + this.margin;
                        if (this.showSmpDendrogram && this.smpDendrogramPosition == "bottom") {
                            k += this.getSmpTreeWidthHeight()
                        }
                    }
                } else {
                    if (this.legendPosition == "right") {
                        r = this.margin;
                        if (this.showSmpDendrogram && this.smpDendrogramPosition == "right") {
                            r += this.getSmpTreeWidthHeight()
                        }
                        r += this.getVarOverlaysLength();
                        k = this.isMultidimensionalHeatmap && this.indicatorsPosition == "bottom" ? this.getVariableLabelLength() + this.margin : 0
                    } else {
                        r = 0;
                        k = Math.max(this.getAxisTitleTickLength(), this.getAxisTitleTickLength(true)) + this.margin
                    }
                }
                this.drawScatterLegend(r, k)
            } else {
                if (this.graphType == "BarLine" || this.graphType == "AreaLine" || this.graphType == "StackedLine" || this.graphType == "StackedPercentLine") {
                    var m = this.maxVarName > this.maxVarStringLen ? this.maxVarNameStr.substring(0, this.maxVarStringLen) : this.maxVarNameStr;
                    var A = this.legendPosition == "right" ? r + this.x + (this.margin * 4) : (r + (this.x / 2)) - ((this.measureText(m, this.legendFont) + C) / 2);
                    var e = this.legendPosition == "right" ? (k + (this.y / 2)) - (this.getLegendHeight(true) / 2) : k + this.y;
                    if (this.smpDendrogramPosition == "right") {
                        A += this.getSmpTreeWidthHeight()
                    }
                    if (this.legendPosition == "bottom") {
                        if (this.graphOrientation == "vertical") {
                            e += this.getSampleTitleHeight() + this.getSampleLabelLength() + this.getSmpOverlaysLength() + this.margin
                        } else {
                            e += this.getAxisTitleTickLength(true) + this.margin
                        } if (this.showSmpDendrogram && this.smpDendrogramPosition == "bottom") {
                            e += this.getSmpTreeWidthHeight()
                        }
                    } else {
                        if (this.graphOrientation == "vertical") {
                            A += this.getAxisTitleTickLength(true)
                        }
                    }
                    var d = e - this.margin;
                    if (this.legendBox && this.legendBackgroundColor) {
                        var m = this.maxVarName > this.maxVarStringLen ? this.maxVarNameStr.substring(0, this.maxVarStringLen) : this.maxVarNameStr;
                        var a = ((this.xAxisVarIndices.length + this.xAxis2VarIndices.length) * C * 1.5) + this.margin;
                        var y = (this.margin * 3) + f + this.measureText(m, this.legendFont);
                        this.rectangle(A - this.margin * 2, d, y, a, this.legendBackgroundColor, this.legendBoxColor)
                    }
                    for (var w = 0; w < this.xAxisVarIndices.length; w++) {
                        var j = this.xAxisVarIndices[w];
                        var B = this.getColor(this.data.y.vars[j]);
                        var o = this.coordinateLineColor || this.gradient ? "closed" : this.getPattern(this.data.y.vars[j]);
                        var m = this.shortenText(this.data.y.vars[j], this.maxVarStringLen);
                        this.addArea(this.rectangle(A, e, C, C, B, B, o), ["Var-" + j]);
                        this.addArea(this.drawText(m, A + f, e + x, this.legendFont, this.legendColor, "left", "middle"), ["Var-" + j]);
                        e += C * 1.5
                    }
                    for (var w = 0; w < this.xAxis2VarIndices.length; w++) {
                        var j = this.xAxis2VarIndices[w];
                        var B = this.coordinateLineColor ? this.colors[w % this.colors.length] : this.getColor(this.data.y.vars[j]);
                        var o = this.coordinateLineColor || this.gradient ? "closed" : this.getPattern(this.data.y.vars[j]);
                        var m = this.shortenText(this.data.y.vars[j], this.maxVarStringLen);
                        var g = this.getFontPt(this.legendFont) / 2;
                        if (this.lineDecoration) {
                            if (this.lineDecoration == "symbol") {
                                this.drawLine("line", A, e + x, A + C, e + x, B);
                                this.addArea(this.drawShape(this.shapes[w % this.shapes.length], A + x, e + x, g, g, B, B, o), ["Var-" + j])
                            } else {
                                if (this.lineDecoration == "dot") {
                                    this.drawLine("line", A, e + x, A + C, e + x, B);
                                    this.addArea(this.drawShape("circle", A + x, e + x, g, g, B, B), ["Var-" + j])
                                }
                            }
                        } else {
                            this.addArea(this.drawLine("line", A, e + x, A + C, e + x, B), ["Var-" + j])
                        }
                        this.addArea(this.drawText(m, A + f, e + x, this.legendFont, this.legendColor, "left", "middle"), ["Var-" + j]);
                        e += C * 1.5
                    }
                    if (this.legendBox) {
                        var m = this.maxVarName > this.maxVarStringLen ? this.maxVarNameStr.substring(0, this.maxVarStringLen) : this.maxVarNameStr;
                        var a = ((e - d) - x) + this.margin;
                        var y = (this.margin * 3) + f + this.measureText(m, this.legendFont);
                        this.disableGradientTransparencyShadow();
                        this.rectangle(A - this.margin * 2, d, y, a, false, this.legendBoxColor, "open");
                        this.enableGradientTransparencyShadow()
                    }
                } else {
                    if (this.graphType == "Treemap") {
                        return
                    }
                    var m = this.maxVarName > this.maxVarStringLen ? this.maxVarNameStr.substring(0, this.maxVarStringLen) : this.maxVarNameStr;
                    var A = this.legendPosition == "right" ? r + this.x + (this.margin * 4) : (r + (this.x / 2)) - ((this.measureText(m, this.legendFont) + C) / 2);
                    var e = this.legendPosition == "right" ? (k + (this.y / 2)) - (this.getLegendHeight(true) / 2) : k + this.y;
                    if (this.legendPosition == "bottom") {
                        if (this.graphOrientation == "vertical") {
                            e += this.getSampleTitleHeight() + this.getSampleLabelLength() + this.getSmpOverlaysLength() + this.margin + this.margin
                        } else {
                            e += this.getAxisTitleTickLength(true) + this.margin
                        } if (this.showSmpDendrogram && this.smpDendrogramPosition == "bottom") {
                            e += this.getSmpTreeWidthHeight()
                        }
                    } else {
                        if (this.graphOrientation == "vertical") {
                            A += this.getAxisTitleTickLength(true)
                        }
                    } if (this.smpDendrogramPosition == "right" && this.showLegend && this.legendPosition == "right") {
                        A += this.getSmpTreeWidthHeight()
                    }
                    var d = e - this.margin;
                    if (this.legendBox && this.legendBackgroundColor) {
                        var m = this.maxVarName > this.maxVarStringLen ? this.maxVarNameStr.substring(0, this.maxVarStringLen) : this.maxVarNameStr;
                        var a = ((this.varIndices.length * C * 1.5)) + this.margin;
                        var y = (this.margin * 3) + f + this.measureText(m, this.legendFont);
                        this.disableGradientTransparencyShadow();
                        this.rectangle(A - this.margin * 2, d, y, a, this.legendBackgroundColor, this.legendBoxColor);
                        this.enableGradientTransparencyShadow()
                    }
                    for (var w = 0; w < this.varIndices.length; w++) {
                        var j = this.varIndices[w];
                        var B = this.getColor(this.data.y.vars[j]);
                        var n = this.coordinateLineColor || this.gradient ? "closed" : this.getPattern(this.data.y.vars[j]);
                        var o = this.shapes[w % this.shapes.length];
                        var m = this.shortenText(this.data.y.vars[j], this.maxVarStringLen);
                        var g = this.getFontPt(this.legendFont) / 2;
                        if (this.graphType == "Line") {
                            if (this.lineDecoration) {
                                if (this.lineDecoration == "symbol") {
                                    this.drawLine("line", A, e + x, A + C, e + x, B);
                                    this.addArea(this.drawShape(o, A + x, e + x, g, g, B, B, n), ["Var-" + j])
                                } else {
                                    if (this.lineDecoration == "dot") {
                                        this.drawLine("line", A, e + x, A + C, e + x, B);
                                        this.addArea(this.drawShape("circle", A + x, e + x, g, g, B, B, n), ["Var-" + j])
                                    }
                                }
                            } else {
                                this.addArea(this.drawLine("line", A, e + x, A + C, e + x, B), ["Var-" + j])
                            }
                        } else {
                            if (this.graphType == "Dotplot") {
                                o = this.shapes[parseInt(w / this.colors.length)];
                                this.addArea(this.drawShape(o, A + x, e + x, C, C, B, B, n), ["Var-" + j])
                            } else {
                                this.addArea(this.rectangle(A, e, C, C, B, B, n), ["Var-" + j])
                            }
                        }
                        this.addArea(this.drawText(m, A + f, e + x, this.legendFont, this.legendColor, "left", "middle"), ["Var-" + j]);
                        e += C * 1.5
                    }
                }
            }
        }
    };
    this.setOverlaysDendrogramVariable = function() {
        if (this.plotByVariable) {
            if (this.graphType.match(/^Bar$|Boxplot|Dotplot/)) {
                this.showOverlays = false;
                this.showVarDendrogram = false;
                this.showSmpDendrogram = false
            } else {
                this.plotByVariable = false
            }
        }
    };
    this.setIndicatorsLegendPositions = function() {
        if ((this.colorBy || this.shapeBy || this.sizeBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap/)) {
            this.indicatorsPosition = this.legendPosition
        }
    };
    this.draw1DLayout = function() {
        this.drawTrees();
        this.draw1DXLayout();
        this.draw1DYLayout()
    };
    this.draw1DData = function() {
        this.drawPlotWindow();
        this.draw1DWireFrame();
        this.draw1DDataPoints();
        this.maskPlotArea();
        this.draw1DLayout();
        this.draw1DLegend();
        this.drawTitle();
        this.drawDecorationData()
    };
    this.draw1DPlot = function() {
        this.setOverlaysDendrogramVariable();
        this.setIndicatorsLegendPositions();
        this.set1DAttributes();
        this.set1DXYDimensions();
        this.set1DPrivateParams();
        this.set1DXAxis();
        this.draw1DData()
    };
    this.checkHeatmap = function() {
        var c = ["outline", "shape", "size"];
        for (var b = 0; b < c.length; b++) {
            var a = c[b] + "ByData";
            if (this[a] && this.data.y[this[a]] && this.isArray(this.data.y[this[a]])) {
                this.isMultidimensionalHeatmap = true
            }
        }
    };
    this.checkSegregation = function() {
        if (this.graphType != "Candlestick") {
            if (this.data.l) {
                if (!this.segregateSamplesBy) {
                    this.desegregateSamples(true)
                } else {
                    if (!this.data.l.smps) {
                        this.segregateSamples(this.segregateSamplesBy, true)
                    }
                } if (!this.segregateVariablesBy) {
                    this.desegregateVariables(true)
                } else {
                    if (!this.data.l.vars) {
                        this.segregateVariables(this.segregateVariablesBy, true)
                    }
                }
            } else {
                if (this.segregateSamplesBy) {
                    this.segregateSamples(this.segregateSamplesBy, true)
                }
                if (this.segregateVariablesBy) {
                    this.segregateVariables(this.segregateVariablesBy, true)
                }
            }
        }
    };
    this.checkOrientation = function() {
        if (this.graphType == "Heatmap") {
            this.graphOrientation = "horizontal"
        }
    };
    this.checkTreemap = function() {
        if (this.graphType == "Treemap") {
            this.showVarDendrogram = true;
            if (this.isGroupedData) {
                this.ungroupSamples()
            }
        }
    };
    this.restoreTempSettings = function() {
        if (this.tmpShowLegend) {
            this.showLegend = this.tmpShowLegend;
            this.tmpShowLegend = false
        }
        if (this.tmpLegendFontSize) {
            this.legendFontSize = this.tmpLegendFontSize;
            this.tmpLegendFontSize = false
        }
        if (this.tmpVarLabelDescription) {
            this.varLabelDescription = this.tmpVarLabelDescription;
            this.tmpVarLabelDescription = false
        }
        if (this.tmpVarLabelScaleFontFactor) {
            this.varLabelScaleFontFactor = this.tmpVarLabelScaleFontFactor;
            this.tmpVarLabelScaleFontFactor = false
        }
        if (this.tmpSmpLabelDescription) {
            this.smpLabelDescription = this.tmpSmpLabelDescription;
            this.tmpSmpLabelDescription = false
        }
        if (this.tmpSmpLabelScaleFontFactor) {
            this.smpLabelScaleFontFactor = this.tmpSmpLabelScaleFontFactor;
            this.tmpSmpLabelScaleFontFactor = false
        }
        if (this.tmpDendrogramSpace) {
            this.dendrogramSpace = this.tmpDendrogramSpace;
            this.tmpDendrogramSpace = false
        }
        this.adjustAspectRatioXTries = 0;
        this.adjustAspectRatioYTries = 0
    };
    this.initialize1DPlot = function() {
        this.checkOrientation();
        this.checkSegregation();
        this.checkHeatmap();
        this.checkTreemap();
        if (this.layoutValid) {
            this.drawLayoutCompartments(this.draw1DPlot)
        } else {
            this.draw1DPlot()
        }
        this.restoreTempSettings()
    };
    this.initialize1DPlot()
};
CanvasXpress.prototype.Network = function(a) {
    this.findXYCoordinates = function(d) {
        var b = this.adjustedCoordinates(d);
        var f = {};
        f.x = (b.x / this.scaleFactor || 1) - this.offsetX;
        f.y = (b.y / this.scaleFactor || 1) - this.offsetY;
        return f
    };
    this.addNode = function(e, d) {
        if (e) {
            if (!e.id) {
                var b = 0;
                var f = "id" + b;
                while (this.nodes.hasOwnProperty(f)) {
                    b++;
                    f = "id" + b
                }
                e.id = f
            }
            if (!e.color) {
                e.color = this.colors[0]
            }
            if (!e.shape) {
                e.shape = this.shapes[0]
            }
            if (!e.size) {
                e.size = 1
            }
            if (d) {
                var c = this.findXYCoordinates(d);
                e.x = c.x;
                e.y = c.y
            }
            this.data.nodeIndices[e.id] = this.data.nodes.length;
            this.data.nodes.push(e);
            this.nodes[e.id] = e;
            return e
        }
    };
    this.getNodeConfigurableProperties = function(b) {
        var d = this.getObjectArray(this.nodeConfigurableProperties);
        if (b) {
            for (var c in this.data.nodes[b]) {
                d[c] = true
            }
        }
        return this.getKeys(d)
    };
    this.getEdgeConfigurableProperties = function(c) {
        var d = this.getObjectArray(this.edgeConfigurableProperties);
        if (c) {
            for (var b in this.data.edges[c]) {
                d[b] = true
            }
        }
        return this.getKeys(d)
    };
    this.removeNode = function(e, l) {
        if (e && e.id) {
            var b = l ? this.getObjectArray(this.findChildrenNodeIndices(e.id)) : false;
            var h = [];
            var d = 0;
            if (this.nodeParentHood[e.id] && this.nodeParentHood[e.id].children) {
                for (var k = 0; k < this.nodeParentHood[e.id].children.length; k++) {
                    var m = this.nodeParentHood[e.id].children[k];
                    if (this.data.nodeIndices[m] && this.data.nodes[this.data.nodeIndices[m]]) {
                        delete(this.data.nodes[this.data.nodeIndices[m]].parentNode)
                    }
                }
            }
            this.data.nodeIndices = {};
            for (var k = 0; k < this.data.nodes.length; k++) {
                if (this.data.nodes[k].id != e.id) {
                    if (b && b.hasOwnProperty(k)) {
                        var g = this.edgesForNode(this.data.edges, this.data.nodes[k].id);
                        for (var f = 0; f < g.length; f++) {
                            this.removeEdge(g[f])
                        }
                    } else {
                        h.push(this.data.nodes[k]);
                        this.data.nodeIndices[this.data.nodes[k].id] = d;
                        d++
                    }
                } else {
                    var g = this.edgesForNode(this.data.edges, e.id);
                    for (var f = 0; f < g.length; f++) {
                        this.removeEdge(g[f])
                    }
                }
            }
            this.data.nodes = h
        }
    };
    this.addEdge = function(b) {
        if (b && b.id1 && b.id2) {
            if (!b.color) {
                b.color = this.colors[0]
            }
            if (!b.width) {
                b.width = 1
            }
            if (!b.type) {
                b.type = "line"
            }
            this.data.edges.push(b)
        }
    };
    this.removeEdge = function(d) {
        if (d && d.id1 && d.id2) {
            var c = [];
            for (var b = 0; b < this.data.edges.length; b++) {
                if (this.data.edges[b].id1 != d.id1 || this.data.edges[b].id2 != d.id2) {
                    c.push(this.data.edges[b])
                }
            }
            this.data.edges = c
        }
    };
    this.getAllObjectAttributes = function(d) {
        var e = [];
        if (this.data[d]) {
            for (var c = 0; c < this.data[d].length; c++) {
                for (var b in this.data[d][c]) {
                    if (e.hasOwnProperty(b)) {
                        e[b]++
                    } else {
                        e[b] = 1
                    }
                }
            }
        }
        return e
    };
    this.setAllObjectAttributes = function(m, n, q, f) {
        if (this.data[m]) {
            var o = this.getAllObjectAttributeValues(m, q);
            if (o) {
                if (this.isNumeric(o)) {
                    var k = this.range(o);
                    if (n == "color") {
                        this.setHeatmapColors(k[1] - k[0]);
                        for (var h = 0; h < this.data[m].length; h++) {
                            if (this.data[m][h].hasOwnProperty(q)) {
                                var e = this.data[m][h][q];
                                var d = this.getHeatmapColor(k[0], k[1], e);
                                this.data[m][h][n] = d
                            } else {
                                this.data[m][h][n] = this.missingDataColor
                            }
                        }
                    } else {
                        if (n == "size") {
                            for (var h = 0; h < this.data[m].length; h++) {
                                if (this.data[m][h].hasOwnProperty(q)) {
                                    var e = this.data[m][h][q];
                                    var g = this.percentile(k[0], k[1], e);
                                    var c = parseInt(g * 25 / 10);
                                    if (f) {
                                        this.data[m][h]["decorationSize"] = 1 + (c / 25)
                                    } else {
                                        this.data[m][h][n] = 1 + (c / 100)
                                    }
                                } else {
                                    if (f) {
                                        this.data[m][h]["decorationSize"] = 0.1
                                    } else {
                                        this.data[m][h][n] = 0.1
                                    }
                                }
                            }
                        } else {
                            if (n == "shape") {
                                if (m == "nodes") {
                                    var s = "square";
                                    for (var h = 0; h < this.data[m].length; h++) {
                                        if (this.data[m][h].hasOwnProperty(q)) {
                                            var e = this.data[m][h][q];
                                            var g = this.percentile(k[0], k[1], e);
                                            var r = parseInt(g / 10);
                                            if (r > 0) {
                                                r--
                                            }
                                            this.data[m][h][n] = "pie" + r
                                        } else {
                                            this.data[m][h][n] = s
                                        }
                                    }
                                } else {
                                    if (m == "edges") {
                                        for (var h = 0; h < this.data[m].length; h++) {
                                            if (this.data[m][h].hasOwnProperty(q)) {
                                                var e = this.data[m][h][q];
                                                var g = this.percentile(k[0], k[1], e);
                                                var r = parseInt(g / 10);
                                                if (r > 0) {
                                                    r--
                                                }
                                                this.data[m][h]["type"] = this.lines[r]
                                            } else {
                                                this.data[m][h]["type"] = this.lines[10]
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    var p = 0;
                    var j = 0;
                    var l = 0.1;
                    var b = {
                        color: {},
                        shape: {},
                        size: {}
                    };
                    for (var h = 0; h < o.length; h++) {
                        if (!b.color.hasOwnProperty(o[h])) {
                            b.color[o[h]] = this.colors[p % this.colors.length];
                            p++
                        }
                        if (m == "nodes") {
                            if (!b.shape.hasOwnProperty(o[h])) {
                                b.shape[o[h]] = this.shapes[j % this.shapes.length];
                                j++
                            }
                        } else {
                            if (!b.shape.hasOwnProperty(o[h])) {
                                b.lines[o[h]] = this.lines[j % this.lines.length];
                                j++
                            }
                        } if (!b.size.hasOwnProperty(o[h])) {
                            b.size[o[h]] = l;
                            l += 0.1
                        }
                    }
                    for (var h = 0; h < this.data[m].length; h++) {
                        if (this.data[m][h].hasOwnProperty(q)) {
                            var e = this.data[m][h][q];
                            this.data[m][h][n] = b[n][e]
                        }
                    }
                }
            }
        }
    };
    this.getAllObjectAttributeValues = function(d, b) {
        var e = [];
        if (this.data[d]) {
            for (var c = 0; c < this.data[d].length; c++) {
                if (this.data[d][c].hasOwnProperty(b)) {
                    e.push(this.data[d][c][b])
                }
            }
        }
        return e
    };
    this.modifyNodeSize = function(e, b, c) {
        var d = this.data.nodes[this.data.nodeIndices[e]];
        delete(d.size);
        d.width = b;
        d.height = c
    };
    this.modifyXYNode = function(g, d, b) {
        var f = this.data.nodes[this.data.nodeIndices[g]];
        if (!f.fixed) {
            f.x -= d;
            f.y -= b;
            if (f.labelX != null && f.labelY != null) {
                this.modifyXYNodeLab(g, d, b)
            }
            if (this.networkLayoutType != "radial") {
                if (this.nodeParentHood[f.id] && this.nodeParentHood[f.id]["children"]) {
                    for (var e = 0; e < this.nodeParentHood[f.id]["children"].length; e++) {
                        var c = this.nodeParentHood[f.id]["children"][e];
                        this.modifyXYNode(c, d, b)
                    }
                }
            }
        }
    };
    this.modifyXYNodeLab = function(d, j, i) {
        var e = this.data.nodes[this.data.nodeIndices[d]];
        if (!e.fixed) {
            var g = e.label != null ? e.label : e.name ? e.name : e.id;
            var b = this.measureText(g, this.nodeFontStyle + " " + (parseInt(this.nodeFontSize * this.nodeScaleFontFactor)) + "Pt " + this.fontName);
            var h = this.nodeFontSize * this.nodeScaleFontFactor;
            var f = e.width ? e.width : e.size ? (this.nodeSize * e.size) : this.nodeSize;
            var c = e.height ? e.height : e.size ? (this.nodeSize * e.size) : this.nodeSize;
            if (e.labelX != null && e.labelY != null) {
                e.labelX -= j;
                e.labelY -= i
            } else {
                if (this.rangeX > this.rangeY) {
                    e.labelX = (e.x - (b / 2)) - j;
                    e.labelY = (e.y + (c / 1.3)) - i
                } else {
                    e.labelX = (e.x + (f / 1.3)) - j;
                    e.labelY = (e.y - (h / 2)) - i
                }
            }
        }
    };
    this.modifyXYNodeDec = function(e, c, b) {
        var d = this.data.nodes[this.data.nodeIndices[e]];
        if (!d.fixed) {
            d.decorationsX -= c;
            d.decorationsY -= b
        }
    };
    this.getHiddenNodes = function() {
        var c = [];
        if (this.data.nodes) {
            for (var b = 0; b < this.data.nodes.length; b++) {
                if (this.data.nodes[b].hide) {
                    c.push(this.data.nodes[b])
                }
            }
        }
        return c
    };
    this.orderNodes = function(c) {
        for (var b in this.selectNode) {
            this[c](this.data.nodes[this.data.nodeIndices[b]])
        }
    };
    this.sendNodeToBack = function(d) {
        var c = [d];
        for (var b = 0; b < this.data.nodes.length; b++) {
            if (this.data.nodes[b].id != d.id) {
                c.push(this.data.nodes[b])
            }
        }
        this.data.nodes = c;
        this.setNodeIndices()
    };
    this.sendNodeBackward = function(e) {
        var d = [];
        var b = this.data.nodeIndices[e.id];
        if (b > 0) {
            for (var c = 0; c < b - 1; c++) {
                d.push(this.data.nodes[c])
            }
            d.push(this.data.nodes[b]);
            d.push(this.data.nodes[b - 1]);
            for (var c = b + 1; c < this.data.nodes.length; c++) {
                d.push(this.data.nodes[c])
            }
            this.data.nodes = d;
            this.setNodeIndices()
        }
    };
    this.bringNodeToFront = function(d) {
        var c = [];
        for (var b = 0; b < this.data.nodes.length; b++) {
            if (this.data.nodes[b].id != d.id) {
                c.push(this.data.nodes[b])
            }
        }
        c.push(d);
        this.data.nodes = c;
        this.setNodeIndices()
    };
    this.bringNodeForward = function(e) {
        var d = [];
        var b = this.data.nodeIndices[e.id];
        if (this.data.nodes.length - 1 > b) {
            for (var c = 0; c < b; c++) {
                d.push(this.data.nodes[c])
            }
            d.push(this.data.nodes[b + 1]);
            d.push(this.data.nodes[b]);
            for (var c = b + 2; c < this.data.nodes.length; c++) {
                d.push(this.data.nodes[c])
            }
            this.data.nodes = d;
            this.setNodeIndices()
        }
    };
    this.flashNode = function(g, d, b) {
        g = this.toArray(g);
        for (var j = 0; j < g.length; j++) {
            var c = g[j];
            var e = this.data.nodes[this.data.nodeIndices[c]];
            var l = e.width ? e.width : e.size ? e.size : this.nodeSize;
            var k = e.height ? e.height : e.size ? e.size : this.nodeSize;
            var f = this.adjustNetworkObjects(["circle", e.x, e.y, 1]);
            this.flash(f[1], f[2], l * this.scaleFactor, k * this.scaleFactor, d || this.nodeHighlightColor, b)
        }
    };
    this.highlightNodes = function(b) {
        if (this.isArray(b)) {
            this.highlightNode = this.highlightNode.concat(b)
        } else {
            this.highlightNode.push(b)
        }
        this.draw()
    };
    this.unHighlightNodes = function(b) {
        var e = [];
        b = this.toArray(b);
        for (var d = 0; d < this.highlightNode.length; d++) {
            var f = false;
            for (var c = 0; c < b.length; c++) {
                if (this.highlightNode[d] == b[c]) {
                    f = true;
                    break
                }
            }
            if (!f) {
                e.push(this.highlightNode[d])
            }
        }
        this.highlightNode = e;
        this.draw()
    };
    this.addToNetworkStack = function() {
        if (this.networkStack.length >= this.networkStackStates) {
            this.networkStack.shift()
        }
        this.networkStackIndex = this.networkStack.length;
        this.networkStack.push(this.cloneObject(this.data));
        if (this.userEvents.stackchange) {
            this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
        }
    };
    this.undoNetworkOp = function() {
        if (this.canNetworkUndoOp()) {
            this.networkStackIndex--;
            this.nodes = {};
            this.updateData(this.networkStack[this.networkStackIndex]);
            if (this.userEvents.stackchange) {
                this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
            }
        } else {
            if (this.debug) {
                alert("No data in Undo Stack")
            }
        }
    };
    this.canNetworkUndoOp = function() {
        return this.networkStackIndex > 0 ? true : false
    };
    this.redoNetworkOp = function() {
        if (this.canNetworkRedoOp()) {
            this.networkStackIndex++;
            this.nodes = {};
            this.updateData(this.networkStack[this.networkStackIndex]);
            if (this.userEvents.stackchange) {
                this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
            }
        } else {
            if (this.debug) {
                alert("No data in Redo Stack")
            }
        }
    };
    this.canNetworkRedoOp = function() {
        return this.networkStackIndex < this.networkStack.length - 1 ? true : false
    };
    this.clearNetworkStack = function() {
        this.stackNumber = false;
        this.networkStackIndex = 0;
        this.networkStack = [];
        if (this.userEvents.stackchange) {
            this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
        }
    };
    this.addLegend = function(b, e, d) {
        this.inititalizeNetworkLegend();
        if (b && e) {
            if (d && b == "text") {
                var c = this.findXYCoordinates(d);
                e.x = c.x;
                e.y = c.y
            }
            this.data.legend[b].push(e);
            return e
        }
    };
    this.deleteLegend = function(d, e) {
        if (d && e && e.id) {
            var c = [];
            for (var b = 0; b < this.data.legend[d].length; b++) {
                if (this.data.legend[d][b].id != e.id) {
                    c.push(this.data.legend[d][b])
                }
            }
            this.data.legend[d] = c;
            delete(this.data.legend.ids[d][e.id])
        }
    };
    this.alignDistributeSelectedNodes = function(k, d, p) {
        var g, b, j, t, h;
        var l = this.getSelectedNodeCoordinates();
        if (l || d == 89 || d == 90) {
            if (k) {
                this.cancelEvent(k);
                this.stopEvent(k)
            }
            if (d == 84) {
                g = this.min(l.y);
                for (var h in this.selectNode) {
                    var f = this.data.nodes[this.data.nodeIndices[h]];
                    this.modifyXYNode(f.id, 0, f.y - g)
                }
            } else {
                if (d == 82) {
                    g = this.max(l.x);
                    for (var h in this.selectNode) {
                        var f = this.data.nodes[this.data.nodeIndices[h]];
                        this.modifyXYNode(f.id, f.x - g, 0)
                    }
                } else {
                    if (d == 66) {
                        g = this.max(l.y);
                        for (var h in this.selectNode) {
                            var f = this.data.nodes[this.data.nodeIndices[h]];
                            this.modifyXYNode(f.id, 0, f.y - g)
                        }
                    } else {
                        if (d == 76) {
                            g = this.min(l.x);
                            for (var h in this.selectNode) {
                                var f = this.data.nodes[this.data.nodeIndices[h]];
                                this.modifyXYNode(f.id, f.x - g, 0)
                            }
                        } else {
                            if (d == 86) {
                                b = this.range(l.y);
                                j = this.rank(l.y);
                                t = (b[1] - b[0]) / (this.isSelectNodes - 1);
                                g = b[0];
                                for (var q = 0; q < j.length; q++) {
                                    h = l.i[j[q]];
                                    var f = this.data.nodes[this.data.nodeIndices[h]];
                                    this.modifyXYNode(f.id, 0, f.y - (g + (q * t)))
                                }
                            } else {
                                if (d == 72) {
                                    b = this.range(l.x);
                                    j = this.rank(l.x);
                                    t = (b[1] - b[0]) / (this.isSelectNodes - 1);
                                    g = b[0];
                                    for (var q = 0; q < j.length; q++) {
                                        h = l.i[j[q]];
                                        var f = this.data.nodes[this.data.nodeIndices[h]];
                                        this.modifyXYNode(f.id, f.x - (g + (q * t)), 0)
                                    }
                                } else {
                                    if (d == 90) {
                                        if (k.shiftKey || p) {
                                            if (this.canNetworkRedoOp()) {
                                                this.resetSelectedNodes();
                                                this.redoNetworkOp()
                                            }
                                        } else {
                                            if (this.canNetworkUndoOp()) {
                                                this.resetSelectedNodes();
                                                this.undoNetworkOp()
                                            }
                                        }
                                        return false
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.draw(false, false, false, true);
            this.addToNetworkStack()
        }
        return false
    };
    this.getSelectedNodeCoordinates = function() {
        var f = {
            x: [],
            y: [],
            i: []
        };
        var b = false;
        for (var d in this.selectNode) {
            var e = this.data.nodes[this.data.nodeIndices[d]];
            f.x.push(e.x);
            f.y.push(e.y);
            f.i.push(d);
            b = true
        }
        return b ? f : false
    };
    this.findNodesBy = function(h) {
        var b = [];
        var l = 0;
        for (var d in h) {
            h[d] = this.toArray(h[d]);
            l++
        }
        for (var k = 0; k < this.data.nodes.length; k++) {
            var e = this.data.nodes[k];
            var f = 0;
            for (var d in h) {
                var o = h[d];
                for (var g = 0; g < o.length; g++) {
                    if (e[d] && e[d] == o[g]) {
                        f++
                    }
                }
            }
            if (f == l) {
                b.push(e)
            }
        }
        return b
    };
    this.setNetworkDimensions = function() {
        this.left = 0;
        this.top = 0;
        this.x = this.width;
        this.y = this.height
    };
    this.setNetworkPrivateParams = function() {
        if (this.data.nodes.length > 0) {
            this.layoutDone = false;
            this.x = this.width;
            this.y = this.height;
            if (this.networkLayoutType == "radial") {
                var b = this.width;
                var c = this.height;
                if (this.width > this.height) {
                    this.width = this.height
                } else {
                    this.height = this.width
                }
                this.x = this.width;
                this.y = this.height;
                this.networkXCenter = this.x / 2;
                this.networkYCenter = this.y / 2;
                this.width = b;
                this.height = c
            } else {
                this.x = this.width;
                this.y = this.height;
                this.set3DParams();
                this.area = this.x * this.y;
                if (this.networkForceConstant != null && this.networkForceConstantOriginal != null) {
                    this.networkForceConstantOriginal = this.networkForceConstant
                }
                if (this.temperature != null && this.temperatureOriginal != null) {
                    this.temperatureOriginal = this.temperature
                }
                if (this.initialTemperature != null && this.initialTemperatureOriginal != null) {
                    this.initialTemperatureOriginal = this.initialTemperature
                }
                this.networkForceConstant = this.networkForceConstant ? this.networkForceConstant : Math.sqrt(this.area / this.data.nodes.length);
                this.temperature = this.temperature ? this.temperature : this.data.nodes.length + Math.floor(Math.sqrt(this.data.edges.length));
                this.minimumTemperature = 1;
                this.initialTemperature = this.initialTemperature ? this.initialTemperature : this.temperature;
                this.iteration = 0;
                if (this.networkForceConstant < 0.001) {
                    this.networkForceConstant = 0.001
                }
            } if (this.x <= 400 || this.y <= 400) {
                this.nodeSize -= 4;
                this.nodeFont = (this.nodeSize - 6) + "Pt " + this.fontName;
                this.showAnimationFont = this.nodeFont + "Pt " + this.fontName
            } else {
                this.edgeWidth = 2
            }
        } else {
            this.layoutDone = true
        }
    };
    this.networkContains = function(b, c) {
        return this.findNode(b, c) != null
    };
    this.findNode = function(c, e) {
        for (var d in c) {
            var b = c[d];
            if (e.call(b)) {
                return b
            }
        }
        return null
    };
    this.filterEdges = function(c, f) {
        var e = [];
        for (var d in c) {
            var b = c[d];
            if (f.call(b)) {
                e.push(b)
            }
        }
        return e
    };
    this.reduceNetwork = function(b, f, d) {
        var e = null;
        for (var c in b) {
            if (e == null) {
                if (d) {
                    e = d.apply(d, [b[c]])
                } else {
                    e = b[c]
                }
            } else {
                e = f.apply(b[c], [e, b[c]])
            }
        }
        return e
    };
    this.vectorDifference = function(e, d) {
        var c = e.x - d.x;
        var g = e.y - d.y;
        var f = e.z - d.z;
        if (c == 0) {
            c = 0.01 + Math.random()
        }
        if (g == 0) {
            g = 0.01 + Math.random()
        }
        if (this.is3DNetwork) {
            if (f == 0) {
                f = 0.01 + Math.random()
            }
        }
        return {
            x: c,
            y: g,
            z: f
        }
    };
    this.vectorMagnitude = function(c) {
        var b;
        if (this.is3DNetwork) {
            b = Math.sqrt((c.x * c.x) + (c.y * c.y) + (c.z * c.z))
        } else {
            b = Math.sqrt((c.x * c.x) + (c.y * c.y))
        }
        return isNaN(b) ? 0 : b
    };
    this.normalizeGraph = function(j) {
        var h = [];
        var b = {};
        var k = this;
        for (var f in j.nodes) {
            if (!b.hasOwnProperty(j.nodes[f].id)) {
                var e = j.nodes[f];
                var d = [];
                b[e.id] = 1;
                if (!this.networkContains(d, function() {
                    return k.networkContains(this.nodes, function() {
                        return this.id = e.id
                    })
                })) {
                    var c = {};
                    c.nodes = [];
                    c.edges = [];
                    this.addNodeToGraph(e, c, j);
                    if (c.nodes.length > 0) {
                        h.push(c)
                    }
                    for (var g = 0; g < c.nodes.length; g++) {
                        b[c.nodes[g].id] = 1
                    }
                }
            }
        }
        return h
    };
    this.addNodeToGraph = function(d, f, e) {
        if (this.findNodeForId(d.id, f) == null) {
            f.nodes.push(d);
            var b = this.edgesForNode(e.edges, d.id);
            for (edgeIndex in b) {
                var c = b[edgeIndex];
                f.edges.push(c);
                if (c.id1 == d.id) {
                    this.addNodeToGraph(this.findNodeForId(c.id2, e), f, e)
                } else {
                    this.addNodeToGraph(this.findNodeForId(c.id1, e), f, e)
                }
            }
        }
    };
    this.findNodeForId = function(c, b) {
        return this.findNode(b.nodes, function() {
            return c == this.id
        })
    };
    this.edgesForNode = function(b, c) {
        return this.filterEdges(b, function(d) {
            return (this.id1 == c || this.id2 == c)
        })
    };
    this.attractiveForce = function(b, c) {
        switch (this.attractiveForceFunction) {
            case "FruchtermanReingold":
                return (b * b) / c;
            case "Eades":
                return c * Math.log(b)
        }
    };
    this.repulsiveForce = function(b, c) {
        return (c * c) / b
    };
    this.storePositions = function() {
        var e = {};
        for (var c = 0; c < this.data.nodes.length; c++) {
            var d = this.data.nodes[c];
            if (!d.hide && !d.hiddenParent) {
                var b = {
                    x: d.x,
                    y: d.y,
                    z: d.z
                };
                e[d.id] = b
            }
        }
        return e
    };
    this.calculateRepulsiveDisplacement = function(e) {
        var d = this;
        var b = function(l, s, h) {
            var r = h * h;
            for (var p = 0; p < s.length; p++) {
                var v = d.data.nodes[d.data.nodeIndices[s[p]]];
                var o = l[v.id];
                for (var n = 0; n < s.length; n++) {
                    if (p != n) {
                        var u = d.data.nodes[d.data.nodeIndices[s[n]]];
                        var g = l[u.id];
                        if (!v.hide && !v.hiddenParent && !u.hide && !u.hiddenParent) {
                            var t = d.vectorDifference(v, u);
                            var f = d.networkLayoutType == "organic" ? Math.max(d.vectorMagnitude(t) - (d.nodeSize * 2), d.networkNodeMinDistance) : d.vectorMagnitude(t);
                            var q = r / f;
                            if (!v.fixed) {
                                o.x += (t.x / f) * q;
                                o.y += (t.y / f) * q;
                                o.z += (t.z / f) * q
                            }
                            if (!u.fixed && d.networkLayoutType == "organic") {
                                g.x -= (t.x / f) * q;
                                g.y -= (t.y / f) * q;
                                g.z -= (t.z / f) * q
                            }
                        }
                    }
                }
            }
        };
        if (this.subNetworks) {
            for (var c = 0; c < this.subNetworks.length; c++) {
                b(e[c], this.subNetworks[c].nodes, this.subNetworks[c].networkForceConstant)
            }
        } else {
            b(e, this.getKeys(this.data.nodeIndices), this.networkForceConstant)
        }
    };
    this.calculateAttractiveDisplacement = function(e) {
        var d = this;
        var b = function(p, o, h) {
            for (var j = 0; j < o.length; j++) {
                var l = o[j];
                if (!d.nodes || !d.nodes[l.id1] || !d.nodes[l.id2]) {
                    alert('Nodes "' + l.id1 + '" and/or "' + l.id2 + '" are missing!');
                    return
                }
                if (d.nodes && !d.nodes[l.id1].hide && !d.nodes[l.id2].hide && !d.nodes[l.id1].hiddenParent && !d.nodes[l.id2].hiddenParent) {
                    var n = d.vectorDifference(d.nodes[l.id1], d.nodes[l.id2]);
                    var f = d.networkLayoutType == "organic" ? Math.max(d.vectorMagnitude(n) - (d.nodeSize * 2), d.networkNodeMinDistance) : Math.max(d.vectorMagnitude(n), d.networkNodeMinDistance);
                    var g = d.attractiveForce(f, h);
                    if (!d.nodes[l.id1].fixed) {
                        p[l.id1].x -= (n.x / f) * g;
                        p[l.id1].y -= (n.y / f) * g;
                        p[l.id1].z -= (n.z / f) * g
                    }
                    if (!d.nodes[l.id2].fixed) {
                        p[l.id2].x += (n.x / f) * g;
                        p[l.id2].y += (n.y / f) * g;
                        p[l.id2].z += (n.z / f) * g
                    }
                }
            }
        };
        if (this.subNetworks) {
            for (var c = 0; c < this.subNetworks.length; c++) {
                b(e[c], this.subNetworks[c].edges, this.subNetworks[c].networkForceConstant)
            }
        } else {
            b(e, this.data.edges, this.networkForceConstant)
        }
    };
    this.applyDisplacement = function(e) {
        var d = this;
        var c = function(j, g) {
            for (var k in j) {
                var h = d.nodes[k];
                if (!h.fixed) {
                    var i = j[k];
                    var f = Math.max(d.vectorMagnitude(i), 0.001);
                    h.x += (i.x / f) * Math.min(g, Math.abs(i.x));
                    h.y += (i.y / f) * Math.min(g, Math.abs(i.y));
                    h.z += (i.z / f) * Math.min(g, Math.abs(i.z))
                }
            }
        };
        if (this.nodes) {
            if (this.subNetworks) {
                for (var b = 0; b < this.subNetworks.length; b++) {
                    c(e[b], this.subNetworks[b].temperature)
                }
            } else {
                c(e, this.temperature)
            }
        }
    };
    this.isLayoutDone = function() {
        var f = this;
        var e = this.storePositions();
        var g = 0;
        var c = 0;
        var b = function(h, l) {
            var w = 0;
            var m = 0;
            var r = {
                x: Number.MAX_VALUE,
                y: Number.MAX_VALUE
            };
            var v = {
                x: Number.MAX_VALUE * -1,
                y: Number.MAX_VALUE * -1
            };
            for (var s = 0; s < h.length; s++) {
                var q = f.data.nodes[f.data.nodeIndices[h[s]]];
                if (!q.hide && !q.hiddenParent && !q.fixed) {
                    var k = e[q.id];
                    r.x = Math.min(r.x, k.x);
                    r.y = Math.min(r.y, k.y);
                    r.z = Math.min(r.z, k.z);
                    v.x = Math.max(v.x, k.x);
                    v.y = Math.max(v.y, k.y);
                    v.z = Math.max(v.z, k.z)
                }
                w += Math.abs(f.vectorMagnitude(f.vectorDifference(f.previousNodePositions[q.id], k)));
                m++
            }
            var u = w / m;
            var t = Math.abs(f.vectorMagnitude(f.vectorDifference(r, v)));
            var j = Math.abs(f.vectorMagnitude({
                x: l.x,
                y: l.y,
                z: parseInt((l.x + l.y) / 2)
            }));
            l.minimumTemperature = t / j;
            l.layoutDone = u < l.minimumTemperature;
            if (l.layoutDone) {
                c++
            }
            if (l.initialProgress == null && l.temperature <= l.minimumTemperature) {
                l.initialProgress = u - (l.minimumTemperature / 2)
            }
            if (l.initialProgress != null) {
                l.layoutProgress = Math.max(l.layoutProgress, 1 - ((u - (l.minimumTemperature / 2)) / l.initialProgress))
            }
            g += l.layoutProgress
        };
        if (this.subNetworks) {
            for (var d = 0; d < this.subNetworks.length; d++) {
                b(this.subNetworks[d].nodes, this.subNetworks[d])
            }
            this.layoutProgress = g / this.subNetworks.length;
            this.layoutDone = c == this.subNetworks.length ? true : false
        } else {
            b(this.getKeys(this.data.nodeIndices), this)
        }
        this.previousNodePositions = e
    };
    this.setInitialForceDirectedLayout = function() {
        var d = this;
        var b = function(j, e, h) {
            for (var f = 0; f < j.length; f++) {
                var g = d.data.nodes[d.data.nodeIndices[j[f]]];
                if (!g.hide && !g.hiddenParent) {
                    g.x = Math.floor(Math.random() * e);
                    g.y = Math.floor(Math.random() * h);
                    g.z = this.is3DNetwork ? Math.floor(Math.random() * parseInt((e + h) / 2)) : 0
                }
            }
        };
        this.layoutProgress = 0;
        if (this.subNetworks) {
            for (var c = 0; c < this.subNetworks.length; c++) {
                b(this.subNetworks[c].nodes, this.subNetworks[c].x, this.subNetworks[c].y)
            }
        } else {
            b(this.getKeys(this.data.nodeIndices), this.x, this.y)
        }
        this.previousNodePositions = this.storePositions()
    };
    this.setInitialNodeDisplacement = function() {
        var d = this.subNetworks ? [] : {};
        if (this.subNetworks) {
            for (var c = 0; c < this.subNetworks.length; c++) {
                d[c] = {};
                for (var b = 0; b < this.subNetworks[c].nodes.length; b++) {
                    d[c][this.subNetworks[c].nodes[b]] = {
                        x: 0,
                        y: 0,
                        z: 0
                    }
                }
            }
        } else {
            for (var c = 0; c < this.data.nodes.length; c++) {
                d[this.data.nodes[c].id] = {
                    x: 0,
                    y: 0,
                    z: 0
                }
            }
        }
        return d
    };
    this.updateForceDirectedLayout = function(d) {
        var f = new Date().getTime();
        var c = f;
        if (this.data.edges.length > 1) {
            if (!this.layoutDone) {
                while (c - f < d) {
                    var e = this.setInitialNodeDisplacement();
                    this.calculateRepulsiveDisplacement(e);
                    this.calculateAttractiveDisplacement(e);
                    this.applyDisplacement(e);
                    if (this.subNetworks) {
                        for (var b = 0; b < this.subNetworks.length; b++) {
                            this.subNetworks[b].temperature = Math.max(this.subNetworks[b].temperature - (this.subNetworks[b].initialTemperature / 100), this.subNetworks[b].minimumTemperature)
                        }
                    } else {
                        this.temperature = Math.max(this.temperature - (this.initialTemperature / 100), this.minimumTemperature)
                    }
                    this.isLayoutDone();
                    this.iteration++;
                    c = new Date().getTime()
                }
            }
        } else {
            this.layoutDone = true
        }
        return this.layoutDone
    };
    this.renderNetwork = function() {
        this.ctx.shadowOffsetX = this.shadowOffsetX;
        this.ctx.shadowOffsetY = this.shadowOffsetY;
        this.ctx.shadowBlur = this.shadowBlur;
        this.ctx.shadowColor = this.shadowColor;
        this.setNetworkRotation();
        this.resizeCanvas();
        if (!this.layoutDone && !this.showAnimation) {
            this.drawNetworkProgressBar(true);
            return
        }
        if (this.data.nodes.length > 0) {
            if (this.layoutDone) {
                this.setXYNodePrecision()
            }
            this.setNetworkMinMaxRangeXY();
            this.setNetworkScaleFactor();
            if (this.scaleFactor) {
                if (this.showAnimation) {
                    if (this.preScaleNetwork) {
                        this.centerNetwork();
                        this.ctx.save();
                        this.ctx.scale(1 / this.scaleFactor, 1 / this.scaleFactor);
                        this.ctx.translate(this.offsetX, this.offsetY);
                        this.ctx.restore();
                        this.drawNetworkNodes(true);
                        if (this.networkNodesOnTop) {
                            this.drawNetworkEdges();
                            this.drawNetworkNodes()
                        } else {
                            this.drawNetworkNodes();
                            this.drawNetworkEdges()
                        } if (this.layoutDone) {
                            this.drawNetworkLegend()
                        }
                        this.ctx.save();
                        this.ctx.translate(-this.offsetX, -this.offsetY);
                        this.ctx.scale(this.scaleFactor, this.scaleFactor);
                        this.ctx.restore()
                    } else {
                        this.ctx.scale(this.scaleFactor, this.scaleFactor);
                        this.ctx.translate(this.offsetX, this.offsetY);
                        this.drawNetworkNodes(true);
                        if (this.networkNodesOnTop) {
                            this.drawNetworkEdges();
                            this.drawNetworkNodes()
                        } else {
                            this.drawNetworkNodes();
                            this.drawNetworkEdges()
                        } if (this.layoutDone) {
                            this.drawNetworkDecorations();
                            this.drawNetworkLegend()
                        }
                        this.ctx.translate(-this.offsetX, -this.offsetY);
                        this.ctx.scale(1 / this.scaleFactor, 1 / this.scaleFactor)
                    }
                    this.drawCitation();
                    this.drawTitle();
                    this.drawCanvasBox(true)
                } else {
                    this.drawCitation();
                    this.drawTitle();
                    this.drawCanvasBox(true);
                    if (this.preScaleNetwork) {
                        this.centerNetwork();
                        this.ctx.save();
                        this.ctx.scale(this.scaleFactor, this.scaleFactor);
                        this.ctx.translate(this.offsetX, this.offsetY);
                        this.ctx.restore()
                    } else {
                        this.ctx.scale(this.scaleFactor, this.scaleFactor);
                        this.ctx.translate(this.offsetX, this.offsetY)
                    }
                    this.drawNetworkNodes(true);
                    if (this.networkNodesOnTop) {
                        this.drawNetworkEdges();
                        this.drawNetworkNodes()
                    } else {
                        this.drawNetworkNodes();
                        this.drawNetworkEdges()
                    } if (this.layoutDone) {
                        this.drawNetworkDecorations();
                        this.drawNetworkLegend()
                    }
                }
                this.drawNetworkProgressBar()
            }
        }
    };
    this.reRootRadialNetwork = function(f) {
        var e = this.data.nodes[f].id;
        this.networkCurrentAngle = this.getAngle(this.finalRadialNodePositions[e].x, this.finalRadialNodePositions[e].y, this.finalRadialNodePositions[this.networkRoot].x, this.finalRadialNodePositions[this.networkRoot].y, 0) + 180;
        this.orderRadialNetwork = {};
        var c = this.data.nodeIndices[e];
        var d = 0;
        for (var b = c; b < this.data.nodes.length; b++) {
            this.orderRadialNetwork[this.data.nodes[b].id] = d;
            d++
        }
        for (var b = 0; b < c; b++) {
            this.orderRadialNetwork[this.data.nodes[b].id] = d;
            d++
        }
        this.networkXCenter = this.finalRadialNodePositions[e].x;
        this.networkYCenter = this.finalRadialNodePositions[e].y;
        this.networkRoot = e;
        this.layoutDone = false;
        this.draw()
    };
    this.renderRadialLayout = function() {
        this.ctx.scale(this.scaleFactor, this.scaleFactor);
        this.ctx.translate(this.offsetX, this.offsetY);
        var b = this.data.nodes[this.data.nodeIndices[this.networkRoot]];
        for (var c = 1; c < this.networkDepth; c++) {
            this.drawShape("circle", b.x, b.y, c * this.networkLevelSize * 2, c * this.networkLevelSize * 2, this.background, this.infoAreaColor, "open")
        }
    };
    this.centerNetwork = function() {
        for (var b = 0; b < this.data.nodes.length; b++) {
            var c = this.data.nodes[b];
            if (!c.hide && !c.hiddenParent) {
                c.x = (this.offsetX + c.x) * this.scaleFactor;
                c.y = (this.offsetY + c.y) * this.scaleFactor
            }
        }
        this.scaleFactor = 0.9;
        this.offsetX = this.x * 0.05;
        this.offsetY = this.y * 0.05
    };
    this.adjustNetworkObjects = function(c) {
        if (c) {
            if (c[0] == "circle") {
                c[1] = (this.offsetX + c[1]) * this.scaleFactor;
                c[2] = (this.offsetY + c[2]) * this.scaleFactor;
                c[3] = c[3] * this.scaleFactor
            } else {
                for (var b = 1; b < c.length; b++) {
                    if (b % 2) {
                        c[b] = (this.offsetX + c[b]) * this.scaleFactor
                    } else {
                        c[b] = (this.offsetY + c[b]) * this.scaleFactor
                    }
                }
            }
        } else {
            return false
        }
        return c
    };
    this.setXYNodePrecision = function() {
        if (this.approximateNodePositions) {
            for (var b = 0; b < this.data.nodes.length; b++) {
                var c = this.data.nodes[b];
                if (c.x) {
                    c.x = parseInt(c.x);
                    this.nodes[c.id].x = c.x
                }
                if (c.y) {
                    c.y = parseInt(c.y);
                    this.nodes[c.id].y = c.y
                }
                if (c.z) {
                    c.z = parseInt(c.z);
                    this.nodes[c.id].z = c.z
                }
            }
        }
    };
    this.getLengthToNodeBoundary = function(d, j, c, i, f, e) {
        if (f) {
            var h = f.size ? f.size : 1;
            var b = e && f.height ? f.height : f.width ? f.width : this.nodeSize * h;
            var g = e && f.width ? f.width : f.height ? f.height : this.nodeSize * h;
            var k = this.clip("line", [d, j, c, i], [d - (b / 2), j - (g / 2), b, g]);
            return this.lineLength(k[0], k[1], k[2], k[3]) + (this.margin * 2)
        } else {
            return this.margin * 2
        }
    };
    this.drawNetworkEdges = function() {
        if (this.nodes) {
            var b = {};
            var c = 1;
            var g = this.foreground;
            for (var r = 0; r < this.data.edges.length; r++) {
                var h = this.data.edges[r];
                var q = this.nodes[h.id1];
                var p = this.nodes[h.id2];
                var v = false;
                if (!q.hide && !q.hiddenParent && !p.hide && !p.hiddenParent && !h.anchor) {
                    v = true
                } else {
                    if (this.showHiddenChildEdges) {
                        if (q.hide || q.hiddenParent || (q.parentNode && this.nodes[q.parentNode].hideChildren)) {
                            q = this.findVisibleParentNode(h.id1);
                            if (q) {
                                v = true
                            }
                        }
                        if (p.hide || p.hiddenParent || (p.parentNode && this.nodes[p.parentNode].hideChildren)) {
                            p = this.findVisibleParentNode(h.id2);
                            if (p) {
                                v = true
                            }
                        }
                    }
                }
                var x = q.id + ":" + p.id;
                if (v && !h.hide) {
                    if (!b.hasOwnProperty(x)) {
                        var d = this.selectNode.hasOwnProperty(q.id) && this.selectNode.hasOwnProperty(p.id) ? this.nodeHighlightColor : h.color ? h.color : g;
                        var k = h.width ? h.width : this.outlineWidth;
                        var j = h.cap ? h.cap : false;
                        var e = h.exact ? h.exact : false;
                        var n, l, t, s;
                        if (this.is3DNetwork) {
                            n = q.x3d;
                            l = q.y3d;
                            t = p.x3d;
                            s = p.y3d
                        } else {
                            n = q.x;
                            l = q.y;
                            t = p.x;
                            s = p.y
                        }
                        var m = h.type ? h.type : "line";
                        var o = m.match(/curved/) ? true : false;
                        var w = e ? 0 : this.getLengthToNodeBoundary(n, l, t, s, q, o);
                        var f = e ? 0 : this.getLengthToNodeBoundary(t, s, n, l, p, o);
                        var u = this.drawLine(m, n, l, t, s, d, k, j, Math.max(0, w), Math.max(0, f));
                        if (this.layoutDone && !this.isAnimation) {
                            if (this.preScaleNetwork) {
                                this.addArea(u, [r + this.data.nodes.length])
                            } else {
                                this.addArea(this.adjustNetworkObjects(u), [r + this.data.nodes.length])
                            }
                            c++
                        }
                        this.ctx.lineWidth = 1;
                        b[x] = 1
                    }
                }
            }
        }
    };
    this.drawNetworkNodes = function(p) {
        var D = this.data.nodes.length / this.zoom < this.showNodeNameThreshold ? true : false;
        var B = this.foreground;
        var G = this.shapes[0];
        var d = 6001;
        var w = this.rangeX > this.rangeY ? "bottom" : "right";
        var A = this.autoHideOnDecorationsCenter && this.decorationsPosition == "center" && this.decorations.length > 0 ? true : false;
        for (var H = 0; H < this.data.nodes.length; H++) {
            var x = this.data.nodes[H];
            if (p) {
                if (!x.eventless) {
                    continue
                }
            } else {
                if (x.eventless) {
                    continue
                }
            }
            var g = this.overrideAnchorNodes ? false : x.anchor;
            if (!x.hide && !x.hiddenParent && !g) {
                var z = this.is3DNetwork ? x.x3d : x.x;
                var n = this.is3DNetwork ? x.y3d : x.y;
                var u = x.shape ? x.shape : G;
                var j = this.selectNode.hasOwnProperty(x.id) ? this.nodeHighlightColor : x.color ? x.color : B;
                var C = x.outline ? x.outline : this.foreground;
                var f = x.size ? x.size : 1;
                var L = x.width ? x.width : this.nodeSize * f;
                var I = x.height ? x.height : this.nodeSize * f;
                var h = x.pattern ? x.pattern : "closed";
                var o = x.rotate ? x.rotate * Math.PI / 180 : false;
                var l = x.outlineWidth ? x.outlineWidth : false;
                var e = x.imagePath ? x.imagePath : false;
                var t = x.zIndex ? x.zIndex : e ? d : false;
                var v = x.eventless ? false : true;
                var E = this.drawShape(u, z, n, L, I, j, C, h, o, l, false, false, false, false, e, t);
                if (this.layoutDone && !this.isAnimation) {
                    if (v || this.overrideEventlessNodes) {
                        if (this.preScaleNetwork) {
                            this.addArea(E, [H])
                        } else {
                            this.addArea(this.adjustNetworkObjects(E), [H])
                        }
                    }
                    if (D && !x.hideLabel) {
                        var r, q;
                        var F = x.label ? x.label : x.name ? x.name : x.id;
                        var s = this.getNodeColor(x.id, x.labelColor);
                        var y = x.labelSize ? this.nodeFontSize * x.labelSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
                        var K = this.nodeFontStyle + " " + (parseInt(y)) + "Pt " + this.fontName;
                        var b = this.measureText(F, K);
                        var c = y;
                        if (x.labelX != null && x.labelY != null) {
                            r = x.labelX - (b / 2);
                            q = x.labelY - (c / 2);
                            this.drawText(F, x.labelX, x.labelY, K, s, "center", "middle")
                        } else {
                            var J = this.isMultipleLines(F);
                            var k = parseInt(y) + 4;
                            if (J) {
                                if (J % 2) {
                                    n += (parseInt(J / 2) * k) + (k / 2)
                                } else {
                                    n = (n + parseInt(J / 2) * k)
                                }
                            }
                            if (x.labelPosition) {
                                switch (x.labelPosition) {
                                    case "top":
                                        r = z - (b / 2);
                                        q = n - ((I / 1.3) + c);
                                        this.drawText(F, z, q, K, s, "center", "top");
                                        break;
                                    case "bottom":
                                        r = z - (b / 2);
                                        q = n + (I / 1.3);
                                        this.drawText(F, z, q, K, s, "center", "top");
                                        break;
                                    case "right":
                                        r = z + (L / 1.3);
                                        q = n - (c / 2);
                                        this.drawText(F, r, n, K, s, "left", "middle");
                                        break;
                                    case "left":
                                        r = z - ((L / 1.3) + b);
                                        q = n - (c / 2);
                                        this.drawText(F, r, n, K, s, "left", "middle");
                                        break;
                                    case "center":
                                        this.drawText(F, z, n, K, s, "center", "middle");
                                        break
                                }
                            } else {
                                if (w == "right") {
                                    r = z + (L / 1.3);
                                    q = n - (c / 2);
                                    this.drawText(F, r, n, K, s, "left", "middle")
                                } else {
                                    r = z - (b / 2);
                                    q = n + (I / 1.3);
                                    this.drawText(F, z, q, K, s, "center", "top")
                                }
                            }
                        }
                        var m = ["rect", r, q, r + b, q + c];
                        if (v || this.overrideEventlessNodes) {
                            if (this.preScaleNetwork && !this.isAnimation) {
                                this.addArea(m, [H], "-lab")
                            } else {
                                this.addArea(this.adjustNetworkObjects(m), [H], "-lab")
                            }
                        }
                    }
                }
                d++
            }
        }
    };
    this.drawNetworkDecorations = function() {
        if (this.showDecorations && this.decorations.length > 0) {
            var b = this.decorations.length * this.decorationsWidth;
            var I = b / 2;
            var V = this.decorationsHeight / 2;
            var h = this.decorationsHeight * 2 / 3;
            var M = this.decorationsHeight / 3;
            this.setHeatmapColors(this.decorationsRange[1] - this.decorationsRange[0]);
            for (var R = 0; R < this.data.nodes.length; R++) {
                var B = this.data.nodes[R];
                var T = [];
                var W = [];
                var y = [];
                var x = false;
                var m = this.sizeDecorationBy && B.decorationSize ? B.decorationSize : V;
                var g = this.overrideAnchorNodes ? false : B.anchor;
                if (!B.hide && !B.hiddenParent && !g) {
                    var C = this.is3DNetwork ? B.x3d : B.x;
                    var u = this.is3DNetwork ? B.y3d : B.y;
                    var Q = B.size ? this.nodeSize * B.size : this.nodeSize;
                    var S = Q / 2;
                    var t, e, o, X, A, n, f;
                    switch (this.decorationsPosition) {
                        case "top":
                            t = this.decorationsType == "pie" ? C : C - I;
                            e = u - (S + this.decorationsHeight + this.decorationsWidth);
                            e = this.decorationsType == "pie" ? e - V : e;
                            break;
                        case "bottom":
                            t = this.decorationsType == "pie" ? C : C - I;
                            e = u + (S + this.decorationsHeight + this.decorationsWidth);
                            e = this.decorationsType == "pie" ? e + V : e;
                            break;
                        case "right":
                            t = C + S + this.decorationsWidth;
                            e = this.decorationsType == "pie" ? u : u - V;
                            t = this.decorationsType == "pie" ? t + V : t;
                            break;
                        case "left":
                            t = C - (S + (this.decorationsWidth * (this.decorations.length + 1)));
                            e = this.decorationsType == "pie" ? u : u - V;
                            t = this.decorationsType == "pie" ? t - V : t;
                            break;
                        case "center":
                            t = this.decorationsType == "pie" ? C : C - I;
                            e = this.decorationsType == "pie" ? u : u - V;
                            break
                    }
                    if (B.decorationsX != null && B.decorationsY != null) {
                        t = B.decorationsX;
                        e = B.decorationsY
                    }
                    if (this.preScaleNetwork && !this.isAnimation) {
                        this.addArea(["rect", t, e, t + b, e - this.decorationsHeight], [R], "-dec")
                    } else {
                        this.addArea(this.adjustNetworkObjects(["rect", t, e, t + b, e - this.decorationsHeight]), [R], "-dec")
                    } if (this.decorationsType == "bar") {
                        f = this.decorationsRange[1] < 0 ? e : this.decorationsRange[0] >= 0 ? e + this.decorationsHeight : (e + this.decorationsHeight) - Math.abs(this.decorationsRange[0] * this.decorationsUnits);
                        for (var P = 0; P < this.decorations.length; P++) {
                            A = this.decorations[P];
                            if (B[A] && !isNaN(B[A])) {
                                this.rectangle(t, f, this.decorationsWidth, -B[A] * this.decorationsUnits, this.decorationsColors[P])
                            } else {
                                if (B.decorations && B.decorations[A] && !isNaN(B.decorations[A])) {
                                    this.rectangle(t, f, this.decorationsWidth, -B.decorations[A] * this.decorationsUnits, this.decorationsColors[P])
                                }
                            }
                            t += this.decorationsWidth
                        }
                    } else {
                        if (this.decorationsType == "heatmap") {
                            for (var P = 0; P < this.decorations.length; P++) {
                                var F = B[this.decorations[P]] ? B[this.decorations[P]] : B.decorations ? B.decorations[this.decorations[P]] : false;
                                if (this.isObject(F)) {
                                    x = {};
                                    for (var O = 0; O < this.decorations.length; O++) {
                                        var E = B[this.decorations[O]] ? B[this.decorations[O]] : B.decorations ? B.decorations[this.decorations[O]] : {};
                                        for (var N in E) {
                                            x[N] = true
                                        }
                                    }
                                    x = this.getKeys(x);
                                    T = [];
                                    for (D = 0; D < x.length; D++) {
                                        T[D] = []
                                    }
                                    break
                                }
                            }
                        }
                        for (var P = 0; P < this.decorations.length; P++) {
                            if (x || B[this.decorations[P]] != null || (B.decorations && B.decorations[this.decorations[P]] != null)) {
                                var F = B[this.decorations[P]] ? B[this.decorations[P]] : B.decorations ? B.decorations[this.decorations[P]] : {};
                                if (this.isObject(F) || x) {
                                    if (this.decorationsType.match(/stacked/)) {
                                        var D = [];
                                        for (var O in F) {
                                            if (!isNaN(F[O])) {
                                                D.push(F[O])
                                            }
                                        }
                                        T.push(D)
                                    } else {
                                        if (this.decorationsType == "heatmap") {
                                            for (D = 0; D < x.length; D++) {
                                                O = x[D];
                                                T[D].push(F && F[O] ? F[O] : "NA")
                                            }
                                        }
                                    }
                                } else {
                                    T.push(B[this.decorations[P]] ? B[this.decorations[P]] : B.decorations ? B.decorations[this.decorations[P]] : "NA")
                                }
                                W.push([R]);
                                if (this.decorationsType == "pie") {
                                    var H = this.decorations[P];
                                    y.push(this.decorationsProperties[H] && this.decorationsProperties[H].color ? this.decorationsProperties[H].color : this.colors[P % this.colors.length])
                                }
                            } else {
                                T.push(false);
                                W.push([R]);
                                if (this.decorationsType == "pie") {
                                    y.push(false)
                                }
                            }
                        }
                        if (T.length > 0) {
                            if (this.decorationsType.match(/stacked/)) {
                                var L = this.decorationsType.match(/percent/) ? true : false;
                                for (var P = 0; P < this.decorations.length; P++) {
                                    if (T[P]) {
                                        var D = [];
                                        var E = [];
                                        var J = 0;
                                        var H = this.decorations[P];
                                        var F = B[this.decorations[P]] ? B[this.decorations[P]] : B.decorations ? B.decorations[this.decorations[P]] : {};
                                        for (var O in F) {
                                            var U = this.decorationsProperties[O] && this.decorationsProperties[O].color ? this.decorationsProperties[O].color : this.decorationsColors[this.decorations.length + J];
                                            D.push(U);
                                            E.push("closed");
                                            J++
                                        }
                                        this.drawStackedPlot(T[P], t, e, this.decorationsWidth, L, this.sum(T[P]), this.decorationsUnits, "vertical", D, E, W[P]);
                                        var U = this.decorationsProperties[H] && this.decorationsProperties[H].color ? this.decorationsProperties[H].color : this.decorationsColors[P];
                                        var G = this.decorationsProperties[H] && this.decorationsProperties[H].shape ? this.decorationsProperties[H].shape : "circle";
                                        this.drawShape(G, t + this.decorationsWidth / 2, e + M, M / 1.3, M / 1.3, U, this.foreground, "closed");
                                        t += this.decorationsWidth
                                    }
                                }
                            } else {
                                if (this.decorationsType == "heatmap") {
                                    if (x) {
                                        h = this.decorationsHeight / T.length;
                                        for (var P = 0; P < T.length; P++) {
                                            if (T[P]) {
                                                var H = x[P];
                                                this.drawHeatmap(T[P], t, e, this.decorationsWidth, h, this.decorationsRange[0], this.decorationsRange[1], false, W, "-dec");
                                                var U = this.decorationsProperties[H] && this.decorationsProperties[H].color ? this.decorationsProperties[H].color : this.decorationsColors[this.decorations.length + P];
                                                var G = this.decorationsProperties[H] && this.decorationsProperties[H].shape ? this.decorationsProperties[H].shape : "square";
                                                this.drawShape(G, t - M, e + (h / 2), M / 2, M / 2, U, this.foreground, "closed")
                                            }
                                            e += h
                                        }
                                        for (var P = 0; P < this.decorations.length; P++) {
                                            var H = this.decorations[P];
                                            var U = this.decorationsProperties[H] && this.decorationsProperties[H].color ? this.decorationsProperties[H].color : this.decorationsColors[P];
                                            var G = this.decorationsProperties[H] && this.decorationsProperties[H].shape ? this.decorationsProperties[H].shape : "circle";
                                            this.drawShape(G, t + this.decorationsWidth / 2, e + M, M / 1.3, M / 1.3, U, this.foreground, "closed");
                                            t += this.decorationsWidth
                                        }
                                    } else {
                                        if (T[0]) {
                                            this.drawHeatmap(T, t, e, this.decorationsWidth, h, this.decorationsRange[0], this.decorationsRange[1], false, W, "-dec");
                                            for (var P = 0; P < this.decorations.length; P++) {
                                                var H = this.decorations[P];
                                                var U = this.decorationsProperties[H] && this.decorationsProperties[H].color ? this.decorationsProperties[H].color : this.decorationsColors[P];
                                                var G = this.decorationsProperties[H] && this.decorationsProperties[H].shape ? this.decorationsProperties[H].shape : "circle";
                                                this.drawShape(G, t + this.decorationsWidth / 2, (e + this.decorationsHeight + (M / 3)), M / 1.3, M / 1.3, U, this.foreground, "closed");
                                                t += this.decorationsWidth
                                            }
                                        }
                                    }
                                } else {
                                    var K = this.colors;
                                    this.colors = y;
                                    this.drawPie(this.setPieData(T), t, e, m);
                                    this.colors = K
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.getLegendId = function(c, d) {
        if (c) {
            if (!d) {
                var b = 0;
                d = c + "LegendId" + b;
                if (this.data.legend.ids.hasOwnProperty(c)) {
                    while (this.data.legend.ids[c].hasOwnProperty(d)) {
                        b++;
                        d = c + "LegendId" + b
                    }
                } else {
                    this.data.legend.ids[c] = {}
                }
            }
            this.data.legend.ids[c][d] = true;
            return d
        }
    };
    this.findNetworkXYRange = function(c) {
        var b = Number.MAX_VALUE;
        var h = Number.MAX_VALUE * -1;
        var j = Number.MAX_VALUE;
        var g = Number.MAX_VALUE * -1;
        if (!c) {
            c = this.getKeys(this.data.nodeIndices)
        }
        if (c && c.length > 0) {
            if (this.is3DNetwork && this.layoutDone && this.scaleFactor) {
                for (var e = 0; e < c.length; e++) {
                    var f = this.data.nodes[this.data.nodeIndices[c[e]]];
                    var d = this.overrideAnchorNodes ? false : f.anchor;
                    if (!f.hide && !f.hiddenParent && !d) {
                        b = Math.min(b, f.x3d);
                        h = Math.max(h, f.x3d);
                        j = Math.min(j, f.y3d);
                        g = Math.max(g, f.y3d)
                    }
                }
            } else {
                for (var e = 0; e < c.length; e++) {
                    var f = this.data.nodes[this.data.nodeIndices[c[e]]];
                    var d = this.overrideAnchorNodes ? false : f.anchor;
                    if (!f.hide && !f.hiddenParent && !d) {
                        b = Math.min(b, f.x);
                        h = Math.max(h, f.x);
                        j = Math.min(j, f.y);
                        g = Math.max(g, f.y)
                    }
                }
            }
        }
        return ({
            minX: b,
            maxX: h,
            minY: j,
            maxY: g
        })
    };
    this.inititalizeNetworkLegend = function() {
        if (!this.data.legend) {
            this.data.legend = {}
        }
        if (!this.data.legend.pos) {
            this.data.legend.pos = {}
        }
        if (!this.data.legend.pos.nodes) {
            this.data.legend.pos.nodes = {
                x: false,
                y: false
            }
        }
        if (!this.data.legend.pos.edges) {
            this.data.legend.pos.edges = {
                x: false,
                y: false
            }
        }
        if (!this.data.legend.pos.decorations) {
            this.data.legend.pos.decorations = {
                x: false,
                y: false
            }
        }
        if (!this.data.legend.ids) {
            this.data.legend.ids = {
                nodes: {},
                edges: {},
                text: {},
                decorations: {}
            }
        }
    };
    this.drawNetworkLegend = function() {
        if (this.showLegend) {
            this.inititalizeNetworkLegend();
            var b = this.findNetworkXYRange();
            this.curLegendX = b.minX;
            this.curLegendY = b.minY;
            if (this.showNetworkNodesLegend) {
                this.drawNetworkLegendNodes()
            }
            if (this.showNetworkEdgesLegend) {
                this.drawNetworkLegendEdges()
            }
            if (this.showNetworkTextLegend) {
                this.drawNetworkLegendText()
            }
            if (this.showNetworkDecorationsLegend) {
                this.drawNetworkLegendDecorations()
            }
        }
    };
    this.drawNetworkLegendNodes = function() {
        if (this.data.legend.nodes && this.data.legend.nodes.length > 0) {
            var g = this.data.legend.pos.nodes.x != null && !isNaN(this.data.legend.pos.nodes.x) ? this.data.legend.pos.nodes.x : this.curLegendX;
            var e = this.data.legend.pos.nodes.y != null && !isNaN(this.data.legend.pos.nodes.y) ? this.data.legend.pos.nodes.y : this.curLegendY;
            this.data.legend.pos.nodes.x = parseInt(g);
            this.data.legend.pos.nodes.y = parseInt(e);
            var x = 0;
            var w = 0;
            var l = 0;
            for (var y = 0; y < this.data.legend.nodes.length; y++) {
                var t = this.data.legend.nodes[y];
                var q = t.size ? t.size * this.nodeFontSize : this.nodeFontSize;
                var m = t.width ? t.width : q;
                var s = t.height ? t.height : q;
                var C = t.font ? t.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
                w = Math.max(w, m);
                l = Math.max(l, Math.max(s, C + this.margin))
            }
            l /= 2;
            for (var y = 0; y < this.data.legend.nodes.length; y++) {
                var t = this.data.legend.nodes[y];
                t.id = this.getLegendId("nodes", t.id);
                var v = t.color || this.nodeFontColor;
                var z = t.outline ? t.outline : this.foreground;
                var b = t.shape || this.shapes[0];
                var q = t.size ? t.size * this.nodeFontSize : this.nodeFontSize;
                var m = t.width ? t.width : q;
                var s = t.height ? t.height : q;
                var n = t.pattern ? t.pattern : "closed";
                var k = t.rotate ? t.rotate * Math.PI / 180 : false;
                var u = t.outlineWidth ? t.outlineWidth : false;
                var h = t.imagePath ? t.imagePath : false;
                var c = t.zIndex ? t.zIndex : false;
                var j = t.font ? t.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
                var p = this.nodeFontStyle + " " + (parseInt(j)) + "Pt " + this.fontName;
                var o = t.text ? t.text : "";
                var r = this.measureText(o, p);
                q = parseFloat(sprintf("%.1f", q));
                x = Math.max(x, (this.margin * 3) + (w * 1.5) + r);
                e += l;
                this.drawShape(b, g + w - this.margin, this.margin + e + l, m, s, v, z, n, k, u, false, false, false, false, h, c);
                this.drawText(o, this.margin + g + (w * 1.5), this.margin + e + l, p, this.nodeFontColor, "left", "middle");
                e += l
            }
            e += this.margin + l;
            var B = this.data.legend.pos.nodes.x;
            var f = this.data.legend.pos.nodes.y + (l * 0.5);
            var A = x;
            var d = e - this.data.legend.pos.nodes.y;
            if (this.legendBox) {
                this.disableGradientTransparencyShadow();
                this.rectangle(B, f, A, d, false, this.legendBoxColor, "open");
                this.enableGradientTransparencyShadow()
            }
            var D = ["rect", B, f, B + A, f + d];
            if (this.preScaleNetwork) {
                this.addArea(D, [-1], "-legend-Nodes")
            } else {
                this.addArea(this.adjustNetworkObjects(D), [-1], "-legend-Nodes")
            }
            this.curLegendX = g;
            this.curLegendY = e
        }
    };
    this.drawNetworkLegendEdges = function() {
        if (this.data.legend.edges && this.data.legend.edges.length > 0) {
            var e = this.data.legend.pos.edges.x != null && !isNaN(this.data.legend.pos.edges.x) ? this.data.legend.pos.edges.x : this.curLegendX;
            var c = this.data.legend.pos.edges.y != null && !isNaN(this.data.legend.pos.edges.y) ? this.data.legend.pos.edges.y : this.curLegendY;
            this.data.legend.pos.edges.x = parseInt(e);
            this.data.legend.pos.edges.y = parseInt(c);
            var p = 0;
            var h = 0;
            for (var q = 0; q < this.data.legend.edges.length; q++) {
                var f = this.data.legend.edges[q];
                f.id = this.getLegendId("edges", f.id);
                var o = f.color || this.nodeFontColor;
                var j = f.type || "line";
                var n = f.width || 1;
                var m = f.size ? f.size * this.nodeFontSize : this.nodeFontSize;
                var g = f.font ? f.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
                var l = this.nodeFontStyle + " " + (parseInt(g)) + "Pt " + this.fontName;
                var k = f.text || "";
                var r = this.measureText(k, l);
                m = parseFloat(sprintf("%.1f", m));
                p = Math.max(p, (this.margin * 3) + m + r);
                h = g / 2;
                c += h;
                this.ctx.lineWidth = n * this.edgeWidth;
                this.drawLine(j, this.margin + e, this.margin + c + h, e + m, this.margin + c + h, o, false, false, 0, 0);
                this.drawText(k, (this.margin * 2) + e + m, this.margin + c + h, l, this.nodeFontColor, "left", "middle");
                c += g
            }
            c += this.margin + h;
            var t = this.data.legend.pos.edges.x;
            var d = this.data.legend.pos.edges.y;
            var s = p;
            var b = c - this.data.legend.pos.edges.y;
            if (this.legendBox) {
                this.disableGradientTransparencyShadow();
                this.rectangle(t, d, s, b, false, this.legendBoxColor, "open");
                this.enableGradientTransparencyShadow()
            }
            var u = ["rect", t, d, t + s, d + b];
            if (this.preScaleNetwork) {
                this.addArea(u, [-1], "-legend-Edges")
            } else {
                this.addArea(this.adjustNetworkObjects(u), [-1], "-legend-Edges")
            }
            this.curLegendX = e;
            this.curLegendY = c
        }
    };
    this.drawNetworkLegendText = function() {
        if (this.data.legend.text && this.data.legend.text.length > 0) {
            var j = 0;
            for (var q = 0; q < this.data.legend.text.length; q++) {
                var g = this.data.legend.text[q];
                g.id = this.getLegendId("text", g.id);
                var f = g.x != null && !isNaN(g.x) ? g.x : this.curLegendX;
                var d = g.y != null && !isNaN(g.y) ? g.y : this.curLegendY;
                g.x = parseInt(f);
                g.y = parseInt(d);
                var n = g.boxed || this.legendBox;
                var l = g.margin || this.margin;
                var b = this.setNetworkLegendMargins(l);
                var p = g.color || this.nodeFontColor;
                var k = g.text || "";
                var h = g.font ? g.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
                var m = this.nodeFontStyle + " " + (parseInt(h)) + "Pt " + this.fontName;
                var o = this.measureText(k, m);
                j = h / 2;
                this.drawText(k, b[3] + f, b[0] + d + j, m, p, "left", "middle");
                var s = g.x;
                var e = g.y;
                var r = b[1] + b[3] + o;
                var c = b[0] + b[2] + h;
                if (n) {
                    this.disableGradientTransparencyShadow();
                    this.rectangle(s, e, r, c, false, this.legendBoxColor, "open");
                    this.enableGradientTransparencyShadow()
                }
                d += b[0] + b[2] + h;
                var t = ["rect", s, e, s + r, e + c];
                if (this.preScaleNetwork) {
                    this.addArea(t, [-1], "-legend-Text" + q)
                } else {
                    this.addArea(this.adjustNetworkObjects(t), [-1], "-legend-Text" + q)
                }
                this.curLegendX = f;
                this.curLegendY = d
            }
        }
    };
    this.drawNetworkLegendDecorations = function() {
        if (this.data.legend.decorations && this.data.legend.decorations.length > 0) {
            var f = this.data.legend.pos.decorations.x != null && !isNaN(this.data.legend.pos.decorations.x) ? this.data.legend.pos.decorations.x : this.curLegendX;
            var d = this.data.legend.pos.decorations.y != null && !isNaN(this.data.legend.pos.decorations.y) ? this.data.legend.pos.decorations.y : this.curLegendY;
            this.data.legend.pos.decorations.x = parseInt(f);
            this.data.legend.pos.decorations.y = parseInt(d);
            var t = 0;
            var j = 0;
            for (var u = 0; u < this.data.legend.decorations.length; u++) {
                this.data.legend.decorations[u].id = this.getLegendId("decorations", this.data.legend.decorations[u].id);
                var s = this.data.legend.decorations[u].color || this.nodeFontColor;
                var v = this.data.legend.decorations[u].outline ? this.data.legend.decorations[u].outline : this.foreground;
                var b = this.data.legend.decorations[u].shape || this.shapes[0];
                var o = this.data.legend.decorations[u].size ? this.data.legend.decorations[u].size * this.nodeFontSize : this.nodeFontSize;
                var k = this.data.legend.decorations[u].width ? this.data.legend.decorations[u].width : o;
                var q = this.data.legend.decorations[u].height ? this.data.legend.decorations[u].height : o;
                var l = this.data.legend.decorations[u].pattern ? this.data.legend.decorations[u].pattern : "closed";
                var h = this.data.legend.decorations[u].rotate ? this.data.legend.decorations[u].rotate * Math.PI / 180 : false;
                var r = this.data.legend.decorations[u].outlineWidth ? this.data.legend.decorations[u].otlineWidth : false;
                var g = this.data.legend.decorations[u].font ? this.data.legend.decorations[u].font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
                var n = this.nodeFontStyle + " " + (parseInt(g)) + "Pt " + this.fontName;
                var m = this.data.legend.decorations[u].text ? this.data.legend.decorations[u].text : "";
                var p = this.measureText(m, n);
                o = parseFloat(sprintf("%.1f", o));
                t = Math.max(t, (this.margin * 3) + o + p);
                j = o / 2;
                d += j;
                this.drawShape(b, this.margin + f + j, this.margin + d + j, k, q, s, v, l, h, r);
                this.drawText(m, (this.margin * 2) + f + o, this.margin + d + j, n, this.nodeFontColor, "left", "middle");
                d += o
            }
            d += this.margin + j;
            var x = this.data.legend.pos.decorations.x;
            var e = this.data.legend.pos.decorations.y;
            var w = t;
            var c = d - this.data.legend.pos.decorations.y;
            if (this.legendBox) {
                this.disableGradientTransparencyShadow();
                this.rectangle(x, e, w, c, false, this.legendBoxColor, "open");
                this.enableGradientTransparencyShadow()
            }
            var y = ["rect", x, e, x + w, e + c];
            if (this.preScaleNetwork) {
                this.addArea(y, [-1], "-legend-Decorations")
            } else {
                this.addArea(this.adjustNetworkObjects(y), [-1], "-legend-Decorations")
            }
            this.curLegendX = f;
            this.curLegendY = d
        }
    };
    this.setNetworkLegendMargins = function(b) {
        if (isNaN(b)) {
            var c = b.split(/[,\s]+/);
            if (c.length > 3) {
                return [parseInt(c[0]), parseInt(c[1]), parseInt(c[2]), parseInt(c[3])]
            } else {
                if (c.length == 3) {
                    return [parseInt(c[0]), parseInt(c[1]), parseInt(c[2]), parseInt(c[1])]
                } else {
                    if (c.length == 2) {
                        return [parseInt(c[0]), parseInt(c[1]), parseInt(c[0]), parseInt(c[1])]
                    } else {
                        return [parseInt(c[0]), parseInt(c[0]), parseInt(c[0]), parseInt(c[0])]
                    }
                }
            }
        } else {
            return [parseInt(b), parseInt(b), parseInt(b), parseInt(b)]
        }
    };
    this.drawNetworkProgressBar = function(c) {
        if (!this.layoutDone) {
            this.ctx.save();
            this.ctx.fillStyle = "#fff";
            this.ctx.strokeStyle = "#fff";
            var b = (new Date().getTime() - this.preUpdateTime) / (this.layoutTime * 1000);
            b = Math.max(b, this.layoutProgress);
            if (c) {
                this.ctx.strokeRect((this.width / 2) - 50, (this.height / 2) - 5, 100, 10);
                this.ctx.fillRect((this.width / 2) - 50, (this.height / 2) - 5, b * 100, 10);
                this.drawText("Calculating ...", (this.width / 2) - 50, (this.height / 2) + 10, this.showAnimationFont, this.showAnimationFontColor, "left", "top")
            } else {
                this.ctx.strokeRect(this.width - 110, this.height - 20, 100, 10);
                this.ctx.fillRect(this.width - 110, this.height - 20, b * 100, 10)
            }
            this.ctx.restore()
        }
    };
    this.packSubNetworks = function() {
        var l = this;
        var q = function(u, t, s) {
            for (var v = 0; v < u.length; v++) {
                l.modifyXYNode(u[v], t, s)
            }
        };
        var c = function(i, u, s, t) {
            this.x = i;
            this.y = u;
            this.w = s;
            this.h = t
        };
        c.prototype.fits = function(i) {
            return i.w >= this.w && i.h >= this.h
        };
        c.prototype.sameSize = function(i) {
            return i.w == this.w && i.h == this.h
        };
        var e = function() {
            this.l = null;
            this.r = null;
            this.a = null;
            this.f = false
        };
        e.prototype.insert = function(i) {
            if (this.l != null) {
                return this.l.insert(i) || this.r.insert(i)
            }
            if (this.f) {
                return null
            }
            if (!i.fits(this.a)) {
                return null
            }
            if (i.sameSize(this.a)) {
                this.f = true;
                return this
            }
            this.l = new e();
            this.r = new e();
            var s = this.a.w - i.w;
            var u = this.a.h - i.h;
            var t = this.a;
            if (s > u) {
                this.l.a = new c(t.x, t.y, i.w, t.h);
                this.r.a = new c(t.x + i.w, t.y, t.w - i.w, t.h)
            } else {
                this.l.a = new c(t.x, t.y, t.w, i.h);
                this.r.a = new c(t.x, t.y + i.h, t.w, t.h - i.h)
            }
            return this.l.insert(i)
        };
        for (var k = 0; k < this.subNetworks.length; k++) {
            this.subNetworks[k].mnm = this.findNetworkXYRange(this.subNetworks[k].nodes);
            this.subNetworks[k].w = (this.subNetworks[k].mnm.maxX - this.subNetworks[k].mnm.minX);
            this.subNetworks[k].h = (this.subNetworks[k].mnm.maxY - this.subNetworks[k].mnm.minY);
            q(this.subNetworks[k].nodes, this.subNetworks[k].mnm.minX, this.subNetworks[k].mnm.minY)
        }
        var r = this.subNetworks[1];
        for (var k = 0; k < this.subNetworks.length; k++) {
            this.subNetworks[k].w += (r.w * 0.5);
            this.subNetworks[k].h += (r.h * 0.5)
        }
        var d = this.subNetworks[0];
        var b = d.nodes.length / this.data.nodes.length;
        var h = ((2 + b) * ((this.x / this.y) * d.w));
        var g = ((2 + b) * ((this.y / this.x) * d.h));
        var m = new e();
        var o, n;
        m.a = new c(0, 0, h, g);
        for (var k = 0; k < this.subNetworks.length; k++) {
            var f = this.subNetworks[k];
            var p = new c(0, 0, f.w, f.h);
            var j = m.insert(p);
            if (j) {
                q(this.subNetworks[k].nodes, -j.a.x, -j.a.y)
            }
        }
        this.scaleFactor *= 0.1
    };
    this.setNetworkMinMaxRangeXY = function() {
        if (!this.networkFreeze || (this.rangeX == null || this.rangeY == null)) {
            if (this.subNetworks && !this.isAnimation) {
                this.packSubNetworks();
                if (!this.isAnimation) {
                    this.subNetworks = false
                }
            }
            this.minX = Number.MAX_VALUE;
            this.minY = Number.MAX_VALUE;
            this.maxX = 0;
            this.maxY = 0;
            if (this.is3DNetwork && this.layoutDone) {
                for (var c = 0; c < this.data.nodes.length; c++) {
                    var e = this.data.nodes[c];
                    var b = e.width ? e.width : e.size ? (this.nodeSize * e.size) : this.nodeSize;
                    var d = e.height ? e.height : e.size ? (this.nodeSize * e.size) : this.nodeSize;
                    if (!e.hide) {
                        this.minX = Math.min(this.minX, e.x3d - b / 2);
                        this.minY = Math.min(this.minY, e.y3d - d / 2);
                        this.maxX = Math.max(this.maxX, e.x3d + b / 2);
                        this.maxY = Math.max(this.maxY, e.y3d + d / 2)
                    }
                }
            } else {
                for (var c = 0; c < this.data.nodes.length; c++) {
                    var e = this.data.nodes[c];
                    var b = e.width ? e.width : e.size ? (this.nodeSize * e.size) : this.nodeSize;
                    var d = e.height ? e.height : e.size ? (this.nodeSize * e.size) : this.nodeSize;
                    if (!e.hide) {
                        this.minX = Math.min(this.minX, e.x - b / 2);
                        this.minY = Math.min(this.minY, e.y - d / 2);
                        this.maxX = Math.max(this.maxX, e.x + b / 2);
                        this.maxY = Math.max(this.maxY, e.y + d / 2)
                    }
                }
            }
            this.minX -= (this.nodeSize * 3);
            this.minY -= (this.nodeSize * 3);
            this.maxX += (this.nodeSize * 3);
            this.maxY += (this.nodeSize * 3);
            this.rangeX = this.maxX - this.minX;
            this.rangeY = this.maxY - this.minY
        }
    };
    this.setNetworkRotation = function() {
        if (this.is3DNetwork && this.layoutDone) {
            var f = [];
            var c = [];
            var l = [];
            this.set3DRotation();
            for (var d = 0; d < this.data.nodes.length; d++) {
                c.push(d);
                var b = this.data.nodes[d];
                var e = this.get3DTransfrom(b.x, b.y, b.z);
                b.x3d = e[0];
                b.y3d = e[1];
                b.z3d = e[2];
                f.push(Math.sqrt((b.x3d * b.x3d) + (b.y3d * b.y3d) + (b.z3d * b.z3d)))
            }
            c.sort(function(m, i) {
                return f[i] - f[m]
            });
            for (var k = 0; k < this.data.nodes.length; k++) {
                var d = c[k];
                var b = this.data.nodes[d];
                l.push(b)
            }
            this.data.nodes = l;
            this.setNodeIndices()
        } else {
            if (this.network2DRotate != 0) {
                if (this.network2DRotate >= Math.abs(360)) {
                    this.network2DRotate = 0
                }
                var g = Math.PI * this.network2DRotate / 360;
                for (var d = 0; d < this.data.nodes.length; d++) {
                    var b = this.data.nodes[d];
                    if (b.x != null && b.y != null) {
                        var j = b.x;
                        var h = b.y;
                        b.x = (j * Math.cos(g)) - (h * Math.sin(g));
                        b.y = (h * Math.cos(g)) + (j * Math.sin(g))
                    }
                }
                if (this.data.legend.pos.nodes.x && this.data.legend.pos.nodes.y) {
                    var j = this.data.legend.pos.nodes.x;
                    var h = this.data.legend.pos.nodes.y;
                    this.data.legend.pos.nodes.x = (j * Math.cos(g)) - (h * Math.sin(g));
                    this.data.legend.pos.nodes.y = (h * Math.cos(g)) + (j * Math.sin(g))
                }
                if (this.data.legend.pos.edges.x && this.data.legend.pos.edges.y) {
                    var j = this.data.legend.pos.edges.x;
                    var h = this.data.legend.pos.edges.y;
                    this.data.legend.pos.edges.x = (j * Math.cos(g)) - (h * Math.sin(g));
                    this.data.legend.pos.edges.y = (h * Math.cos(g)) + (j * Math.sin(g))
                }
                if (this.data.legend.text) {
                    for (var d = 0; d < this.data.legend.text.length; d++) {
                        var j = textl.x;
                        var h = textl.y;
                        textl.x = (j * Math.cos(g)) - (h * Math.sin(g));
                        textl.y = (h * Math.cos(g)) + (j * Math.sin(g))
                    }
                }
                this.network2DRotate = 0
            }
        }
    };
    this.setNetworkScaleFactor = function() {
        if (!this.networkFreeze || this.scaleFactor == null || isNaN(this.scaleFactor)) {
            this.scaleFactor = this.networkLayoutType == "radial" ? 0.3 : Math.min(this.x / (this.maxX - this.minX), this.y / (this.maxY - this.minY))
        }
        this.scaleFactor *= this.zoom;
        if (this.networkFreeze) {
            this.zoomGlobal *= this.zoom;
            this.zoom = 1
        }
        this.widthBounds = this.x / this.scaleFactor;
        this.heightBounds = this.y / this.scaleFactor;
        this.offsetX = ((this.widthBounds / 2) - ((this.minX + this.maxX) / 2)) + this.panningX + this.panningGlobalX;
        this.offsetY = ((this.heightBounds / 2) - ((this.minY + this.maxY) / 2)) + this.panningY + this.panningGlobalY
    };
    this.optimizeNetworkLayout = function() {
        if (this.data.nodes.length > 0) {
            this.isAnimation = true;
            this.setInitialForceDirectedLayout();
            this.preUpdateTime = new Date().getTime();
            var b = this.layoutTime * 1000;
            var c = this.maxIterations * this.nodes.length;
            var d = this;
            var e = function() {
                this.update = function() {
                    var g = new Date().getTime();
                    if (d.updateForceDirectedLayout(30) || (g - d.preUpdateTime > b) || d.iteration > c) {
                        d.layoutDone = true;
                        clearInterval(f);
                        d.isAnimation = false;
                        d.iteration = 0
                    }
                    d.renderNetwork()
                };
                var f = setInterval(this.update, 30)
            };
            e.call()
        }
    };
    this.getAngle = function(e, g, c, f, d) {
        var b = (Math.atan2(f - g, c - e) * 180 / Math.PI) % 360;
        if (!d) {
            d = 0
        }
        while (b < d) {
            b += 360
        }
        while (b >= (d + 360)) {
            b -= 360
        }
        return b
    };
    this.getPolar = function(c, b) {
        return {
            x: this.networkXCenter + c * Math.cos(b * Math.PI / 180),
            y: this.networkYCenter + c * Math.sin(b * Math.PI / 180)
        }
    };
    this.setNodePositions = function(b) {
        for (var d in b) {
            var c = this.data.nodes[this.data.nodeIndices[d]];
            c.x = b[d].x;
            c.y = b[d].y
        }
    };
    this.animateRadialNodePositions = function() {
        this.isAnimation = true;
        var f = this;
        var e = 50;
        var d = 0;
        var c = 0;
        for (var h in f.finalRadialNodePositions) {
            if (this.initialRadialNodePositions[h].r == 0) {
                this.initialRadialNodePositions[h].a = this.finalRadialNodePositions[h].a
            }
            if (this.finalRadialNodePositions[h].r == 0) {
                this.finalRadialNodePositions[h].a = this.initialRadialNodePositions[h].a
            }
            var b = (this.finalRadialNodePositions[h].a - this.initialRadialNodePositions[h].a);
            if (b < 0) {
                b += 360
            }
            if (b > 360) {
                b -= 360
            }
            if (b > 180) {
                b -= 360
            }
            this.finalRadialNodePositions[h].a = (this.initialRadialNodePositions[h].a + b)
        }
        var g = function() {
            this.update = function() {
                var k = {};
                var s = Math.atan((d / e) * 10 - 5) * 0.5 / Math.atan(5) + 0.5;
                var p = 1 - s;
                for (var m in f.finalRadialNodePositions) {
                    var j = ((p * f.initialRadialNodePositions[m].a) + (s * f.finalRadialNodePositions[m].a));
                    var l = ((p * f.initialRadialNodePositions[m].r) + (s * f.finalRadialNodePositions[m].r));
                    var q = f.getPolar(l, j);
                    k[m] = {
                        x: q.x,
                        y: q.y
                    }
                }
                if (d >= e) {
                    clearInterval(i);
                    f.isAnimation = false;
                    k = f.finalRadialNodePositions
                }
                d++;
                f.setNodePositions(k);
                f.renderNetwork();
                if (!f.isAnimation && f.networkLayoutType == "radial" && f.showNetworkRadialLayout) {
                    f.renderRadialLayout()
                }
            };
            var i = setInterval(this.update, 50)
        };
        g.call()
    };
    this.setFinalRadialNodePositions = function(e, d) {
        if (!this.finalRadialNodePositions) {
            this.finalRadialNodePositions = {}
        }
        if (!this.nodeParentHood.drawn.hasOwnProperty(e)) {
            var m, o, g, n, b;
            var f = this.data.nodes[this.data.nodeIndices[e]];
            if (!f.hide && !f.hiddenParent) {
                if (this.nodeParentHood[e].children.length > 1 && !d) {
                    var k = [];
                    var j = this;
                    if (this.orderRadialNetwork) {
                        this.nodeParentHood[e].children.sort(function(i, c) {
                            return j.orderRadialNetwork[i] - j.orderRadialNetwork[c]
                        })
                    }
                    for (var h = 0; h < this.nodeParentHood[e].children.length; h++) {
                        if (this.nodeParentHood[this.nodeParentHood[e].children[h]].level > this.nodeParentHood[e].level) {
                            this.setFinalRadialNodePositions(this.nodeParentHood[e].children[h]);
                            k.push(this.nodeParentHood[this.nodeParentHood[e].children[h]].angle)
                        }
                    }
                    if (k.length > 0) {
                        if (k.length == 1) {
                            n = k[0]
                        } else {
                            if (k[0] > k[k.length - 1]) {
                                n = ((k[0] + k[k.length - 1]) % 360) / 2
                            } else {
                                n = (k[0] + k[k.length - 1]) / 2
                            }
                        }
                    } else {
                        this.setFinalRadialNodePositions(e, true)
                    }
                } else {
                    n = this.networkCurrentAngle;
                    this.networkCurrentAngle = (this.networkCurrentAngle + this.networkAngleStep)
                }
                g = (this.networkDepth - 1) - this.nodeParentHood[e].level;
                m = this.getPolar(this.networkRadialRadius, n);
                o = this.shortenLine(this.networkXCenter, this.networkYCenter, m.x, m.y, 0, this.networkLevelSize * g, "line");
                b = this.lineLength(this.networkXCenter, this.networkYCenter, o[2], o[3]);
                if (this.nodeParentHood[e].level == 0) {
                    n = 0;
                    b = 0
                }
                this.finalRadialNodePositions[f.id] = {
                    x: o[2],
                    y: o[3],
                    r: b,
                    a: n % 360
                };
                this.nodeParentHood.drawn[e] = true;
                this.nodeParentHood[e].angle = n
            }
        }
    };
    this.setInitialRadialNodePositions = function() {
        if (!this.initialRadialNodePositions) {
            this.initialRadialNodePositions = {};
            for (var b = 0; b < this.data.nodes.length; b++) {
                if (!this.data.nodes[b].hide && !this.data.nodes[b].hiddenParent) {
                    var c = this.data.nodes[b];
                    this.initialRadialNodePositions[c.id] = {
                        x: this.networkXCenter,
                        y: this.networkYCenter,
                        r: 0,
                        a: 0
                    }
                }
            }
        } else {
            this.initialRadialNodePositions = this.finalRadialNodePositions;
            this.finalRadialNodePositions = false
        }
    };
    this.setRadialNetwrorkLayout = function() {
        if (this.data.nodes.length > 0) {
            this.networkLevelSize = this.x * 4 / (this.networkDepth * 2);
            this.networkAngleStep = 360 / this.networkDivisions;
            this.networkCurrentAngle = this.networkCurrentAngle ? this.networkCurrentAngle : 0;
            this.networkRadialRadius = this.networkLevelSize * (this.networkDepth - 1);
            this.setInitialRadialNodePositions();
            this.setFinalRadialNodePositions(this.networkRoot);
            this.layoutDone = true;
            if (this.showAnimation) {
                this.animateRadialNodePositions()
            } else {
                this.setNodePositions(this.finalRadialNodePositions);
                this.renderNetwork()
            }
        }
    };
    this.createRandomNetwork = function(u) {
        var m = {};
        var b = {};
        if (u) {
            m = this.createMesh()
        } else {
            m.nodes = [];
            var e = Math.floor(Math.random() * this.randomNetworkNodes) + 1;
            for (var o = 0; o < e; o++) {
                var h = {};
                var s = Math.floor(Math.random() * this.shapes.length);
                var f = Math.floor(Math.random() * this.colors.length);
                h.id = "id" + o;
                h.shape = this.shapes[s];
                if (h.shape == "image") {
                    h.imagePath = "cx.png"
                }
                h.color = this.colors[f];
                h.size = 1;
                m.nodes.push(h)
            }
            m.edges = [];
            if (this.lines.length == 0) {
                this.lines = this.setLineTypes()
            }
            for (var o = 0; o < m.nodes.length; o++) {
                var g = m.nodes[o];
                var l = [];
                for (var k = 0; k < Math.floor(Math.random() * this.randomNetworkNodeEdgesMax) - 1; k++) {
                    l.push(Math.floor(Math.random() * e))
                }
                for (var k = 0; k < l.length; k++) {
                    var d = m.nodes[l[k]];
                    var r = o + ":" + l[k];
                    var q = l[k] + ":" + o;
                    if (g.id != d.id && !b.hasOwnProperty(r) && !b.hasOwnProperty(r)) {
                        var c = {};
                        var t = Math.floor(Math.random() * this.lines.length);
                        var f = Math.floor(Math.random() * this.colors.length);
                        c.id1 = g.id;
                        c.id2 = d.id;
                        c.width = 1;
                        c.type = this.lines[t];
                        c.color = this.colors[f];
                        m.edges.push(c);
                        b[r] = 1;
                        b[q] = 1
                    }
                }
            }
        } if (this.randomNetworkReduce) {
            var p = this.normalizeGraph(m);
            m = this.reduceNetwork(p, function(j, i) {
                if (j.nodes && i.nodes) {
                    if (j.nodes.length >= i.nodes.length) {
                        return j
                    } else {
                        return i
                    }
                } else {
                    if (j.nodes) {
                        return j
                    } else {
                        if (i.nodes) {
                            return i
                        } else {
                            return null
                        }
                    }
                }
            })
        }
        if (m.nodes.length < 5) {
            return this.createRandomNetwork(true)
        } else {
            var l = [];
            for (var o = 0; o < m.edges.length; o++) {
                if (m.edges[o].id1 && m.edges[o].id2) {
                    l.push(m.edges[o])
                }
            }
            m.edges = l;
            this.resetObjectAttributes();
            return m
        }
    };
    this.createMesh = function() {
        var g = {};
        g.nodes = [];
        g.edges = [];
        var f = 7;
        var b = this;
        for (var i = 0; i < f * f; i++) {
            var d = {};
            var h = Math.floor(Math.random() * this.shapes.length);
            var c = Math.floor(Math.random() * this.colors.length);
            d.id = "id" + i;
            d.shape = this.shapes[h];
            d.color = this.colors[c];
            d.size = 1;
            g.nodes.push(d)
        }
        var e = function(n, m) {
            var l = {};
            var j = Math.floor(Math.random() * b.lines.length);
            var k = Math.floor(Math.random() * b.colors.length);
            l.id1 = g.nodes[n].id;
            l.id2 = g.nodes[m].id;
            l.width = 1;
            l.type = b.lines[j];
            l.color = b.colors[k];
            return l
        };
        for (var i = 0; i < g.nodes.length; i++) {
            if (Math.floor(Math.random() * f) != 0) {
                if (i + 1 < g.nodes.length && (i + 1) % f != 0) {
                    g.edges.push(e(i, i + 1))
                }
                if (i + f < g.nodes.length) {
                    g.edges.push(e(i, i + f))
                }
            }
        }
        return g
    };
    this.setNodeChildren = function(g, c, h) {
        this.networkDepth = c > this.networkDepth ? c : this.networkDepth;
        var e = this.data.nodes[this.data.nodeIndices[g]];
        if (!e.hide && !e.hiddenParent) {
            var b = this.edgesForNode(this.data.edges, g);
            if (!this.nodeParentHood.hasOwnProperty(g)) {
                if (b.length == 1) {
                    this.networkDivisions++
                }
                if (b.length > 0) {
                    for (var d = 0; d < b.length; d++) {
                        if (!this.nodeParentHood[g]) {
                            this.nodeParentHood[g] = {};
                            this.nodeParentHood[g].children = [];
                            this.nodeParentHood[g].level = c;
                            this.nodeParentHood[g].angle = 0;
                            this.nodeParentHood[g].parent = h
                        }
                        this.nodeParentHood[g].level = c < this.nodeParentHood[g].level ? c : this.nodeParentHood[g].level;
                        if (b[d].id1 == g) {
                            this.nodeParentHood[g].children.push(b[d].id2);
                            this.setNodeChildren(b[d].id2, c + 1, g)
                        } else {
                            if (b[d].id2 == g) {
                                this.nodeParentHood[g].children.push(b[d].id1);
                                this.setNodeChildren(b[d].id1, c + 1, g)
                            }
                        }
                    }
                }
            } else {
                this.nodeParentHood[g].level = c < this.nodeParentHood[g].level ? c : this.nodeParentHood[g].level;
                for (var d = 0; d < this.nodeParentHood[g].children.length; d++) {
                    var f = this.nodeParentHood[g].children[d];
                    if (this.nodeParentHood[f]) {
                        if ((c + 1) < this.nodeParentHood[f].level) {
                            this.nodeParentHood[f].level = c + 1;
                            this.nodeParentHood[f].parent = g
                        }
                    }
                }
            }
        }
    };
    this.setNodeParentHood = function() {
        this.nodeParentHood = {};
        if (this.networkLayoutType == "radial") {
            if (!this.networkRoot) {
                this.networkRoot = this.data.nodes[0].id
            }
            this.nodeParentHood.drawn = {};
            this.networkDepth = 0;
            this.networkDivisions = 0;
            this.setNodeChildren(this.networkRoot, 0, false)
        } else {
            for (var b = 0; b < this.data.nodes.length; b++) {
                if (!this.data.nodes[b].hide) {
                    if (this.data.nodes[b].parentNode || this.data.nodes[b].hideChildren) {
                        if (this.data.nodes[b].parentNode && !this.nodeParentHood.hasOwnProperty(this.data.nodes[b].parentNode)) {
                            this.nodeParentHood[this.data.nodes[b].parentNode] = {}
                        }
                        if (this.data.nodes[b].parentNode) {
                            if (!this.nodeParentHood[this.data.nodes[b].parentNode].children) {
                                this.nodeParentHood[this.data.nodes[b].parentNode].children = []
                            }
                            this.nodeParentHood[this.data.nodes[b].parentNode].children.push(this.data.nodes[b].id);
                            if (this.data.nodes[this.data.nodeIndices[this.data.nodes[b].parentNode]].hideChildren) {
                                this.data.nodes[b].hiddenParent = true
                            }
                        }
                        if (this.data.nodes[b].hideChildren) {
                            if (!this.nodeParentHood.hasOwnProperty(this.data.nodes[b].id)) {
                                this.nodeParentHood[this.data.nodes[b].id] = {}
                            }
                            this.nodeParentHood[this.data.nodes[b].id].hideChildren = true
                        }
                    }
                }
            }
            for (var c in this.nodeParentHood) {
                if (this.data.nodes[this.data.nodeIndices[c]].hideChildren || this.isParentHidden(c)) {
                    this.hideUnhideChildrenNodes(c, true)
                } else {
                    if (this.nodeParentHood[c].children) {
                        this.hideUnhideChildrenNodes(c, false)
                    }
                }
            }
        }
    };
    this.isParentHidden = function(d) {
        var c = this.findParentNodes(d);
        if (c) {
            for (var b = 0; b < c.length; b++) {
                if (this.data.nodes[this.data.nodeIndices[c[b]]].hideChildren) {
                    return true
                }
            }
        }
        return false
    };
    this.findParentNodes = function(d, b) {
        if (this.data.nodes[this.data.nodeIndices[d]].parentNode) {
            var c = this.data.nodes[this.data.nodeIndices[d]].parentNode;
            if (!b) {
                b = []
            }
            b.push(c);
            b = this.findParentNodes(c, b);
            return b
        } else {
            return b ? b.reverse() : false
        }
    };
    this.findChildrenNodeIndices = function(d, c) {
        if (!c) {
            c = []
        }
        if (this.networkLayoutType != "radial") {
            if (this.nodeParentHood[d] && this.nodeParentHood[d]["children"]) {
                for (var b = 0; b < this.nodeParentHood[d]["children"].length; b++) {
                    c.push(this.data.nodeIndices[this.nodeParentHood[d]["children"][b]]);
                    c = this.findChildrenNodeIndices(this.nodeParentHood[d]["children"][b], c)
                }
            }
        }
        return c.length > 0 ? c : false
    };
    this.hasChildren = function(b) {
        return this.nodeParentHood[b] && this.nodeParentHood[b].children
    };
    this.findVisibleParentNode = function(d) {
        var c = this.findParentNodes(d);
        if (c) {
            c.reverse();
            for (var b = 0; b < c.length; b++) {
                if (!this.nodes[c[b]].hide && !this.nodes[c[b]].hiddenParent) {
                    return this.nodes[c[b]]
                }
            }
        }
        return false
    };
    this.collateNetworks = function() {
        if (this.data.nodes.length > 0) {
            var l = this.normalizeGraph({
                nodes: this.data.nodes,
                edges: this.data.edges
            });
            if (l.length > 1) {
                var b = [];
                for (var h = 0; h < l.length; h++) {
                    b.push(h)
                }
                b.sort(function(j, i) {
                    return l[i].nodes.length - l[j].nodes.length
                });
                this.subNetworks = [];
                for (var p = 0; p < l.length; p++) {
                    var h = b[p];
                    var d = [];
                    var m = [];
                    var g = l[h].nodes.length;
                    var k = l[h].edges.length;
                    var c = g / this.data.nodes.length;
                    var o = c * (this.x * Math.log(l.length));
                    var n = c * (this.y * Math.log(l.length));
                    var e = o * n;
                    for (var f = 0; f < l[h].nodes.length; f++) {
                        d.push(l[h].nodes[f].id)
                    }
                    for (var f = 0; f < l[h].edges.length; f++) {
                        if (typeof l[h].edges[f] != "function") {
                            m.push(l[h].edges[f])
                        }
                    }
                    this.subNetworks.push({
                        nodes: d,
                        edges: m,
                        x: o,
                        y: n,
                        area: e,
                        networkForceConstant: Math.sqrt(e / g),
                        temperature: g + Math.floor(Math.sqrt(k)),
                        minimumTemperature: 1,
                        initialTemperature: g + Math.floor(Math.sqrt(k)),
                        initialProgress: null,
                        layoutProgress: 0,
                        layoutDone: false
                    })
                }
            }
        }
    };
    this.setObjectAttributes = function() {
        if (this.colorNodeBy) {
            this.setAllObjectAttributes("nodes", "color", this.colorNodeBy)
        }
        if (this.shapeNodeBy) {
            this.setAllObjectAttributes("nodes", "shape", this.shapeNodeBy)
        }
        if (this.sizeNodeBy) {
            this.setAllObjectAttributes("nodes", "size", this.sizeNodeBy)
        }
        if (this.sizeDecorationBy) {
            this.setAllObjectAttributes("nodes", "size", this.sizeDecorationBy, true)
        }
        if (this.colorEdgeBy) {
            this.setAllObjectAttributes("edges", "color", this.colorEdgeBy)
        }
        if (this.shapeEdgeBy) {
            this.setAllObjectAttributes("edges", "shape", this.shapeEdgeBy)
        }
        if (this.sizeEdgeBy) {
            this.setAllObjectAttributes("edges", "size", this.sizeEdgeBy)
        }
    };
    this.resetObjectAttributes = function() {
        this.colorNodeBy = false;
        this.shapeNodeBy = false;
        this.sizeNodeBy = false;
        this.sizeDecorationBy = false;
        this.colorEdgeBy = false;
        this.shapeEdgeBy = false;
        this.sizeEdgeBy = false
    };
    this.setDecorationsRangeUnits = function() {
        this.decorationsRange = [];
        var c = {};
        var d = {};
        if (this.showDecorations && this.decorations.length > 0) {
            var n = [];
            for (var l = 0; l < this.data.nodes.length; l++) {
                var f = this.data.nodes[l];
                for (var h = 0; h < this.decorations.length; h++) {
                    if (f[this.decorations[h]] || (f.decorations && f.decorations[this.decorations[h]])) {
                        var o = f[this.decorations[h]] ? f[this.decorations[h]] : f.decorations[this.decorations[h]];
                        if (this.isObject(o)) {
                            if (this.decorationsType == "stacked") {
                                var q = 0;
                                for (var g in o) {
                                    if (!isNaN(o[g])) {
                                        d[g] = true;
                                        q += o[g]
                                    }
                                }
                                n.push(q)
                            } else {
                                if (this.decorationsType == "stackedpercent") {
                                    for (var g in o) {
                                        if (!isNaN(o[g])) {
                                            d[g] = true
                                        }
                                    }
                                    n = [0, 100]
                                } else {
                                    if (this.decorationsType == "heatmap") {
                                        for (var g in o) {
                                            if (!isNaN(o[g])) {
                                                d[g] = true;
                                                n.push(o[g])
                                            }
                                        }
                                    } else {
                                        alert("Ooops! canvasXpress does not support " + this.decorationsType + " for this multidimensional plotting");
                                        return
                                    }
                                }
                            }
                        } else {
                            if (!isNaN(f[this.decorations[h]]) || (f.decorations && !isNaN(f.decorations[this.decorations[h]]))) {
                                n.push(f[this.decorations[h]] ? f[this.decorations[h]] : f.decorations[this.decorations[h]])
                            }
                        }
                    }
                }
            }
            this.decorationsRange = this.range(n);
            if (this.decorationsType == "stacked") {
                this.decorationsRange[0] = 0
            }
            var b = this.decorationsRange[1] - this.decorationsRange[0];
            if (b == 0) {
                this.decorationsRange[1] = this.max(n) + 1
            }
            var m = this.decorationsType.match(/stacked/) ? this.decorationsRange[0] : this.decorationsRange[0] - (b * 0.05);
            if (m > 0) {
                this.decorationsRange[0] = m;
                b = this.decorationsRange[1] - this.decorationsRange[0]
            }
            this.decorationsUnits = this.decorationsHeight / b;
            if (!this.data.legend) {
                this.data.legend = {}
            }
            this.data.legend.decorations = [];
            for (var l = 0; l < this.decorations.length; l++) {
                if (this.decorationsColors[l]) {
                    c[this.decorationsColors[l]] = true;
                    this.data.legend.decorations.push({
                        shape: this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].shape ? this.decorationsProperties[this.decorations[l]].shape : "circle",
                        color: this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].color ? this.decorationsProperties[this.decorations[l]].color : this.decorationsColors[l],
                        text: this.decorations[l],
                        size: 0.5,
                        font: 0.5
                    })
                } else {
                    for (var h = 0; h < this.colors.length; h++) {
                        if (!c.hasOwnProperty(this.colors[h])) {
                            var e = this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].color ? this.decorationsProperties[this.decorations[l]].color : this.colors[h];
                            var p = this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].shape ? this.decorationsProperties[this.decorations[l]].shape : "circle";
                            this.decorationsColors[l] = e;
                            c[e] = true;
                            this.data.legend.decorations.push({
                                shape: p,
                                color: e,
                                text: this.decorations[l],
                                size: 0.5,
                                font: 0.5
                            });
                            break
                        }
                    }
                }
            }
            var l = this.decorations.length;
            for (var g in d) {
                if (this.decorationsColors[l]) {
                    c[this.decorationsColors[l]] = true;
                    this.data.legend.decorations.push({
                        shape: this.decorationsProperties[g] && this.decorationsProperties[g].shape ? this.decorationsProperties[g].shape : "square",
                        color: this.decorationsProperties[g] && this.decorationsProperties[g].color ? this.decorationsProperties[g].color : this.decorationsColors[l],
                        text: g,
                        size: 0.5,
                        font: 0.5
                    })
                } else {
                    for (var h = 0; h < this.colors.length; h++) {
                        if (!c.hasOwnProperty(this.colors[h])) {
                            var e = this.decorationsProperties[g] && this.decorationsProperties[g].color ? this.decorationsProperties[g].color : this.colors[h];
                            var p = this.decorationsProperties[g] && this.decorationsProperties[g].shape ? this.decorationsProperties[g].shape : "square";
                            this.decorationsColors[l] = e;
                            c[e] = true;
                            this.data.legend.decorations.push({
                                shape: p,
                                color: e,
                                text: g,
                                size: 0.5,
                                font: 0.5
                            });
                            break
                        }
                    }
                }
                l++
            }
        }
    };
    this.checkCalculateLayout = function() {
        if (!this.calculateLayout) {
            for (var b = 0; b < this.data.nodes.length; b++) {
                var c = this.data.nodes[b];
                if (this.is3DNetwork) {
                    if (c.x3d == null || c.y3d == null) {
                        this.calculateLayout = true;
                        return
                    }
                } else {
                    if (c.x == null || c.y == null) {
                        this.calculateLayout = true;
                        return
                    }
                }
            }
        }
    };
    this.recalculateLayout = function() {
        this.calculateLayout = true;
        this.initializeNetwork()
    };
    this.validateXYNodeCoordinates = function() {
        for (var b = 0; b < this.data.nodes.length; b++) {
            var c = this.data.nodes[b];
            if (this.is3DNetwork) {
                if (c.x3d == null) {
                    c.x3d = -1
                }
                if (c.y3d == null) {
                    c.y3d = -1
                }
            } else {
                if (c.x == null) {
                    c.x = -1
                }
                if (c.y == null) {
                    c.y = -1
                }
            }
        }
    };
    this.drawNetworkPlot = function() {
        this.showAnimationFont = (this.showAnimationFontSize) + "Pt " + this.fontName;
        this.setNodeParentHood();
        this.setObjectAttributes();
        this.setDecorationsRangeUnits();
        if (this.calculateLayout) {
            this.collateNetworks();
            this.setNetworkPrivateParams();
            if (this.networkLayoutType == "radial") {
                this.setRadialNetwrorkLayout()
            } else {
                this.optimizeNetworkLayout()
            }
            this.calculateLayout = false
        } else {
            this.validateXYNodeCoordinates();
            this.layoutDone = true;
            if (this.networkLayoutType == "radial" && this.showAnimation) {
                this.setRadialNetwrorkLayout()
            } else {
                this.renderNetwork()
            }
        } if (this.networkFreezeOnLoad && this.layoutDone) {
            this.networkFreezeOnLoad = false;
            this.networkFreeze = true
        }
    };
    this.initializeNetwork = function() {
        this.checkCalculateLayout();
        this.setNetworkDimensions();
        if (!this.nodes && this.data.nodes) {
            this.setNodes()
        }
        this.drawNetworkPlot()
    };
    if (!a) {
        this.initializeNetwork()
    }
};
CanvasXpress.prototype.Genome = function() {
    this.setGenomeSubtracks = function() {
        this.subtracks = [];
        this.subtracksInfo = [];
        this.y = this.margin;
        var a = this.marginTop + this.top;
        var G = 0;
        var C = this.xAxisMin * this.xAxisUnit;
        var u = this.xAxisMax * this.xAxisUnit;
        for (var I = 0; I < this.data.tracks.length; I++) {
            var g, q, K, n;
            var f = [];
            var A = [];
            var F = 0;
            var w = this.data.tracks[I];
            var d = w.data;
            var b = w.type ? w.type : this.featureTypeDefault;
            var J = w.height ? w.height : this.featureHeightDefault;
            var B = w.subtracksMax || this.subtracksMaxDefault;
            var L = w.bumpSpace ? w.bumpSpace : 0;
            if (!w.hide) {
                if (w.name && !w.hideName) {
                    this.y += this.trackNameFontSize + (this.margin * 2)
                }
                w.startY = this.marginTop + this.top + this.y;
                this.subtracks[I] = [];
                if (this.featureStaggered) {
                    for (var E = 0; E < d.length; E++) {
                        var c = d[E];
                        var p = this.shortenText(c.label || c.name || c.id, this.maxFeatureStringLen);
                        var y = c.hideName || w.hideFeatureNames ? 0 : this.measureText(p, this.featureNameFont) + (this.margin * 3);
                        var M = c.data;
                        if (!c.hide) {
                            c.index = E;
                            c.counter = G++;
                            if (b == "box") {
                                g = this.getGenomeBoxRange(M);
                                q = g[0] * this.xAxisUnit;
                                K = (g[1] + L) * this.xAxisUnit;
                                if (c.showDir && this.xAxisUnit > 0.001) {
                                    if (c.dir == "right") {
                                        K += 11
                                    } else {
                                        q -= 11
                                    }
                                }
                                K = Math.max(q + y, K)
                            } else {
                                if (b == "sequence") {
                                    var x = this.setGenomeGaps(c.gaps, c.sequence.length, c.dir);
                                    if (c.offsetLeft && !c.offset) {
                                        c.offset = (c.offsetLeft - (c.sequence.length + x.total)) + 1
                                    }
                                    q = c.offset * this.xAxisUnit;
                                    K = q + ((c.sequence.length + x.total + L) * this.xAxisUnit);
                                    K = Math.max(q + y, K)
                                } else {
                                    q = (c.offset + L) * this.xAxisUnit;
                                    K = w.autowidth && this.isArray(M) ? q + (M.length * this.xAxisUnit) : q + w.width ? w.width : this.featureWidthDefault;
                                    K = Math.max(q + y, K)
                                }
                            }
                            n = q >= C && q < u ? true : K > C && K <= u ? true : q <= C && K >= u ? true : false;
                            f.push([q, K, n, E])
                        }
                    }
                    if (f.length > 0) {
                        f.sort(function(h, e) {
                            return h[0] - e[0]
                        });
                        for (var E = 0; E < f.length; E++) {
                            if (f[E][2]) {
                                n = false;
                                for (var D = 0; D < A.length; D++) {
                                    K = A[D][A[D].length - 1][1];
                                    if (f[E][0] > K) {
                                        A[D].push(f[E]);
                                        n = true;
                                        break
                                    }
                                }
                                if (!n) {
                                    A.push([f[E]])
                                }
                            }
                        }
                        for (var E = 0; E < A.length; E++) {
                            if (E < B) {
                                this.subtracks[I][E] = [];
                                F += A[E].length;
                                var H = 0;
                                var t = 0;
                                var o = 0;
                                for (var D = 0; D < A[E].length; D++) {
                                    c = d[A[E][D][3]];
                                    this.subtracks[I][E].push(A[E][D][3]);
                                    this.subtracksInfo[c.counter] = {
                                        track: I,
                                        subtrack: E,
                                        index: c.index,
                                        name: c.label || c.name || c.id,
                                        start: a + this.y
                                    };
                                    if (b == "box") {
                                        H = Math.max(H, this.getBoxFeatureHeight(c));
                                        t = Math.max(t, c.translatesTop || 0);
                                        o = Math.max(o, c.translatesBottom || 0)
                                    } else {
                                        if (b == "sequence") {
                                            H = Math.max(H, this.getSequenceFeatureHeight(c))
                                        }
                                    }
                                }
                                if (!this.isNameInSubtrack(w, this.subtracks[I][E])) {
                                    this.y += this.featureNameFontSize + this.margin
                                }
                                this.y += J + this.margin;
                                if (b == "box" || b == "sequence") {
                                    this.y += H
                                }
                                for (var D = 0; D < A[E].length; D++) {
                                    c = d[A[E][D][3]];
                                    this.subtracksInfo[c.counter].end = a + this.y;
                                    this.subtracksInfo[c.counter].maxHeight = H;
                                    this.subtracksInfo[c.counter].translateTop = t;
                                    this.subtracksInfo[c.counter].translateBottom = o
                                }
                            }
                        }
                    }
                } else {
                    for (var E = 0; E < d.length; E++) {
                        var c = d[E];
                        if (!c.hide) {
                            c.index = E;
                            c.counter = G++;
                            if (E < B) {
                                F++;
                                this.subtracks[I][E] = [E];
                                this.subtracksInfo[c.counter] = {
                                    track: I,
                                    subtrack: E,
                                    index: c.index,
                                    name: c.label || c.name || c.id,
                                    start: a + this.y
                                };
                                this.y += J + this.margin;
                                if (b == "box") {
                                    this.subtracksInfo[c.counter].maxHeight = this.getBoxFeatureHeight(c);
                                    this.subtracksInfo[c.counter].translateTop = c.translatesTop || 0;
                                    this.subtracksInfo[c.counter].translateBottom = c.translatesBottom || 0;
                                    this.y += this.subtracksInfo[c.counter].maxHeight
                                } else {
                                    if (b == "sequence") {
                                        this.subtracksInfo[c.counter].maxHeight = this.getSequenceFeatureHeight(c);
                                        this.y += this.subtracksInfo[c.counter].maxHeight
                                    }
                                }
                                this.subtracksInfo[c.counter].end = a + this.y
                            }
                        }
                    }
                }
                w.endY = this.y;
                w.displayedFeatures = F;
                w.totalFeatures = d.length;
                this.y += (this.margin * 2)
            }
        }
    };
    this.isNameInSubtrack = function(a, e) {
        for (var c = 0; c < e.length; c++) {
            var d = e[c];
            var b = a.data[d];
            if (!b.hideName && !a.hideFeatureNames) {
                return false
            }
        }
        return true
    };
    this.getGenomeRange = function(a) {
        var f = [];
        for (var d = 0; d < a.length; d++) {
            var e = a[d].data;
            if (this.isArray(e[0])) {
                for (var c = 0; c < e.length; c++) {
                    for (var b = 0; b < e[c].length; b++) {
                        f = f.concat(e[c][b])
                    }
                }
            } else {
                for (var c = 0; c < e.length; c++) {
                    f = f.concat(e[c])
                }
            }
        }
        return this.range(f)
    };
    this.getGenomeBoxRange = function(c) {
        if (c) {
            var a = [];
            for (var b = 0; b < c.length; b++) {
                a.push(c[b][0]);
                a.push(c[b][1])
            }
            a.sort(function(e, d) {
                return e - d
            });
            return [a[0], a[a.length - 1]]
        } else {
            return [0, 1]
        }
    };
    this.setGenomeGaps = function(e, a, b) {
        var d = 0;
        var f = {
            total: d
        };
        if (e && this.isArray(e) && e.length > 0) {
            for (var c = 0; c < e.length; c++) {
                var h = b == "left" ? a - e[c][0] : e[c][0];
                f[h] = e[c][1];
                d += e[c][1]
            }
            f.total = d
        }
        return f
    };
    this.getBoxFeatureHeight = function(b) {
        if (this.genomeResolution != "low" && (b.translate || b.sequence)) {
            if (b.dir == "left" && !b.sequenceRC) {
                b.sequenceRC = this.getReverseComplement(b.sequence)
            }
            if (b.cds && !b.translate) {
                var a = b.cds[0] % 3 || 3;
                b.translate = b.dir == "left" ? [a * -1] : [a]
            }
            if (b.translate && !b.translateRC && this.featureTranslateShow) {
                b.translateRC = this.translate(b.translate, b.dir == "left" ? b.sequenceRC : b.sequence)
            }
            if (b.translate && this.genomeResolution == "high") {
                return this.featureTranslateHeight * b.translate.length
            }
        }
        return 0
    };
    this.getSequenceFeatureHeight = function(b) {
        var c = 0;
        if (this.genomeResolution == "high") {
            if (b.trace && this.featureTracesShow) {
                c += this.featureTraceHeight
            }
            if (b.translate && this.featureTranslateShow) {
                for (var a = 0; a < b.translate.length; a++) {
                    c += this.featureTranslateHeight
                }
            }
            if (b.quality && this.featureQualityShow) {
                c += this.featureQualityHeight
            }
            if (b.signalToNoise && this.featureSignalToNoiseShow) {
                c += this.featureSignalToNoiseHeight
            }
            if (b.coordinate && this.featureCoordinateShow) {
                c += this.featureCoordinateHeight
            }
        } else {
            if (this.genomeResolution == "medium") {
                if (b.trace && this.featureTracesShow) {
                    c += this.featureTraceHeight
                }
            }
        }
        return c
    };
    this.getReverseComplement = function(d) {
        var b = d.split("");
        var a = [];
        for (var c = 0; c < b.length; c++) {
            a.unshift(this.reverseComplement[b[c]])
        }
        return a.join("")
    };
    this.translate = function(b, g) {
        var a = {
            top: [],
            bottom: []
        };
        var m = g.split("");
        var e = this.getReverseComplement(g).split("").reverse();
        for (var h = 0; h < b.length; h++) {
            var l = b[h];
            var f = {
                seq: [],
                off: 0,
                rf: b[h]
            };
            if (l == "-1") {
                f.off = e.length % 3;
                for (var d = e.length - 1; d >= 0; d -= 3) {
                    var n = e[d] + e[d - 1] + e[d - 2];
                    var k = this.codon[n.toUpperCase()];
                    f.seq.unshift(k ? k[0] : "")
                }
                a.bottom.push(f)
            } else {
                if (l == "-2") {
                    f.off = (e.length - 1) % 3;
                    for (var d = e.length - 2; d >= 0; d -= 3) {
                        var n = e[d] + e[d - 1] + e[d - 2];
                        var k = this.codon[n.toUpperCase()];
                        f.seq.unshift(k ? k[0] : "")
                    }
                    a.bottom.push(f)
                } else {
                    if (l == "-3") {
                        f.off = (e.length - 2) % 3;
                        for (var d = e.length - 3; d >= 0; d -= 3) {
                            var n = e[d] + e[d - 1] + e[d - 2];
                            var k = this.codon[n.toUpperCase()];
                            f.seq.unshift(k ? k[0] : "")
                        }
                        a.bottom.push(f)
                    } else {
                        if (l == "1") {
                            f.off = 0;
                            for (var d = 0; d < m.length; d += 3) {
                                var n = m[d] + m[d + 1] + m[d + 2];
                                var k = this.codon[n.toUpperCase()];
                                f.seq.push(k ? k[0] : "")
                            }
                            a.top.push(f)
                        } else {
                            if (l == "2") {
                                f.off = 1;
                                for (var d = 1; d < m.length; d += 3) {
                                    var n = m[d] + m[d + 1] + m[d + 2];
                                    var k = this.codon[n.toUpperCase()];
                                    f.seq.push(k ? k[0] : "")
                                }
                                a.top.push(f)
                            } else {
                                if (l == "3") {
                                    f.off = 2;
                                    for (var d = 2; d < m.length; d += 3) {
                                        var n = m[d] + m[d + 1] + m[d + 2];
                                        var k = this.codon[n.toUpperCase()];
                                        f.seq.push(k ? k[0] : "")
                                    }
                                    a.top.push(f)
                                }
                            }
                        }
                    }
                }
            }
        }
        return a
    };
    this.setReverseTrace = function(j) {
        if (!j.reversed) {
            var d = j.A.length;
            var b = j.T.reverse();
            var m = j.G.reverse();
            var h = j.C.reverse();
            var f = j.A.reverse();
            var k = [];
            for (var e = 0; e < j.peak.length; e++) {
                k.unshift(d - j.peak[e])
            }
            j.A = b;
            j.C = m;
            j.G = h;
            j.T = f;
            j.peak = k;
            j.reversed = true
        }
    };
    this.getCoordinateStep = function() {
        var a = 1;
        if (this.xAxisUnit * 0.2 > this.sequenceFontSize) {
            a = 1
        } else {
            if (this.xAxisUnit * 0.5 > this.sequenceFontSize) {
                a = 5
            } else {
                if (this.xAxisUnit * 1 > this.sequenceFontSize) {
                    a = 10
                } else {
                    if (this.xAxisUnit * 200 > this.sequenceFontSize) {
                        a = 20
                    } else {
                        if (this.xAxisUnit * 500 > this.sequenceFontSize) {
                            a = 50
                        } else {
                            if (this.xAxisUnit * 1000 > this.sequenceFontSize) {
                                a = 100
                            } else {
                                if (this.xAxisUnit * 2500 > this.sequenceFontSize) {
                                    a = 250
                                } else {
                                    if (this.xAxisUnit * 5000 > this.sequenceFontSize) {
                                        a = 500
                                    } else {
                                        if (this.xAxisUnit * 2000 > this.sequenceFontSize) {
                                            a = 1000
                                        } else {
                                            if (this.xAxisUnit * 10000 > this.sequenceFontSize) {
                                                a = 5000
                                            } else {
                                                if (this.xAxisUnit * 20000 > this.sequenceFontSize) {
                                                    a = 10000
                                                } else {
                                                    if (this.xAxisUnit * 100000 > this.sequenceFontSize) {
                                                        a = 50000
                                                    } else {
                                                        if (this.xAxisUnit * 200000 > this.sequenceFontSize) {
                                                            a = 100000
                                                        } else {
                                                            if (this.xAxisUnit * 2000000 > this.sequenceFontSize) {
                                                                a = 1000000
                                                            } else {
                                                                if (this.xAxisUnit * 20000000 > this.sequenceFontSize) {
                                                                    a = 10000000
                                                                } else {
                                                                    if (this.xAxisUnit * 200000000 > this.sequenceFontSize) {
                                                                        a = 100000000
                                                                    } else {
                                                                        if (this.xAxisUnit * 2000000000 > this.sequenceFontSize) {
                                                                            a = 1000000000
                                                                        } else {
                                                                            if (this.xAxisUnit * 20000000000 > this.sequenceFontSize) {
                                                                                a = 10000000000
                                                                            } else {
                                                                                if (this.xAxisUnit * 200000000000 > this.sequenceFontSize) {
                                                                                    a = 100000000000
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } if (this.xAxisRange / a > 10) {
            a *= (a * 0.1);
            while (a * 10 > this.xAxisRange) {
                a *= 0.1
            }
            return a
        } else {
            if (a * 3 > this.xAxisRange) {
                return a * 0.1
            } else {
                return a
            }
        }
    };
    this.drawBoxSequenceName = function(h, b, e, m, a, d, l, j, g, c) {
        var k = this.featureNameFontSize / 2;
        var f = this.measureText(b, this.featureNameFont) + this.margin;
        if (g >= this.xAxisMin && c <= this.xAxisMax) {
            d = j + d;
            this.addArea(this.drawText(b, d, l + k, this.featureNameFont, this.featureNameFontColor, "left", "middle"), ["track-" + h + ":" + a])
        } else {
            if (g <= this.xAxisMin && c >= this.xAxisMin) {
                d = j;
                this.addArea(this.drawText(b, d, l + k, this.featureNameFont, this.featureNameFontColor, "left", "middle"), ["track-" + h + ":" + a])
            } else {
                if ((g <= this.xAxisMax && c >= this.xAxisMax)) {
                    d = j + d;
                    this.addArea(this.drawText(b, d, l + k, this.featureNameFont, this.featureNameFontColor, "left", "middle"), ["track-" + h + ":" + a])
                } else {
                    d = j + d
                }
            }
        } if (e == "right") {
            this.drawShape("polygon", [d + f, d + f + (this.margin * 2), d + f], [l - 1, l + k - 1, l + (k * 2) - 1], false, false, m, m, "closed")
        } else {
            if (e == "left") {
                this.drawShape("polygon", [d + f, d + f + (this.margin * 2), d + f + (this.margin * 2)], [l + k - 1, l - 1, l + (k * 2) - 1], false, false, m, m, "closed")
            }
        }
    };
    this.drawGenomeLabels = function() {
        if (!this.featureStaggered) {
            var w = this.marginLeft;
            var c = this.marginTop + this.top + this.margin;
            var b = this.featureNameFontSize / 2;
            var a = 0;
            for (var v = 0; v < this.data.tracks.length; v++) {
                var p = this.data.tracks[v];
                var d = p.type || this.featureTypeDefault;
                var n = p.height || this.featureHeightDefault;
                if (!p.hide) {
                    if (p.name && !p.hideName) {
                        c += this.trackNameFontSize + (this.margin * 2)
                    }
                    for (var t = 0; t < this.subtracks[v].length; t++) {
                        var x = this.subtracks[v][t];
                        if (!x) {
                            continue
                        }
                        for (var r = 0; r < x.length; r++) {
                            var m = x[r];
                            var e = p.data[m];
                            var u = e.counter;
                            var s = e.fill || p.fill || this.foreground;
                            var g = this.shortenText(e.label || e.name || e.id, this.maxFeatureStringLen);
                            var f = e.measureText || this.measureText(g, this.featureNameFont) + this.margin;
                            e.measureText = f;
                            if (!e.hideName && !p.hideFeatureNames) {
                                this.addArea(this.drawText(g, this.marginLeft, c + (n / 2), this.featureNameFont, this.featureNameFontColor, "left", "middle"), ["track-" + v + ":" + u])
                            }
                            if (d == "box" || d == "sequence") {
                                if (e.dir == "right") {
                                    this.drawShape("polygon", [w + f, w + f + (this.margin * 2), w + f], [c, c + b, c + (b * 2)], false, false, s, s, "closed")
                                } else {
                                    if (e.dir == "left") {
                                        this.drawShape("polygon", [w + f, w + f + (this.margin * 2), w + f + (this.margin * 2)], [c + b, c, c + (b * 2)], false, false, s, s, "closed")
                                    }
                                } if (e.translate && this.genomeResolution == "high") {
                                    var h = (this.featureNameFontSize - 2) + "Pt " + this.fontName;
                                    a = -4;
                                    if (e.trace && this.featureTracesShow) {
                                        a += this.featureTraceHeight
                                    }
                                    if (e.translate && this.featureTranslateShow) {
                                        for (var q = 0; q < e.translate.length; q++) {
                                            var o = "+" + e.translate[q];
                                            if (o == "+1") {
                                                this.drawText(o, this.marginLeft + f, c + a + (n / 2), h, this.featureNameFontColor, "left", "middle");
                                                a += this.featureTranslateHeight
                                            } else {
                                                if (o == "+2") {
                                                    this.drawText(o, this.marginLeft + f, c + a + (n / 2), h, this.featureNameFontColor, "left", "middle");
                                                    a += this.featureTranslateHeight
                                                } else {
                                                    if (o == "+3") {
                                                        this.drawText(o, this.marginLeft + f, c + a + (n / 2), h, this.featureNameFontColor, "left", "middle");
                                                        a += this.featureTranslateHeight
                                                    }
                                                }
                                            }
                                        }
                                        a += this.sequenceFontSize + 2;
                                        for (var q = 0; q < e.translate.length; q++) {
                                            var o = e.translate[q];
                                            if (o == "-1") {
                                                this.drawText(o, this.marginLeft + f, c + a + (n / 2), h, this.featureNameFontColor, "left", "middle");
                                                a += this.featureTranslateHeight
                                            } else {
                                                if (o == "-2") {
                                                    this.drawText(o, this.marginLeft + f, c + a + (n / 2), h, this.featureNameFontColor, "left", "middle");
                                                    a += this.featureTranslateHeight
                                                } else {
                                                    if (o == "-3") {
                                                        this.drawText(o, this.marginLeft + f, c + a + (n / 2), h, this.featureNameFontColor, "left", "middle");
                                                        a += this.featureTranslateHeight
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                if (d == "box") {
                                    c += this.getBoxFeatureHeight(e)
                                } else {
                                    c += this.getSequenceFeatureHeight(e)
                                }
                            }
                            c += n + this.margin
                        }
                    }
                    c += this.margin * 2
                }
            }
        }
    };
    this.setMinMaxGenome = function(c, a, b) {
        if (a != null) {
            c = Math.max(c, a)
        }
        if (b != null) {
            c = Math.min(c, b)
        }
        return c
    };
    this.plotGenomeData = function() {
        var z, y, ae, x, ac, w, f, Q, B;
        var K = this.marginLeft + this.left;
        var a = this.marginTop + this.top;
        var ab = this.xAxisUnit / 2;
        for (var V = 0; V < this.data.tracks.length; V++) {
            var D = this.data.tracks[V];
            var ad = D.type || this.featureTypeDefault;
            var e = D.height || this.featureHeightDefault;
            var C = D.subtracksMax || this.subtracksMaxDefault;
            var F = this.setMaxY != null ? this.setMaxY : D.setMaxY != null ? D.setMaxY : null;
            var aa = this.setMinY != null ? this.setMinY : D.setMinY != null ? D.setMinY : null;
            var p = ad.match(/bar|heatmap|line/) && F != null && aa != null ? [F, aa] : ad.match(/bar|heatmap|line/) ? this.getGenomeRange(D.data) : false;
            var A = ad.match(/bar|line|box/) && D.fill ? D.fill : false;
            var E = ad.match(/bar|line|box/) && D.outline ? D.outline : this.foreground;
            var o = A ? "closed" : "open";
            var M = false;
            z = K;
            if (!D.hide) {
                if (p) {
                    if (F != null) {
                        p[1] = F
                    }
                    if (aa != null) {
                        p[0] = aa
                    }
                    Q = (p[1] - p[0]) * 1.05;
                    B = e / Q
                }
                if (D.name && !D.hideName) {
                    var u = D.name;
                    if (D.displayedFeatures != D.totalFeatures) {
                        u += " (Showing " + D.displayedFeatures + " out of " + D.totalFeatures + ")"
                    }
                    this.addArea(this.drawText(u, z, a + (this.trackNameFontSize / 2) + this.margin, this.trackNameFont, this.trackNameFontColor, "left", "middle"), ["track-" + V]);
                    a += this.trackNameFontSize + (this.margin * 2)
                }
                if (D.highlight && this.genomeResolution != "low") {
                    var W = D.highlight;
                    for (var T = 0; T < W.length; T++) {
                        if (W[T].offset) {
                            var Z = W[T].color ? W[T].color : this.colors[V % this.colors.length];
                            z = this.marginLeft + this.left + (((W[T].offset - 0.5) - this.xAxisMin) * this.xAxisUnit);
                            y = W[T].width ? W[T].width * this.xAxisUnit : this.xAxisUnit;
                            this.rectangle(z, D.startY, y, (D.endY - D.startY) + e, Z, Z)
                        }
                    }
                }
                for (var T = 0; T < this.subtracks[V].length; T++) {
                    var t = this.subtracks[V][T];
                    if (!t) {
                        continue
                    }
                    if (this.featureStaggered) {
                        M = this.isNameInSubtrack(D, t)
                    }
                    for (var S = 0; S < t.length; S++) {
                        var Y = t[S];
                        var L = D.data[Y];
                        var X = L.data;
                        var u = this.shortenText(L.label || L.name || L.id, this.maxFeatureStringLen);
                        if (ad == "box") {
                            if (X.length > 0) {
                                this.setGenomeBoxExons(L);
                                if (this.featureStaggered && !D.hideFeatureNames && (!L.hideName || !M)) {
                                    if (!L.hideName) {
                                        z = (((L.start - this.xAxisMin) * this.xAxisUnit)) - ab;
                                        this.drawBoxSequenceName(V, u, L.dir, L.fill || A, L.counter, z, a, K, L.start, L.end)
                                    }
                                    a += this.featureNameFontSize + this.margin
                                }
                                this.drawGenomeBox(a, e, L, D);
                                if (this.genomeResolution == "high" && L.translate && this.featureTranslateShow) {
                                    a += this.featureTranslateHeight * L.translate.length
                                }
                            }
                        } else {
                            if (ad == "sequence") {
                                var v = this.setGenomeGaps(L.gaps, L.sequence.length, L.dir);
                                if (L.offsetLeft && !L.offset) {
                                    L.offset = (L.offsetLeft - (L.sequence.length + v.total)) + 1
                                }
                                if (this.featureStaggered && !D.hideFeatureNames && (!L.hideName || !M)) {
                                    if (!L.hideName) {
                                        z = ((L.offset - this.xAxisMin) * this.xAxisUnit) - ab;
                                        this.drawBoxSequenceName(V, u, L.dir, L.fill, L.counter, z, a, K, L.offset, L.offset + L.sequence.length + v.total)
                                    }
                                    a += this.featureNameFontSize + this.margin
                                }
                                if (this.genomeResolution == "high") {
                                    if (L.trace && this.featureTracesShow) {
                                        this.drawGenomeTrace(a, L.counter, this.featureTraceHeight - 1, L.offset, L.trace, v, L.dir);
                                        a += this.featureTraceHeight
                                    }
                                    this.drawGenomeSequence(a, e, v, L, D);
                                    a += e;
                                    if (L.translate && this.featureTranslateShow) {
                                        for (var R = 0; R < L.translate.length; R++) {
                                            a += this.featureTranslateHeight
                                        }
                                    }
                                    if (L.quality && this.featureQualityShow) {
                                        this.drawGenomeQuality(a, L.counter, this.featureQualityHeight - 1, L.offset, L.quality, v, L.dir, D);
                                        a += this.featureQualityHeight
                                    }
                                    if (L.signalToNoise && this.featureSignalToNoiseShow) {
                                        this.drawGenomeSignalToNoise(a, L.counter, this.featureSignalToNoiseHeight - 1, L.offset, L.signalToNoise, v, L.dir, D);
                                        a += this.featureSignalToNoiseHeight
                                    }
                                    if (L.coordinate && this.featureCoordinateShow) {
                                        this.drawGenomeCoordinate(a + 1, L.counter, this.featureCoordinateHeight - 1, L.offset, L.coordinate, L.sequence.length, v, L.dir, D);
                                        a += this.featureCoordinateHeight
                                    }
                                    a -= e
                                } else {
                                    if (this.genomeResolution == "medium") {
                                        if (L.trace && this.featureTracesShow) {
                                            this.drawGenomeTrace(a, L.counter, this.featureTraceHeight - 1, L.offset, L.trace, v, L.dir);
                                            a += this.featureTraceHeight
                                        }
                                        this.drawGenomeSequence(a, e, v, L, D);
                                        if (L.coordinate && this.featureCoordinateShow) {
                                            this.drawGenomeCoordinate(a + 1, L.counter, this.featureCoordinateHeight - 1, L.offset, L.coordinate, L.sequence.length, v, L.dir, D)
                                        }
                                    } else {
                                        this.drawGenomeSequence(a, e, v, L, D);
                                        if (L.coordinate && this.featureCoordinateShow) {
                                            this.drawGenomeCoordinate(a + 1, L.counter, this.featureCoordinateHeight - 1, L.offset, L.coordinate, L.sequence.length, v, L.dir, D)
                                        }
                                    }
                                }
                            } else {
                                if (ad == "bar") {
                                    var m;
                                    if (this.genomeResolution == "high") {
                                        m = this.xAxisUnit / X.length
                                    } else {
                                        m = D.autowidth ? this.xAxisUnit : L.width ? L.width : D.width ? D.width : this.featureWidthDefault
                                    }
                                    var U = m * X.length;
                                    z = this.marginLeft + this.left + ((L.offset - this.xAxisMin) * this.xAxisUnit) - ((U / 2) + 1);
                                    if (this.featureStaggered && !D.hideFeatureNames && (!L.hideName || !M)) {
                                        if (!L.hideName) {
                                            this.addArea(this.drawText(u, z, a + (this.featureNameFontSize / 2), this.featureNameFont, this.featureNameFontColor, "left", "middle"), ["track-" + V + ":" + L.counter])
                                        }
                                        a += this.featureNameFontSize + this.margin
                                    }
                                    this.addArea(["rect", z, a, z + (X.length * m), a + e], [L.counter]);
                                    y = z;
                                    var b = p[1] < 0 ? a : p[0] >= 0 ? a + e : (a + e) - Math.abs(p[0] * B);
                                    for (var O = 0; O < X.length; O++) {
                                        var g = L.fill || A;
                                        var N = L.outline || E;
                                        var J = this.isArray(g) && g.length == X.length ? g[O] : this.isArray(g) ? g[0] : this.foreground;
                                        var r = this.isArray(N) && N.length == X.length ? N[O] : this.isArray(N) ? N[0] : this.foreground;
                                        var W = X[O] * B;
                                        this.rectangle(y, b, m, -W, J, r);
                                        if (D.autowidth) {
                                            y += m
                                        } else {
                                            y += m + 2
                                        }
                                    }
                                } else {
                                    if (ad == "heatmap") {
                                        var m;
                                        if (this.genomeResolution == "high") {
                                            m = this.xAxisUnit
                                        } else {
                                            m = D.autowidth ? this.xAxisUnit : L.width ? L.width : D.width ? D.width : this.featureWidthDefault
                                        }
                                        z = this.marginLeft + this.left + ((L.offset - this.xAxisMin) * this.xAxisUnit) - ((m / 2) + 1);
                                        if (this.featureStaggered && !D.hideFeatureNames && (!L.hideName || !M)) {
                                            if (!L.hideName) {
                                                this.addArea(this.drawText(u, z, a + (this.featureNameFontSize / 2), this.featureNameFont, this.featureNameFontColor, "left", "middle"), ["track-" + V + ":" + L.counter])
                                            }
                                            a += this.featureNameFontSize + this.margin
                                        }
                                        this.addArea(["rect", z, a, z + m, a + e], [L.counter]);
                                        var W = D.autowidth ? e : e / X.length;
                                        ae = a;
                                        for (var O = 0; O < X.length; O++) {
                                            var H = X[O];
                                            var n = this.getHeatmapColor(p[0], p[1], H);
                                            if (isNaN(H)) {
                                                this.rectangle(z, ae, m, W, this.missingDataColor, this.missingDataColor)
                                            } else {
                                                this.rectangle(z, ae, m, W, n, n)
                                            } if (D.autowidth) {
                                                z += m
                                            } else {
                                                ae += W
                                            }
                                        }
                                    } else {
                                        if (ad == "line") {
                                            var m = D.autowidth ? this.xAxisUnit : L.width ? L.width : D.width ? D.width : this.featureWidthDefault;
                                            z = this.marginLeft + this.left + ((L.offset - this.xAxisMin) * this.xAxisUnit);
                                            if (this.featureStaggered && !D.hideFeatureNames && (!L.hideName || !M)) {
                                                if (!L.hideName) {
                                                    this.addArea(this.drawText(u, z, a + (this.featureNameFontSize / 2), this.featureNameFont, this.featureNameFontColor, "left", "middle"), ["track-" + V + ":" + L.counter])
                                                }
                                                a += this.featureNameFontSize + this.margin
                                            }
                                            if (this.isArray(X[0])) {
                                                var d = 0;
                                                for (var P = 0; P < X.length; P++) {
                                                    d = Math.max(X[P].length, d)
                                                }
                                                this.addArea(["rect", z, a, z + (d * m), a + e], [L.counter]);
                                                for (var P = 0; P < X.length; P++) {
                                                    z = this.marginLeft + this.left + ((L.offset - this.xAxisMin) * this.xAxisUnit);
                                                    var r = this.isArray(E) && E[P] ? E[P] : this.foreground;
                                                    for (var O = 1; O < X[P].length; O++) {
                                                        var I = this.setMinMaxGenome((X[P][O - 1] - p[0]) * B, aa, F);
                                                        var G = this.setMinMaxGenome((X[P][O] - p[0]) * B, aa, F);
                                                        this.drawLine("line", z, e + a - I, z + m, e + a - G, r, false, "butt");
                                                        if (D.autowidth) {
                                                            z += m
                                                        } else {
                                                            z += m + 2
                                                        }
                                                    }
                                                }
                                            } else {
                                                this.addArea(["rect", z, a, z + (X.length * m), a + e], [L.counter]);
                                                var r = this.isArray(E) ? E[0] : this.foreground;
                                                for (var O = 1; O < X.length; O++) {
                                                    var I = this.setMinMaxGenome((X[O - 1] - p[0]) * B, aa, F);
                                                    var G = this.setMinMaxGenome((X[O] - p[0]) * B, aa, F);
                                                    this.drawLine("line", z, e + a - I, z + m, e + a - G, r, false, "butt");
                                                    if (D.autowidth) {
                                                        z += m
                                                    } else {
                                                        z += m + 2
                                                    }
                                                }
                                            }
                                        } else {
                                            if (ad == "triangle") {
                                                z = this.marginLeft + this.left + ((L.offset - this.xAxisMin) * this.xAxisUnit);
                                                A = L.fill ? L.fill : this.foreground;
                                                E = L.outline ? L.outline : this.foreground;
                                                if (this.featureStaggered && !D.hideFeatureNames && (!L.hideName || !M)) {
                                                    if (!L.hideName) {
                                                        this.addArea(this.drawText(u, z, a + (this.featureNameFontSize / 2), this.featureNameFont, this.featureNameFontColor, "left", "middle"), ["track-" + V + ":" + L.counter])
                                                    }
                                                    a += this.featureNameFontSize + this.margin
                                                }
                                                this.addArea(this.drawShape("triangle", z, a + (e / 2), e, e, A, E, "closed"), [L.counter])
                                            }
                                        }
                                    }
                                }
                            }
                        } if (this.featureStaggered) {
                            if (S < t.length - 1) {
                                if (!M) {
                                    a -= (this.featureNameFontSize + this.margin)
                                }
                                if (ad == "box") {
                                    a -= this.getBoxFeatureHeight(L)
                                } else {
                                    if (ad == "sequence") {
                                        a -= this.getSequenceFeatureHeight(L)
                                    }
                                }
                            }
                        }
                    }
                    a += e + this.margin
                }
                a += this.margin * 2
            }
        }
    };
    this.setGenomeBoxExons = function(b) {
        var e = b.data;
        if (!b.start || !b.end) {
            b.start = e[0][0];
            b.end = e[e.length - 1][1];
            if (b.sequence) {
                var g = b.dir == "left" ? b.sequence.length : 1;
                for (var a = 0; a < e.length; a++) {
                    if (e[a].length == 2) {
                        var f = e[a][1] - e[a][0];
                        if (b.dir == "left") {
                            b.data[a].push(g - f, g)
                        } else {
                            b.data[a].push(g, g + f)
                        }
                    }
                    g = b.dir == "left" ? g - (f + 1) : g + f + 1
                }
            }
        }
    };
    this.setGenomeBoxArea = function(g, h, i) {
        if (!i.insertion) {
            var c = this.marginLeft + this.left;
            var d = this.xAxisUnit / 2;
            var e = this.xAxisUnit / 4;
            var b = (((i.start - this.xAxisMin) * this.xAxisUnit) - d);
            var a = (((i.end - this.xAxisMin) * this.xAxisUnit) + d);
            var f = this.subtracksInfo[i.counter].maxHeight;
            if (i.showDir && this.xAxisUnit > 0.001) {
                if (i.dir == "right") {
                    this.addArea(["rect", c + b, g, c + a + 10, g + h + f], [i.counter])
                } else {
                    this.addArea(["rect", (c + b) - 10, g, c + a, g + h + f], [i.counter])
                }
            } else {
                this.addArea(["rect", c + b, g, c + a, g + h + f], [i.counter])
            }
        }
    };
    this.drawGenomeBoxLines = function(o, q, r, e) {
        var d, c, b, a;
        var n = o + (q / 2);
        var l = r.dir == "right" ? o : o + q;
        var g = this.marginLeft + this.left;
        var p = g + this.x;
        var k = r.data;
        var f = this.validateColor(r.fill || r.connect || e.connect || this.foreground);
        var h = this.xAxisUnit / 2;
        var m = [];
        for (var j = 0; j < k.length; j++) {
            d = (((k[j][0] - this.xAxisMin) * this.xAxisUnit) - h);
            c = (((k[j][1] - this.xAxisMin) * this.xAxisUnit) + h) - d;
            if (!r.insertion && (e.connect || r.connect)) {
                if (j < k.length - 1) {
                    b = ((k[j + 1][0] - this.xAxisMin) * this.xAxisUnit);
                    a = (d + c + b - h) / 2;
                    if (g + d + c < p && g + b > g) {
                        if (Math.abs(l - n) < 3) {
                            this.drawLine("line", g + d + c, n, g + b, n, f, false, "butt")
                        } else {
                            this.drawLine("line", g + d + c, n, g + a, l, f, false, "butt");
                            this.drawLine("line", g + a, l, g + b - h, n, f, false, "butt")
                        }
                    }
                }
            }
            if (r.insertion) {
                d = ((((k[j][0] + k[j][1]) / 2) - this.xAxisMin) * this.xAxisUnit);
                m.push([g + d, o + q / 2, h / 2, q])
            } else {
                m.push([g + d, o, c, q])
            }
        }
        if (r.showDir && this.xAxisUnit > 0.001 && !r.insertion) {
            f = this.validateColor(r.showDir) || f;
            d = g + (((r.start - this.xAxisMin) * this.xAxisUnit)) - h;
            c = g + (((r.end - this.xAxisMin) * this.xAxisUnit)) + h;
            b = 10;
            a = 5;
            if (r.dir == "right") {
                if (c < p && c + b > g) {
                    this.drawLine("line", c, n, c + b, n, f, false, "butt");
                    this.drawLine("line", c + a, n - (q / 3), c + b, n, f, false, "butt");
                    this.drawLine("line", c + a, n + (q / 3), c + b, n, f, false, "butt")
                }
            } else {
                if (d - b < p && d > g) {
                    this.drawLine("line", d, n, d - b, n, f, false, "butt");
                    this.drawLine("line", d - a, n - (q / 3), d - b, n, f, false, "butt");
                    this.drawLine("line", d - a, n + (q / 3), d - b, n, f, false, "butt")
                }
            }
        }
        return m
    };
    this.drawGenomeBoxAlleles = function(e, s, d, q, f) {
        var n = q / f.length;
        for (var m = 0; m < f.length; m++) {
            var r = f[m].split("");
            var g = (d - e) / r.length;
            var p = s + (n * m);
            for (var k = 0; k < r.length; k++) {
                var b = e + (g * k);
                if (r[k] == "-") {
                    r[k] = "Gap"
                }
                var o = "sequence" + r[k].toUpperCase() + "Color";
                this.rectangle(b, p, g, n, this[o], this[o])
            }
        }
    };
    this.drawGenomeBox = function(c, u, l, w) {
        var p = this;
        var r = function() {
            if (p.genomeResolution != "low" && l.sequence) {
                return l.dir == "left" ? l.sequenceRC.split("") : l.sequence.split("")
            } else {
                return false
            }
        };
        var y = this.validateColor(l.fill || l.connect || w.fill || w.connect || this.foreground);
        var D = l.outline || w.outline || y;
        var n = y ? "closed" : "open";
        var z = this.xAxisUnit / 2;
        var t = this.sequenceFontSize > u ? (u - 3) + "Pt " + this.fontName : this.sequenceFont;
        var q = r();
        var e = l.translateRC;
        var o = l.data;
        var f = this.marginLeft + this.left;
        var E = f + this.x;
        this.setGenomeBoxArea(c, u, l);
        if (this.genomeResolution == "high" && e) {
            c += e.top.length * this.featureTranslateHeight
        }
        var v = this.drawGenomeBoxLines(c, u, l, w);
        for (var A = 0; A < v.length; A++) {
            var C = v[A][0];
            var B = C + v[A][2];
            if (C < E && B > f) {
                if (this.genomeResolution != "low" && l.alleles && l.alleles[A] && !l.insertion) {
                    this.drawGenomeBoxAlleles(C, c, B, u, l.alleles[A])
                }
                if (!e || this.genomeResolution != "high") {
                    if (l.insertion) {
                        var b = l.dir == "left" ? "triangle" : "triangle2";
                        this.drawShape(b, v[A][0], v[A][1], v[A][2], v[A][3], y, D, n);
                        this.addArea(["rect", v[A][0] - (v[A][2] / 2), v[A][1] - (v[A][3] / 2), v[A][0] + (v[A][2] / 2), v[A][1] + (v[A][3] / 2)], [l.counter])
                    } else {
                        if (this.genomeResolution != "low" && l.sequence && (l.sequenceFill || w.sequenceFill || this.sequenceFill)) {
                            this.rectangle(v[A][0], v[A][1], v[A][2], v[A][3], l.sequenceFill || w.sequenceFill || this.sequenceFill, D, n)
                        } else {
                            this.rectangle(v[A][0], v[A][1], v[A][2], v[A][3], y, D, n)
                        }
                    }
                }
                if (this.genomeResolution != "low" && l.sequence && !l.insertion) {
                    var d = {};
                    var a = o[A][0];
                    var m = o[A][1];
                    var F = l.dir == "left" ? q.length - o[A][3] + 1 : o[A][2];
                    var g = l.dir == "left" ? q.length - o[A][2] + 1 : o[A][3];
                    var k = F - 3;
                    if (m - a != g - F) {
                        this.errors.push("Exon length for segment " + A + " in feature " + l.id + "is different to the box dimmension")
                    }
                    if (q.length > 0) {
                        C += z;
                        for (var x = F; x <= g; x++) {
                            var s = q[x - 1];
                            if (!s) {
                                this.errors.push("Nucleotide " + x + " in exon " + (A + 1) + " in feature " + l.id + "not specified")
                            }
                            if (s) {
                                var h = "sequence" + s.toUpperCase() + "Color";
                                if (this.genomeResolution == "high") {
                                    if (e && (!l.cds || (l.cds && x >= l.cds[0] && x <= l.cds[1]))) {
                                        this.drawTranslationTop(e, C, c, z, k, D, t, 0, d);
                                        this.drawText(s, C, c + (u / 2), t, this[h], "center", "middle");
                                        this.drawTranslationBottom(e, C, c, z, k, D, t, 0, d)
                                    } else {
                                        this.drawText(s, C, c + (u / 2), t, this[h], "center", "middle")
                                    }
                                } else {
                                    this.rectangle(C - 0.5, c + 1, 1, u - 2, this[h], this[h])
                                }
                            } else {
                                if (this.genomeResolution == "high") {
                                    this.drawText("-", C, c + (u / 2), t, this.missingDataColor, "center", "middle")
                                } else {
                                    this.rectangle(C - 0.5, c + 1, 1, u - 2, this.missingDataColor, this.missingDataColor)
                                }
                            }
                            k++;
                            C += this.xAxisUnit
                        }
                    }
                }
            }
        }
    };
    this.drawGenomeTrace = function(b, m, q, f, z, t, s) {
        if (this.genomeResolution != "low") {
            if (s == "left" && !z.reversed) {
                this.setReverseTrace(z)
            }
            var o = [];
            var g = ["A", "C", "G", "T"];
            var D = this.marginLeft + this.left + (((f - 1) - this.xAxisMin) * this.xAxisUnit);
            var u = this.marginLeft + this.left;
            var p = this.marginLeft + this.left + this.x;
            var a = b + q;
            if (z.max == null) {
                for (var A = 0; A < g.length; A++) {
                    o = o.concat(z[g[A]])
                }
                if (this.browser == "Firefox") {
                    o = this.radixSort(o)
                } else {
                    o.sort(function(j, i) {
                        return j - i
                    })
                }
                var B = Math.floor(o.length * this.featureTraceTrim / 100);
                z.max = o[o.length - (B + 1)]
            }
            var v = q / z.max;
            var e = g.length;
            for (var A = 0; A < e; A++) {
                var c = 0;
                var h = [];
                var y = [];
                var C = D;
                var d = "sequence" + g[A].toUpperCase() + "Color";
                var F = z.peak.length;
                for (var x = 0; x < F; x++) {
                    if (C > u - this.xAxisUnit && C < p) {
                        var n = this.xAxisUnit / (z.peak[x] - c);
                        if (t[x]) {
                            var E = Math.floor((z.peak[x] - c) / 2);
                            for (var w = c; w < (z.peak[x] - E); w++) {
                                h.push(C);
                                y.push(a - (Math.min(z.max, z[g[A]][w]) * v));
                                C += n
                            }
                            c += E;
                            if (h.length > 1 && y.length > 1) {
                                this.drawShape("path", h, y, false, false, this[d], this[d], "open")
                            }
                            h = [];
                            y = [];
                            for (var w = 0; w < t[x]; w++) {
                                C += this.xAxisUnit
                            }
                        }
                        for (var w = c; w <= z.peak[x]; w++) {
                            h.push(C);
                            y.push(a - (Math.min(z.max, z[g[A]][w]) * v));
                            C += n
                        }
                        C -= n;
                        c = z.peak[x]
                    } else {
                        if (t[x]) {
                            for (var w = 0; w < t[x]; w++) {
                                C += this.xAxisUnit
                            }
                        }
                        c = z.peak[x];
                        C += this.xAxisUnit
                    }
                }
                if (C > u - this.xAxisUnit && C < p) {
                    for (var w = c; w < z[g[A]].length; w++) {
                        h.push(C);
                        y.push(a - (Math.min(z.max, z[g[A]][w]) * v));
                        C += n
                    }
                }
                if (h.length > 1 && y.length > 1) {
                    this.drawShape("path", h, y, false, false, this[d], this[d], "open")
                }
            }
        }
    };
    this.drawTranslationTop = function(p, b, k, f, j, n, m, o, d) {
        if (p.top && p.top.length > 0) {
            for (var e = 0; e < p.top.length; e++) {
                y1 = k - ((p.top.length - e) * this.featureTranslateHeight);
                var g = p.top[e];
                if (j - g.off >= 0 && (j - g.off) % 3 == 0) {
                    var a = g.seq[Math.floor((j - g.off) / 3)];
                    var l = j % 2 ? this.oddColor : this.evenColor;
                    if (a == "M") {
                        l = this.sequenceStartColor
                    } else {
                        if (a == "*") {
                            l = this.sequenceEndColor
                        }
                    } if (!d[g.rf]) {
                        d[g.rf] = b - (this.xAxisUnit * (o + 2.5))
                    }
                    x0 = (b - d[g.rf]) + f;
                    this.rectangle(d[g.rf], y1, x0, this.featureTranslateHeight, l, n);
                    this.drawText(a, d[g.rf] + (x0 / 2), y1 + (this.featureTranslateHeight / 2) + 1, m, this.foreground, "center", "middle");
                    d[g.rf] = b + f
                }
            }
        }
    };
    this.drawTranslationBottom = function(p, b, k, f, j, n, m, o, d) {
        if (p.bottom && p.bottom.length > 0) {
            for (var e = 0; e < p.bottom.length; e++) {
                y1 = k + ((e + 1) * this.featureTranslateHeight);
                var g = p.bottom[e];
                if (j - g.off >= 0 && (j - g.off) % 3 == 0) {
                    var a = g.seq[Math.floor((j + g.off + 1) / 3)];
                    var l = j % 2 ? this.oddColor : this.evenColor;
                    if (a == "M") {
                        l = this.sequenceStartColor
                    } else {
                        if (a == "*") {
                            l = this.sequenceEndColor
                        }
                    } if (!d[g.rf]) {
                        d[g.rf] = b - (this.xAxisUnit * (o + 2.5))
                    }
                    x0 = (b - d[g.rf]) + f;
                    this.rectangle(d[g.rf], y1, x0, this.featureTranslateHeight, l, n);
                    this.drawText(a, d[g.rf] + (x0 / 2), y1 + (this.featureTranslateHeight / 2) + 1, m, this.foreground, "center", "middle");
                    d[g.rf] = b + f
                }
            }
        }
    };
    this.drawGenomeSequence = function(a, d, m, y, u) {
        var f = y.counter;
        var t = y.fill ? y.fill : u.fill ? u.fill : false;
        var v = y.outline;
        var k = t ? "closed" : "open";
        var e = this.sequenceFontSize > d ? (d - 3) + "Pt " + this.fontName : this.sequenceFont;
        var D = y.offset;
        var M = y.sequence;
        var P = y.sequenceRC;
        var C = y.translate;
        var L = y.translateRF;
        var O = y.dir;
        if (O == "left" && !P) {
            P = M;
            M = this.getReverseComplement(M)
        }
        if (C && !L) {
            L = C;
            C = this.translate(C, M)
        }
        var g = M.split("");
        var q = this.marginLeft + this.left + ((D - this.xAxisMin) * this.xAxisUnit);
        var I = this.marginLeft + this.left;
        var G = this.marginLeft + this.left + this.x;
        var p = (g.length + m.total) * this.xAxisUnit;
        var H = 0;
        var F = u.subtype.match(/DNA|RNA/) ? 1 : 3;
        var E = this.xAxisUnit * 4;
        var K = this.xAxisUnit / 2;
        var N = -2;
        var w = {};
        var Q = a;
        var B = 0;
        var z = 0;
        var A = this;
        if (this.genomeResolution == "high") {
            var o = q + (H * this.xAxisUnit);
            if (C) {
                a += C.top.length * this.featureTranslateHeight
            }
            while (g.length > 0) {
                if (o > I - E && o < G + E) {
                    var b = g.shift();
                    if (b == "[") {
                        b = g.shift();
                        var x = [];
                        while (b != "]") {
                            x.push(b);
                            b = g.shift()
                        }
                        this.drawText(x.join("/"), q + (H * this.xAxisUnit), a + (d / 2), e, this.sequenceMColor, "center", "middle")
                    } else {
                        var j = "sequence" + b.toUpperCase() + "Color";
                        if (C) {
                            this.drawTranslationTop(C, o, a, K, N, v, e, z, w);
                            this.drawText(b, o, a + (d / 2), e, this[j], "center", "middle");
                            this.drawTranslationBottom(C, o, a, K, N, v, e, z, w)
                        } else {
                            this.drawText(b, o, a + (d / 2), e, this[j], "center", "middle")
                        }
                    }
                    H += F;
                    o = q + ((H + B) * this.xAxisUnit);
                    N++;
                    z = 0;
                    if (m[parseInt(H / F)]) {
                        for (var J = 0; J < m[parseInt(H / F)]; J++) {
                            this.drawText("-", o, a + (d / 2), e, this.missingDataColor, "center", "middle");
                            B++;
                            z++;
                            o = q + ((H + B) * this.xAxisUnit)
                        }
                    }
                } else {
                    g.shift();
                    H += F;
                    o = q + ((H + B) * this.xAxisUnit);
                    N++;
                    z = 0;
                    if (m[parseInt(H / F)]) {
                        for (var J = 0; J < m[parseInt(H / F)]; J++) {
                            B++;
                            z++;
                            o = q + ((H + B) * this.xAxisUnit)
                        }
                    }
                }
            }
        } else {
            q = this.marginLeft + this.left + (((D - 0.5) - this.xAxisMin) * this.xAxisUnit);
            this.rectangle(q, a, p, d, t, v);
            for (var J in m) {
                q = this.marginLeft + this.left + ((((D - 0.5) + parseInt(J) + z) - this.xAxisMin) * this.xAxisUnit);
                p = m[J] * this.xAxisUnit;
                z += m[J];
                this.rectangle(q, a, p, d, this.missingDataColor, v, k)
            }
        }
        this.addArea(["rect", q, a, p, a + d], [f])
    };
    this.drawGenomeQuality = function(a, f, p, d, c, v, q, t) {
        if (this.genomeResolution != "low") {
            var h = q == "left" ? this.cloneObject(c).reverse() : c;
            var m = this.range(h);
            var B = this.marginLeft + this.left + (((d - 0.5) - this.xAxisMin) * this.xAxisUnit);
            var x = this.marginLeft + this.left;
            var o = this.marginLeft + this.left + this.x;
            var A = B;
            var u = 0;
            var k = t.subtype.match(/DNA|RNA/) ? 1 : 3;
            var g = k * this.xAxisUnit;
            var e = (this.featureQualityHeight - 3) + "Pt " + this.fontName;
            for (var z = 0; z < h.length; z++) {
                if (B < o) {
                    if (v[z]) {
                        for (var y = 0; y < v[z]; y++) {
                            A += g
                        }
                    }
                    var b = this.getHeatmapColor(m[0], m[1], h[z]);
                    this.rectangle(A, a, g, p, b, b);
                    if (A > x && this.genomeResolution == "high" && this.featureQualityValues) {
                        this.drawText(h[z], A + (g / 2), a + (p / 2), e, this.foreground, "center", "middle")
                    }
                    A += g
                }
            }
            this.addArea(["rect", B, a, B + A, a + p], [f])
        }
    };
    this.drawGenomeSignalToNoise = function(a, f, o, d, z, u, p, q) {
        if (this.genomeResolution != "low") {
            var c = p == "left" ? this.cloneObject(z).reverse() : z;
            var k = this.range(c);
            var B = this.marginLeft + this.left + (((d - 0.5) - this.xAxisMin) * this.xAxisUnit);
            var v = this.marginLeft + this.left;
            var m = this.marginLeft + this.left + this.x;
            var A = B;
            var t = 0;
            var h = q.subtype.match(/DNA|RNA/) ? 1 : 3;
            var g = h * this.xAxisUnit;
            var e = (this.featureSignalToNoiseHeight - 3) + "Pt " + this.fontName;
            for (var y = 0; y < c.length; y++) {
                if (B < m) {
                    if (u[y]) {
                        for (var x = 0; x < u[y]; x++) {
                            A += g
                        }
                    }
                    var b = this.getHeatmapColor(k[0], k[1], c[y]);
                    this.rectangle(A, a, g, o, b, b);
                    if (A > v && this.genomeResolution == "high" && this.featureSignalToNoiseValues) {
                        this.drawText(c[y], A + (g / 2), a + (o / 2), e, this.foreground, "center", "middle")
                    }
                    A += g
                }
            }
            this.addArea(["rect", B, a, B + A, a + o], [f])
        }
    };
    this.drawGenomeCoordinate = function(a, g, m, e, C, b, x, p, u) {
        if (this.genomeResolution != "low") {
            var A = this.marginLeft + this.left + ((e - this.xAxisMin) * this.xAxisUnit);
            var y = this.marginLeft + this.left;
            var k = this.marginLeft + this.left + this.x;
            var v = C;
            var j = u.subtype.match(/DNA|RNA/) ? 1 : 3;
            var h = j * this.xAxisUnit;
            var B = this.getCoordinateStep();
            var o = b + x.total;
            var i = C + o;
            var f = (m - 3) + "Pt " + this.fontName;
            if (p == "left") {
                var z = A + ((o - 1) * h);
                while (C < i - x.total) {
                    if (x[(o - (C - v)) - 2]) {
                        z -= (h * x[(o - (C - v)) - 2])
                    }
                    if (z > y && z < k) {
                        if (C % B == 0) {
                            this.drawText(C, z, a + (m / 2), f, this.foreground, "center", "middle")
                        }
                    }
                    z -= h;
                    C++
                }
            } else {
                var z = A;
                while (C < i - x.total) {
                    if (x[C - v]) {
                        z += (h * x[C - v])
                    }
                    if (z > y && z < k) {
                        if (C % B == 0) {
                            this.drawText(C, z, a + (m / 2), f, this.foreground, "center", "middle")
                        }
                    }
                    z += h;
                    C++
                }
            }
        }
    };
    this.setGenomeWireFrame = function() {
        var b = this.marginLeft + this.left;
        var a = this.marginLeft + this.left + this.x;
        var f = this.getCoordinateStep();
        var g = Math.floor(this.xAxisMin);
        var e = this.getFontPt(this.featureNameFont) / 2;
        if (this.genomeResolution == "low") {
            f *= 5
        }
        while (b <= a) {
            b = this.marginLeft + this.left + ((g - this.xAxisMin) * this.xAxisUnit);
            if (g % f == 0) {
                if (this.xAxisTickStyle == "dotted") {
                    this.drawLine("dottedLine", b, this.marginTop + this.top, b, this.marginTop + this.top + this.y, this.wireColor, false, "butt")
                } else {
                    this.drawLine("line", b, this.marginTop + this.top, b, this.marginTop + this.top + this.y, this.wireColor, false, "butt")
                }
            }
            g++
        }
    };
    this.setGenomeTicks = function() {
        var e = this.marginLeft + this.left;
        var b = this.marginLeft + this.left + this.x;
        var f = this.marginLeft + this.left;
        var h = this.getCoordinateStep();
        var i = Math.floor(this.xAxisMin);
        var g = this.getFontPt(this.featureNameFont) / 2;
        if (this.genomeResolution == "low") {
            h *= 5
        }
        while (e <= b) {
            e = this.marginLeft + this.left + ((i - this.xAxisMin) * this.xAxisUnit);
            if (i % h == 0) {
                var a = this.measureText(i, this.featureNameFont);
                if (e >= f) {
                    this.drawText(i.toString(), e, this.marginTop + this.top + this.y + this.margin + g, this.featureNameFont, this.xAxisTickColor, "center", "middle", false, false, false, true);
                    f = e + (a * 1.5)
                }
            }
            i++
        }
    };
    this.setGenomeLeftDimentions = function() {
        var e = [];
        for (var d = 0; d < this.data.tracks.length; d++) {
            var a = this.data.tracks[d];
            for (var b = 0; b < a.data.length; b++) {
                var c = a.data[b];
                e.push(c.label || c.name || c.id)
            }
        }
        return this.measureText(this.shortenText(this.getMaxText(e), this.maxFeatureStringLen), this.featureNameFont) + (this.margin * 4)
    };
    this.setGenomeYDimentions = function() {
        this.bottom += this.margin + this.getFontPt(this.featureNameFont);
        if (this.adjustAspectRatio || this.height < (this.marginTop + this.top + this.y + this.bottom + this.marginBottom)) {
            this.height = this.marginTop + this.top + this.y + this.bottom + this.marginBottom
        }
        this.resizeCanvas();
        this.resizeViewport()
    };
    this.setGenomeAxisUnits = function() {
        this.setAxisUnits("xAxis");
        this.genomeResolution = this.xAxisUnit > this.sequenceFontSize ? "high" : this.xAxisUnit * 5 > this.sequenceFontSize ? "medium" : "low"
    };
    this.setGenomeXDimentions = function() {
        if (this.featureStaggered) {
            if (this.width) {
                this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
            } else {
                this.width = this.marginLeft + this.left + this.x + this.right + this.marginRight
            }
        } else {
            this.left = this.setGenomeLeftDimentions();
            if (this.width) {
                this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
            } else {
                this.width = this.marginLeft + this.left + this.x + this.right + this.marginRight
            }
        }
    };
    this.setGenomeFontsColors = function() {
        this.trackNameFont = this.trackNameFontStyle + " " + this.trackNameFontSize + "Pt " + this.fontName;
        this.featureNameFont = this.featureNameFontStyle + " " + this.featureNameFontSize + "Pt " + this.fontName;
        this.sequenceFont = (this.sequenceFontSize) + "Pt " + this.fontName;
        if (!this.wireColor.match(/,0.1\)$/)) {
            this.wireColor = this.wireColor.replace(/\)$/, ",0.1)")
        }
    };
    this.drawGenome = function() {
        this.setGenomeFontsColors();
        this.setGenomeXDimentions();
        this.setGenomeAxisUnits();
        this.setGenomeSubtracks();
        this.setGenomeYDimentions();
        this.setGenomeWireFrame();
        this.plotGenomeData();
        this.maskPlotArea();
        this.drawGenomeLabels();
        this.setGenomeTicks()
    };
    this.initializeGenome = function() {
        this.drawGenome()
    };
    this.initializeGenome()
};
CanvasXpress.prototype.Circular = function() {
    this.setCircularXYDimensions = function() {
        this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight);
        this.y = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
        this.r = Math.min(this.x, this.y) / 2;
        this.d = this.r * 2;
        this.cx = this.marginLeft + this.left + this.r;
        this.cy = this.marginTop + this.top + this.r
    };
    this.setCircularSampleOverlays = function() {
        if (this.segregateSamplesBy && this.data.x[this.segregateSamplesBy] && this.smpOverlays.length == 0) {
            this.smpOverlays = [this.segregateSamplesBy]
        }
    };
    this.setCircularFonts = function() {
        var b, a;
        if (this.autoScaleFont) {
            b = this.scaleTextToSize(this.smpIndices.length * 0.5);
            a = this.scaleTextToSize(this.varIndices.length * 0.5)
        } else {
            b = this.smpLabelFontSize;
            a = this.varLabelFontSize
        }
        this.smpLabelFont = this.smpLabelFontStyle + " " + parseInt(b * this.smpLabelScaleFontFactor) + "Pt " + this.fontName;
        this.varLabelFont = this.varLabelFontStyle + " " + parseInt(a * this.varLabelScaleFontFactor) + "Pt " + this.fontName;
        this.setAxisFont(this.data.y.desc ? this.data.y.desc[0] : "NA", this.y / (Math.PI * 2))
    };
    this.setCircularLegendDimensions = function() {
        this.legendVariableWidth = 0;
        this.legendVariableHeight = 0;
        if (this.showLegend) {
            var a = this.getFontPt(this.legendFont);
            var b = this.shortenText(this.maxVarNameStr, this.maxVarStringLen);
            var c = this.getVariableInLegends();
            this.legendVariableWidth = (a - 1) + this.measureText(b, this.legendFont) + (this.margin * 3);
            this.legendVariableHeight = (c * (a + this.margin)) + this.margin
        }
    };
    this.getVariableInLegends = function() {
        var b = 0;
        for (var a = 0; a < this.ringsNumber; a++) {
            if (this.rAxisIndex >= 0 && a == this.rAxisIndex) {
                continue
            }
            if (this.rAxisIndex < 0 && this.ringsType[a] == "heatmap") {
                continue
            }
            b += this.ringsVarIndices[a].length
        }
        return b
    };
    this.getCircularSampleLabelLength = function() {
        if (this.showSampleNames && this.rAxisIndex < 0) {
            if (this.smpLabelOrientation == "circular") {
                return this.getFontPt(this.smpLabelFont) + this.margin
            } else {
                if (this.maxSmpName > this.maxSmpStringLen) {
                    return this.measureText(this.maxSmpNameStr.substring(0, this.maxSmpStringLen), this.smpLabelFont) + this.margin
                } else {
                    return this.measureText(this.maxSmpNameStr, this.smpLabelFont) + this.margin
                }
            }
        } else {
            return 0
        }
    };
    this.getCircularOverlaysWidth = function() {
        var b = 0;
        if (this.showOverlays && this.smpOverlays.length > 0) {
            if (this.segregateSamplesBy && this.data.x[this.segregateSamplesBy]) {
                b++
            }
            for (var a = 0; a < this.smpOverlays.length; a++) {
                if (this.data.x.hasOwnProperty(this.smpOverlays[a])) {
                    if (this.segregateSamplesBy && this.data.x[this.segregateSamplesBy] && this.smpOverlays[a] == this.segregateSamplesBy) {
                        continue
                    }
                    b++
                }
            }
            if (b > 0) {
                b = b * ((this.overlaysWidth / 2) + this.margin)
            }
        }
        return b
    };
    this.getCircularXAxisTickLength = function() {
        return this.measureText(this.xAxisMaxStrLength, this.axisTickFont) + (this.margin * 4)
    };
    this.getCircularRAxisTickLength = function() {
        return this.measureText(this.rAxisMaxStrLength, this.axisTickFont) + (this.margin * 2)
    };
    this.getCircularSmpTreeHeight = function() {
        var a = 0;
        if (this.showSmpDendrogram && this.smpDendrogram) {
            a = ((this.smpDendrogram.depth + 1) * this.dendrogramSpace) + this.margin
        }
        return a
    };
    this.setCircularArcSegments = function() {
        this.rAxisIndex = this.rAxis ? this.getVariableIndices(this.rAxis) : -1;
        this.arcSegmentsCenter = this.xAxisShow ? this.arcLengthToDegrees(this.r * this.circularCenterProportion * 2, this.getCircularXAxisTickLength()) : 0;
        var b = this.xAxisShow ? ((this.arcSegmentsSeparation + this.arcSegmentsCenter) * Math.PI / 360) : 0;
        this.circularStart = (Math.PI * 1.5) + b;
        this.currentRadius = this.r;
        this.arcSegments = [];
        this.arcSegmentsSampleIndices = [];
        this.arcSegmentsSamplePosition = [];
        this.arcSegmentsRange = [];
        this.arcSegmentsMin = [];
        this.arcSegmentsMax = [];
        this.arcSegmentsRangeMap = {};
        this.arcSegmentsDims = [];
        if (this.segregateSamplesBy && this.data.x[this.segregateSamplesBy]) {
            var t = [];
            var m = [];
            var k = this.getSmpAnnotations(this.segregateSamplesBy, this.smpIndices);
            for (var l = 0; l < k.length; l++) {
                this.arcSegments.push(k[l]);
                this.arcSegmentsRangeMap[k[l]] = l;
                var f = this.getSamplesByAnnotationLevel(this.segregateSamplesBy, k[l]);
                this.arcSegmentsSampleIndices.push(f);
                t = t.concat(f)
            }
            for (var l = 0; l < t.length; l++) {
                if (this.hiddenSmps[t[l]]) {
                    m.push(true)
                } else {
                    m.push(false)
                }
            }
            this.smpIndices = t;
            this.hiddenSmps = m;
            if (this.rAxisIndex >= 0) {
                var h = {};
                var p = 0;
                for (var l = 0; l < this.data.y.smps.length; l++) {
                    var u = this.data.x[this.segregateSamplesBy][l];
                    if (!h[u]) {
                        h[u] = []
                    }
                    h[u].push(this.data.y.data[this.rAxisIndex][l])
                }
                for (var u in h) {
                    var l = this.arcSegmentsRangeMap[u];
                    var a = this.range(h[u]);
                    this.arcSegmentsMin[l] = a[0];
                    this.arcSegmentsMax[l] = a[1];
                    if (this.rAxisZero) {
                        p += a[1];
                        this.arcSegmentsRange[l] = a[1]
                    } else {
                        p += (a[1] - a[0]);
                        this.arcSegmentsRange[l] = a[1] - a[0]
                    }
                }
                this.rAxisUnit = (360 - ((this.arcSegmentsSeparation * this.arcSegmentsSampleIndices.length) + this.arcSegmentsCenter)) / p
            } else {
                this.rAxisUnit = (360 - ((this.arcSegmentsSeparation * this.arcSegmentsSampleIndices.length) + this.arcSegmentsCenter)) / this.data.y.smps.length;
                var u = this.circularStart;
                for (var l = 0; l < this.arcSegmentsSampleIndices.length; l++) {
                    this.arcSegmentsSamplePosition[l] = [];
                    for (var g = 0; g < this.arcSegmentsSampleIndices[l].length; g++) {
                        this.arcSegmentsSamplePosition[l].push(u);
                        u += this.rAxisUnit * Math.PI / 180
                    }
                    u += this.arcSegmentsSeparation * Math.PI / 180
                }
            }
            var u = this.circularStart;
            for (var c in this.arcSegmentsRangeMap) {
                var l = this.arcSegmentsRangeMap[c];
                var d = this.rAxisIndex >= 0 ? this.arcSegmentsRange[l] : this.arcSegmentsSampleIndices[l].length;
                var q = this.rAxisUnit * d * Math.PI / 180;
                this.arcSegmentsDims.push([u, u + q]);
                u += q + (this.arcSegmentsSeparation * Math.PI / 180)
            }
        } else {
            this.arcSegments = false;
            this.arcSegmentsSampleIndices = [this.smpIndices];
            if (this.rAxisIndex >= 0) {
                var a = this.range(this.data.y.data[this.rAxisIndex]);
                this.arcSegmentsMin.push(a[0]);
                this.arcSegmentsMax.push(a[1]);
                if (this.rAxisZero) {
                    this.rAxisUnit = (360 - (this.arcSegmentsSeparation + this.arcSegmentsCenter)) / a[1];
                    this.arcSegmentsRange.push(a[1])
                } else {
                    this.rAxisUnit = (360 - (this.arcSegmentsSeparation + this.arcSegmentsCenter)) / (a[1] - a[0]);
                    this.arcSegmentsRange.push(a[1] - a[0])
                }
            } else {
                this.rAxisUnit = (360 - (this.arcSegmentsSeparation + this.arcSegmentsCenter)) / this.data.y.smps.length;
                var u = this.circularStart;
                for (var l = 0; l < this.arcSegmentsSampleIndices.length; l++) {
                    this.arcSegmentsSamplePosition[l] = [];
                    for (var g = 0; g < this.arcSegmentsSampleIndices[l].length; g++) {
                        this.arcSegmentsSamplePosition[l].push(u);
                        u += this.rAxisUnit * Math.PI / 180
                    }
                    u += this.arcSegmentsSeparation * Math.PI / 180
                }
            }
            var q = (this.rAxisUnit * Math.PI / 180) * (this.rAxisIndex >= 0 ? this.arcSegmentsRange[0] : this.smpIndices.length);
            this.arcSegmentsDims.push([this.circularStart, this.circularStart + q])
        }
        this.arcSegmentsNumber = this.arcSegmentsSampleIndices.length
    };
    this.setCircularRings = function() {
        this.ringsVarIndices = [];
        if (this.rAxisIndex >= 0) {
            this.ringsVarIndices.push([this.rAxisIndex])
        }
        if (this.segregateVariablesBy && this.data.z[this.segregateVariablesBy]) {
            var d = {};
            for (var f = 0; f < this.data.z[this.segregateVariablesBy].length; f++) {
                if (this.rAxisIndex >= 0 && f == this.rAxisIndex) {
                    continue
                }
                var c = this.data.z[this.segregateVariablesBy][f];
                if (!d[c]) {
                    this.ringsVarIndices.push(this.getVariablesByAnnotationLevel(this.segregateVariablesBy, c));
                    d[c] = true
                }
            }
        } else {
            var b = [];
            var e = 0;
            for (var f = 0; f < this.data.y.vars.length; f++) {
                if (this.rAxisIndex >= 0 && f == this.rAxisIndex) {
                    continue
                }
                b.push(e++)
            }
            this.ringsVarIndices.push(b)
        }
        this.ringsNumber = this.ringsVarIndices.length;
        if (this.ringsType.length < this.ringsNumber) {
            for (var f = this.ringsType.length; f < this.ringsNumber; f++) {
                this.ringsType.push("dot")
            }
        }
        if (this.ringsWeight && this.ringsWeight.length > 0) {
            while (this.ringsWeight.length != this.ringsNumber) {
                if (this.ringsWeight.length > this.ringsNumber) {
                    this.ringsWeight.pop()
                } else {
                    this.ringsWeight.push(this.ringsWeight[this.ringsWeight.length - 1])
                }
            }
        } else {
            this.ringsWeight = [];
            for (var f = 0; f < this.ringsNumber; f++) {
                if (this.rAxisShow && this.rAxisIndex >= 0 && f == this.rAxisIndex) {
                    this.ringsWeight.push(0);
                    continue
                }
                this.ringsWeight.push(1)
            }
        }
        var a = 0;
        for (var f = 0; f < this.ringsWeight.length; f++) {
            if (this.rAxisShow && this.rAxisIndex >= 0 && f == this.rAxisIndex) {
                continue
            }
            a += parseFloat(this.ringsWeight[f])
        }
        for (var f = 0; f < this.ringsWeight.length; f++) {
            this.ringsWeight[f] /= a
        }
    };
    this.drawCircularRadialAxis = function() {
        if (this.rAxisShow && this.rAxisIndex >= 0) {
            if (this.rAxisLabelOrientation = "circular") {
                var h = this.rAxisUnit * Math.PI / 180;
                for (var f = 0; f < this.arcSegmentsRange.length; f++) {
                    var p = this.arcSegmentsDims[f][0];
                    var a = this.getAxisIncrements(this.arcSegmentsMin[f], this.arcSegmentsMax[f], this.rAxisTicks);
                    var o = this.rAxisUnit * a * Math.PI / 180;
                    for (var d = 0; d < this.rAxisTicks; d++) {
                        var b = this.bestFormatNumber(this.arcSegmentsMin[f] + (a * d));
                        if (b <= this.arcSegmentsMax[f]) {
                            var g = this.measureText(b, this.axisTickFont);
                            this.drawArcText(b, this.cx, this.cy, this.currentRadius + this.axisTickFontSize, p - (h * g / 7), h * g / 3.5, this.axisTickFont, this.rAxisTickColor);
                            p += o
                        }
                    }
                }
            } else {
                this.ctx.save();
                this.ctx.translate(this.cx, this.cy);
                for (var f = 0; f < this.arcSegmentsRange.length; f++) {
                    var p = this.arcSegmentsDims[f][0] - (Math.PI / 2);
                    var a = this.getAxisIncrements(this.arcSegmentsMin[f], this.arcSegmentsMax[f], this.rAxisTicks);
                    var o = this.rAxisUnit * a * Math.PI / 180;
                    this.ctx.save();
                    this.ctx.rotate(p);
                    for (var d = 0; d < this.rAxisTicks; d++) {
                        var b = this.bestFormatNumber(this.arcSegmentsMin[f] + (a * d));
                        var n = this.currentRadius * Math.cos(p);
                        var m = this.currentRadius * Math.sin(p);
                        var k = b <= this.arcSegmentsMax[f] ? this.axisTickColor : this.background;
                        if (p < Math.PI * 2) {
                            this.drawText(b, 0, this.currentRadius - this.margin, this.axisTickFont, k, "right", "middle", Math.PI / 2)
                        } else {
                            this.drawText(b, 0, this.currentRadius - this.margin, this.axisTickFont, k, "left", "middle", -Math.PI / 2)
                        }
                        p += o;
                        this.ctx.rotate(o)
                    }
                    for (var d = 0; d < this.rAxisTicks; d++) {
                        this.ctx.restore()
                    }
                    this.ctx.restore()
                }
                this.ctx.restore();
                this.currentRadius -= this.getCircularRAxisTickLength()
            }
        }
    };
    this.drawCircularOverlays = function() {
        if (this.showOverlays && this.smpOverlays.length > 0) {
            var r = this.circularStart;
            if (this.segregateSamplesBy && this.data.x[this.segregateSamplesBy]) {
                var a = this.rAxisIndex >= 0 ? 0.033 : 0;
                for (var b in this.smpOverlayColors[this.segregateSamplesBy]) {
                    var m = this.smpOverlayColors[this.segregateSamplesBy][b];
                    var d = this.rAxisIndex >= 0 ? this.arcSegmentsRange[this.arcSegmentsRangeMap[b]] : (this.getSamplesByAnnotationLevel(this.segregateSamplesBy, b)).length;
                    var l = this.rAxisUnit * d * Math.PI / 180;
                    this.drawShape("arc2", this.cx, this.cy, (this.overlaysWidth / 2), this.currentRadius, m, m, false, false, false, false, false, r - a, r + l + a);
                    this.drawArcText(b, this.cx, this.cy, this.currentRadius - (this.overlaysWidth / 4), r, l, this.overlayFont, this.overlayFontColor);
                    r += l + (this.arcSegmentsSeparation * Math.PI / 180)
                }
                r -= (this.arcSegmentsSeparation * Math.PI / 180);
                r = r % (Math.PI * 2);
                this.drawArcText(this.segregateSamplesBy, this.cx, this.cy, this.currentRadius - (this.overlaysWidth / 4), r, this.circularStart - r, this.overlayFont, this.overlayFontColor);
                this.currentRadius -= ((this.overlaysWidth / 2) + this.margin);
                r = this.circularStart
            }
            if (this.rAxisIndex < 0) {
                for (var h = 0; h < this.smpOverlays.length; h++) {
                    var b = this.smpOverlays[h];
                    if (this.segregateSamplesBy && this.data.x[this.segregateSamplesBy] && b == this.segregateSamplesBy) {
                        continue
                    }
                    var l = this.rAxisUnit * Math.PI / 180;
                    if (b != "-") {
                        for (var g = 0; g < this.arcSegmentsSampleIndices.length; g++) {
                            for (var f = 0; f < this.arcSegmentsSampleIndices[g].length; f++) {
                                var q = this.data.x[b][this.smpIndices[this.arcSegmentsSampleIndices[g][f]]];
                                var m = this.smpOverlayColors[b][q];
                                this.drawShape("arc2", this.cx, this.cy, (this.overlaysWidth / 2), this.currentRadius, m, m, false, false, false, false, false, r, r + l);
                                if (this.showLevelOverlays) {
                                    this.drawArcText(b, this.cx, this.cy, this.currentRadius - (this.overlaysWidth / 4), r, l, this.overlayFont, this.overlayFontColor)
                                }
                                r += l
                            }
                            r += (this.arcSegmentsSeparation * Math.PI / 180)
                        }
                    }
                    this.currentRadius -= ((this.overlaysWidth / 2) + this.margin);
                    r = this.circularStart
                }
            }
        }
    };
    this.drawCircularSampleLabels = function() {
        if (this.showSampleNames && this.rAxisIndex < 0) {
            var h = this.rAxisUnit * Math.PI / 180;
            if (this.smpLabelOrientation == "circular") {
                var g = this.circularStart;
                for (var f = 0; f < this.arcSegmentsSampleIndices.length; f++) {
                    for (var d = 0; d < this.arcSegmentsSampleIndices[f].length; d++) {
                        var b = this.data.y.smps[this.smpIndices[this.arcSegmentsSampleIndices[f][d]]];
                        var m = this.getSmpColor(b);
                        this.drawArcText(b, this.cx, this.cy, this.currentRadius - (this.smpLabelFontSize / 2), g, h, this.smpLabelFont, m);
                        g += h
                    }
                    g += this.arcSegmentsSeparation * Math.PI / 180
                }
            } else {
                var g = this.circularStart + (h / 2) - (Math.PI / 2);
                this.ctx.save();
                this.ctx.translate(this.cx, this.cy);
                this.ctx.rotate(g);
                for (var f = 0; f < this.arcSegmentsSampleIndices.length; f++) {
                    for (var d = 0; d < this.arcSegmentsSampleIndices[f].length; d++) {
                        var b = this.data.y.smps[this.smpIndices[this.arcSegmentsSampleIndices[f][d]]];
                        var a = this.currentRadius * Math.cos(g);
                        var k = this.currentRadius * Math.sin(g);
                        var m = this.getSmpColor(b);
                        if (g < Math.PI * 2) {
                            this.drawText(b, 0, this.currentRadius, this.smpLabelFont, m, "right", "middle", Math.PI / 2)
                        } else {
                            this.drawText(b, 0, this.currentRadius, this.smpLabelFont, m, "left", "middle", -Math.PI / 2)
                        }
                        g += h;
                        this.ctx.rotate(h)
                    }
                    g += this.arcSegmentsSeparation * Math.PI / 180;
                    this.ctx.rotate(this.arcSegmentsSeparation * Math.PI / 180)
                }
                for (var f = 0; f < this.smpIndices.length + 2; f++) {
                    this.ctx.restore()
                }
            }
            this.currentRadius -= this.getCircularSampleLabelLength()
        }
    };
    this.drawCircularData = function() {
        var b = this.circularCenterProportion * this.r;
        var a = this.currentRadius - b;
        var g = this.varIndices;
        var d = 0;
        for (var c = 0; c < this.ringsNumber; c++) {
            if (this.rAxisIndex >= 0 && c == this.rAxisIndex) {
                continue
            }
            var f = this.circularStart;
            var h = (a * this.ringsWeight[c]) - this.margin;
            this.setVariablesVisible(this.ringsVarIndices[c]);
            this.setAxes();
            this.xAxisUnit = h / this.xAxisRange;
            this.drawCircularDataAxis(f, h, this.ringsType[c] == "heatmap");
            this.drawCircularDataPoints(f, h, c, d);
            d += this.varIndices.length;
            this.currentRadius -= (h + this.ringSeparation)
        }
        this.varIndices = g
    };
    this.drawCircularDataAxis = function(u, I, E) {
        if (E && this.rAxisIndex < 0) {
            var w = I / this.varIndices.length;
            var H = this.arcSegmentsDims[0][0];
            var z = this.arcSegmentsDims[this.arcSegmentsNumber - 1][1] % (Math.PI * 2);
            if (this.showRingLegend) {
                var K = (this.currentRadius - this.margin) * 2;
                this.drawArcText("Min: " + this.minData + "; Max: " + this.maxData, this.cx, this.cy, (K * 0.5) + (this.axisTickFontSize / 2) - 1, z + ((z - H) / 2), (H - z) * 2, this.axisTickFont, this.axisTickColor)
            }
            for (var D = 0; D < this.varIndices.length; D++) {
                var K = (this.currentRadius - (((D + 0.5) * w) + this.margin)) * 2;
                this.drawArcText(this.data.y.vars[this.varIndices[D]], this.cx, this.cy, (K * 0.5) - (this.axisTickFontSize / 4), z, H - z, this.axisTickFont, this.axisTickColor)
            }
        } else {
            var H, z, o, q, L, G, g, F, a;
            var J = I / this.xAxisValues.length;
            var x = this.rAxisIndex >= 0 ? 0.033 : 0;
            for (var D = 0; D <= this.xAxisValues.length; D++) {
                var y = u;
                var K = (this.currentRadius - ((D * J) + this.margin)) * 2;
                for (var C = 0; C < this.arcSegmentsNumber; C++) {
                    if (D < this.xAxisValues.length && C == 0) {
                        H = this.arcSegmentsDims[C][0];
                        z = this.arcSegmentsDims[this.arcSegmentsNumber - 1][1] % (Math.PI * 2);
                        if (D == 0) {
                            if (this.showRingLegend) {
                                var B = [];
                                for (var A = 0; A < this.varIndices.length; A++) {
                                    B.push(this.data.y.vars[this.varIndices[A]])
                                }
                                o = B.join(", ");
                                this.drawArcText(o, this.cx, this.cy, (K * 0.5) + (this.axisTickFontSize / 2) - 1, z + ((z - H) / 2), (H - z) * 2, this.axisTickFont, this.axisTickColor)
                            } else {
                                o = this.xAxisValues[this.xAxisValues.length - (D + 1)].toString();
                                this.drawArcText(o, this.cx, this.cy, (K * 0.5) - (this.axisTickFontSize / 4), z, H - z, this.axisTickFont, this.axisTickColor)
                            }
                        } else {
                            o = this.xAxisValues[this.xAxisValues.length - (D + 1)].toString();
                            this.drawArcText(o, this.cx, this.cy, (K * 0.5) - (this.axisTickFontSize / 4), z, H - z, this.axisTickFont, this.axisTickColor)
                        }
                    }
                    var m = D == 0 || D == this.xAxisValues.length ? this.foreground : this.xAxisTickColor;
                    this.drawShape("arc3", this.cx, this.cy, K, K, m, m, false, false, false, false, false, this.arcSegmentsDims[C][0] - x, this.arcSegmentsDims[C][1] + x)
                }
            }
            for (var D = 0; D < this.arcSegmentsNumber; D++) {
                q = this.currentRadius - this.margin;
                L = this.currentRadius - ((this.xAxisValues.length * J) + this.margin);
                G = q * Math.cos(this.arcSegmentsDims[D][0] - x);
                g = q * Math.sin(this.arcSegmentsDims[D][0] - x);
                F = L * Math.cos(this.arcSegmentsDims[D][0] - x);
                a = L * Math.sin(this.arcSegmentsDims[D][0] - x);
                this.drawLine("line", G + this.cx, g + this.cy, F + this.cx, a + this.cy, this.foreground);
                G = q * Math.cos(this.arcSegmentsDims[D][1] + x);
                g = q * Math.sin(this.arcSegmentsDims[D][1] + x);
                F = L * Math.cos(this.arcSegmentsDims[D][1] + x);
                a = L * Math.sin(this.arcSegmentsDims[D][1] + x);
                this.drawLine("line", G + this.cx, g + this.cy, F + this.cx, a + this.cy, this.foreground)
            }
        }
    };
    this.drawCircularDataPoints = function(w, L, J, u) {
        var a = this.xAxisMin < 0 ? Math.abs(this.xAxisMin) * this.xAxisUnit : 0;
        var E = (this.rAxisUnit * Math.PI / 180) * 0.3;
        var K = E / 2;
        var N = (this.rAxisUnit * Math.PI / 180) * 0.7 / this.ringsVarIndices[J].length;
        if (this.rAxisIndex < 0) {
            if (this.ringsType[J] != "heatmap") {
                w += K
            }
            for (var I = 0; I < this.arcSegmentsSampleIndices.length; I++) {
                for (var H = 0; H < this.arcSegmentsSampleIndices[I].length; H++) {
                    if (this.ringsType[J] == "heatmap") {
                        var A = L / this.varIndices.length;
                        var C = 0;
                        for (var G = 0; G < this.varIndices.length; G++) {
                            var o = this.getDataAtPos(this.varIndices[G], this.smpIndices[this.arcSegmentsSampleIndices[I][H]]);
                            var M = !isNaN(o) ? this.getHeatmapColor(this.minData, this.maxData, o) : this.missingDataColor;
                            this.drawShape("arc2", this.cx, this.cy, A, this.currentRadius - (C + this.margin), M, M, false, false, false, false, false, w, w + this.rAxisUnit * Math.PI / 180);
                            C += A
                        }
                        w += this.rAxisUnit * Math.PI / 180
                    } else {
                        for (var G = 0; G < this.varIndices.length; G++) {
                            var o = this.getDataAtPos(this.varIndices[G], this.smpIndices[this.arcSegmentsSampleIndices[I][H]]);
                            var M = this.colors[(G + u) % this.colors.length];
                            var F = this.ringsType[J] == "bar" ? (o - this.xAxisMin) * this.xAxisUnit : (this.xAxisMax - o) * this.xAxisUnit;
                            if (this.ringsType[J] == "bar") {
                                if (o >= 0) {
                                    this.drawShape("arc2", this.cx, this.cy, F, this.currentRadius + a - ((L - F) + this.margin), M, M, false, false, false, false, false, w, w + N)
                                } else {
                                    this.drawShape("arc2", this.cx, this.cy, -F, this.currentRadius - ((L - F) + this.margin), M, M, false, false, false, false, false, w, w + N)
                                }
                            } else {
                                if (this.ringsType[J] == "dot") {
                                    var f = this.cx + ((this.currentRadius - (F + this.margin)) * Math.cos(w + (N / 2)));
                                    var d = this.cy + ((this.currentRadius - (F + this.margin)) * Math.sin(w + (N / 2)));
                                    this.addArea(this.drawShape("circle", f, d, this.margin, this.margin, M, M), [this.varIndices[G], this.arcSegmentsSampleIndices[I][H]])
                                }
                            }
                            w += N
                        }
                        w += E
                    }
                }
                w += this.arcSegmentsSeparation * Math.PI / 180
            }
        } else {
            for (var I = 0; I < this.arcSegmentsSampleIndices.length; I++) {
                var w = this.arcSegmentsDims[I][0];
                var F = this.rAxisZero && this.arcSegmentsMin[I] < 0 ? this.arcSegmentsMin[I] : 0;
                for (var H = 0; H < this.arcSegmentsSampleIndices[I].length; H++) {
                    for (var G = 0; G < this.varIndices.length; G++) {
                        var M = this.colors[(G + u) % this.colors.length];
                        var n = this.getDataAtPos(this.rAxisIndex, this.smpIndices[this.arcSegmentsSampleIndices[I][H]]);
                        var g = this.getDataAtPos(this.varIndices[G], this.smpIndices[this.arcSegmentsSampleIndices[I][H]]);
                        if (this.rAxisZero && n < 0) {
                            continue
                        }
                        var D = (n + F - this.arcSegmentsMin[I]) * (this.rAxisUnit * Math.PI / 180);
                        var B = ((g - this.xAxisMin) * this.xAxisUnit) + (this.margin / 2);
                        var f = this.cx + ((this.currentRadius - ((L - B) + this.margin)) * Math.cos(w + D));
                        var d = this.cy + ((this.currentRadius - ((L - B) + this.margin)) * Math.sin(w + D));
                        this.addArea(this.drawShape("circle", f, d, this.margin, this.margin, M, M), [this.varIndices[G], this.arcSegmentsSampleIndices[I][H]])
                    }
                }
            }
        }
    };
    this.drawCircularLegend = function() {
        var c = this.x - this.legendVariableWidth / 2;
        var o = this.y - this.legendVariableHeight / 2;
        if (this.showLegend) {
            var m = c;
            var e = o;
            var s = this.getFontPt(this.legendFont);
            var n = this.sizeBy && this.sizeBy == "variable" ? Math.max(this.sizes[this.varIndices.length - 1], s) : s;
            o += this.margin + (n / 2);
            if (this.legendBox && this.legendBackgroundColor) {
                this.disableGradientTransparencyShadow();
                this.rectangle(m, e, this.legendVariableWidth, this.legendVariableHeight, this.legendBackgroundColor, this.legendBoxColor);
                this.enableGradientTransparencyShadow()
            }
            var p = 0;
            for (var h = 0; h < this.ringsNumber; h++) {
                if (this.rAxisIndex >= 0 && h == this.rAxisIndex) {
                    continue
                }
                if (this.rAxisIndex < 0 && this.ringsType[h] == "heatmap") {
                    p += this.ringsVarIndices[h].length;
                    continue
                }
                for (var g = 0; g < this.ringsVarIndices[h].length; g++) {
                    var l = this.ringsVarIndices[h][g];
                    var d = p % this.colors.length;
                    var r = this.shapeBy && this.shapeBy == "variable" ? p % this.shapes.length : 0;
                    var b = this.sizeBy && this.sizeBy == "variable" ? this.sizes[p % this.sizes.length] : n;
                    var q = n / 2;
                    var f = c + q + this.margin;
                    var a = o + q + this.margin;
                    var k = this.shortenText(this.data.y.vars[l], this.maxVarStringLen);
                    if (this.colorBy && this.colorBy != "variable") {
                        this.drawShape(this.shapes[r], f, o, b, b, this.background, this.foreground, "open")
                    } else {
                        this.drawShape(this.shapes[r], f, o, b, b, this.colors[d], this.foreground, "closed")
                    }
                    this.drawText(k, f + q + this.margin, o, this.legendFont, this.legendColor, "left", "middle");
                    o += n + this.margin;
                    p++
                }
            }
            if (this.legendBox) {
                this.disableGradientTransparencyShadow();
                this.rectangle(m, e, this.legendVariableWidth, this.legendVariableHeight, false, this.legendBoxColor, "open");
                this.enableGradientTransparencyShadow()
            }
            this.addArea(["rect", m, e, m + this.legendVariableWidth, e + this.legendVariableHeight], [-1], "-legend-variable")
        }
    };
    this.getCircularCoordinates = function(l) {
        var f = this;
        var h = this.rAxisUnit * Math.PI / 180;
        var p = function(t) {
            for (var e = 0; e < f.arcSegmentsSampleIndices.length; e++) {
                for (var c = 0; c < f.arcSegmentsSampleIndices[e].length; c++) {
                    var u = f.arcSegmentsSampleIndices[e][c];
                    if (f.data.y.smps[u] == t) {
                        return f.arcSegmentsSamplePosition[e][c]
                    }
                }
            }
            return false
        };
        var g = function(e) {
            var s = f.arcSegmentsRangeMap[e[1]];
            var v = f.arcSegmentsRangeMap[e[3]];
            if (s != null && v != null) {
                var c = f.rAxisZero && f.arcSegmentsMin[s] < 0 ? f.arcSegmentsMin[s] : 0;
                var y = f.rAxisZero && f.arcSegmentsMin[v] < 0 ? f.arcSegmentsMin[v] : 0;
                if (e[2] >= f.arcSegmentsMin[s] && e[2] <= f.arcSegmentsMax[s] && e[4] >= f.arcSegmentsMin[v] && e[4] <= f.arcSegmentsMax[v]) {
                    var u, x, t, w;
                    u = f.arcSegmentsDims[s][0] + ((e[2] + c - f.arcSegmentsMin[s]) * (f.rAxisUnit * Math.PI / 180));
                    x = f.arcSegmentsDims[v][0] + ((e[4] + y - f.arcSegmentsMin[v]) * (f.rAxisUnit * Math.PI / 180));
                    if (e[5] != null || e[6] != null) {
                        t = f.arcSegmentsDims[s][0] + ((Math.min(e[2] + (e[5] || 0), f.arcSegmentsMax[s]) + c - f.arcSegmentsMin[s]) * (f.rAxisUnit * Math.PI / 180));
                        w = f.arcSegmentsDims[v][0] + ((Math.min(e[4] + (e[6] || 0), f.arcSegmentsMax[v]) + y - f.arcSegmentsMin[v]) * (f.rAxisUnit * Math.PI / 180));
                        return [u, x, t, w]
                    }
                    return [u, x]
                }
            }
            return false
        };
        if (this.rAxisIndex < 0) {
            var r = p(l[1]);
            var i = p(l[2]);
            if (r && i) {
                var d = this.cx + (this.currentRadius * Math.cos(r));
                var o = this.cy + (this.currentRadius * Math.sin(r));
                var b = this.cx + (this.currentRadius * Math.cos(i + h));
                var n = this.cy + (this.currentRadius * Math.sin(i + h));
                var a = this.cx + (this.currentRadius * Math.cos(i));
                var k = this.cy + (this.currentRadius * Math.sin(i));
                var q = this.cx + (this.currentRadius * Math.cos(r + h));
                var j = this.cy + (this.currentRadius * Math.sin(r + h));
                return [d, o, b, n, a, k, q, j, r, r + h, i, i + h]
            }
        } else {
            if (this.segregateSamplesBy && this.data.x[this.segregateSamplesBy]) {
                var m = g(l);
                if (m) {
                    var d, o, b, n, a, k, q, j;
                    if (m.length > 2) {
                        d = this.cx + (this.currentRadius * Math.cos(m[0]));
                        o = this.cy + (this.currentRadius * Math.sin(m[0]));
                        b = this.cx + (this.currentRadius * Math.cos(m[3]));
                        n = this.cy + (this.currentRadius * Math.sin(m[3]));
                        a = this.cx + (this.currentRadius * Math.cos(m[1]));
                        k = this.cy + (this.currentRadius * Math.sin(m[1]));
                        q = this.cx + (this.currentRadius * Math.cos(m[2]));
                        j = this.cy + (this.currentRadius * Math.sin(m[2]));
                        return [d, o, b, n, a, k, q, j, m[0], m[2], m[1], m[3]]
                    } else {
                        d = this.cx + (this.currentRadius * Math.cos(m[0]));
                        o = this.cy + (this.currentRadius * Math.sin(m[0]));
                        b = this.cx + (this.currentRadius * Math.cos(m[1]));
                        n = this.cy + (this.currentRadius * Math.sin(m[1]));
                        return [d, o, b, n]
                    }
                } else {}
            }
        }
        return false
    };
    this.drawCircularConnections = function() {
        if (this.showCircularConnections && this.data.c) {
            this.currentRadius += (this.margin - 2);
            var d = this.rAxisUnit * Math.PI / 180;
            for (var a = 0; a < this.data.c.length; a++) {
                var g = this.getCircularCoordinates(this.data.c[a]);
                var b = this.addColorTransparency(this.data.c[a][0], this.circularConnectionsTransparency);
                if (g.length > 4) {
                    this.drawShape("arch", [g[0], this.cx, g[2], g[4], this.cx, g[6]], [g[1], this.cy, g[3], g[5], this.cy, g[7]], [g[8], g[9], g[10], g[11]], this.currentRadius, b, b)
                } else {
                    this.drawLine("arch", [g[0], this.cx, g[2]], [g[1], this.cy, g[3]], false, false, b, b)
                }
            }
        }
    };
    this.drawCircularPlot = function() {
        this.setCircularArcSegments();
        this.setCircularRings();
        this.setCircularLegendDimensions();
        this.drawCircularRadialAxis();
        this.drawCircularOverlays();
        this.drawCircularSampleLabels();
        this.drawCircularData();
        this.drawCircularLegend();
        this.drawCircularConnections();
        this.drawTitle()
    };
    this.setCircularAttributes = function() {
        this.setCircularXYDimensions();
        this.setCircularSampleOverlays();
        this.setCircularFonts();
        this.setLegendFont();
        this.setTrees();
        this.setOverlayColors();
        this.setOverlayFont();
        this.setValidDataColorShapeSize();
        this.setDataColorShapeSize()
    };
    this.initializeCircular = function() {
        this.setCircularAttributes();
        this.drawCircularPlot()
    };
    this.initializeCircular()
};
CanvasXpress.prototype.Video = function() {
    this.videoPlay = function(a) {
        return function(b) {
            a.copyVideo(this, a.ctx, a.width, a.height)
        }
    }(this);
    this.videoUpdate = function() {
        var h = this.video.currentTime;
        if (this.videoCurrentTime) {
            this.drawText(h, this.width / 2, 20, false, this.videoColor)
        }
        if (this.videoGrid) {
            var g = (this.width - 1) / this.videoGridStep;
            var f = (this.height - 1) / this.videoGridStep;
            for (var d = 0; d <= this.videoGridStep; d++) {
                this.drawLine("line", g * d, 0, g * d, this.height, this.videoColor);
                this.drawLine("line", 0, f * d, this.width, f * d, this.videoColor)
            }
        }
        for (var d = 0; d < this.data.video.length; d++) {
            var j = this.data.video[d][0];
            var b = j + this.data.video[d][1];
            if (h >= j && h <= b) {
                var c = this.data.video[d][2];
                var e = this.data.video[d][3];
                var a = this.data.video[d][4];
                switch (c) {
                    case "text":
                        this.drawText(e, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9]);
                        break;
                    case "line":
                        this.drawLine(e, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10]);
                        break;
                    case "shape":
                        this.drawShape(e, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14]);
                        break
                }
            }
        }
    };
    this.copyVideo = function(b, f, a, d) {
        var e = this;
        if (b.paused || b.ended) {
            return false
        }
        f.drawImage(b, 0, 0, a, d);
        this.videoUpdate();
        setTimeout(function() {
            e.copyVideo(b, f, a, d)
        }, 50)
    };
    this.initializeVideo = function() {
        if (!this.data) {
            this.data = {
                video: {}
            }
        }
        if (!this.data.video) {
            this.data.video = {}
        }
    };
    this.initializeVideo()
};
CanvasXpress.doc = {
    F: {
        fill: {
            M: "Genome",
            T: "color",
            C: "Color for the feature"
        },
        id: {
            M: "Genome",
            T: "string",
            C: "Feature id"
        }
    },
    M: {
        Shadows: {
            D: "Shadow properties used in most visualizations :",
            P: ["shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "showShadow", "showTextShadow"],
            B: ["showShadow", "showTextShadow"]
        },
        Acknowledgment: {
            D: "Properties used to acknowledge the use of canvasXpress :",
            P: ["acknowledgment", "acknowledgmentIcon", "acknowledgmentIconPosition"],
            B: ["acknowledgment", "acknowledgmentIcon", "acknowledgmentIconPosition"]
        },
        Clustering: {
            D: "Parameters used in clustering",
            P: ["centerData", "clusterAxis", "distance", "imputeMethod", "kmeansClusters", "linkage", "maxIterations", "useSmpVarIndexOnClustering"],
            B: ["centerData", "clusterAxis", "distance", "imputeMethod", "kmeansClusters", "linkage", "maxIterations", "useSmpVarIndexOnClustering"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        Histograms: {
            D: "Parameters used to create histograms in 2d scatter plots :",
            P: ["histogramBarWidth", "histogramBins", "isCreateHistogram", "isHistogram"],
            B: ["isCreateHistogram"]
        },
        "Boxplot Graphs": {
            D: "General parameters in Boxplot Graphs",
            P: ["boxPlotOutliersRatio", "boxplotDataPointRatio", "boxplotDataPointTransparency", "showBoxplotOriginalData"],
            U: {
                Boxplot: "true"
            }
        },
        "Space and Width": {
            D: "Properties used to size the bars and point in one dimensional plots",
            P: ["sampleSeparationFactor", "variableSeparationFactor", "widthFactor"],
            B: ["sampleSeparationFactor", "variableSeparationFactor", "widthFactor"],
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                BarLine: "true",
                Dotplot: "true",
                Stacked: "true",
                AreaLine: "true",
                Heatmap: "true"
            }
        },
        "Axis Resizer": {
            D: "Parameters used when resizing graphs",
            P: ["resizerBackgroundColor", "resizerBackgroundColorCurrent", "resizerBackgroundColorOutlineCurrent", "resizerBackgroundImage", "resizerDataIndex", "resizerDraw", "resizerPosition", "resizerTransparency", "resizerType", "resizerWidth"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        "Y-Axis": {
            D: "Y axes parameters",
            P: ["setMaxY", "setMinY", "yAxis", "yAxisAbsMax", "yAxisAbsMin", "yAxisCurrent", "yAxisExact", "yAxisMaxStrLength", "yAxisMinorTicks", "yAxisMinorValues", "yAxisShow", "yAxisTickColor", "yAxisTickFormat", "yAxisTickStyle", "yAxisTicks", "yAxisTitle", "yAxisTransform", "yAxisTransformTicks", "yAxisValues"],
            B: ["yAxisAbsMax", "yAxisAbsMin", "yAxisMaxStrLength", "yAxisShow", "yAxisTickColor", "yAxisTitle", "yAxisTransform", "yAxisTransformTicks"],
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        Foreground: {
            D: "Foreground properties used in all visualizations :",
            P: ["foreground", "foregroundWindow"],
            B: ["foreground"]
        },
        "Venn Diagrams": {
            D: "General parameters in Venn diagrams",
            P: ["vennColors", "vennCompartments", "vennGroups", "vennLegendColors"],
            B: ["vennCompartments", "vennGroups", "vennLegendColors"],
            U: {
                Venn: "true"
            }
        },
        "Heatmap Graphs": {
            D: "General parameters for heatmaps",
            P: ["isMultidimensionalHeatmap", "smpIndicesStart", "varIndicesStart", "varTitleLabelOverlayPosition"],
            B: ["isMultidimensionalHeatmap", "smpIndicesStart", "varIndicesStart", "varTitleLabelOverlayPosition"],
            U: {
                Heatmap: "true"
            }
        },
        Gradients: {
            D: "Properties used to adjust color gradients in all visualizations :",
            P: ["gradient", "gradientOrientation", "gradientRatio", "gradientType"]
        },
        "Remote Procedures": {
            D: "Parameters used when getting data remotely :",
            P: ["remoteAutoPlay", "remoteAutoPlayDelay", "remoteDataIndex", "remoteDirection", "remoteIds", "remoteParams", "remoteParentId", "remoteService", "remoteUpdate", "remoteUpdateDelay", "remoteUpdating", "remoteWindow"]
        },
        Animation: {
            D: "Animation parameters :",
            P: ["animationCycles", "animationTime", "animationType", "showAnimation", "showAnimationFont", "showAnimationFontColor", "showAnimationFontSize", "showAnimationFontStyle", "snapshotCopyChangeOnly"]
        },
        Events: {
            D: "Event parameters :",
            P: ["alignConfiguratorExamples", "broadcast", "broadcastType", "configuratorExamplesSize", "configuratorWidth", "dataEvent", "dataFilterWidth", "destroyCanvasXpressZombies", "disableConfigurator", "disableDataFilters", "disableDataTable", "disableEvents", "disableMenu", "disableToolbar", "eventArrowKeys", "eventKeys", "eventPlusMinusKeys", "helpKeyEvents", "infoStartTime", "infoTimeIn", "infoTimeOut", "isLayoutConfigurator", "maintainZoomOnDrag", "monitorCanvasXpressZombiesTime", "resizable", "resizeHeightOnLayout", "resizeWidthOnLayout", "showAdvancedConfiguration", "showConfiguratorExamplesOnSelect", "toolbarPermanent"],
            B: ["alignConfiguratorExamples", "showAdvancedConfiguration", "showConfiguratorExamplesOnSelect"]
        },
        "R-Axis": {
            D: "R axis parameters",
            P: ["rAxisAbsMax", "rAxisAbsMin", "rAxisLabelOrientation", "rAxisMaxStrLength", "rAxisMinorValues", "rAxisShow", "rAxisTickColor", "rAxisTicks", "rAxisValues"],
            B: ["rAxisAbsMax", "rAxisAbsMin", "rAxisLabelOrientation", "rAxisMaxStrLength", "rAxisShow", "rAxisTickColor"],
            U: {
                Circular: "true"
            }
        },
        Images: {
            D: "General parameters with images :",
            P: ["dropdownButton", "imageDir", "nextButton", "playButton", "previousButton", "stopButton"]
        },
        Videos: {
            D: "Video properties used in all visualizations",
            P: ["videoAutoplay", "videoClassName", "videoColor", "videoControls", "videoCurrentTime", "videoData", "videoGrid", "videoGridStep", "videoLoop", "videoPlaybackRate", "videoPoster", "videoPreload"],
            B: ["videoAutoplay", "videoClassName", "videoColor", "videoControls", "videoCurrentTime", "videoData", "videoGrid", "videoGridStep", "videoLoop", "videoPlaybackRate", "videoPoster", "videoPreload"],
            U: {
                Video: "true"
            }
        },
        "Genome Browser": {
            D: "General parameters used in genome browser",
            P: ["featureConfigurableProperties", "featureCoordinateHeight", "featureCoordinateShow", "featureHeightDefault", "featureNameFont", "featureNameFontColor", "featureNameFontSize", "featureNameFontStyle", "featureQualityHeight", "featureQualityShow", "featureQualityValues", "featureSignalToNoiseHeight", "featureSignalToNoiseShow", "featureSignalToNoiseValues", "featureStaggered", "featureTraceHeight", "featureTraceTrim", "featureTracesShow", "featureTranslateHeight", "featureTranslateShow", "featureTypeDefault", "featureWidthDefault", "filterFeatureBy", "genomeResolution", "genomeTicks", "maxFeatureStringLen", "periodTicksLabels", "sequenceAColor", "sequenceBColor", "sequenceCColor", "sequenceDColor", "sequenceEColor", "sequenceEndColor", "sequenceFColor", "sequenceFill", "sequenceFont", "sequenceFontSize", "sequenceFontStyle", "sequenceGAPColor", "sequenceGColor", "sequenceHColor", "sequenceIColor", "sequenceKColor", "sequenceLColor", "sequenceMColor", "sequenceNColor", "sequencePColor", "sequenceQColor", "sequenceRColor", "sequenceSColor", "sequenceStartColor", "sequenceTColor", "sequenceUColor", "sequenceVColor", "sequenceWColor", "sequenceXColor", "sequenceYColor", "sequenceZColor", "showFeatureNameThereshold", "subtracksMaxDefault", "trackConfigurableProperties", "trackNameFont", "trackNameFontColor", "trackNameFontSize", "trackNameFontStyle", "wireColor"],
            B: ["featureCoordinateShow", "featureNameFont", "featureNameFontColor", "featureQualityShow", "featureQualityValues", "featureSignalToNoiseShow", "featureSignalToNoiseValues", "featureStaggered", "featureTracesShow", "featureTranslateShow", "featureTypeDefault", "filterFeatureBy", "maxFeatureStringLen", "sequenceAColor", "sequenceBColor", "sequenceCColor", "sequenceDColor", "sequenceEColor", "sequenceEndColor", "sequenceFColor", "sequenceFill", "sequenceGAPColor", "sequenceGColor", "sequenceHColor", "sequenceIColor", "sequenceKColor", "sequenceLColor", "sequenceMColor", "sequenceNColor", "sequencePColor", "sequenceQColor", "sequenceRColor", "sequenceSColor", "sequenceStartColor", "sequenceTColor", "sequenceUColor", "sequenceVColor", "sequenceWColor", "sequenceXColor", "sequenceYColor", "sequenceZColor", "showFeatureNameThereshold", "subtracksMaxDefault", "trackNameFont", "trackNameFontColor"],
            U: {
                Genome: "true"
            }
        },
        Random: {
            D: "Properties used to generate random data sets :",
            P: ["randomData", "randomDataMean", "randomDataSampleAnnotationRatio", "randomDataSampleAnnotations", "randomDataSamples", "randomDataSigma", "randomDataSymmetrical", "randomDataUniform", "randomDataVariableAnnotationRatio", "randomDataVariableAnnotations", "randomDataVariables", "randomMissingDataPercentage", "randomNetworkNodeEdgesMax", "randomNetworkNodes", "randomNetworkReduce"],
            B: ["randomData"]
        },
        "Data Table/Filter": {
            D: "Parameters associated with data table and data filter",
            P: ["edgesProperties", "featuresProperties", "nodesProperties", "skipConfigurableProperties"],
            B: ["edgesProperties", "featuresProperties", "nodesProperties", "skipConfigurableProperties"],
            U: {
                Network: "true",
                Genome: "true"
            }
        },
        Samples: {
            D: "Properties associated with samples",
            P: ["filterSmpBy", "highlightSmp", "maxSmpStringLen", "showSampleNames", "smpHighlightColor", "smpLabelDescription", "smpLabelFont", "smpLabelFontColor", "smpLabelFontSize", "smpLabelFontStyle", "smpLabelInterval", "smpLabelRotate", "smpLabelScaleFontFactor", "smpTitle", "smpTitleFont", "smpTitleFontColor", "smpTitleFontSize", "smpTitleFontStyle", "smpTitleScaleFontFactor"],
            B: ["filterSmpBy", "highlightSmp", "maxSmpStringLen", "showSampleNames", "smpHighlightColor", "smpLabelDescription", "smpLabelFontColor", "smpLabelRotate", "smpLabelScaleFontFactor", "smpTitle", "smpTitleFont", "smpTitleFontColor", "smpTitleScaleFontFactor"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        Snapshots: {
            D: "Paremeters used in snapshots",
            P: ["isAnimation", "snapshots"],
            U: {
                Network: "true"
            }
        },
        "General Attributes": {
            D: "Properties related to Shapes, Sizes, Images and Time :",
            P: ["images", "shapes", "sizes", "timeFormat"]
        },
        "Z-Axis": {
            D: "Z axes parameters",
            P: ["setMaxZ", "setMinZ", "zAxis", "zAxisAbsMax", "zAxisAbsMin", "zAxisCurrent", "zAxisExact", "zAxisMaxStrLength", "zAxisMinorValues", "zAxisShow", "zAxisTickColor", "zAxisTickFormat", "zAxisTickStyle", "zAxisTicks", "zAxisTitle", "zAxisValues"],
            B: ["zAxisAbsMax", "zAxisAbsMin", "zAxisMaxStrLength", "zAxisShow", "zAxisTickColor", "zAxisTicks", "zAxisTitle"],
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true"
            }
        },
        Decorations: {
            D: "Additional elements added to graphs to increase data understanding",
            P: ["decorationFont", "decorationFontSize", "decorationFontStyle", "decorationScaleFontFactor", "decorations", "decorationsColor", "decorationsColors", "decorationsHeight", "decorationsPosition", "decorationsProperties", "decorationsType", "decorationsWidth", "showDecorations", "showDecorationsKaplanMeyerConfidence"],
            B: ["decorationFont"],
            U: {
                Network: "true",
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        "Aspect Ratio": {
            D: "Properties used to adjust the aspect ratio in one dimensional plots",
            P: ["adjustAspectRatio", "adjustAspectRatioMax", "adjustAspectRatioXTries", "adjustAspectRatioYTries"],
            B: ["adjustAspectRatioXTries", "adjustAspectRatioYTries"],
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                BarLine: "true",
                Dotplot: "true",
                Stacked: "true",
                AreaLine: "true",
                Heatmap: "true"
            }
        },
        Overlays: {
            D: "Colored boxes to help in the visualization of samples and variables",
            P: ["overlayFont", "overlayFontColor", "overlayFontSize", "overlayFontStyle", "overlayScaleFontFactor", "overlaysWidth", "showLevelOverlays", "showOverlays", "smpOverlayRecycleColors", "smpOverlays", "varOverlayRecycleColors", "varOverlays"],
            B: ["overlayFont", "showLevelOverlays", "showOverlays", "smpOverlayRecycleColors", "smpOverlays", "varOverlayRecycleColors", "varOverlays"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        Margins: {
            D: "Margin properties used in most visualizations :",
            P: ["margin", "marginBottom", "marginLeft", "marginRight", "marginTop"],
            B: ["margin", "marginBottom", "marginLeft", "marginRight", "marginTop"]
        },
        "Citations or References": {
            D: "Properties associated with citations or references of the plot :",
            P: ["citation", "citationColor", "citationFont", "citationFontSize", "citationFontStyle", "citationScaleFontFactor"],
            B: ["citation", "citationColor", "citationFont", "citationFontSize", "citationScaleFontFactor"]
        },
        Indicators: {
            D: "Legends for color, shape and size in visualizations",
            P: ["indicatorsPosition", "showIndicators"],
            B: ["indicatorsPosition", "showIndicators"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        Text: {
            D: "Properties associated with text attributes :",
            P: ["align", "autoScaleFont", "baseline", "font", "fontName", "fontSize", "fontStyle", "maxTextSize", "minTextSize", "scaleTextConstantAdd", "scaleTextConstantMult"],
            B: ["font", "scaleTextConstantAdd", "scaleTextConstantMult"]
        },
        "Plot area": {
            D: "General parameters for the plotting area in one dimensional plots",
            P: ["blockContrast", "is3DPlot", "jitter", "plotByVariable", "showDataValues", "smpHairline", "smpHairlineColor", "smpHairlineWidth"],
            B: ["blockContrast", "is3DPlot", "plotByVariable", "showDataValues", "smpHairline", "smpHairlineColor", "smpHairlineWidth"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correlation: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        Variables: {
            D: "Properties associated with variables",
            P: ["filterVarBy", "highlightVar", "maxVarStringLen", "showVariableNames", "varHighlightColor", "varLabelDescription", "varLabelFont", "varLabelFontColor", "varLabelFontSize", "varLabelFontStyle", "varLabelInterval", "varLabelRotate", "varLabelScaleFontFactor", "varTitle", "varTitleFont", "varTitleFontColor", "varTitleFontSize", "varTitleFontStyle", "varTitleScaleFontFactor"],
            B: ["filterVarBy", "highlightVar", "maxVarStringLen", "showVariableNames", "varHighlightColor", "varLabelDescription", "varLabelFont", "varLabelFontColor", "varLabelRotate", "varLabelScaleFontFactor", "varTitle", "varTitleFont", "varTitleFontColor", "varTitleScaleFontFactor"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        "Data Point Attributes": {
            D: "General attributes for data points in scatter and one dimensional plots",
            P: ["colorBy", "outlineBy", "outlineByData", "shapeBy", "shapeByData", "shapeByShape", "sizeBy", "sizeByData"],
            B: ["colorBy", "outlineBy", "shapeBy", "sizeBy"],
            U: {
                Boxplot: "true",
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Bar: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Heatmap: "true"
            }
        },
        "Scatter Plot Matrix": {
            D: "Parameters used to create a matrix of 2d scatter plots",
            P: ["scatterPlotMatrix", "scatterPlotMatrixType"],
            B: ["scatterPlotMatrix", "scatterPlotMatrixType"],
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        Dendrograms: {
            D: "General parameters in dendrograms",
            P: ["dendrogramColor", "dendrogramHang", "dendrogramHeight", "dendrogramSpace", "showSmpDendrogram", "showVarDendrogram", "smpDendrogramPosition", "varDendrogramPosition"],
            B: ["dendrogramColor", "dendrogramHang", "dendrogramHeight", "dendrogramSpace", "showSmpDendrogram", "showVarDendrogram", "smpDendrogramPosition", "varDendrogramPosition"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        "Area Graphs": {
            D: "General parameters in area graphs",
            P: ["areaIsCumulative"],
            B: ["areaIsCumulative"],
            U: {
                Area: "true",
                AreaLine: "true"
            }
        },
        "Candlestick Plots": {
            D: "General parameters in candlestick plots",
            P: ["showVolume", "sma10Color", "sma20Color", "sma25Color", "sma50Color", "sma5Color", "stockIndicators"],
            B: ["showVolume", "sma10Color", "sma20Color", "sma25Color", "sma50Color", "sma5Color", "stockIndicators"],
            U: {
                Candlestick: "true"
            }
        },
        "Pie Charts": {
            D: "General parameters in pie charts",
            P: ["maxPieSectors", "pieSegmentLabels", "pieSegmentPrecision", "pieSegmentSeparation", "pieType", "showPieGrid", "showPieSampleLabel", "showPieValues", "startPieSectors"],
            B: ["maxPieSectors", "pieSegmentLabels", "pieSegmentPrecision", "pieSegmentSeparation", "pieType", "showPieGrid", "showPieSampleLabel", "showPieValues", "startPieSectors"],
            U: {
                Pie: "true"
            }
        },
        General: {
            D: "General properties used in most visualizations :",
            P: ["canvasBox", "canvasBoxColor", "functions", "graphOrientation", "graphType", "loadImagesTimeOut", "transparency", "useFlashIE"],
            B: ["canvasBox", "canvasBoxColor", "functions", "graphOrientation", "graphType"]
        },
        Axis: {
            D: "General axis parameters",
            P: ["axisExtension", "axisTickColor", "axisTickFont", "axisTickFontSize", "axisTickFontStyle", "axisTickScaleFontFactor", "axisTitleColor", "axisTitleFont", "axisTitleFontSize", "axisTitleFontStyle", "axisTitleScaleFontFactor", "setMax", "setMin"],
            B: ["axisTickColor", "axisTickFont", "axisTickScaleFontFactor", "axisTitleColor", "axisTitleFont", "axisTitleScaleFontFactor", "setMax", "setMin"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        "Line Graphs": {
            D: "General parameters in line graphs",
            P: ["coordinateLineColor", "lineDecoration", "lineThickness", "lineType", "tension"],
            B: ["coordinateLineColor", "lineDecoration", "lineType"],
            U: {
                StackedLine: "true",
                Line: "true",
                StackedPercentLine: "true",
                BarLine: "true",
                AreaLine: "true"
            }
        },
        Colors: {
            D: "Properties to adjust Colors :",
            P: ["colorHSV", "colorRGB", "colorScheme", "colors", "evenColor", "oddColor"],
            B: ["colorHSV", "colorRGB", "colorScheme", "colors", "evenColor", "oddColor"]
        },
        "X-Axis2": {
            D: "X2 Axis parameters",
            P: ["setMaxX2", "setMinX2", "xAxis2AbsMax", "xAxis2Exact", "xAxis2MaxStrLength", "xAxis2MinorValues", "xAxis2Show", "xAxis2TickFormat", "xAxis2Ticks", "xAxis2Title", "xAxis2Values"],
            B: ["xAxis2AbsMax", "xAxis2Show", "xAxis2Ticks", "xAxis2Title"],
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                Correletion: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Pie: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                BarLine: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        "Network Graphs": {
            D: "General parameters used in networks",
            P: ["approximateNodePositions", "attractiveForceFunction", "autoHideOnDecorationsCenter", "calculateLayout", "colorEdgeBy", "colorNodeBy", "edgeConfigurableProperties", "edgeWidth", "filterEdgeBy", "filterNodeBy", "highlightNode", "initialTemperature", "is3DNetwork", "isSelectNodes", "layoutTime", "moveParentsWithChildren", "network2DRotate", "networkDepth", "networkDivisions", "networkForceConstant", "networkFreeze", "networkFreezeOnLoad", "networkLayoutType", "networkNodeMinDistance", "networkNodesOnTop", "networkRoot", "networkStack", "networkStackIndex", "networkStackStates", "nodeConfigurableProperties", "nodeFont", "nodeFontColor", "nodeFontSize", "nodeFontStyle", "nodeHighlightColor", "nodeScaleFontFactor", "nodeSize", "overrideAnchorNodes", "overrideEventlessNodes", "preScaleNetwork", "repulsiveForceFunction", "selectNode", "shapeEdgeBy", "shapeNodeBy", "showHiddenChildEdges", "showNetworkDecorationsLegend", "showNetworkEdgesLegend", "showNetworkNodesLegend", "showNetworkRadialLayout", "showNetworkTextLegend", "showNodeNameThreshold", "sizeDecorationBy", "sizeEdgeBy", "sizeNodeBy", "skipClick", "subNetworks", "temperature"],
            B: ["autoHideOnDecorationsCenter", "calculateLayout", "colorEdgeBy", "colorNodeBy", "edgeWidth", "filterEdgeBy", "filterNodeBy", "highlightNode", "is3DNetwork", "isSelectNodes", "networkLayoutType", "networkNodesOnTop", "networkRoot", "nodeFontColor", "nodeHighlightColor", "nodeScaleFontFactor", "nodeSize", "selectNode", "shapeEdgeBy", "shapeNodeBy", "showHiddenChildEdges", "showNetworkRadialLayout", "showNodeNameThreshold", "sizeDecorationBy", "sizeEdgeBy", "sizeNodeBy"],
            U: {
                Network: "true"
            }
        },
        "Combination Plots": {
            D: "Parameters used in complex plots :",
            P: ["layout", "layoutAdjust", "layoutAxis", "layoutComb", "layoutCurrent", "layoutHeight", "layoutMaxVarLegend", "layoutMulticolor", "layoutWidth", "offsetX", "offsetY", "scaleX", "scaleY", "translateX", "translateY", "weight"]
        },
        "Circular Graphs": {
            D: "General parameters in circular graphs",
            P: ["arcSegmentsSeparation", "circularCenterProportion", "circularConnectionsTransparency", "circularLetterSeparationFactor", "rAxis", "rAxisZero", "ringSeparation", "ringsType", "ringsWeight", "showCircularConnections", "showRingLegend", "smpLabelOrientation"],
            B: ["arcSegmentsSeparation", "circularCenterProportion", "circularLetterSeparationFactor", "rAxis", "rAxisZero", "ringSeparation", "ringsType", "ringsWeight", "showCircularConnections", "showRingLegend", "smpLabelOrientation"],
            U: {
                Circular: "true"
            }
        },
        Skins: {
            D: "Parameters to change the skin of the application widgets :",
            P: ["selectedBackgroundColor", "skin", "skinProperties", "skinPropertiesBlue", "skinPropertiesGrey"]
        },
        "Zooming and Panning": {
            D: "Parameters associated with zooming and panning events :",
            P: ["panningGlobalX", "panningGlobalY", "panningStep", "panningX", "panningY", "zoom", "zoomGlobal", "zoomSamplesDisable", "zoomStep", "zoomVariablesDisable"],
            B: ["panningGlobalX", "panningGlobalY", "zoomGlobal", "zoomSamplesDisable", "zoomVariablesDisable"]
        },
        Lines: {
            D: "Properties to adjust Lines :",
            P: ["arrowPointSize", "capType", "dashLength", "dotLength", "joinType", "lineWidthEvent", "lines", "outlineWidth"],
            B: ["lines"]
        },
        Debug: {
            D: "Debugging parameters :",
            P: ["codeType", "debug", "errors", "showCode", "showVersion"],
            B: ["errors"]
        },
        Legends: {
            D: "Legends for variables and samples",
            P: ["legendBackgroundColor", "legendBox", "legendBoxColor", "legendColor", "legendFont", "legendFontSize", "legendFontStyle", "legendPosition", "legendScaleFontFactor", "showLegend"],
            B: ["legendBackgroundColor", "legendBox", "legendBoxColor", "legendColor", "legendFont", "legendPosition", "legendScaleFontFactor", "showLegend"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        "Heatmap Color Schemes": {
            D: "General parameters in heatmaps, correlations and networks :",
            P: ["heatmapType", "indicatorCenter", "indicatorHeight", "indicatorWidth"],
            B: ["heatmapType", "indicatorCenter", "indicatorHeight", "indicatorWidth"]
        },
        Patterns: {
            D: "Properties related to Patterns :",
            P: ["patternImages", "patternNames", "patterns"],
            B: ["patterns"]
        },
        "Data Table": {
            D: "Parameters associated with the data table :",
            P: ["colWidth", "dataTableColumnWidth", "dataTableTransposed", "freezeColLeft", "freezeColRight", "freezeRowBottom", "freezeRowTop", "maxCols", "maxRows", "networkShowDataTable", "refresehDataTableOnDraw", "rowHeight", "showDataTable", "showDataTableOnSelect", "startCol", "startRow"],
            B: ["dataTableColumnWidth"]
        },
        "Titles and Subtitles": {
            D: "Properties associated with titles and subtitles :",
            P: ["subtitle", "subtitleColor", "subtitleHeight", "title", "titleColor", "titleHeight"],
            B: ["subtitle", "subtitleColor", "subtitleHeight", "title", "titleColor", "titleHeight"]
        },
        "Scatter Plots": {
            D: "General parameters in scatter plots",
            P: ["functionIntervals", "isSelectDataPoints", "scatterType", "selectDataMode", "selectDataModeDescription", "selectDataPoint"],
            B: ["isSelectDataPoints", "scatterType", "selectDataMode", "selectDataModeDescription", "selectDataPoint"],
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        Background: {
            D: "Background properties used in all visualizations :",
            P: ["background", "backgroundGradient1Color", "backgroundGradient2Color", "backgroundImage", "backgroundType", "backgroundVideo", "backgroundWindow", "backgroundWindowGradient1Color", "backgroundWindowGradient2Color", "backgroundWindowGradientOrientation"],
            B: ["background", "backgroundGradient1Color", "backgroundGradient2Color", "backgroundImage", "backgroundType", "backgroundVideo"]
        },
        "3D Attributes": {
            D: "General parameters in 3d scatter plots and networks",
            P: ["bar3DInverseWeight", "cullingThreshold", "maxRotate", "minRotate", "rotationDelay", "rotationSensitivity", "rotationStep", "show3DGrid", "x3DRatio", "xRotate", "y3DRatio", "yRotate", "z3DRatio", "zRotate"],
            U: {
                Network: "true",
                Scatter3D: "true",
                Bar: "true"
            }
        },
        "Data Filters": {
            D: "Parameters associated with filtering :",
            P: ["filterSkipNullKeys", "filterType"],
            B: ["filterSkipNullKeys", "filterType"]
        },
        "Correlation Graphs": {
            D: "General parameters for correlation",
            P: ["correlationAnchorLegend", "correlationAnchorLegendAlignWidth", "correlationAxis", "correlationLabelInterval"],
            B: ["correlationAxis"],
            U: {
                Correlation: "true"
            }
        },
        Functions: {
            D: "Functions exposed in the configurator :",
            P: ["addNormalDistributionLine", "addRegressionLine", "clusterSamples", "clusterVariables", "createHistogram", "createRandomData", "desegregateSamples", "desegregateVariables", "draw", "groupSamples", "hideCodeDiv", "hideInfoDiv", "hideUnhideSmps", "hideUnhideVars", "kmeansSamples", "kmeansVariables", "print", "recalculateLayout", "removeHistogram", "reset", "saveRemoteParameters", "segregateSamples", "segregateVariables", "setSkin", "showCodeDiv", "showInfoDiv", "sortSamplesByCategory", "sortSamplesByVariable", "sortVariablesByCategory", "sortVariablesBySample", "transform", "transpose", "ungroupSamples", "updateCodeDiv"],
            B: ["addNormalDistributionLine", "addRegressionLine", "clusterSamples", "clusterVariables", "createRandomData", "desegregateSamples", "desegregateVariables", "draw", "groupSamples", "hideUnhideSmps", "hideUnhideVars", "kmeansSamples", "kmeansVariables", "print", "recalculateLayout", "removeHistogram", "reset", "saveRemoteParameters", "segregateSamples", "segregateVariables", "setSkin", "sortSamplesByCategory", "sortSamplesByVariable", "sortVariablesByCategory", "sortVariablesBySample", "transform", "transpose", "ungroupSamples"]
        },
        "X-Axis": {
            D: "X axis parameters",
            P: ["setMaxX", "setMinX", "timeTicksFirst", "timeValueIndices", "timeValues", "xAxis", "xAxisAbsMax", "xAxisAbsMin", "xAxisCurrent", "xAxisExact", "xAxisMaxStrLength", "xAxisMinorTicks", "xAxisMinorValues", "xAxisShow", "xAxisTickColor", "xAxisTickFormat", "xAxisTickStyle", "xAxisTicks", "xAxisTitle", "xAxisTransform", "xAxisTransformTicks", "xAxisValues"],
            B: ["setMaxX", "xAxisAbsMax", "xAxisAbsMin", "xAxisMaxStrLength", "xAxisShow", "xAxisTickColor", "xAxisTitle", "xAxisTransform", "xAxisTransformTicks"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                StackedLine: "true",
                Scatter2D: "true",
                BarLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        Data: {
            D: "Data related parameters",
            P: ["groupingFactors", "isBoxPlotCalc", "isGraphTime", "isGroupedData", "isLogData", "isMarketDataFormated", "isMarketSwitched", "isTransformedData", "missingDataColor", "ratioReference", "segregateSamplesBy", "segregateVariablesBy", "showErrorBars", "showErrorBarsWidth", "smpSort", "sortDir", "tmpAsciiArray", "transformBase", "transformType", "varSort", "zscoreAxis"],
            B: ["groupingFactors", "isBoxPlotCalc", "isGroupedData", "isLogData", "isMarketDataFormated", "isMarketSwitched", "isTransformedData", "missingDataColor", "ratioReference", "segregateSamplesBy", "segregateVariablesBy", "showErrorBars", "showErrorBarsWidth", "smpSort", "sortDir", "tmpAsciiArray", "transformBase", "transformType", "varSort", "zscoreAxis"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        }
    },
    N: {
        hideLabel: {
            M: "Network",
            T: "boolean",
            C: "Flag to hide the label node"
        },
        zIndex: {
            M: "Network",
            T: "integer",
            C: "Css property for the imagePath"
        },
        x: {
            M: "Network",
            T: "float",
            C: "X coordinate"
        },
        outline: {
            M: "Network",
            T: "color",
            C: "Color for the outline of the node"
        },
        imagePath: {
            M: "Network",
            T: "url",
            C: "Url for the node image"
        },
        parentNode: {
            M: "Network",
            T: "string",
            C: "Id of parent node"
        },
        y: {
            M: "Network",
            T: "float",
            C: "Y coordinate"
        },
        anchor: {
            M: "Network",
            T: "boolean",
            C: "Flag make the node transparent"
        },
        color: {
            M: "Network",
            T: "color",
            C: "Color for the node"
        },
        outlineWidth: {
            M: "Network",
            T: "integer",
            C: "Pixels used to raw the outline of the node"
        },
        eventless: {
            M: "Network",
            T: "boolean",
            C: "Flag to disable all events in the node"
        },
        pattern: {
            O: "open, closed",
            M: "Network",
            T: "option",
            C: "Whether to draw a solid shape or just an outline"
        },
        rotate: {
            M: "Network",
            T: "integer",
            C: "Number of degrees to rotate the shape"
        },
        hide: {
            M: "Network",
            T: "boolean",
            C: "Flag to hide the node"
        },
        shape: {
            M: "Network",
            T: "string",
            C: "Shape for the node. One of the ones defined in shapes"
        },
        z: {
            M: "Network",
            T: "float",
            C: "Z coordinate"
        }
    },
    P: {
        yAxisTransform: {
            H: ['{*,"graphType":"Scatter2D"}'],
            O: ["false", "log2", "log10", "exp2", "exp10", "percentile"],
            M: "Y-Axis",
            T: "option",
            C: "Transformation for the values in the Y axis.",
            D: "false"
        },
        vennCompartments: {
            Z: "true",
            M: "Venn Diagrams",
            T: "array",
            C: "Name for the compartments in the the Venn diagrams"
        },
        setMaxX: {
            Z: "true",
            H: ['{"setMaxX":200}', '{"setMaxX":50}', '{"setMaxX":null}'],
            M: "X-Axis",
            T: "float",
            C: "Maximum value to set the data in the X axis",
            D: "null"
        },
        adjustAspectRatioYTries: {
            Z: "true",
            M: "Aspect Ratio",
            T: "integer",
            C: "Counter set when trying to automatically adjust the vertical size of the canvas when adjustAspectRatio is true"
        },
        sequenceLColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the leucines in the genome browser",
            D: "rgb(0,103,0)"
        },
        pieSegmentLabels: {
            H: ["{*}"],
            O: ["inside", "outside"],
            M: "Pie Charts",
            T: "option",
            C: "Location for the values in the pie charts",
            D: "inside"
        },
        shapeBy: {
            S: ["shapeByData"],
            O: ["false", "variable"],
            T: "option",
            X: "getXZData",
            H: ['{"graphType":"Scatter3D","shapeBy":"Annt1"}', '{"graphType":"Scatter3D","shapeBy":"Sample4"}', '{"graphType":"Dotplot","shapeBy":"Factor1"}', '{"graphType":"Dotplot","shapeBy":"Annt1"}', '{"graphType":"Dotplot","shapeBy":"variable"}'],
            M: "Data Point Attributes",
            D: "false",
            C: "Name of a variable annotation or a sample name or the string 'variable' to shape the variables. When shapeByData is specified shapeBy is used for the title in the legend."
        },
        xAxis2Exact: {
            A: "true",
            H: ['{*,"graphType":"BarLine"}'],
            M: "X-Axis2",
            T: "boolean",
            C: "Flag to force exact values for the data in the 2nd X axis",
            D: "false",
            U: {
                StackedLine: "true",
                StackedPercentLine: "true",
                BarLine: "true",
                AreaLine: "true"
            }
        },
        sequenceFont: {
            A: "true",
            Z: "true",
            M: "Genome Browser",
            T: "font",
            C: "Font for the text of the sequence in the genome browser"
        },
        networkStack: {
            A: "true",
            Z: "true",
            M: "Network Graphs",
            T: "array",
            C: "Array to keep state of the network after a drag or move"
        },
        desegregateSamples: {
            S: ["segregateSamples"],
            M: "Functions",
            T: "void",
            C: "Desegreagate samples previously segregated based on a sample category (data.x object)",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                Correletion: "true",
                StackedPercentLine: "true",
                Pie: "true",
                Barline: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        is3DNetwork: {
            H: ["{*}"],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to create or not a 3D network",
            D: "false"
        },
        backgroundWindow: {
            A: "true",
            S: ["backgroundType"],
            H: ['{*,"backgroundType":"window"}'],
            M: "Background",
            T: "color",
            C: "Specifies the background color for the canvas when the background type is of a type 'window'.",
            D: "rgb(204,204,204)"
        },
        varDendrogramPosition: {
            H: ['{*,"data":"Generic","graphType":"Heatmap","showVarDendrogram":true}'],
            O: ["top", "bottom"],
            M: "Dendrograms",
            T: "option",
            C: "Position for the variable dendrogram in the plot. It could be top, bottom, right or left depending on the orientation of the graph.",
            D: "top"
        },
        calculateLayout: {
            H: ['{"data":"NetworkBasic","calculateLayout":false}', '{"data":"LesMiserables","calculateLayout":true,"colorNodeBy":"group"}'],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to force or not to calculate the network layout.",
            D: "true"
        },
        varLabelInterval: {
            A: "true",
            H: ["{*}"],
            M: "Variables",
            T: "integer",
            C: "Interval for the variable labels in heatmaps",
            D: "1",
            U: {
                Heatmap: "true"
            }
        },
        shapes: {
            A: "true",
            H: ['{"data":"Shapes","calculateLayout":false,"graphType":"Network"}'],
            O: ["sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "pacman", "mdavid", "rect2", "rect3", "arc", "rectangle", "image"],
            M: "General Attributes",
            T: "array",
            C: "Shapes used in network graphs"
        },
        yAxisMinorValues: {
            A: "true",
            M: "Y-Axis",
            T: "array",
            C: "Values for the minor ticks in the Y axis",
            D: "[]"
        },
        sequenceTColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the thymidines and threonines in the genome browser",
            D: "rgb(255,0,0)"
        },
        nodeFontColor: {
            H: ["{*}"],
            M: "Network Graphs",
            T: "color",
            C: "Color for the network text",
            D: "background color"
        },
        networkNodeMinDistance: {
            A: "true",
            H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
            M: "Network Graphs",
            T: "integer",
            C: "Minimum distance between nodes in forceDirected and organic layouts",
            D: "2"
        },
        lineThickness: {
            A: "true",
            S: ["outlineWidth"],
            H: ['{*,"graphType":"Line"}'],
            M: "Line Graphs",
            T: "float",
            C: "Thickness in pixels for the lines in the line plots.",
            D: "1"
        },
        title: {
            S: ["titleHeight", "titleColor"],
            H: ['{"title":"Graph Title"}'],
            M: "Titles and Subtitles",
            T: "string",
            C: "Title of the graph.",
            D: "false"
        },
        zAxisMaxStrLength: {
            Z: "true",
            M: "Z-Axis",
            T: "string",
            C: "Longest string of all the values in the ticks in the Z axis"
        },
        yAxisExact: {
            A: "true",
            H: ['{*,"graphType":"Scatter2D"}'],
            M: "Y-Axis",
            T: "boolean",
            C: "Flag to force exact values for the data in the Y axis",
            D: "false"
        },
        showShadow: {
            S: ["shadowOffsetX", "shadowOffsetY", "shadowBlur", "shadowColor"],
            H: ["{*}"],
            M: "Shadows",
            T: "boolean",
            C: "Flag used to add shadows to all graph objects in the canvas. It will be forced to false if the browser is IE.",
            D: "false"
        },
        colorScheme: {
            S: ["colors"],
            H: ['{*,"data":"Random:16:1:0:0:1","graphType":"Pie"}'],
            O: ["user", "basic", "dark", "strong", "light", "pastel", "balanced", "reset"],
            M: "Colors",
            T: "option",
            C: "Color schemes can be user defined which will take the colors in the color property or one provided in canvasXpress. The order of the colors will be used to sequentially select when a different color is needed in a particular visualization.",
            D: "basic"
        },
        remoteWindow: {
            A: "true",
            M: "Remote Procedures",
            T: "integer",
            C: "Number of plots to show  when requesting remote data",
            D: "1"
        },
        showNetworkDecorationsLegend: {
            A: "true",
            H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to show node legends in the networks",
            D: "true"
        },
        zAxisTickFormat: {
            A: "true",
            H: ['{"graphType":"Scatter3D","zAxisTickFormat":"%.2f cxs"}'],
            M: "Z-Axis",
            T: "string",
            C: "Format for the tick values in the Z axis",
            D: "false"
        },
        xAxisMinorValues: {
            A: "true",
            M: "X-Axis",
            T: "array",
            C: "Values for the minor ticks in the X axis",
            D: "[]"
        },
        rAxisMinorValues: {
            A: "true",
            M: "R-Axis",
            T: "array",
            C: "Values for the minor ticks in the R axis",
            D: "[]"
        },
        isMarketDataFormated: {
            Z: "true",
            M: "Data",
            T: "boolean",
            C: "Flag to indicate if the data has been formated to display Candlestick."
        },
        segregateSamples: {
            S: ["desegregateSamples"],
            M: "Functions",
            T: "option",
            C: "Segregate samples based on a sample category (data.x object)",
            X: "getXData",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                Correletion: "true",
                StackedPercentLine: "true",
                Pie: "true",
                Barline: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        ringsWeight: {
            H: ['{"data":"Circular","segregateVariablesBy":"Ring","ringsWeight":[0.5,0.25,0.25]}'],
            M: "Circular Graphs",
            T: "array",
            C: "Array containing the dimensions for each ring in the circular plots",
            D: "[]"
        },
        skin: {
            A: "true",
            H: ["{*}"],
            O: ["blue", "grey"],
            M: "Skins",
            T: "option",
            C: "Skin for the application",
            D: "grey"
        },
        isTransformedData: {
            Z: "true",
            M: "Data",
            T: "boolean",
            C: "Flag to indicate if the data is transformed."
        },
        background: {
            S: ["backgroundType"],
            H: ["{*}"],
            M: "Background",
            T: "color",
            C: "Specifies the background color for the canvas.",
            D: "rgb(255,255,255)"
        },
        resizerTransparency: {
            A: "true",
            M: "Axis Resizer",
            T: "boolean",
            C: "Flag to make the axis resizers transparent",
            D: "true"
        },
        hideUnhideVars: {
            M: "Functions",
            T: "array",
            C: "Hide or unhide variables. It works like a switch",
            X: "getVariablesAsArray",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        periodTicksLabels: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Number of ticks to skip between values in the genome browser",
            D: "5"
        },
        colWidth: {
            A: "true",
            M: "Data Table",
            T: "integer",
            C: "Mumber of pixels for the width of cells in the data table",
            D: "100"
        },
        showAnimationFontStyle: {
            A: "true",
            O: ["", "bold", "italic", "bold italic"],
            M: "Animation",
            T: "option",
            C: "Font style for the animation. @default"
        },
        scaleY: {
            A: "true",
            Z: "true",
            M: "Combination Plots",
            T: "float",
            C: "Scale factor for the Y axis"
        },
        varLabelFont: {
            Z: "true",
            M: "Variables",
            T: "font",
            C: "Font for the variable labels in one dimensional plots"
        },
        startCol: {
            A: "true",
            Z: "true",
            M: "Data Table",
            T: "integer",
            C: "Starting column in the data table"
        },
        xAxisTransform: {
            H: ['{*,"graphType":"Scatter2D"}'],
            O: ["false", "log2", "log10", "exp2", "exp10", "percentile"],
            M: "X-Axis",
            T: "option",
            C: "Tranformation for the values in the X axis.",
            D: "false",
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        nodesProperties: {
            M: "Data Table/Filter",
            T: "array",
            C: "Two dimensional array with object properties not at the root level for the nodes in the Network graph to include in the Data table and the data filter",
            D: "[]"
        },
        ratioReference: {
            H: ["{*}"],
            M: "Data",
            T: "integer",
            C: "Default index of sample used in ratio transformation.",
            D: "0"
        },
        citationColor: {
            S: ["citation"],
            H: ['{*,"citation":"Graph citation or reference"}'],
            M: "Citations or References",
            T: "color",
            C: "Color for a reference citation of the graph",
            D: "rgb(0,0,0)"
        },
        rAxisZero: {
            M: "Circular Graphs",
            T: "boolean",
            C: "Flag to force the rAxis to start from zero otherwise it starts from the minimum value",
            D: "false"
        },
        decorationsPosition: {
            A: "true",
            H: ['{*,"showDecorations":true,"showLegend":false,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}', '{*,"data":"NetworkDecorations","graphType":"Network","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"],"conditional":{"decorationsPosition":["top","right"]}}', '{*,"data":"NetworkDecorations","graphType":"Network","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"],"conditional":{"decorationsPosition":["bottom","left"]}}'],
            O: ["bottom", "right"],
            M: "Decorations",
            T: "option",
            C: "Position for the decorations in scatter plots and network graphs",
            D: "bottom"
        },
        eventPlusMinusKeys: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to enable plus / minus key binding events.",
            D: "true"
        },
        resizerBackgroundColorCurrent: {
            A: "true",
            M: "Axis Resizer",
            T: "color",
            C: "Color for the div that shows up the current area selected in the axes in the canvas",
            D: "rgb(153,187,232)"
        },
        correlationAnchorLegend: {
            A: "true",
            H: ["{*}"],
            M: "Correlation Graphs",
            T: "boolean",
            C: "Flag to show a region above the correlation plot that anchror a sample/variable to a position",
            D: "false"
        },
        minRotate: {
            A: "true",
            M: "3D Attributes",
            T: "float",
            C: "Minimum number of degrees to rotate graph arround axes",
            D: "null"
        },
        axisTitleColor: {
            H: ["{*}"],
            M: "Axis",
            T: "color",
            C: "Color for the axis title in one and two dimensional plots",
            D: "foreground color"
        },
        varTitleFontColor: {
            H: ['{*,"varTitle":"Variable Title"}'],
            M: "Variables",
            T: "color",
            C: "Font color for the variable titles in one dimensional plots",
            D: "foreground color",
            U: {
                Heatmap: "true"
            }
        },
        circularConnectionsTransparency: {
            A: "true",
            H: ['{*,"data":"Circular","segregateSamplesBy":"Segment"}'],
            M: "Circular Graphs",
            T: "float",
            C: "Percentage of transparency applied to the connections in the circular graphs",
            D: "0.5"
        },
        loadImagesTimeOut: {
            A: "true",
            M: "General",
            T: "integer",
            C: "Specifies the number of milliseconds to wait trying to load images before atempting to plot the data. For developers only.",
            D: "100"
        },
        xAxis2AbsMax: {
            Z: "true",
            M: "X-Axis2",
            T: "float",
            C: "Minimum non-filtered value for the data plotted in the 2nd X axis"
        },
        panningGlobalX: {
            Z: "true",
            M: "Zooming and Panning",
            T: "float",
            C: "Cumulative number of unit to pan the network in the X dimension"
        },
        xAxis: {
            A: "true",
            T: "array",
            X: "getSamplesAsArray",
            H: ['{"xAxis":["Sample1","Sample2","Sample3"],"yAxis":["Sample4","Sample5","Sample6"],"graphType":"Scatter2D"}'],
            M: "X-Axis",
            D: "[]",
            C: "Name of the samples or sample groups to be displayed in the X axis",
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        featureNameFont: {
            Z: "true",
            M: "Genome Browser",
            T: "font",
            C: "Font for the text of the features in the genome browser"
        },
        offsetY: {
            A: "true",
            Z: "true",
            M: "Combination Plots",
            T: "float",
            C: "Additional amount to move for the Y axis."
        },
        selectNode: {
            Z: "true",
            M: "Network Graphs",
            T: "object",
            C: "Name of nodes (in the data object) to select.",
            D: "{}"
        },
        showErrorBarsWidth: {
            H: ['{"showErrorBars":true,"showErrorBarsWidth":2,"functions":["groupSamples:Factor1"]}', '{"showErrorBars":true,"showErrorBarsWidth":10,"functions":["groupSamples:Factor1"]}'],
            M: "Data",
            T: "integer",
            C: "Minimum size of the bar in pixels to determine to show or hide error bar ends in the graphs when available.",
            D: "2"
        },
        isGraphTime: {
            A: "true",
            H: ['{"isGraphTime":true,"data":"Random:1:150:0:0:0:0:1","showVolume":false}'],
            M: "Data",
            T: "boolean",
            C: "Flag to indicate if the data is a time series so there is no need to plot every time interval",
            D: "false"
        },
        featureTraceHeight: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Default size in pixels of the trace height",
            D: "40"
        },
        featureQualityShow: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "boolean",
            C: "Flag use to show quality",
            D: "true"
        },
        smpLabelFontStyle: {
            A: "true",
            H: ["{*}"],
            O: ["", "bold", "italic", "bold italic"],
            M: "Samples",
            T: "option",
            C: "Font style for the sample label. @default"
        },
        lineDecoration: {
            H: ['{*,"graphType":"Line"}'],
            O: ["false", "dot", "symbol"],
            M: "Line Graphs",
            T: "option",
            C: "Lines decorations in the line graphs",
            D: "symbol"
        },
        kmeansVariables: {
            S: ["kmeansClusters", "maxIterations"],
            M: "Functions",
            T: "void",
            C: "Cluster variables using kmeans",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                StackedLine: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        xAxisValues: {
            A: "true",
            M: "X-Axis",
            T: "array",
            C: "Values for the ticks in the X axis",
            D: "[]"
        },
        clusterAxis: {
            S: ["distance", "linkage", "imputeMethod", "centerData", "clusterSamples", "clusterVariables"],
            O: ["samples", "variables"],
            M: "Clustering",
            T: "option",
            C: "Default axis to use when clustering data.",
            D: "samples"
        },
        rotationDelay: {
            A: "true",
            M: "3D Attributes",
            T: "integer",
            C: "Time in milliseconds to wait between rendering the plot when dragging the mouse.",
            D: "100"
        },
        varLabelScaleFontFactor: {
            H: ["{*}"],
            M: "Variables",
            T: "float",
            C: "Scaling factor used to increse or decrease variable font size in the canvas.",
            D: "1",
            U: {
                Heatmap: "true"
            }
        },
        maxVarStringLen: {
            H: ['{"maxVarStringLen":50}', '{"maxVarStringLen":5}'],
            M: "Variables",
            T: "integer",
            C: "Maximum length in characters a variable label or description can have so anything above is truncated.",
            D: "30",
            U: {
                Heatmap: "true"
            }
        },
        varLabelRotate: {
            H: ['{"varLabelRotate":0}', '{"varLabelRotate":45}', '{"varLabelRotate":90}'],
            M: "Variables",
            T: "integer",
            C: "Rotation for variable labels in degrees It could be positive or negative.",
            D: "0",
            U: {
                Heatmap: "true"
            }
        },
        networkNodesOnTop: {
            H: ["{*}"],
            M: "Network Graphs",
            T: "boolean",
            C: "Order to use when drawing nodes and edges in the networks",
            D: "true"
        },
        colorRGB: {
            Z: "true",
            M: "Colors",
            T: "array",
            C: "Color RGB. Red, Green, Blue used in the configurator"
        },
        setMaxZ: {
            A: "true",
            H: ['{"graphType":"Scatter3D","setMaxZ":200}', '{"graphType":"Scatter3D","setMaxZ":50}', '{"graphType":"Scatter3D","setMaxZ":null}'],
            M: "Z-Axis",
            T: "float",
            C: "Maximum value to set the data in the Z axis",
            D: "null"
        },
        dendrogramHeight: {
            M: "Dendrograms",
            T: "boolean",
            C: "Flag to size the branches of the dendrogram. Not implemented yet.",
            D: "false"
        },
        showFeatureNameThereshold: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Threshehold used to set te limit when there are too many features in the genome browser",
            D: "20"
        },
        zAxisAbsMin: {
            Z: "true",
            M: "Z-Axis",
            T: "float",
            C: "Minimum non-filtered value for the data plotted in the Z axis"
        },
        setMinZ: {
            A: "true",
            H: ['{"graphType":"Scatter3D","setMinY":15}', '{"graphType":"Scatter3D","setMinY":30}', '{"graphType":"Scatter3D","setMinY":null}'],
            M: "Z-Axis",
            T: "float",
            C: "Minimum value to set the data in the Z axis",
            D: "null"
        },
        varTitleFontSize: {
            A: "true",
            H: ['{"varTitle":"Variable Title","autoScaleFont":false,"varTitleFontSize":10}', '{"varTitle":"Variable Title","autoScaleFont":false,"varTitleFontSize":20}'],
            M: "Variables",
            T: "integer",
            C: "Size for the variable title in one dimensional plots",
            D: "10",
            U: {
                Heatmap: "true"
            }
        },
        edgeWidth: {
            H: ["{*}"],
            M: "Network Graphs",
            T: "integer",
            C: "Default width for the edges in the networks",
            D: "1"
        },
        genomeTicks: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Number of ticks in the genome browser",
            D: "50"
        },
        sequenceSColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the degenerate G/C and serines in the genome browser",
            D: "rgb(255,165,0)"
        },
        showCircularConnections: {
            H: ['{*,"data":"Circular","segregateVariablesBy":"Ring"}'],
            M: "Circular Graphs",
            T: "boolean",
            C: "Flag to show connections in circular graphs",
            D: "true"
        },
        showTextShadow: {
            S: ["shadowOffsetX", "shadowOffsetY", "shadowBlur", "shadowColor"],
            H: ["{*}"],
            M: "Shadows",
            T: "boolean",
            C: "Flag used to add shadows to all text in the canvas. It will be forced to false if the browser is IE.",
            D: "false"
        },
        isMultidimensionalHeatmap: {
            Z: "true",
            M: "Heatmap Graphs",
            T: "boolean",
            C: "Flag to indicate if the heatmap is multidimensional"
        },
        maxIterations: {
            S: ["kmeansClusters", "kmeansSamples", "kmeansVariables"],
            M: "Clustering",
            T: "integer",
            C: "Number of maximum iterations when clustering data with kmeans for one dimensional graphs or maximum number of iterations when calculating force direct layout networks.",
            D: "10"
        },
        sortDir: {
            H: ["{*}"],
            O: ["ascending", "descending"],
            M: "Data",
            T: "option",
            C: "Default direction for data sorting.",
            D: "ascending"
        },
        filterSmpBy: {
            M: "Samples",
            T: "filter",
            C: "Filter samples by their annotation included in the 'data.x' object used in one dimensional plots",
            D: "[]",
            X: "getXData"
        },
        showOverlays: {
            H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
            M: "Overlays",
            T: "boolean",
            C: "Flag to indicate to show or not the overlays in one dimensional plots",
            D: "true"
        },
        graphOrientation: {
            H: ["{*}"],
            O: ["horizontal", "vertical"],
            M: "General",
            T: "option",
            C: "Specifies the orientation of one dimensional graphs.",
            D: "horizontal",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                StackedPercentLine: "true",
                Treemap: "true",
                Candlestick: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                BarLine: "true",
                Dotplot: "true",
                Stacked: "true",
                AreaLine: "true",
                Heatmap: "true"
            }
        },
        outlineWidth: {
            A: "true",
            S: ["lineThickness"],
            H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
            M: "Lines",
            T: "integer",
            C: "Default width in pixels for lines in networks and other line elements in all visualizations except for the lines in the line plots.",
            D: "1"
        },
        randomDataVariableAnnotationRatio: {
            A: "true",
            M: "Random",
            T: "integer",
            C: "Approximate number of classes in each variable annotation when creating random data",
            D: "2"
        },
        marginRight: {
            H: ["{*}"],
            M: "Margins",
            T: "integer",
            C: "Specifies the length in pixels for the right margin in the canvas.",
            D: "20"
        },
        align: {
            A: "true",
            H: ['{*,"title":"Graph Title"}'],
            O: ["right", "center", "left"],
            M: "Text",
            T: "option",
            C: "Default horizontal alignment for drawing text.",
            D: "center"
        },
        dataTableTransposed: {
            A: "true",
            M: "Data Table",
            T: "boolean",
            C: "Flag to transpose the data in the data table",
            D: "true"
        },
        showDataTableOnSelect: {
            A: "true",
            M: "Data Table",
            T: "boolean",
            C: "Flag to indicate to show data after selecting data in the plot",
            D: "false"
        },
        wireColor: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the ticks in the genome browser",
            D: "rgba(204,204,204,0.1)"
        },
        sequenceVColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the degenerate A/C/G and valines in the genome browser",
            D: "rgb(0,103,0)"
        },
        marginTop: {
            H: ["{*}"],
            M: "Margins",
            T: "integer",
            C: "Specifies the length in pixels for the top margin in the canvas.",
            D: "20"
        },
        setMin: {
            Z: "true",
            M: "Axis",
            T: "float",
            C: "Minimum value to set the data",
            D: "null"
        },
        animationCycles: {
            A: "true",
            M: "Animation",
            T: "integer",
            C: "Number of cycles to plot the graph for the animations.",
            D: "20"
        },
        sequenceDColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the degenerate A/G/T and aspartic acids in the genome browser",
            D: "rgb(0,0,0)"
        },
        videoLoop: {
            H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Videos",
            T: "boolean",
            C: "Flag to loop videos default false"
        },
        shapeNodeBy: {
            H: ['{"data":"LesMiserables","colorNodeBy":"group","shapeNodeBy":"group"}'],
            M: "Network Graphs",
            T: "string",
            C: "Name of the attribute to shape the nods.",
            D: "false"
        },
        axisTickFontStyle: {
            A: "true",
            H: ["{*}"],
            O: ["", "bold", "italic", "bold italic"],
            M: "Axis",
            T: "option",
            C: "Font style for the axis. @default"
        },
        errors: {
            Z: "true",
            M: "Debug",
            T: "array",
            C: "Array containing benign errors produced when rendering canvasXpress",
            D: "[]"
        },
        xAxisShow: {
            H: ["{*}"],
            M: "X-Axis",
            T: "boolean",
            C: "Flag to show on not the values of the ticks in the X axis",
            D: "true"
        },
        skinPropertiesGrey: {
            A: "true",
            Z: "true",
            H: ["{*}"],
            M: "Skins",
            T: "array",
            C: "Values for the grey skin",
            D: "[]"
        },
        canvasBoxColor: {
            S: ["canvasBox"],
            H: ['{*,"canvasBox":true}'],
            M: "General",
            T: "color",
            C: "Color for the box around the canvas",
            D: "rgb(0,0,0)"
        },
        subtitleHeight: {
            S: ["subtitle", "subtitleColor"],
            H: ['{*,"title":"Graph Title","subtitle":"Graph Subtitle"}'],
            M: "Titles and Subtitles",
            T: "integer",
            C: "Height for the subtitle of the graph. The font height will be adjusted automatically to fit in the canvas.",
            D: "16"
        },
        indicatorsPosition: {
            H: ['{*,"data":"Random:16:4:0:0","colorBy":"Sample4","showIndicators":true,"graphType":"Scatter3D"}'],
            O: ["bottom", "right"],
            M: "Indicators",
            T: "option",
            C: "Position for the color, shape and size indicators in several visualizations",
            D: "bottom"
        },
        featureConfigurableProperties: {
            A: "true",
            F: "id:[string];Feature id;[],fill:[color];Color for the feature;[]",
            H: ["{*}"],
            M: "Genome Browser",
            T: "array",
            C: "Feature configurable properties",
            D: ["'id'", "'name'", "'label'", "'hideName'", "'fill'", "'outline'", "'dir'", "'showDir'", "'connect'", "'offset'", "'data'", "'subtype'", "'quality'", "'signalToNoise'", "'coordinate'", "'sequence'", "'trace'", "'gaps'", "'translate'", "'hide'", "'counter'"]
        },
        titleHeight: {
            S: ["title", "titleColor"],
            H: ['{*,"title":"Graph Title"}'],
            M: "Titles and Subtitles",
            T: "integer",
            C: "Height for the title of the graph. The font height will be adjusted automatically to fit in the canvas.",
            D: "30"
        },
        subtracksMaxDefault: {
            M: "Genome Browser",
            T: "integer",
            C: "Maximum number of subtracks to show in a track",
            D: "8"
        },
        acknowledgment: {
            H: ["{*}"],
            S: ["acknowledgmentIcon", "acknowledgmentIconPosition"],
            M: "Acknowledgment",
            T: "boolean",
            C: "Flag to include an acknowledgment image for canvasXpress",
            D: "false"
        },
        videoColor: {
            H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Videos",
            T: "color",
            C: "Color for the video grid and current time",
            D: "rgb(255,0,0)"
        },
        sizes: {
            A: "true",
            H: ['{"data":"Random:16:3:16:0","graphType":"Scatter3D","sizeBy":"Annt1"}'],
            O: ["4", "6", "8", "10", "12", "14", "16", "18", "20", "22", "24", "26", "28", "30", "32", "34"],
            M: "General Attributes",
            T: "array",
            C: "Sizes used invisualizations"
        },
        infoTimeIn: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "integer",
            C: "Time in milliseconds to start showing info after a mouse over",
            D: "3000"
        },
        layoutHeight: {
            A: "true",
            Z: "true",
            M: "Combination Plots",
            T: "float",
            C: "Height of the current segment of the canvas when there are multiple graphs."
        },
        sizeEdgeBy: {
            H: ['{"data":"LesMiserables","sizeEdgeBy":"value"}'],
            M: "Network Graphs",
            T: "string",
            C: "Name of the attribute to size the edges.",
            D: "false"
        },
        xAxis2Title: {
            H: ['{"graphType":"BarLine","xAxis2Title":"2nd X-axis title"}'],
            M: "X-Axis2",
            T: "string",
            C: "Title for the 2nd X axis",
            D: "false"
        },
        foregroundWindow: {
            A: "true",
            S: ["backgroundType"],
            H: ['{*,"backgroundType":"window"}'],
            M: "Foreground",
            T: "color",
            C: "Specifies the foreground color for text or lines when the background type is of a type 'window'.",
            D: "rgb(0,0,0)"
        },
        colorBy: {
            H: ['{"graphType":"Scatter3D","colorBy":"Annt1"}', '{"graphType":"Scatter3D","colorBy":"Sample4"}', '{"graphType":"Bar","colorBy":"Factor1"}', '{"graphType":"Dotplot","colorBy":"Factor1"}', '{"graphType":"Dotplot","colorBy":"Annt1"}'],
            O: ["false", "variable"],
            M: "Data Point Attributes",
            T: "option",
            C: "Name of a variable annotation or a sample name or the string 'variable' to color the variables.",
            D: "false",
            X: "getXZData"
        },
        randomNetworkNodeEdgesMax: {
            A: "true",
            M: "Random",
            T: "integer",
            C: "Default number of maximum edges when creating random networks",
            D: "5",
            U: {
                Network: "true"
            }
        },
        scaleTextConstantAdd: {
            Z: "true",
            M: "Text",
            T: "float",
            C: "Constants to autoscale text (extra)",
            D: "2.5"
        },
        outlineByData: {
            A: "true",
            S: ["outlineBy"],
            T: "string",
            H: ['{"data":"MultidimensionalHeatmap","outlineByData":"data2","outlineBy":"Data Outline"}'],
            M: "Data Point Attributes",
            D: "false",
            C: "String that identify the object containing a two dimensional array with values used to color the outline data points when drawing a multidimensional Heatmap. It must be located within the data.y object (for example: data.y.data4)",
            U: {
                Heatmap: "true"
            }
        },
        transformBase: {
            H: ["{*}"],
            O: ["2", "10"],
            M: "Data",
            T: "integer",
            C: "Default log or exponential transformation.",
            D: "2"
        },
        centerData: {
            H: ['{"graphType":"Heatmap","centerData":true,"functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","centerData":false,"functions":["clusterSamples","clusterVariables"]}'],
            S: ["distance", "linkage", "clusterAxis", "imputeMethod", "clusterSamples", "clusterVariables"],
            M: "Clustering",
            T: "boolean",
            C: "Flag to indicate whether to center data when clustering",
            D: "false"
        },
        missingDataColor: {
            H: ['{*,"data":"Random:10:10::::::0.15","graphType":"Heatmap"}'],
            M: "Data",
            T: "color",
            C: "Color for the missing data",
            D: "rgb(255,255,0)"
        },
        offsetX: {
            A: "true",
            Z: "true",
            M: "Combination Plots",
            T: "float",
            C: "Additional amount to move for the X axis"
        },
        videoAutoplay: {
            H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Videos",
            T: "boolean",
            C: "Flag to autoplay videos default true"
        },
        rAxisAbsMin: {
            Z: "true",
            M: "R-Axis",
            T: "float",
            C: "Minimum non-filtered value for the data plotted in the R axis"
        },
        zAxisTickStyle: {
            A: "true",
            H: ['{*,"graphType":"Scatter3D"}'],
            O: ["solid", "dotted"],
            M: "Z-Axis",
            T: "option",
            C: "Style for the tick lines in the Z axis",
            D: "solid"
        },
        showNodeNameThreshold: {
            H: ['{"data":"LesMiserables","showNodeNameThreshold":50,"colorNodeBy":"group"}', '{"data":"LesMiserables","showNodeNameThreshold":100,"colorNodeBy":"group"}'],
            M: "Network Graphs",
            T: "integer",
            C: "Thereshold used to set the limit to hide or display the name of nodes in a network. If the number of nodes exceed this thereshold then the name will not be shown.",
            D: "50"
        },
        arcSegmentsSeparation: {
            H: ['{*,"data":"Circular","segregateSamplesBy":"Segment"}'],
            M: "Circular Graphs",
            T: "integer",
            C: "Number of degrees to separate the segments in the circular plots",
            D: "8"
        },
        sizeByData: {
            A: "true",
            S: ["sizeBy"],
            T: "string",
            H: ['{"data":"MultidimensionalHeatmap","sizeByData":"data3","sizeBy":"Data Size"}'],
            M: "Data Point Attributes",
            D: "false",
            C: "String that identify the object containing a two dimensional array with values used to size data points when drawing a multidimensional Heatmap. It must be located within the data.y object (for example: data.y.data3)",
            U: {
                Heatmap: "true"
            }
        },
        isSelectDataPoints: {
            Z: "true",
            M: "Scatter Plots",
            T: "integer",
            C: "Number of selected data points (in the data object).",
            D: "0"
        },
        randomDataSampleAnnotations: {
            A: "true",
            M: "Random",
            T: "integer",
            C: "Default number of sample annotations when creating random data",
            D: "3"
        },
        smpLabelRotate: {
            H: ['{"smpLabelRotate":0}', '{"smpLabelRotate":-45}', '{"smpLabelRotate":90}'],
            M: "Samples",
            T: "integer",
            C: "Rotation for sample labels in degrees. It could be positive or negative.",
            D: "0"
        },
        randomDataUniform: {
            A: "true",
            M: "Random",
            T: "boolean",
            C: "Flag to create or not uniform random data for debug and demonstration purposes",
            D: "false"
        },
        resizerWidth: {
            A: "true",
            M: "Axis Resizer",
            T: "integer",
            C: "Length in pixels for the width of the visible axis resizer",
            D: "18"
        },
        showNetworkRadialLayout: {
            H: ['{*,"data":"NetworkRadial","networkLayoutType":"radial"}'],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to show or not a radial layout wire.",
            D: "false"
        },
        infoTimeOut: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "integer",
            C: "Time in milliseconds to wait between updates for the mouse over info to show up",
            D: "3000"
        },
        overlayFont: {
            Z: "true",
            M: "Overlays",
            T: "font",
            C: "Font for the overlays in one dimensional plots"
        },
        setMinY: {
            A: "true",
            H: ['{"graphType":"Scatter2D","setMinY":15}', '{"graphType":"Scatter2D","setMinY":30}', '{"graphType":"Scatter2D","setMinY":null}'],
            M: "Y-Axis",
            T: "float",
            C: "Minimum value to set the data in the Y axis",
            D: "null"
        },
        showNetworkEdgesLegend: {
            A: "true",
            H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to show edge legends in the networks",
            D: "true"
        },
        alignConfiguratorExamples: {
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to align examples to the configurator",
            D: "false"
        },
        filterNodeBy: {
            M: "Network Graphs",
            T: "filter",
            C: "Filter nodes by their properties used in network graphs",
            D: "[]",
            X: "getNodeData"
        },
        panningGlobalY: {
            Z: "true",
            M: "Zooming and Panning",
            T: "float",
            C: "Cumulative number of unit to pan the network in the Y dimension"
        },
        featureHeightDefault: {
            A: "true",
            M: "Genome Browser",
            T: "integer",
            C: "Default size in pixels of the feature height",
            D: "14"
        },
        zAxisTicks: {
            Z: "true",
            M: "Z-Axis",
            T: "integer",
            C: "Number of ticks in the Z axis",
            D: "10"
        },
        remoteIds: {
            A: "true",
            Z: "true",
            M: "Remote Procedures",
            T: "array",
            C: "Array of the remoteIds passed after a service call"
        },
        freezeColLeft: {
            A: "true",
            M: "Data Table",
            T: "integer",
            C: "Number of columns to freeze in the left side of the data table",
            D: "0"
        },
        yAxisTickFormat: {
            A: "true",
            H: ['{"graphType":"Scatter2D","yAxisTickFormat":"%.2f cxs"}'],
            M: "Y-Axis",
            T: "string",
            C: "Format for the tick values in the Y axis",
            D: "false"
        },
        isGroupedData: {
            Z: "true",
            M: "Data",
            T: "boolean",
            C: "Flag to indicate if the data is grouped."
        },
        vennLegendColors: {
            H: ["{*}"],
            M: "Venn Diagrams",
            T: "boolean",
            C: "Flag to use the venn colors to use for the legends instead of the letters",
            D: "false"
        },
        zoomGlobal: {
            Z: "true",
            M: "Zooming and Panning",
            T: "float",
            C: "Cumulative zoom factor for the networks."
        },
        decorationsType: {
            A: "true",
            O: ["pie", "bar", "heatmap", "stacked", "stackedpercent"],
            T: "option",
            H: ['{*,"data":"NetworkDecorations","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"conditional":{"decorations":[["exp1","exp2","exp3"],["exp1","exp2","exp3"],["exp4","exp5"],["exp4","exp5"],["exp4","exp5"]]}}'],
            M: "Decorations",
            D: "bar",
            C: "Type for the decorations in the networks. The types stacked and stackedpercent must be two dimensional. Heatmap could be one or two dimensional",
            U: {
                Network: "true"
            }
        },
        showVersion: {
            A: "true",
            M: "Debug",
            T: "boolean",
            C: "Flag to show version when mouse over top-left corner of the canvas.",
            D: "true"
        },
        networkDepth: {
            A: "true",
            Z: "true",
            M: "Network Graphs",
            T: "integer",
            C: "Depth of the radial network."
        },
        showHiddenChildEdges: {
            H: ["{*}"],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to show or not children nodes when the parent node is hidden.",
            D: "true"
        },
        randomDataSigma: {
            A: "true",
            M: "Random",
            T: "integer",
            C: "Sigma value when creating random data",
            D: "100"
        },
        resizeWidthOnLayout: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to enable resizing the width of the canvas after changing the layout",
            D: "true"
        },
        nodeConfigurableProperties: {
            A: "true",
            M: "Network Graphs",
            T: "array",
            C: "Node configurable properties",
            N: "x:[float];X coordinate;[],y:[float];Y coordinate;[],z:[float];Z coordinate;[],parentNode:[string];Id of parent node;[],shape:[string];Shape for the node. One of the ones defined in shapes;[shapes],color:[color];Color for the node;[],outline:[color];Color for the outline of the node;[],pattern:[open|closed];Whether to draw a solid shape or just an outline;[],rotate:[integer];Number of degrees to rotate the shape;[],outlineWidth:[integer];Pixels used to raw the outline of the node;[],imagePath:[url];Url for the node image;[],zIndex:[integer];Css property for the imagePath;[],eventless:[boolean];Flag to disable all events in the node;[overrideEventlessNodes],hide:[boolean];Flag to hide the node;[],hideLabel:[boolean];Flag to hide the label node;[],anchor:[boolean];Flag make the node transparent;[]",
            D: ["'x'", "'y'", "'z'", "'shape'", "'color'", "'outline'", "'size'", "'width'", "'height'", "'pattern'", "'rotate'", "'outlineWidth'", "'imagePath'", "'zIndex'", "'eventless'"]
        },
        zoomStep: {
            A: "true",
            H: ['{*,"graphType":"Heatmap"}'],
            M: "Zooming and Panning",
            T: "float",
            C: "Percentage step for zooming networks and genome panel.",
            D: "0.2"
        },
        axisTitleScaleFontFactor: {
            H: ["{*}"],
            M: "Axis",
            T: "float",
            C: "Scaling factor used to increase or decrease title font size in the canvas in one and two dimensional plots",
            D: "1"
        },
        zAxisExact: {
            A: "true",
            H: ['{*,"graphType":"Scatter3D"}'],
            M: "Z-Axis",
            T: "boolean",
            C: "Flag to force exact values for the data in the Z axis",
            D: "false"
        },
        featureSignalToNoiseValues: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "boolean",
            C: "Flag use to show values for the quality",
            D: "false"
        },
        showNetworkTextLegend: {
            A: "true",
            H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to show node legends in the networks",
            D: "true"
        },
        showIndicators: {
            H: ['{*,"data":"Random:16:4:0:0","colorBy":"Sample4","graphType":"Scatter3D"}'],
            M: "Indicators",
            T: "boolean",
            C: "Flag to show color, shape and size indicators in several visualizations",
            D: "true"
        },
        createHistogram: {
            A: "true",
            O: ["x", "y"],
            M: "Functions",
            T: "option",
            C: "Create a histogram in 2D-Scatter plots in the 'x' axis or the 'y' axis",
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        sma20Color: {
            H: ['{*,"stockIndicators":["Sma20"]}'],
            M: "Candlestick Plots",
            T: "color",
            C: "The color for the 25 day single moving average",
            D: "rgb(0,0,255)"
        },
        smpHairlineColor: {
            H: ['{*,"graphType":"Bar","smpHairline":true}'],
            M: "Plot area",
            T: "color",
            C: "The color for the thin line that appears in the middle of the bar graphs",
            D: "rgb(204,204,204)"
        },
        axisTitleFont: {
            Z: "true",
            M: "Axis",
            T: "font",
            C: "Font for the axis titles in one and two dimensional plots"
        },
        functions: {
            Z: "true",
            M: "General",
            T: "array",
            C: "Functions exposed to the api"
        },
        decorationsProperties: {
            A: "true",
            H: ['{"data":"NetworkDecorations","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"],"decorationsProperties":{"exp1":{"color":"rgb(51,125,255)","shape":"square"},"exp2":{"color":"rgb(125,255,51)","shape":"square"},"exp2":{"color":"rgb(255,125,51)","shape":"square"}}}'],
            M: "Decorations",
            T: "object",
            C: "Object to assign properties like color for the network decorations",
            D: "{}",
            U: {
                Network: "true"
            }
        },
        rAxisMaxStrLength: {
            Z: "true",
            M: "R-Axis",
            T: "string",
            C: "Longest string of all the values in the ticks in the R axis"
        },
        showAnimationFont: {
            A: "true",
            Z: "true",
            M: "Animation",
            T: "font",
            C: "Font for the text in animations"
        },
        videoPoster: {
            H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Videos",
            T: "url",
            C: "Video poster for videos",
            D: "false"
        },
        nodeFontSize: {
            A: "true",
            H: ["{*}"],
            M: "Network Graphs",
            T: "integer",
            C: "Size in pixels for the font size of text in the networks",
            D: "20"
        },
        sortSamplesByVariable: {
            S: ["sortDir", "sortSamplesByCategory"],
            M: "Functions",
            T: "array",
            C: "Sort the samples by the value of a variable",
            X: "getVariablesAsArray",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                Correletion: "true",
                StackedPercentLine: "true",
                Pie: "true",
                Barline: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        resizerBackgroundImage: {
            A: "true",
            M: "Axis Resizer",
            T: "url",
            C: "Resizer background image",
            D: "false"
        },
        sizeDecorationBy: {
            M: "Network Graphs",
            T: "string",
            C: "Name of the attribute to size the network decoration.",
            D: "false"
        },
        setSkin: {
            O: ["blue", "grey"],
            M: "Functions",
            T: "option",
            C: "Change the skin of the application"
        },
        trackConfigurableProperties: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "array",
            C: "Track configurable properties",
            D: ["'name'", "'hideName'", "'hideFeatureNames'", "'type'", "'height'", "'fill'", "'outline'", "'data'", "'hide'", "'connect'", "'subtracksMax'", "'highlight'"],
            G: "name:[string];Track name;[]"
        },
        xAxisTickColor: {
            H: ["{*}"],
            M: "X-Axis",
            T: "color",
            C: "Color for the tick lines in the X axis",
            D: "rgb(204,204,204)"
        },
        yAxisTickColor: {
            H: ['{*,"graphType":"Scatter2D"}'],
            M: "Y-Axis",
            T: "color",
            C: "Color for the tick lines in the Y axis",
            D: "rgb(204,204,204)",
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Correlation: "true",
                Scatter2D: "true"
            }
        },
        isAnimation: {
            A: "true",
            Z: "true",
            M: "Snapshots",
            T: "boolean",
            C: "Flag to indicate if there is an active animation"
        },
        pieSegmentPrecision: {
            H: ["{*}"],
            M: "Pie Charts",
            T: "integer",
            C: "Number of decimals for values in the Pie charts",
            D: "0"
        },
        layoutMulticolor: {
            A: "true",
            H: ["{*}"],
            M: "Combination Plots",
            T: "boolean",
            C: "Flag to cycle colors when displaying multiple graps in the canvas. If set to false the color will be reseted for every graph.",
            D: "true"
        },
        disableToolbar: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to disable showing the toolbar",
            D: "false"
        },
        decorationScaleFontFactor: {
            A: "true",
            H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
            M: "Decorations",
            T: "float",
            C: "Scaling factor used to increase or decrease decoration font size in the canvas.",
            D: "1"
        },
        previousButton: {
            A: "true",
            M: "Images",
            T: "image",
            C: "Relative path to an image file to the previous button (not including the image directory)",
            D: "rewind.png"
        },
        boxPlotOutliersRatio: {
            A: "true",
            H: ['{"data":"Boxplot","boxPlotOutliersRatio":8,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","boxPlotOutliersRatio":10,"functions":["groupSamples:Factor1"]}'],
            M: "Boxplot Graphs",
            T: "integer",
            C: "Ratio for the size of the outliers with respect to boxplot",
            D: "8"
        },
        panningY: {
            A: "true",
            H: ["{*}"],
            M: "Zooming and Panning",
            T: "float",
            C: "Number of unit to pan the network in the Y dimension",
            D: "0"
        },
        useFlashIE: {
            A: "true",
            M: "General",
            T: "boolean",
            C: "Flag to use flash rather than VML (through excanvas.js) when graphs are displayed in IE browsers (not HTML5 compliant). For developers only.",
            D: "true"
        },
        randomDataMean: {
            A: "true",
            M: "Random",
            T: "integer",
            C: "Mean value when creating random data",
            D: "100"
        },
        transpose: {
            M: "Functions",
            T: "void",
            C: "Transpose the data. It takes no parameters",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                StackedLine: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        smpLabelScaleFontFactor: {
            H: ["{*}"],
            M: "Samples",
            T: "float",
            C: "Scaling factor used to increase or decrease sample label font size in the canvas.",
            D: "1"
        },
        circularLetterSeparationFactor: {
            H: ['{*,"data":"Circular","segregateSamplesBy":"Segment"}'],
            M: "Circular Graphs",
            T: "float",
            C: "Factor to adjust the spacing between letters in the circular graphs. The greater the number the closer the letters in the labels",
            D: "2"
        },
        debug: {
            A: "true",
            M: "Debug",
            T: "boolean",
            C: "Flag to turn on alerts.",
            D: "true"
        },
        patternNames: {
            A: "true",
            S: ["patternImages", "patterns"],
            M: "Patterns",
            T: "array",
            C: "Pattern names used in visualizations to fill objects. This array must have the same length as that one for the pattern images."
        },
        citation: {
            S: ["citationColor"],
            H: ['{"citation":"Graph citation or reference"}'],
            M: "Citations or References",
            T: "string",
            C: "A reference citation of the graph which is placed at the bottom right corner",
            D: "false"
        },
        smpSort: {
            Z: "true",
            M: "Data",
            T: "integer",
            C: "Sample index used in sorting the data."
        },
        resizerBackgroundColorOutlineCurrent: {
            A: "true",
            M: "Axis Resizer",
            T: "color",
            C: "Color for the div that shows up the current area selected in the axes in the canvas",
            D: "rgb(153,187,232)"
        },
        showAnimation: {
            A: "true",
            H: ["{*}"],
            M: "Animation",
            T: "boolean",
            C: "Flag to show or not animation for the graphs",
            D: "false"
        },
        networkFreezeOnLoad: {
            A: "true",
            H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to prevent autoscaling for the network layout after loading. Useful when images are part of the network.",
            D: "false"
        },
        layoutTime: {
            A: "true",
            H: ["{*}"],
            M: "Network Graphs",
            T: "integer",
            C: "Time in milliseconds used to calculate the layout for the network",
            D: "15"
        },
        xAxisAbsMax: {
            Z: "true",
            M: "X-Axis",
            T: "float",
            C: "Maximum non-filtered value for the data plotted in the X axis"
        },
        isLogData: {
            H: ["{*}"],
            M: "Data",
            T: "boolean",
            C: "Flag to indicate if the data is Log transformed.",
            D: "false"
        },
        tension: {
            A: "true",
            H: ['{*,"data":"Random:4:6","graphType":"Line","lineType":"spline"}'],
            M: "Line Graphs",
            T: "float",
            C: "Curvature for the splines",
            D: "0.3"
        },
        networkStackIndex: {
            A: "true",
            Z: "true",
            M: "Network Graphs",
            T: "integer",
            C: "Index in the network stack for undo and redo operations"
        },
        axisTickColor: {
            H: ["{*}"],
            M: "Axis",
            T: "color",
            C: "Color for the axis ticks in one and two dimensional plots",
            D: "foreground color"
        },
        resizerBackgroundColor: {
            A: "true",
            M: "Axis Resizer",
            T: "color",
            C: "Color for the div that shows up when resizing the axes in the canvas or the whole canvas",
            D: "rgb(204,204,204)"
        },
        groupSamples: {
            S: ["ungroupSamples"],
            M: "Functions",
            T: "array",
            C: "Group samples based on a sample category (data.x object)",
            X: "getXData",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                Correletion: "true",
                StackedPercentLine: "true",
                Pie: "true",
                Barline: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        zRotate: {
            A: "true",
            H: ['{"graphType":"Scatter3D","zRotate":0}', '{"graphType":"Scatter3D","zRotate":45}'],
            M: "3D Attributes",
            T: "float",
            C: "Starting number of degrees to rotate graph arround the Z axis",
            D: "0"
        },
        remoteDirection: {
            A: "true",
            O: ["next", "prev"],
            M: "Remote Procedures",
            T: "option",
            C: "Direction parameter used to obtain data remotely.",
            D: "next"
        },
        featureWidthDefault: {
            A: "true",
            M: "Genome Browser",
            T: "integer",
            C: "Default size in pixels of the feature width",
            D: "3"
        },
        skinPropertiesBlue: {
            A: "true",
            Z: "true",
            H: ["{*}"],
            M: "Skins",
            T: "array",
            C: "Values for the blue skin",
            D: "[]"
        },
        rAxisShow: {
            H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":"Ring","segregateSamplesBy":"Segment"}'],
            M: "R-Axis",
            T: "boolean",
            C: "Flag to show on not the values of the ticks in the R axis",
            D: "true"
        },
        showVariableNames: {
            H: ["{*}"],
            M: "Variables",
            T: "boolean",
            C: "Flag to show the variable names in one dimensional plots",
            D: "true",
            U: {
                Heatmap: "true"
            }
        },
        decorationFontSize: {
            A: "true",
            H: ['{*,"autoScaleFont":false,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
            M: "Decorations",
            T: "integer",
            C: "Font size for the decorations in scatter plots and network graphs",
            D: "10"
        },
        infoStartTime: {
            A: "true",
            Z: "true",
            M: "Events",
            T: "time",
            C: "Time in milliseconds to keep track of time"
        },
        fontSize: {
            A: "true",
            H: ['{*,"title":"Graph Title"}'],
            M: "Text",
            T: "integer",
            C: "Font size for text in complex plot only. See other categories to modify specific font sizes.",
            D: "12"
        },
        filterType: {
            O: ["and", "or"],
            M: "Data Filters",
            T: "option",
            C: "Type for the filter. Can be 'and' or 'or'",
            D: "and"
        },
        imageDir: {
            A: "true",
            M: "Images",
            T: "url",
            C: "Relative path to a directory contaioning images",
            D: "http://canvasxpress.org/images/"
        },
        animationTime: {
            A: "true",
            M: "Animation",
            T: "integer",
            C: "Time in milliseconds to wait between rendering the plot when showing the animation.",
            D: "30"
        },
        layoutMaxVarLegend: {
            A: "true",
            Z: "true",
            M: "Combination Plots",
            T: "integer",
            C: "Maximum length of legend when multiple graphs are displayed in the canvas."
        },
        resizable: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to disable resizing the canvas by dragging the mouse over the edges",
            D: "true"
        },
        attractiveForceFunction: {
            A: "true",
            H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
            O: ["Eades", "FruchtermanReingold"],
            M: "Network Graphs",
            T: "option",
            C: "Type of function to apply when calculating attractive force in forceDirected network layouts",
            D: "FruchtermanReingold"
        },
        rotationStep: {
            A: "true",
            H: ['{*,"graphType":"Scatter3D","data":"3DScatter"}'],
            M: "3D Attributes",
            T: "integer",
            C: "Number of degrees used when the plot is automatically rotated",
            D: "2"
        },
        xAxis2Ticks: {
            Z: "true",
            M: "X-Axis2",
            T: "integer",
            C: "Number of ticks in the 2nd X axis. It is the same as xAxisTicks.",
            D: "5"
        },
        layoutCurrent: {
            A: "true",
            Z: "true",
            M: "Combination Plots",
            T: "integer",
            C: "Integer to identify the current graph being displayed in the canvas."
        },
        graphType: {
            H: ['{*,"graphOrientation":"vertical"}'],
            O: ["Bar", "Line", "Area", "AreaLine", "BarLine", "Boxplot", "Dotplot", "Heatmap", "Candlestick", "Stacked", "StackedLine", "StackedPercent", "StackedPercentLine", "Treemap", "Scatter2D", "ScatterBubble2D", "Scatter3D", "Correlation", "Pie", "Venn", "Network", "Genome", "Circular"],
            M: "General",
            T: "option",
            C: "Specifies the type of graph.",
            D: "Bar"
        },
        distance: {
            H: ['{"graphType":"Heatmap","distance":"euclidian","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","distance":"manhattan","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","distance":"max","functions":["clusterSamples","clusterVariables"]}'],
            S: ["linkage", "clusterAxis", "centerData", "clusterSamples", "clusterVariables"],
            O: ["euclidian", "manhattan", "max"],
            M: "Clustering",
            T: "option",
            C: "Distance metric to use when clustering data.",
            D: "euclidian"
        },
        featureSignalToNoiseShow: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "boolean",
            C: "Flag use to show quality",
            D: "true"
        },
        remoteUpdateDelay: {
            A: "true",
            M: "Remote Procedures",
            T: "integer",
            C: "Time in milliseconds to wait between tryig to get an upated version of the file containing the data",
            D: "10000"
        },
        layout: {
            A: "true",
            H: ["{*}"],
            M: "Combination Plots",
            T: "string",
            C: "Topology of the canvas. Number of rows and columns.",
            D: "1X1"
        },
        marginBottom: {
            H: ["{*}"],
            M: "Margins",
            T: "integer",
            C: "Specifies the length in pixels for the bottom margin in the canvas.",
            D: "20"
        },
        filterEdgeBy: {
            M: "Network Graphs",
            T: "filter",
            C: "Filter edges by their properties used in network graphs",
            D: "[]",
            X: "getEdgeData"
        },
        showPieValues: {
            H: ["{*}"],
            M: "Pie Charts",
            T: "boolean",
            C: "A flag to show the values for the pie",
            D: "true"
        },
        showDecorationsKaplanMeyerConfidence: {
            A: "true",
            S: ["decorations"],
            H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"KaplanMeyer","showLegend":false,"title":"Kaplan-Meyer Plot","functions":["addKaplanMeyerCurve:Time:Censored-1:Data 1 Population:rgb(0,0,255)","addKaplanMeyerCurve:Time:Censored-2:Data 2 Population:rgb(255,0,0)","draw"]}'],
            M: "Decorations",
            T: "boolean",
            C: "Flag to show or not the confidence intervals in the Kaplan-Meyer plots",
            D: "false"
        },
        smpTitleFontSize: {
            A: "true",
            H: ['{"smpTitle":"Sample Title","autoScaleFont":false,"smpTitleFontSize":10}', '{"smpTitle":"Sample Title","autoScaleFont":false,"smpTitleFontSize":20}'],
            M: "Samples",
            T: "integer",
            C: "Size for the sample title in one dimensional plots",
            D: "10"
        },
        edgeConfigurableProperties: {
            A: "true",
            M: "Network Graphs",
            T: "array",
            C: "Edge configurable properties",
            D: ["'width'", "'cap'", "'exact'", "'type'"],
            E: "color:[color];Color for the edge;[],width:[integer];Pixel width for the edges between nodes;[],cap:[butt|round|square];Type of cap for the end of the lines;[capType],exact:[boolean];Flag to indicate to create the edge between nodes without subtracting the size of the nodes;[],type:[string];Type of line use to join the nodes;[lines],hide:[boolean];Flag to hide the edge;[],anchor:[boolean];Flag make the edge transparent;[]"
        },
        zoomSamplesDisable: {
            H: ['{*,"graphType":"Heatmap"}'],
            S: ["zoomVariablesDisable"],
            M: "Zooming and Panning",
            T: "boolean",
            C: "Flag to disable zooming of samples with mouse wheel in Heatmaps",
            D: "false"
        },
        decorationsColor: {
            A: "true",
            H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
            M: "Decorations",
            T: "color",
            C: "Color for the decorations in scatter plots and network graphs",
            D: "foreground color"
        },
        sequenceUColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the uracils in the genome browser",
            D: "rgb(255,0,0)"
        },
        freezeRowTop: {
            A: "true",
            M: "Data Table",
            T: "integer",
            C: "Number of rows to freeze at the top of the data table",
            D: "0"
        },
        nodeHighlightColor: {
            H: ['{*,"highlightNode":["Gene1","Gene2"]}'],
            M: "Network Graphs",
            T: "color",
            C: "The color for the highlighted nodes.",
            D: "rgb(255,0,0)"
        },
        oddColor: {
            S: ["blockContrast", "evenColor"],
            H: ['{*,"data":"Random:1:6:0:0","blockContrast":true}'],
            M: "Colors",
            T: "color",
            C: "The color for the odd numbers in samples when the property block contrast is set in one dimensional plots or the color for odd number residues in translations in genome plots.",
            D: "rgb(255,255,255)"
        },
        capType: {
            A: "true",
            H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
            O: ["butt", "round", "square"],
            M: "Lines",
            T: "option",
            C: "Default type of cap for lines.",
            D: "butt"
        },
        patternImages: {
            A: "true",
            S: ["patternNames", "patterns"],
            M: "Patterns",
            T: "array",
            C: "Image patterns used in visualizations to fill objects. This array must have the same length as that one for the pattern names."
        },
        showAnimationFontColor: {
            A: "true",
            M: "Animation",
            T: "color",
            C: "Color for the animation text",
            D: "background color"
        },
        canvasBox: {
            S: ["canvasBoxColor"],
            H: ["{*}"],
            M: "General",
            T: "boolean",
            C: "Flag to create a box around the canvas",
            D: "true"
        },
        updateCodeDiv: {
            A: "true",
            M: "Functions",
            T: "void",
            C: "Update the code to generate the plot"
        },
        videoGridStep: {
            H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Videos",
            T: "integer",
            C: "Number of steps to divide the grid in the video",
            D: "10"
        },
        rAxisTicks: {
            A: "true",
            H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":"Ring","segregateSamplesBy":"Segment"}'],
            M: "R-Axis",
            T: "integer",
            C: "Number of ticks in the R axis",
            D: "5"
        },
        sortVariablesBySample: {
            S: ["sortDir", "sortVariablesByCategory"],
            M: "Functions",
            T: "array",
            C: "Sort the variables by the value of a sample",
            X: "getSamplesAsArray",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                Correletion: "true",
                StackedPercentLine: "true",
                Pie: "true",
                Barline: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        layoutWidth: {
            A: "true",
            Z: "true",
            M: "Combination Plots",
            T: "float",
            C: "Width of the current segment of the canvas when there are multiple graphs."
        },
        histogramBarWidth: {
            A: "true",
            S: ["scatterType", "isHistogram"],
            H: ['{*,"graphType":"Scatter2D","isHistogram":true}'],
            M: "Histograms",
            T: "float",
            C: "Length in pixels for half of the bar width in the 2D sccater plot histogram.",
            D: "0.5"
        },
        correlationAxis: {
            H: ["{*}"],
            O: ["samples", "variables"],
            M: "Correlation Graphs",
            T: "option",
            C: "Axis used for the correlation.",
            D: "samples"
        },
        shadowOffsetX: {
            A: "true",
            S: ["showShadow"],
            H: ['{*,"showShadow":true}'],
            M: "Shadows",
            T: "integer",
            C: "Length in pixels for the shadow offset in the X axis.",
            D: "1"
        },
        xAxisTicks: {
            A: "true",
            H: ["{*}"],
            M: "X-Axis",
            T: "integer",
            C: "Number of ticks in the X axis",
            D: "5"
        },
        sequenceZColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the glutamines in the genome browser",
            D: "rgb(0,0,0)"
        },
        skinProperties: {
            A: "true",
            Z: "true",
            H: ["{*}"],
            M: "Skins",
            T: "array",
            C: "Properties for the skin",
            D: ["'skinBackgroundColor'", "'skinBorderColor'", "'skinColor'", "'skinShadowColor'"]
        },
        setMaxY: {
            A: "true",
            H: ['{"graphType":"Scatter2D","setMaxY":200}', '{"graphType":"Scatter2D","setMaxY":50}', '{"graphType":"Scatter2D","setMaxY":null}'],
            M: "Y-Axis",
            T: "float",
            C: "Maximum value to set the data in the Y axis",
            D: "null"
        },
        ungroupSamples: {
            S: ["groupSamples"],
            M: "Functions",
            T: "void",
            C: "Ungroup samples previously grouped according to a sample category (data.x object)",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                Correletion: "true",
                StackedPercentLine: "true",
                Pie: "true",
                Barline: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        legendFontSize: {
            A: "true",
            S: ["autoScaleFont", "legendScaleFontFactor"],
            H: ['{*,"autoScaleFont":false}'],
            M: "Legends",
            T: "integer",
            C: "Font size for the legends. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the legend scaling factor",
            D: "10"
        },
        randomDataSamples: {
            A: "true",
            M: "Random",
            T: "integer",
            C: "Default number of samples when creating random data",
            D: "50"
        },
        shapeByShape: {
            A: "true",
            O: ["false", "sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "mdavid"],
            T: "option",
            H: ["{*}"],
            M: "Data Point Attributes",
            D: "false",
            C: "String that identify the shape to use in regular and multidimensional heatmaps. shapeByData will take precedence over this property.",
            U: {
                Heatmap: "true"
            }
        },
        indicatorHeight: {
            H: ['{*,"graphType":"Heatmap"}'],
            M: "Heatmap Color Schemes",
            T: "integer",
            C: "Length in pixels for the heatmap indicator",
            D: "8"
        },
        marginLeft: {
            H: ["{*}"],
            M: "Margins",
            T: "integer",
            C: "Specifies the length in pixels for the left margin in the canvas.",
            D: "20"
        },
        layoutComb: {
            A: "true",
            H: ["{*}"],
            M: "Combination Plots",
            T: "boolean",
            C: "Flag that identify that multiple graphs will be displayed in the canvas.",
            D: "false"
        },
        broadcast: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to enable broadcasting to other canvasXpress objects in the page",
            D: "true"
        },
        yAxisTitle: {
            H: ['{"graphType":"Scatter2D","yAxisTitle":"Y-axis title"}', '{"graphType":"Correlation","yAxisTitle":"Correlation Title"}'],
            M: "Y-Axis",
            T: "string",
            C: "Title for the Y axis in Scatter plots and in Correlation graphs.",
            D: "false",
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Correlation: "true",
                Scatter2D: "true"
            }
        },
        eventKeys: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to enable key binding events. This prevent some default browser shortcuts and it is system specific. Please see the Event section bellow.",
            D: "true"
        },
        yRotate: {
            A: "true",
            H: ['{"graphType":"Scatter3D","yRotate":0}', '{"graphType":"Scatter3D","yRotate":45}'],
            M: "3D Attributes",
            T: "float",
            C: "Starting number of degrees to rotate graph arround the Y axis",
            D: "0"
        },
        rAxisLabelOrientation: {
            H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":"Ring","segregateSamplesBy":"Segment"}'],
            O: ["perpendicular", "circular"],
            M: "R-Axis",
            T: "option",
            C: "Orientation to show the ticks values in circular plots.",
            D: "perpendicular"
        },
        featureTraceTrim: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Default triming for nucleotide values in the traces (expressed in percent)",
            D: "1"
        },
        smpTitleFont: {
            Z: "true",
            M: "Samples",
            T: "font",
            C: "Font for the sample title in one dimensional plots"
        },
        nextButton: {
            A: "true",
            M: "Images",
            T: "image",
            C: "Relative path to an image file to the next button (not including the image directory)",
            D: "fast_forward.png"
        },
        sequenceCColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the cytosines and cysteins in the genome browser",
            D: "rgb(0,0,255)"
        },
        segregateVariablesBy: {
            H: ['{"data":"Random:3:2:3:0:0:1","segregateVariablesBy":"Annt3","smpLabelRotate":90,"smpLabelScaleFontFactor":0.5}'],
            O: ["false", "string"],
            M: "Data",
            T: "option",
            C: "String to indicate the annotation used to segregate the variables. It must be a category in the 'data.z' object",
            D: "false"
        },
        yAxisMaxStrLength: {
            Z: "true",
            M: "Y-Axis",
            T: "string",
            C: "Longest string of all the values in the ticks in the Y axis"
        },
        showSmpDendrogram: {
            H: ['{*,"data":"Generic","graphType":"Heatmap"}'],
            M: "Dendrograms",
            T: "boolean",
            C: "Flag to show or not the sample dendrogram",
            D: "false"
        },
        showAdvancedConfiguration: {
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to show advanced configuration properties.",
            D: "false"
        },
        disableEvents: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to disable all events.",
            D: "false"
        },
        edgesProperties: {
            M: "Data Table/Filter",
            T: "array",
            C: "Two dimensional array with object properties not at the root level for the edges in the Network graph to include in the Data table and the data filter",
            D: "[]"
        },
        showVarDendrogram: {
            H: ['{*,"data":"Generic","graphType":"Heatmap"}'],
            M: "Dendrograms",
            T: "boolean",
            C: "Flag to show or not the variable dendrogram",
            D: "false"
        },
        freezeColRight: {
            A: "true",
            M: "Data Table",
            T: "integer",
            C: "Number of columns to freeze in the right side of the data table",
            D: "0"
        },
        pieType: {
            H: ["{*}"],
            O: ["separated", "solid"],
            M: "Pie Charts",
            T: "option",
            C: "Position for the pices of the pie",
            D: "separated"
        },
        rAxis: {
            H: ['{"data":"Circular","segregateVariablesBy":"Ring","rAxis":false}', '{"data":"Circular2","rAxis":"Number","segregateVariablesBy":"Ring","segregateSamplesBy":"Segment"}'],
            M: "Circular Graphs",
            T: "string",
            C: "Radial axis for circular plots. It must be the name of a variable",
            D: "false"
        },
        reset: {
            M: "Functions",
            T: "void",
            C: "Reset the canvas"
        },
        remoteDataIndex: {
            A: "true",
            Z: "true",
            M: "Remote Procedures",
            T: "integer",
            C: "Index of the canvasXpress object requested"
        },
        showDecorations: {
            A: "true",
            H: ['{"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
            M: "Decorations",
            T: "boolean",
            C: "Flag to show or not extra decorations like (regression lines, splines, etc) in scatter plots and (heatmaps, pie charts or stacked bar graphs in) network graphs",
            D: "false"
        },
        backgroundVideo: {
            S: ["backgroundType"],
            H: ['{"graphType":"Video","videoAutoplay":true,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Background",
            T: "url",
            C: "An array containing urls for the background video when the background type is of the type 'video'.",
            D: "false"
        },
        approximateNodePositions: {
            A: "true",
            H: ["{*}"],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to force approximate X, Y node positions.",
            D: "false"
        },
        heatmapType: {
            H: ['{*,"graphType":"Heatmap"}'],
            O: ["blue", "blue-green", "blue-red", "blue-yellow", "blue-cyan", "blue-purple", "blue-white", "blue-black", "green", "green-blue", "green-red", "green-yellow", "green-cyan", "green-purple", "green-white", "green-black", "red", "red-blue", "red-green", "red-yellow", "red-cyan", "red-purple", "red-white", "red-black", "yellow", "yellow-green", "yellow-red", "yellow-cyan", "yellow-purple", "yellow-white", "yellow-black", "cyan", "cyan-green", "cyan-red", "cyan-yellow", "cyan-purple", "cyan-white", "cyan-black", "purple", "purple-green", "purple-red", "purple-yellow", "purple-cyan", "purple-white", "purple-black", "white-green", "white-red", "white-yellow", "white-cyan", "white-purple", "white-black", "black-green", "black-red", "black-yellow", "black-cyan", "black-purple", "black-white"],
            M: "Heatmap Color Schemes",
            T: "option",
            C: "Color shades for the heatmap. It could be red, blue, green, yellow, cyan, purple, black, white or any combination of two colors separated by a dash",
            D: "blue-red"
        },
        citationScaleFontFactor: {
            H: ['{*,"citation":"Graph citation or reference"}'],
            M: "Citations or References",
            T: "float",
            C: "Scaling factor used to increase or decrease citation font size in the canvas",
            D: "1"
        },
        zoomVariablesDisable: {
            H: ['{*,"graphType":"Heatmap"}'],
            S: ["zoomSamplesDisable"],
            M: "Zooming and Panning",
            T: "boolean",
            C: "Flag to disable zooming of variables with mouse wheel in Heatmaps",
            D: "false"
        },
        hideInfoDiv: {
            A: "true",
            M: "Functions",
            T: "void",
            C: "Hide additional information"
        },
        smpTitleScaleFontFactor: {
            H: ['{*,"smpTitle":"Sample Title"}'],
            M: "Samples",
            T: "float",
            C: "Scaling factor used to increse or decrease sample title font size in the canvas",
            D: "1"
        },
        xAxisTickStyle: {
            A: "true",
            H: ["{*}"],
            O: ["solid", "dotted"],
            M: "X-Axis",
            T: "option",
            C: "Style for the tick lines in the X axis",
            D: "solid"
        },
        showConfiguratorExamplesOnSelect: {
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to display examples as the configurator property changes",
            D: "false"
        },
        lineWidthEvent: {
            A: "true",
            H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
            M: "Lines",
            T: "integer",
            C: "Size in pixels of the width for the events in the lines.",
            D: "2"
        },
        monitorCanvasXpressZombiesTime: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "integer",
            C: "Time in milliseconds to wait between checking for canvasXpress zombies",
            D: "30000"
        },
        selectDataPoint: {
            Z: "true",
            M: "Scatter Plots",
            T: "array",
            C: "Ids of data points (in the data object) to select.",
            D: "[]"
        },
        subtitle: {
            S: ["subtitleHeight", "subtitleColor"],
            H: ['{"title":"Graph Title","subtitle":"Graph Subtitle"}'],
            M: "Titles and Subtitles",
            T: "string",
            C: "Title of the graph.",
            D: "rgb(0,0,0)"
        },
        animationType: {
            A: "true",
            O: ["grow", "spring", "random"],
            M: "Animation",
            T: "option",
            C: "Type of animation",
            D: "grow"
        },
        circularCenterProportion: {
            H: ['{*,"data":"Circular"}'],
            M: "Circular Graphs",
            T: "float",
            C: "Proportion of the center of the circular graph to use as void",
            D: "0.3"
        },
        showErrorBars: {
            H: ['{"showErrorBars":true,"functions":["groupSamples:Factor1"]}', '{"showErrorBars":false,"functions":["groupSamples:Factor1"]}'],
            M: "Data",
            T: "boolean",
            C: "Flag to indicate whether to show or not error bars in the graphs.",
            D: "true"
        },
        axisTickScaleFontFactor: {
            H: ["{*}"],
            M: "Axis",
            T: "float",
            C: "Scaling factor used to increase or decrease tick font size in the canvas in one and two dimensional plots",
            D: "1"
        },
        colorEdgeBy: {
            H: ['{"data":"LesMiserables","colorEdgeBy":"value"}'],
            M: "Network Graphs",
            T: "string",
            C: "Name of the attribute to color the edges.",
            D: "false"
        },
        margin: {
            H: ["{*}"],
            M: "Margins",
            T: "integer",
            C: "Specifies the length in pixels for the distance between various objects in the graphs.",
            D: "5"
        },
        xAxisMaxStrLength: {
            Z: "true",
            M: "X-Axis",
            T: "string",
            C: "Longest string of all the values in the ticks in the X axis"
        },
        broadcastType: {
            A: "true",
            H: ["{*}"],
            O: ["var", "comb"],
            M: "Events",
            T: "option",
            C: "Model for broadcasting to identify either variables or a combination of variable and samples",
            D: "var"
        },
        segregateSamplesBy: {
            H: ['{"data":"Random:2:3:0:3:0:1","segregateSamplesBy":"Factor3","smpLabelRotate":90,"smpLabelScaleFontFactor":0.5}'],
            O: ["false", "string"],
            M: "Data",
            T: "option",
            C: "String to indicate the annotation used to segregate the samples. It must be a category in the 'data.x' object",
            D: "false"
        },
        print: {
            M: "Functions",
            T: "void",
            C: "Print the canvas"
        },
        backgroundType: {
            H: ['{*,"backgroundImage":"http://www.canvasxpress.org/images/nanotube.jpg","skipExample":["video"]}'],
            S: ["backgroundImage", "gradientOrientation", "backgroundGradient1Color", "backgroundGradient2Color"],
            O: ["solid", "gradient", "window", "windowGradient", "windowGradient2", "windowSolidGradient", "image", "windowImage", "video"],
            M: "Background",
            T: "option",
            C: "Specifies the style for the background of the canvas. The canvas background is composed of a frame with a window where the data is plotted. Either of these elements the may be a solid or gradient color or an image or a video of your choosing.",
            D: "solid"
        },
        maxSmpStringLen: {
            H: ['{"maxSmpStringLen":50}', '{"maxSmpStringLen":5}'],
            M: "Samples",
            T: "integer",
            C: "Maximum length in characters a sample label or description can have so anything above is truncated.",
            D: "50"
        },
        showAnimationFontSize: {
            A: "true",
            M: "Animation",
            T: "integer",
            C: "Size in pixels for the font size of text involved in the animation",
            D: "10"
        },
        axisExtension: {
            A: "true",
            H: ['{"graphType":"Scatter2D","axisExtension":0.1}', '{"graphType":"Scatter2D","axisExtension":0.2}'],
            M: "Axis",
            T: "float",
            C: "Percentage to extend the values in the data",
            D: "0.1"
        },
        sequenceMColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the degenerate A/G and methionines in the genome browser",
            D: "rgb(0,103,0)"
        },
        randomDataVariableAnnotations: {
            A: "true",
            H: ["{*}"],
            M: "Random",
            T: "integer",
            C: "Default number of variable annotations when creating random data",
            D: "2"
        },
        featureTranslateHeight: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Default size in pixels of the translation height",
            D: "12"
        },
        subNetworks: {
            A: "true",
            Z: "true",
            M: "Network Graphs",
            T: "array",
            C: "Array to keep independent networks"
        },
        legendFontStyle: {
            A: "true",
            H: ["{*}"],
            O: ["", "bold", "italic", "bold italic"],
            M: "Legends",
            T: "option",
            C: "Font style for the legend. @default"
        },
        showInfoDiv: {
            A: "true",
            M: "Functions",
            T: "void",
            C: "Show additional information"
        },
        sampleSeparationFactor: {
            S: ["widthFactor", "variableSeparationFactor"],
            H: ["{*}"],
            M: "Space and Width",
            T: "integer",
            C: "Factor to adjust the spacing between the sample blocks in the one dimensional graphs. The default is 1. If you  want to make the blocks wider apart then increase this parameter (2 is twice as much).",
            D: "1"
        },
        yAxisAbsMin: {
            Z: "true",
            M: "Y-Axis",
            T: "float",
            C: "Minimum non-filtered value for the data plotted in the Y axis"
        },
        blockContrast: {
            S: ["evenColor", "oddColor"],
            H: ['{*,"graphType":"Bar"}'],
            M: "Plot area",
            T: "boolean",
            C: "A flag to creates a shade between the samples so there are two backgrounds, one for the odd samples and one for the even samples.",
            D: "false"
        },
        featureSignalToNoiseHeight: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Default size in pixels of the quality height",
            D: "12"
        },
        xAxisExact: {
            A: "true",
            H: ["{*}"],
            M: "X-Axis",
            T: "boolean",
            C: "Flag to force exact values for the data in the X axis",
            D: "false"
        },
        videoData: {
            H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Videos",
            T: "object",
            C: "Data for videos",
            D: "{}"
        },
        resizeHeightOnLayout: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to enable resizing the height of the canvas after changing the layout",
            D: "false"
        },
        legendBox: {
            S: ["legendBoxColor", "legendBackgroundColor"],
            H: ["{*}"],
            M: "Legends",
            T: "boolean",
            C: "Flag to create a box around the legend",
            D: "true"
        },
        showDataTable: {
            A: "true",
            M: "Data Table",
            T: "boolean",
            C: "Flag to indicate to show the data table",
            D: "false"
        },
        remoteService: {
            A: "true",
            M: "Remote Procedures",
            T: "url",
            C: "Url used to obtain data remotely. It expects and array of canvasXpress objects",
            D: "false"
        },
        randomDataVariables: {
            A: "true",
            M: "Random",
            T: "integer",
            C: "Default number of variables when creating random data",
            D: "50"
        },
        gradientRatio: {
            A: "true",
            S: ["gradientType"],
            H: ['{*,"data":"Random:1:3:0:0","gradient":true,"gradientType":"linear"}'],
            M: "Gradients",
            T: "float",
            C: "Specifies the ratio used to generate linear gradients.",
            D: "1.3"
        },
        decorationFont: {
            Z: "true",
            M: "Decorations",
            T: "font",
            C: "Font for the decoration in scatter plots and network graphs"
        },
        playButton: {
            A: "true",
            M: "Images",
            T: "image",
            C: "Relative path to an image file to the play button (not including the image directory)",
            D: "play.png"
        },
        sequenceRColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the degenerate A/G and arginines in the genome browser",
            D: "rgb(255,0,0)"
        },
        varOverlayRecycleColors: {
            H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
            M: "Overlays",
            T: "boolean",
            C: "Flag to indicate to recycle variable overlay colors with each overlay",
            D: "false"
        },
        zAxisShow: {
            H: ['{*,"graphType":"Scatter3D"}'],
            M: "Z-Axis",
            T: "boolean",
            C: "Flag to show on not the values of the ticks in the Z axis",
            D: "true"
        },
        sequenceNColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the degenerate A/C/G/T and asparagines in the genome browser",
            D: "rgb(0,0,0)"
        },
        smpOverlays: {
            H: ['{"data":"Random:10:10:0:3","smpOverlays":["Factor1","Factor2","Factor3"]}'],
            M: "Overlays",
            T: "array",
            C: "Sample annotations included in the 'data.x' object used in one dimensional plots",
            D: "[]",
            X: "getXData"
        },
        translateY: {
            A: "true",
            Z: "true",
            M: "Combination Plots",
            T: "float",
            C: "Amount to translate for the Y axis."
        },
        axisTitleFontSize: {
            A: "true",
            S: ["autoScaleFont", "axisTitleScaleFontFactor"],
            H: ['{*,"autoScaleFont":false}'],
            M: "Axis",
            T: "integer",
            C: "Font size for the axis titles in one and two dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the axis title scaling factor",
            D: "10"
        },
        shapeByData: {
            A: "true",
            S: ["shapeBy"],
            T: "string",
            H: ['{"data":"MultidimensionalHeatmap","shapeByData":"data4","shapeBy":"Data Shape"}'],
            M: "Data Point Attributes",
            D: "false",
            C: "String that identify the object containing a two dimensional array with values used to shape data points when drawing a multidimensional Heatmap. It must be located within the data.y object (for example: data.y.data2)",
            U: {
                Heatmap: "true"
            }
        },
        draw: {
            M: "Functions",
            T: "void",
            C: "Redraw the canvas"
        },
        featureNameFontSize: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Size in pixels for the font size of text of the features in the genome browser",
            D: "8"
        },
        sequenceFColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the phenylalanines in the genome browser",
            D: "rgb(0,0,255)"
        },
        xAxisTickFormat: {
            A: "true",
            H: ['{"xAxisTickFormat":"%.2f cxs","graphOrientation":"vertical"}'],
            M: "X-Axis",
            T: "string",
            C: "Format for the tick values in the X axis",
            D: "false"
        },
        resizerDataIndex: {
            Z: "true",
            A: "true",
            M: "Axis Resizer",
            T: "integer",
            C: "Object to store data when the canvas is zoomed with the axis resizer resizerEventData @type {object}",
            D: "0"
        },
        addRegressionLine: {
            M: "Functions",
            T: "void",
            C: "Add regression line(s) to a 2D-Scatter plot",
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        nodeSize: {
            H: ["{*}"],
            M: "Network Graphs",
            T: "integer",
            C: "Length in pixels for the size of the nodes in the network",
            D: "10 | 20"
        },
        maxRows: {
            A: "true",
            M: "Data Table",
            T: "integer",
            C: "Maximum number of rows to display in the data table",
            D: "10"
        },
        yAxisShow: {
            H: ['{*,"graphType":"Scatter2D"}'],
            M: "Y-Axis",
            T: "boolean",
            C: "Flag to show on not the values of the ticks in the Y axis",
            D: "true",
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Correlation: "true",
                Scatter2D: "true"
            }
        },
        destroyCanvasXpressZombies: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to destroy canvasXpress objects stored in the references array when they are no longer part of the DOM. This may happen when canvasXpress is used in other JS frameworks and the objects are not destroyed by the developer",
            D: "true"
        },
        axisTickFont: {
            Z: "true",
            M: "Axis",
            T: "font",
            C: "Font for the axis ticks in one and two dimensional plots"
        },
        baseline: {
            A: "true",
            H: ['{*,"title":"Graph Title"}'],
            O: ["top", "middle", "bottom"],
            M: "Text",
            T: "option",
            C: "Default vertical alignment for drawing text.",
            D: "middle"
        },
        setMinX2: {
            A: "true",
            H: ['{"graphType":"BarLine","setMinX2":50}', '{"graphType":"BarLine","setMinX2":20}', '{"graphType":"BarLine","setMinX2":null}'],
            M: "X-Axis2",
            T: "float",
            C: "Minimum value to set the data in the 2nd axis",
            D: "null",
            U: {
                StackedLine: "true",
                StackedPercentLine: "true",
                BarLine: "true",
                AreaLine: "true"
            }
        },
        ringSeparation: {
            H: ['{*,"data":"Circular","segregateVariablesBy":"Ring"}'],
            M: "Circular Graphs",
            T: "integer",
            C: "Number of pixels to separate the rings in the circular plots",
            D: "9"
        },
        smpDendrogramPosition: {
            H: ['{*,"data":"Generic","graphType":"Heatmap","showSmpDendrogram":true}'],
            O: ["right", "left"],
            M: "Dendrograms",
            T: "option",
            C: "Position for the sample dendrogram in the plot. It could be top, bottom, right or left depending on the orientation of the graph.",
            D: "left"
        },
        is3DPlot: {
            H: ['{*,"graphType":"Bar"}'],
            M: "Plot area",
            T: "boolean",
            C: "Flag to create or not a 3D plot",
            D: "false"
        },
        isLayoutConfigurator: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to disable showing the configurator when there is a click in the full layout icon in the toolbar",
            D: "false"
        },
        removeHistogram: {
            M: "Functions",
            T: "void",
            C: "Remove histogram from a 2D-Scatter plot",
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        disableDataFilters: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to disable showing data filters",
            D: "false"
        },
        createRandomData: {
            M: "Functions",
            T: "void",
            C: "Create a random data set"
        },
        yAxisMinorTicks: {
            A: "true",
            H: ['{*,"graphType":"Scatter2D"}'],
            M: "Y-Axis",
            T: "boolean",
            C: "A flag to show minor tick lines in the Y axis",
            D: "true"
        },
        helpKeyEvents: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to enable help on key events.",
            D: "true"
        },
        remoteUpdate: {
            A: "true",
            M: "Remote Procedures",
            T: "boolean",
            C: "Flag to indicate that the file to get the data needs to be updated",
            D: "false"
        },
        shadowOffsetY: {
            A: "true",
            S: ["showShadow"],
            H: ['{*,"showShadow":true}'],
            M: "Shadows",
            T: "integer",
            C: "Length in pixels for the shadow offset in the Y axis.",
            D: "1"
        },
        variableSeparationFactor: {
            S: ["sampleSeparationFactor", "widthFactor"],
            H: ["{*}"],
            M: "Space and Width",
            T: "float",
            C: "Factor to adjust the spacing between the variables in the one dimensional plots.",
            D: "2"
        },
        citationFontStyle: {
            A: "true",
            H: ['{*,"citation":"Graph citation or reference"}'],
            O: ["", "bold", "italic", "bold italic"],
            M: "Citations or References",
            T: "option",
            C: "Font style for the citation. @default"
        },
        varSort: {
            Z: "true",
            M: "Data",
            T: "integer",
            C: "Variable index used in sorting the data."
        },
        yAxisTicks: {
            A: "true",
            H: ['{*,"graphType":"Scatter2D"}'],
            M: "Y-Axis",
            T: "integer",
            C: "Number of ticks in the Y axis",
            D: "5"
        },
        decorations: {
            A: "true",
            S: ["showDecorations"],
            T: "array",
            H: ['{"data":"NetworkDecorations","graphType":"Network","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}', '{"showDecorations":true,"graphType":"Scatter2D","data":"NonLinearFit","xAxisTransform":"log10","xAxisTransformTicks":false,"setMaxY":350,"setMinY":100,"yAxisExact":true}', '{"showDecorations":true,"graphType":"Scatter2D","data":"DecorationLine"}', '{"showDecorations":true,"graphType":"Bar","data":"DecorationLines","graphOrientation":"vertical"}', '{"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}', '{"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addRegressionLine","draw"]}', '{"showDecorations":true,"showLegend":false,"graphType":"Scatter2D","data":"DecorationArea"}', '{"showDecorations":true,"graphType":"Scatter2D","data":"KaplanMeyer","showLegend":false,"title":"Kaplan-Meyer Plot","functions":["addKaplanMeyerCurve:Time:Censored-1:Data 1 Population:rgb(0,0,255)","addKaplanMeyerCurve:Time:Censored-2:Data 2 Population:rgb(255,0,0)","draw"]}'],
            M: "Decorations",
            D: "[]",
            C: "Name of the node properties to include in the network decorations in the 'data.nodes' object",
            U: {
                Network: "true",
                Scatter2D: "true"
            }
        },
        sequenceFontStyle: {
            A: "true",
            H: ["{*}"],
            O: ["", "bold", "italic", "bold italic"],
            M: "Genome Browser",
            T: "option",
            C: "Font style for the sequences. @default"
        },
        acknowledgmentIconPosition: {
            H: ['{*,"acknowledgment":true}'],
            S: ["acknowledgment", "acknowledgmentIcon"],
            O: ["inside", "outside"],
            M: "Acknowledgment",
            T: "option",
            C: "Specifies the acknowledgment canvasXpress icon position",
            D: "inside"
        },
        showCode: {
            A: "true",
            M: "Debug",
            T: "boolean",
            C: "Flag to show code for the canvas.",
            D: "false"
        },
        autoHideOnDecorationsCenter: {
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to hide node when decorations are positioned on the center",
            D: "false"
        },
        colors: {
            S: ["colorScheme"],
            H: ['{"data":"Random:16:1:0:0:1","graphType":"Pie"}'],
            M: "Colors",
            T: "array",
            C: "Colors.",
            D: "colors"
        },
        showSampleNames: {
            H: ["{*}"],
            M: "Samples",
            T: "boolean",
            C: "Flag to show the sample names in one dimensional plots.",
            D: "true"
        },
        panningX: {
            A: "true",
            M: "Zooming and Panning",
            T: "float",
            C: "Number of unit to pan the network in the X dimension",
            D: "0"
        },
        saveRemoteParameters: {
            M: "Functions",
            T: "void",
            C: "Save the current parameters for a remote data set."
        },
        yAxisCurrent: {
            A: "true",
            H: ['{"yAxis":["Sample1","Sample2"],"xAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","yAxisCurrent":0}', '{"yAxis":["Sample1","Sample2"],"xAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","yAxisCurrent":1}'],
            M: "Y-Axis",
            T: "integer",
            C: "Index (zero-based) of the sample that is currently displayed in the Y axis when there are more series in the X axis than in the Y axis in an Scarrter2D plot or when there are multiple series in an ScatterBubble2D plot. Use ctrl + arrow keys to cycle through data series.",
            D: "0",
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        citationFontSize: {
            H: ['{*,"citation":"Graph citation or reference"}'],
            M: "Citations or References",
            T: "integer",
            C: "Size for the text of the reference citation of the graph",
            D: "6"
        },
        shadowColor: {
            A: "true",
            S: ["showShadow"],
            H: ['{*,"showShadow":true}'],
            M: "Shadows",
            T: "color",
            C: "Color for the shadow.",
            D: "rgba(0,0,0,0.5)"
        },
        xAxis2Show: {
            H: ["{*}"],
            M: "X-Axis2",
            T: "boolean",
            C: "Flag to show on not the values of the ticks in the second X axis",
            D: "true"
        },
        showCodeDiv: {
            A: "true",
            M: "Functions",
            T: "void",
            C: "Show the code for the plot"
        },
        dendrogramSpace: {
            H: ['{*,"data":"Generic","graphType":"Bar","showSmpDendrogram":true}'],
            M: "Dendrograms",
            T: "integer",
            C: "Length in pixels to space the branches in the dendrograms.",
            D: "6"
        },
        addNormalDistributionLine: {
            M: "Functions",
            T: "void",
            C: "Add a normaldistribution line(s) to a 2D-Scatter plot",
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        kmeansSamples: {
            S: ["kmeansClusters", "maxIterations"],
            M: "Functions",
            T: "void",
            C: "Cluster samples using kmeans",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                StackedLine: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        eventArrowKeys: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to enable arrow key binding events.",
            D: "true"
        },
        maxTextSize: {
            A: "true",
            H: ['{*,"title":"Graph Title"}'],
            M: "Text",
            T: "integer",
            C: "Maximum size for any text in the canvas.",
            D: "14"
        },
        xAxisTitle: {
            H: ['{"xAxisTitle":"X-axis title"}'],
            M: "X-Axis",
            T: "string",
            C: "Title for the X axis",
            D: "false"
        },
        functionIntervals: {
            A: "true",
            H: ['{*,"data":"Function"}'],
            M: "Scatter Plots",
            T: "integer",
            C: "Number of intervals to use when drawing functions in the decorations. In Scatter 3D is more like a factor",
            D: "25"
        },
        gradient: {
            A: "true",
            S: ["gradientType"],
            H: ['{*,"data":"Random:1:3:0:0"}'],
            M: "Gradients",
            T: "boolean",
            C: "Flag used to apply gradients to all objects in the graphs.",
            D: "false"
        },
        genomeResolution: {
            A: "true",
            Z: "true",
            O: ["low", "medium", "high"],
            M: "Genome Browser",
            T: "option",
            C: "Number to adjust the splines curvature"
        },
        maxCols: {
            A: "true",
            M: "Data Table",
            T: "integer",
            C: "Maximum number of columns to display in the data table",
            D: "8"
        },
        rAxisAbsMax: {
            Z: "true",
            M: "R-Axis",
            T: "float",
            C: "Maximum non-filtered value for the data plotted in the R axis"
        },
        sma5Color: {
            H: ['{*,"stockIndicators":["Sma5"]}'],
            M: "Candlestick Plots",
            T: "color",
            C: "The color for the 5 day single moving average",
            D: "rgb(255,0,0)"
        },
        nodeFont: {
            A: "true",
            Z: "true",
            M: "Network Graphs",
            T: "font",
            C: "Font for the text in networks"
        },
        x3DRatio: {
            A: "true",
            H: ['{"graphType":"Scatter3D","x3DRatio":0.5}', '{"graphType":"Scatter3D","x3DRatio":1}'],
            M: "3D Attributes",
            T: "float",
            C: "Value between 0 - 1 for adjusting the 3D of the X Axis",
            D: "1",
            U: {
                Scatter3D: "true",
                Bar: "true"
            }
        },
        sequenceGAPColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the deletions, insertions and gaps  in the genome browser",
            D: "rgb(255,0,255)"
        },
        smpTitleFontStyle: {
            A: "true",
            H: ['{*,"smpTitle":"Sample Title"}'],
            O: ["", "bold", "italic", "bold italic"],
            M: "Samples",
            T: "option",
            C: "Font style for the samples. @default"
        },
        maintainZoomOnDrag: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to enable maintaining zooming after initial drag in one dimensional plots",
            D: "false"
        },
        disableConfigurator: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to disable configurator.",
            D: "false"
        },
        sequenceIColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the isoleucines in the genome browser",
            D: "rgb(0,103,0)"
        },
        colorHSV: {
            Z: "true",
            M: "Colors",
            T: "array",
            C: "Color HSV. Hue, Saturation and Value used in the configurator"
        },
        smpTitle: {
            H: ['{"smpTitle":"Sample Title"}'],
            M: "Samples",
            T: "string",
            C: "Title for the sample axis in one dimensional plots",
            D: "false"
        },
        correlationAnchorLegendAlignWidth: {
            A: "true",
            H: ['{*,"correlationAnchorLegend":true}'],
            M: "Correlation Graphs",
            T: "integer",
            C: "Length in pixels of the height of the correlation anchor legend",
            D: "40"
        },
        axisTitleFontStyle: {
            A: "true",
            H: ["{*}"],
            O: ["", "bold", "italic", "bold italic"],
            M: "Axis",
            T: "option",
            C: "Font style for the axis titles. @default"
        },
        shapeEdgeBy: {
            H: ['{"data":"LesMiserables","shapeEdgeBy":"value"}'],
            M: "Network Graphs",
            T: "string",
            C: "Name of the attribute to shape the nods.",
            D: "false"
        },
        featureNameFontStyle: {
            A: "true",
            H: ["{*}"],
            O: ["", "bold", "italic", "bold italic"],
            M: "Genome Browser",
            T: "option",
            C: "Font style for the feature name. @default"
        },
        scatterPlotMatrixType: {
            H: ['{*,"graphType":"Scatter2D","scatterPlotMatrix":true}'],
            S: ["scatterPlotMatrix"],
            O: ["both", "upper", "lower"],
            M: "Scatter Plot Matrix",
            T: "option",
            C: "Type for the n-1 x n-1 matrix of 2D sccaterplots",
            D: "both"
        },
        xAxis2MaxStrLength: {
            A: "true",
            Z: "true",
            M: "X-Axis2",
            T: "string",
            C: "Longest string of all the values in the ticks in the 2nd X axis"
        },
        randomNetworkNodes: {
            A: "true",
            M: "Random",
            T: "integer",
            C: "Default number of nodes when creating random networks",
            D: "50",
            U: {
                Network: "true"
            }
        },
        show3DGrid: {
            A: "true",
            H: ["{*}"],
            M: "3D Attributes",
            T: "boolean",
            C: "Flag to show the X,Y,Z grid in scatter 3D plots",
            D: "true",
            U: {
                Scatter3D: "true"
            }
        },
        codeType: {
            A: "true",
            O: ["pretty", "compact", "tab", "params"],
            M: "Debug",
            T: "option",
            C: "Output type for the JSON code",
            D: "params"
        },
        xAxis2MinorValues: {
            A: "true",
            M: "X-Axis2",
            T: "array",
            C: "Values for the minor ticks in the 2nd X axis",
            D: "[]",
            U: {
                StackedLine: "true",
                StackedPercentLine: "true",
                BarLine: "true",
                AreaLine: "true"
            }
        },
        fontName: {
            A: "true",
            H: ["{*}"],
            O: ["Courier", "Arial", "Verdana"],
            M: "Text",
            T: "option",
            C: "Font name. It will be set depending on the browser.",
            D: "Verdana"
        },
        smpLabelInterval: {
            A: "true",
            H: ["{*}"],
            M: "Samples",
            T: "integer",
            C: "Interval for the sample labels in one dimensional plots",
            D: "1"
        },
        dataTableColumnWidth: {
            Z: "true",
            M: "Data Table",
            T: "array",
            C: "Initialize configurations"
        },
        highlightSmp: {
            H: ['{"highlightSmp":["Sample1","Sample3"]}'],
            M: "Samples",
            T: "array",
            C: "Name of samples in the 'data.y' object to highlight.",
            D: "[]",
            X: "getSamplesAsArray"
        },
        decorationsHeight: {
            A: "true",
            H: ['{*,"data":"NetworkDecorations","decorationsPosition":"left","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}'],
            M: "Decorations",
            T: "integer",
            C: "Length in pixels of the height for the decorations in the networks",
            D: "20",
            U: {
                Network: "true"
            }
        },
        smpLabelFontColor: {
            H: ["{*}"],
            M: "Samples",
            T: "color",
            C: "Font color for the sample labels in one dimensional plots",
            D: "foreground color"
        },
        sequenceBColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the degenerate C/G/T and asparagines in the genome browser",
            D: "rgb(0,0,0)"
        },
        segregateVariables: {
            S: ["segregateVariables"],
            M: "Functions",
            T: "option",
            C: "Segregate variables based on a variable category (data.z object)",
            X: "getZData",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                Correletion: "true",
                StackedPercentLine: "true",
                Pie: "true",
                Barline: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        coordinateLineColor: {
            H: ['{*,"graphType":"BarLine"}'],
            M: "Line Graphs",
            T: "boolean",
            C: "Flag to used same color in BarLine plots. If set to true the color of the bars and the lines will be the same",
            D: "false"
        },
        adjustAspectRatioMax: {
            A: "true",
            M: "Aspect Ratio",
            T: "integer",
            C: "Specifies the number of times to try to automatically adjust the size of the canvas when adjustAspectRatio is true",
            D: "3"
        },
        widthFactor: {
            S: ["sampleSeparationFactor", "variableSeparationFactor"],
            H: ["{*}"],
            M: "Space and Width",
            T: "integer",
            C: "Factor to adjust the width of the sample blocks in the one dimensional graphs. The default is 1. If you want to make the blocks wider then increase this parameter (2 is twice as wide).",
            D: "1"
        },
        dendrogramColor: {
            H: ['{*,"data":"Generic","graphType":"Bar","showSmpDendrogram":true}'],
            M: "Dendrograms",
            T: "color",
            C: "The color for the dendrograms",
            D: "rgb(204,204,204)"
        },
        sequenceQColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the glutamines in the genome browser",
            D: "rgb(0,0,0)"
        },
        layoutAxis: {
            A: "true",
            Z: "true",
            O: ["1", "2", "3"],
            M: "Combination Plots",
            T: "option",
            C: "Flag to indicated whether to print axes values when multiple graphs are displayed in the canvas. The possible values are: 1: horizontal, 2: vertical, 3: both"
        },
        adjustAspectRatioXTries: {
            Z: "true",
            M: "Aspect Ratio",
            T: "integer",
            C: "Counter set when trying to automatically adjust the horizontal size of the canvas when adjustAspectRatio is true"
        },
        smpIndicesStart: {
            Z: "true",
            M: "Heatmap Graphs",
            T: "integer",
            C: "Number that indicates starting point for samples in heatmaps when the canvas is zoom in."
        },
        xAxisCurrent: {
            A: "true",
            H: ['{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","xAxisCurrent":0}', '{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","xAxisCurrent":1}'],
            M: "X-Axis",
            T: "integer",
            C: "Index (zero-based) of the sample that is currently displayed in the X axis when there are more series in the Y axis than in the X axis in an Scarrter2D plot or when there are multiple series in an ScatterBubble2D plot. Use ctrl + arrow keys to cycle through data series.",
            D: "0",
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        zAxisCurrent: {
            A: "true",
            H: ['{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"ScatterBubble2D","yAxisCurrent":0}', '{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"ScatterBubble2D","yAxisCurrent":1}'],
            M: "Z-Axis",
            T: "integer",
            C: "Index (zero-based) of the sample that is currently displayed in the Z axis when there are multiple series in an ScatterBubble2D plot. Use ctrl + arrow keys to cycle through data series.",
            D: "0",
            U: {
                ScatterBubble2D: "true"
            }
        },
        nodeScaleFontFactor: {
            H: ["{*}"],
            M: "Network Graphs",
            T: "float",
            C: "Scaling factor used to increse or decrease network text font size in the canvas.",
            D: "1"
        },
        evenColor: {
            S: ["blockContrast", "oddColor"],
            H: ['{*,"data":"Random:1:6:0:0","blockContrast":true}'],
            M: "Colors",
            T: "color",
            C: "The color for the even numbers in samples when the property block contrast is set in one dimensional plots or the color for odd number residues in translations in genome plots.",
            D: "rgb(240,240,240)"
        },
        backgroundWindowGradient2Color: {
            A: "true",
            S: ["backgroundType"],
            H: ['{*,"backgroundType":"windowSolidGradient"}'],
            M: "Background",
            T: "color",
            C: "Specifies the second color of the gradient if the background type is of the type of 'windowGradient'.",
            D: "rgb(0,0,36)"
        },
        showLevelOverlays: {
            H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
            M: "Overlays",
            T: "boolean",
            C: "Flag to indicate to show or not the level overlays in one dimensional plots",
            D: "true"
        },
        startPieSectors: {
            H: ['{"startPieSectors":0}', '{"startPieSectors":90}', '{"startPieSectors":180}', '{"startPieSectors":270}'],
            M: "Pie Charts",
            T: "float",
            C: "Starting degrees for pie sectors. 0 is equivalent to 3:00 oclock",
            D: "0"
        },
        legendBoxColor: {
            S: ["legendBox"],
            H: ["{*}"],
            M: "Legends",
            T: "color",
            C: "Color for the box around the legend",
            D: "rgb(0,0,0)"
        },
        rotationSensitivity: {
            A: "true",
            M: "3D Attributes",
            T: "integer",
            C: "Factor to adjust the sensitivity of the mouse when rotating the  graph",
            D: "45"
        },
        selectDataMode: {
            H: ['{*,"graphType":"Scatter2D"}'],
            O: ["area", "name"],
            M: "Scatter Plots",
            T: "option",
            C: "Type of mode to highlight selected data points with mouse events. (Shift + mouse drag) @see{selectDataModeDescription}",
            D: "area"
        },
        font: {
            Z: "true",
            M: "Text",
            T: "font",
            C: "The combination of font name style and size.",
            D: "Verdana 12pt"
        },
        skipClick: {
            A: "true",
            Z: "true",
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to skip click events after a mouse down event in the networks when the eventModel is global"
        },
        trackNameFontColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the text of the tracks in the genome browser",
            D: "background color"
        },
        scaleTextConstantMult: {
            Z: "true",
            M: "Text",
            T: "integer",
            C: "Constants to autoscale text",
            D: "40"
        },
        varLabelDescription: {
            H: ['{"data":"Random:16:3:3:0","varLabelDescription":"Annt3"}'],
            M: "Variables",
            T: "string",
            C: "Variable label description is a valid sample classification included in the 'data.z' object used in heatmaps",
            D: "false",
            U: {
                Heatmap: "true"
            }
        },
        images: {
            A: "true",
            S: ["scatterType"],
            H: ['{"data":"Random:6:3:0:0","graphType":"Scatter2D","scatterType":"image","images":["met.png", "prot9.png", "prot8.png", "prot7.png", "prot6.png", "prot5.png"]}'],
            M: "General Attributes",
            T: "array",
            C: "Array of urls of images used in scatter plots.",
            D: "[]"
        },
        linkage: {
            H: ['{"graphType":"Heatmap","linkage":"single","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","linkage":"complete","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","linkage":"average","functions":["clusterSamples","clusterVariables"]}'],
            S: ["distance", "clusterAxis", "imputeMethod", "centerData", "clusterSamples", "clusterVariables"],
            O: ["single", "complete", "average"],
            M: "Clustering",
            T: "option",
            C: "Linkage type to use when clustering data.",
            D: "single"
        },
        adjustAspectRatio: {
            A: "true",
            S: ["variableSeparationFactor", "sampleSeparationFactor", "widthFactor"],
            H: ['{*,"graphOrientation":"vertical"}'],
            M: "Aspect Ratio",
            T: "boolean",
            C: "Flag to automatically adjust the size of the bars or points in the one dimensional plots to fit in the provided canvas width and height. If the flag is set to 'false' the width and height of the canvas will be sized according to the number of bars or points in the data set.",
            D: "true"
        },
        sequenceStartColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the start codon in the genome browser",
            D: "rgb(0,255,0)"
        },
        smpLabelDescription: {
            H: ['{"data":"Random:16:3:0:3","smpLabelDescription":"Factor3"}'],
            M: "Samples",
            T: "string",
            C: "Sample label description is a valid sample classification included in the 'data.x' object used in heatmaps",
            D: "false",
            U: {
                Heatmap: "true"
            }
        },
        backgroundGradient1Color: {
            S: ["backgroundType", "backgroundGradient2Color"],
            H: ['{*,"backgroundType":"gradient"}'],
            M: "Background",
            T: "color",
            C: "Specifies the first color of the gradient if the background type is of the type of 'gradient'.",
            D: "rgb(0,0,200)"
        },
        smpLabelFont: {
            A: "true",
            Z: "true",
            M: "Samples",
            T: "font",
            C: "Font for the sample labels in one dimensional plots"
        },
        timeValueIndices: {
            A: "true",
            M: "X-Axis",
            T: "array",
            C: "Array containing the indices of the values when the the graph is a time series",
            D: "[]"
        },
        legendColor: {
            H: ["{*}"],
            M: "Legends",
            T: "color",
            C: "Color for the legends",
            D: "foreground color"
        },
        layoutAdjust: {
            A: "true",
            H: ["{*}"],
            M: "Combination Plots",
            T: "boolean",
            C: "Flag to force recalculating the ranges in the axes when multiple graphs are displayed in the canvas.",
            D: "false"
        },
        featureNameFontColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the text of the features in the genome browser",
            D: "background color"
        },
        isSelectNodes: {
            Z: "true",
            M: "Network Graphs",
            T: "integer",
            C: "Number of selected nodes (in the data object).",
            D: "0"
        },
        varHighlightColor: {
            H: ['{*,"highlightVar":["Variable1","Variable3"]}'],
            M: "Variables",
            T: "color",
            C: "The color for the highlighted variables.",
            D: "rgb(255,0,0)",
            U: {
                Heatmap: "true"
            }
        },
        startRow: {
            A: "true",
            Z: "true",
            M: "Data Table",
            T: "integer",
            C: "Starting row in the data table"
        },
        remoteAutoPlayDelay: {
            A: "true",
            M: "Remote Procedures",
            T: "integer",
            C: "Time in milliseconds to wait between iterations over remote data sets",
            D: "3000"
        },
        kmeansClusters: {
            H: ['{"graphType":"Heatmap","kmeansClusters":2,"functions":["kmeansSamples","kmeansVariables"]}', '{"graphType":"Heatmap","kmeansClusters":4,"functions":["kmeansSamples","kmeansVariables"]}'],
            S: ["maxIterations", "kmeansSamples", "kmeansVariables"],
            M: "Clustering",
            T: "integer",
            C: "Number of clusters when clustering data with kmeans.",
            D: "3"
        },
        lines: {
            Z: "true",
            H: ['{"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
            O: ["", "dashed", "dotted", "bezierY", "bezierX", "curved + arrow", "arrowHead", "arrowTail", "arrowHeadSquareTail", "arrowTailSquareHead", "square", "squareHead", "squareTail", "squareHeadArrowTail", "squareTailArrowHead"],
            M: "Lines",
            T: "array",
            C: "Line types available network graphs The patterns can be: '', 'dashed', 'dotted', 'bezierY', 'bezierX' and 'curved'. The end could be: 'arrow', 'arrowHead', 'arrowTail', 'arrowHeadSquareTail', 'arrowTailSquareHead', 'square', 'squareHead', 'squareTail', 'squareHeadArrowTail' or 'squareTailArrowHead'."
        },
        varTitleScaleFontFactor: {
            H: ['{*,"varTitle":"Variable Title"}'],
            M: "Variables",
            T: "float",
            C: "Scaling factor used to increse or decrease variable font size in the canvas.",
            D: "1",
            U: {
                Heatmap: "true"
            }
        },
        sequenceHColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the degenerate A/C/T and histidines in the genome browser",
            D: "rgb(255,0,0)"
        },
        showPieGrid: {
            H: ['{*,"data":"Generic","xAxis":["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6"],"layout":"2X3"}'],
            M: "Pie Charts",
            T: "boolean",
            C: "A flag to show the labels for the grid when plotting multiple pies",
            D: "true"
        },
        timeFormat: {
            A: "true",
            O: ["default", "shortDate", "mediumDate", "longDate", "fullDate", "shortTime", "mediumTime", "longTime", "isoDate", "isoTime", "isoDateTime", "isoUtcDateTime"],
            M: "General Attributes",
            T: "option",
            C: "Time Format according to date.format.js Steven Levithan <stevenlevithan.com>",
            D: "isoDate"
        },
        networkStackStates: {
            A: "true",
            H: ["{*}"],
            M: "Network Graphs",
            T: "integer",
            C: "Number of states to keep in the network stack after a drag or move",
            D: "8"
        },
        sequenceEColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the glutamic acids in the genome browser",
            D: "rgb(0,0,0)"
        },
        hideCodeDiv: {
            A: "true",
            M: "Functions",
            T: "void",
            C: "Hide the code for the plot"
        },
        trackNameFontSize: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Size in pixels for the font size of text of the tracks in the genome browser",
            D: "10"
        },
        sequenceEndColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the end codon in the genome browser",
            D: "rgb(255,0,0)"
        },
        subtitleColor: {
            S: ["subtitle", "subtitleHeight"],
            H: ['{*,"title":"Graph Title","subtitle":"Graph Subtitle"}'],
            M: "Titles and Subtitles",
            T: "color",
            C: "Color for the subtitle",
            D: "rgb(0,0,0)"
        },
        dropdownButton: {
            A: "true",
            H: ["{*}"],
            M: "Images",
            T: "image",
            C: "Relative path to an image file to the drop down button (not including the image directory)",
            D: "menu_dropdown.png"
        },
        legendFont: {
            Z: "true",
            M: "Legends",
            T: "font",
            C: "Font for the legends"
        },
        randomDataSampleAnnotationRatio: {
            A: "true",
            M: "Random",
            T: "integer",
            C: "Approximate number of classes in each sample annotation when creating random data",
            D: "2"
        },
        xAxis2Values: {
            A: "true",
            M: "X-Axis2",
            T: "array",
            C: "Values for the ticks in the 2nd X axis",
            D: "[]",
            U: {
                StackedLine: "true",
                StackedPercentLine: "true",
                BarLine: "true",
                AreaLine: "true"
            }
        },
        freezeRowBottom: {
            A: "true",
            M: "Data Table",
            T: "integer",
            C: "Number of rows to freeze at the bottom of the data table",
            D: "0"
        },
        xAxisTransformTicks: {
            H: ['{*,"xAxisTransform":"log10","graphType":"Scatter2D"}'],
            M: "X-Axis",
            T: "boolean",
            C: "Flag to transform the values of the ticks in the X axis",
            D: "true",
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        overrideEventlessNodes: {
            A: "true",
            H: ["{*}"],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to override nodes that do not take events to be able to edit them",
            D: "false"
        },
        legendScaleFontFactor: {
            H: ["{*}"],
            M: "Legends",
            T: "float",
            C: "Scaling factor used to increase or decrease legend font size in the canvas.",
            D: "1"
        },
        tmpAsciiArray: {
            Z: "true",
            M: "Data",
            T: "array",
            C: "A temporary array to enable sorting data asciibetically."
        },
        boxplotDataPointTransparency: {
            A: "true",
            S: ["showBoxplotOriginalData", "boxplotDataPointRatio", "jitter"],
            H: ['{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"boxplotDataPointTransparency":0.5,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"boxplotDataPointTransparency":0.2,"functions":["groupSamples:Factor1"]}'],
            M: "Boxplot Graphs",
            T: "float",
            C: "Fraction to adjust color transparency for the data points when displaying original data in boxplots.",
            D: "0.5"
        },
        showRingLegend: {
            H: ['{*,"data":"Circular","segregateVariablesBy":"Ring"}'],
            M: "Circular Graphs",
            T: "boolean",
            C: "Flag to show legends in each ring of a circular graph",
            D: "true"
        },
        sma50Color: {
            M: "Candlestick Plots",
            T: "color",
            C: "The color for the 50 day single moving average",
            D: "rgb(0,0,0)"
        },
        areaIsCumulative: {
            H: ['{*,"transparency":0.5}'],
            M: "Area Graphs",
            T: "boolean",
            C: "Flag to treat area graphs as cumulative values",
            D: "false"
        },
        stopButton: {
            A: "true",
            M: "Images",
            T: "image",
            C: "Relative path to an image file to the stop button (not including the image directory)",
            D: "stop.png"
        },
        trackNameFont: {
            Z: "true",
            M: "Genome Browser",
            T: "font",
            C: "Font for the text of the tracks in the genome browser"
        },
        randomData: {
            Z: "true",
            M: "Random",
            T: "boolean",
            C: "Flag to indicate random data for debug and demonstration purposes"
        },
        jitter: {
            A: "true",
            S: ["showBoxplotOriginalData", "boxplotDataPointTransparency", "boxplotDataPointRatio"],
            T: "boolean",
            H: ['{"data":"Boxplot","graphType":"Dotplot","jitter":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","graphType":"Dotplot","jitter":false,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","graphType":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","graphType":"Boxplot","jitter":false,"showBoxplotOriginalData":true,"functions":["groupSamples:Factor1"]}'],
            M: "Plot area",
            D: "false",
            C: "Flag to jitter the point in dotplots and boxplots",
            U: {
                Boxplot: "true",
                Dotplot: "true"
            }
        },
        networkDivisions: {
            A: "true",
            Z: "true",
            M: "Network Graphs",
            T: "integer",
            C: "Number of angular divisions in the radial network."
        },
        resizerDraw: {
            A: "true",
            M: "Axis Resizer",
            T: "boolean",
            C: "Flag to make the axis resizers draw the canvas as they move",
            D: "true"
        },
        temperature: {
            A: "true",
            H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
            M: "Network Graphs",
            T: "integer",
            C: "Temperature to limit displacement at later stages of forceDirected and organic layouts. A value based on the number of node and edges will be assigned if not specified",
            D: "0"
        },
        indicatorWidth: {
            H: ['{*,"graphType":"Heatmap"}'],
            M: "Heatmap Color Schemes",
            T: "integer",
            C: "Length in pixels for the heatmap indicator line width used for increase the size of the indicator",
            D: "1"
        },
        sequenceFontSize: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Size in pixels for the font size of text of the sequence in the genome browser",
            D: "10"
        },
        panningStep: {
            A: "true",
            H: ['{*,"graphType":"Heatmap"}'],
            M: "Zooming and Panning",
            T: "float",
            C: "Percentage step for panning networks.",
            D: "0.2"
        },
        featureTypeDefault: {
            O: ["box", "bar", "heatmap", "sequence", "triangle", "line"],
            M: "Genome Browser",
            T: "option",
            C: "Default type for the feature in the genome browser",
            D: "line"
        },
        zAxisValues: {
            A: "true",
            M: "Z-Axis",
            T: "array",
            C: "Values for the ticks in the Z axis",
            D: "[]"
        },
        overlayFontSize: {
            A: "true",
            H: ['{*,"autoScaleFont":false,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
            M: "Overlays",
            T: "integer",
            C: "Font size for the overlays in one dimensional plots",
            D: "6"
        },
        backgroundWindowGradientOrientation: {
            A: "true",
            S: ["backgroundType"],
            O: ["vertical", "horizontal"],
            T: "option",
            H: ['{*,"backgroundType":"windowGradient"}'],
            M: "Background",
            D: "vertical",
            C: "Specifies the orientation of the gradient if the background type is of the type 'windowGradient' or 'windowGradient2'."
        },
        yAxisTransformTicks: {
            H: ['{*,"yAxisTransform":"log10","graphType":"Scatter2D"}'],
            M: "Y-Axis",
            T: "boolean",
            C: "Flag to transform the values of the ticks in the Y axis",
            D: "true"
        },
        isCreateHistogram: {
            Z: "true",
            M: "Histograms",
            T: "boolean",
            C: "Flag to indicate there is a histogram",
            D: "false"
        },
        setMaxX2: {
            A: "true",
            H: ['{"graphType":"BarLine","setMaxX2":200}', '{"graphType":"BarLine","setMaxX2":50}', '{"graphType":"BarLine","setMaxX2":null}'],
            M: "X-Axis2",
            T: "float",
            C: "Maximum value to set the data in the 2nd axis",
            D: "null",
            U: {
                StackedLine: "true",
                StackedPercentLine: "true",
                BarLine: "true",
                AreaLine: "true"
            }
        },
        autoScaleFont: {
            A: "true",
            S: ["smpLabelFontSize", "varLabelFontSize", "legendFontSize", "axisTickFontSize", "axisTitleFontSize"],
            H: ['{*,"title":"Graph Title"}'],
            M: "Text",
            T: "boolean",
            C: "Flag to automatically adjust the font size in many visualization. Please be aware that scaling factors can still modify the font size. This flag needs to be false for the text to accept the specified font size.",
            D: "true"
        },
        rAxisValues: {
            A: "true",
            M: "R-Axis",
            T: "array",
            C: "Values for the ticks in the R axis",
            D: "[]"
        },
        varIndicesStart: {
            Z: "true",
            M: "Heatmap Graphs",
            T: "integer",
            C: "Number that indicates starting point for variables in heatmaps when the canvas is zoom in."
        },
        backgroundGradient2Color: {
            S: ["backgroundType", "backgroundGradient1Color"],
            H: ['{*,"backgroundType":"gradient"}'],
            M: "Background",
            T: "color",
            C: "Specifies the second color of the gradient if the background type is of the type of 'gradient'.",
            D: "rgb(0,0,36)"
        },
        videoGrid: {
            H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Videos",
            T: "boolean",
            C: "Flag to show grid in video",
            D: "false"
        },
        decorationFontStyle: {
            A: "true",
            H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
            O: ["", "bold", "italic", "bold italic"],
            M: "Decorations",
            T: "option",
            C: "Font style for the decorations. @default"
        },
        dataFilterWidth: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "integer",
            C: "Size in pixels for the data filters.",
            D: "300"
        },
        overlayFontStyle: {
            A: "true",
            H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
            O: ["", "bold", "italic", "bold italic"],
            M: "Overlays",
            T: "option",
            C: "Font style for the overlays. @default"
        },
        transparency: {
            A: "true",
            H: ["{*}"],
            M: "General",
            T: "float",
            C: "Percentage of transparency applied to all elements in the visualizations",
            D: "null"
        },
        useSmpVarIndexOnClustering: {
            M: "Clustering",
            T: "boolean",
            C: "Flag to indicate to use variable or sample index rather than names when clustering. This allows to use '(', ')' and ':' in the variable or sample name",
            D: "false"
        },
        zAxisTickColor: {
            H: ['{*,"graphType":"Scatter3D"}'],
            M: "Z-Axis",
            T: "color",
            C: "Color for the tick lines in the Z axis",
            D: "rgb(204,204,204)"
        },
        transform: {
            S: ["transformType", "transformBase", "ratioReference", "zscoreAxis"],
            O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "zscore", "ratio", "ratio2", "ratio10", "save", "reset", "undo"],
            M: "Functions",
            T: "option",
            C: "Transform all the data. Warning: the option 'save' overwrites the original data",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        transformType: {
            H: ["{*}"],
            O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "zscore", "ratio", "ratio2", "ratio10", "save", "reset", "undo"],
            M: "Data",
            T: "option",
            C: "Default transformation type.",
            D: "false"
        },
        timeValues: {
            A: "true",
            M: "X-Axis",
            T: "array",
            C: "Array containing the tick values when the the graph is a time series",
            D: "[]"
        },
        sequenceKColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the degenerate G/T and lysines in the genome browser",
            D: "rgb(255,0,0)"
        },
        backgroundWindowGradient1Color: {
            A: "true",
            S: ["backgroundType"],
            H: ['{*,"backgroundType":"windowSolidGradient"}'],
            M: "Background",
            T: "color",
            C: "Specifies the first color of the gradient if the background type is of the type of 'windowGradient'.",
            D: "rgb(0,0,200)"
        },
        disableDataTable: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to disable showing data table",
            D: "false"
        },
        maxFeatureStringLen: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Maximum length in characters a feature label can have so anything above is truncated.",
            D: "50"
        },
        yAxis: {
            A: "true",
            T: "array",
            X: "getSamplesAsArray",
            H: ['{"xAxis":["Sample1","Sample2","Sample3"],"yAxis":["Sample4","Sample5","Sample6"],"graphType":"Scatter2D"}'],
            M: "Y-Axis",
            D: "[]",
            C: "Name of the samples groups or variables to be displayed in the Y axis",
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        setMinX: {
            A: "true",
            H: ['{"setMinX":50}', '{"setMinX":20}', '{"setMinX":null}'],
            M: "X-Axis",
            T: "float",
            C: "Minimum value to set the data in the X axis",
            D: "null"
        },
        sizeBy: {
            S: ["sizeByData"],
            O: ["false", "variable"],
            T: "option",
            X: "getXZData",
            H: ['{"graphType":"Scatter3D","sizeBy":"Annt1"}', '{"graphType":"Scatter3D","sizeBy":"Sample4"}', '{"graphType":"Dotplot","sizeBy":"Factor1"}', '{"graphType":"Dotplot","sizeBy":"Annt1"}', '{"graphType":"Dotplot","sizeBy":"variable"}'],
            M: "Data Point Attributes",
            D: "false",
            C: "Name of a variable annotation or a sample name or the string 'variable' to size the variables. When sizeByData is specified sizeBy is used for the title in the legend."
        },
        featureTranslateShow: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "boolean",
            C: "Flag use to show tranlation",
            D: "true"
        },
        varTitleFont: {
            Z: "true",
            M: "Variables",
            T: "font",
            C: "Font for the variable titles in one dimensional plots"
        },
        videoClassName: {
            H: ['{"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Videos",
            T: "string",
            C: "Video class name / css for videos",
            D: "video-js vjs-default-skin"
        },
        preScaleNetwork: {
            A: "true",
            H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to prescale or not the network. This is an aesthetic parameter to make the graph look nicer... Sometimes...",
            D: "false"
        },
        sequencePColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the prolines in the genome browser",
            D: "rgb(255,165,0)"
        },
        randomDataSymmetrical: {
            A: "true",
            M: "Random",
            T: "boolean",
            C: "Flag to add missing data to the random data for debug and demonstration purposes @cfg {} randomDataMissing",
            D: "false"
        },
        isHistogram: {
            A: "true",
            S: ["scatterType", "histogramBarWidth"],
            H: ['{*,"graphType":"Scatter2D"}'],
            M: "Histograms",
            T: "boolean",
            C: "Flag to convert the 2D scatter plot into a histogram. That is, the points in the scatter plot are converted to bars that start at the bottom of the Y axis. It is useful to represent proteomics spectra. This can also be done setting scatterType to 'bar'.",
            D: "false"
        },
        smpTitleFontColor: {
            H: ['{*,"smpTitle":"Sample Title"}'],
            M: "Samples",
            T: "color",
            C: "Font color for the sample title in one dimensional plots",
            D: "foreground color"
        },
        xRotate: {
            A: "true",
            H: ['{"graphType":"Scatter3D","xRotate":0}', '{"graphType":"Scatter3D","xRotate":45}'],
            M: "3D Attributes",
            T: "float",
            C: "Starting number of degrees to rotate graph arround the X axis",
            D: "45"
        },
        featureCoordinateShow: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "boolean",
            C: "Flag use to show coordinates",
            D: "true"
        },
        weight: {
            A: "true",
            Z: "true",
            M: "Combination Plots",
            T: "float",
            C: "Fraction of the canvas to be used (a value between 0 and 1). Used when multiple graphs are displayed in one canvas. Could be an number or an array of numbers."
        },
        showLegend: {
            H: ["{*}"],
            M: "Legends",
            T: "boolean",
            C: "Flag to show or not the legend in the graphs",
            D: "true"
        },
        indicatorCenter: {
            H: ['{*,"graphType":"Heatmap"}'],
            O: ["white", "black", "rainbow", "rainbow-green"],
            M: "Heatmap Color Schemes",
            T: "option",
            C: "Color for the center of the heatmap indicator. If rainbow-red is specified the order of the colors to generate the gradient will be: red - blue - green. If rainbow-green is specified then the order of the colors to generate the gradient will be: green - blue - red. The option rainbow is an alias for rainbow-red.",
            D: "white"
        },
        sequenceYColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the degenerate C/T and tyrosines in the genome browser",
            D: "rgb(0,0,255)"
        },
        histogramBins: {
            A: "true",
            H: ['{"data":"Random:200:2","functions":["createHistogram"],"histogramBins":20}', '{"data":"Random:200:2","functions":["createHistogram"],"histogramBins":10}'],
            S: ["createHistogram"],
            M: "Histograms",
            T: "integer",
            C: "Number of bins in histogram",
            D: "20"
        },
        yAxisTickStyle: {
            A: "true",
            O: ["solid", "dotted"],
            T: "option",
            H: ['{*,"graphType":"Scatter2D"}'],
            M: "Y-Axis",
            D: "solid",
            C: "Style for the tick lines in the Y axis",
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Correlation: "true",
                Scatter2D: "true"
            }
        },
        varTitle: {
            H: ['{"varTitle":"Variable Title"}'],
            M: "Variables",
            T: "string",
            C: "Title for the sample axis in one dimensional plots",
            D: "false",
            U: {
                Heatmap: "true"
            }
        },
        networkFreeze: {
            A: "true",
            H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to prevent autoscaling for the network layout. Useful when images are part of the network.",
            D: "false"
        },
        scatterPlotMatrix: {
            H: ['{"graphType":"Scatter2D","scatterPlotMatrix":true}'],
            S: ["scatterPlotMatrixType"],
            M: "Scatter Plot Matrix",
            T: "boolean",
            C: "Flag to plot an n-1 x n-1 matrix of 2D sccaterplots",
            D: "false"
        },
        stockIndicators: {
            H: ['{"graphType":"Candlestick"}'],
            O: ["Sma5", "Sma10", "Sma20", "Sma25", "Sma50"],
            M: "Candlestick Plots",
            T: "array",
            C: "Stock technical indicators",
            D: ["'Sma5'", " 'Sma10'", " 'Sma25'"]
        },
        colorNodeBy: {
            H: ['{"data":"LesMiserables","colorNodeBy":"group"}'],
            M: "Network Graphs",
            T: "string",
            C: "Name of the attribute to color the nodes.",
            D: "false"
        },
        featureCoordinateHeight: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Default size in pixels of the coordinates height",
            D: "12"
        },
        backgroundImage: {
            S: ["backgroundType"],
            H: ['{"backgroundType":"image","backgroundImage":"http://www.canvasxpress.org/images/nanotube.jpg"}', '{"backgroundType":"windowImage","backgroundImage":"http://www.canvasxpress.org/images/nanotube.jpg"}'],
            M: "Background",
            T: "url",
            C: "Specifies the url for the background image when the background type is of the type 'image' or 'windowImage'.",
            D: "false"
        },
        showPieSampleLabel: {
            H: ['{*,"data":"Generic","xAxis":["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6"],"layout":"2X3"}'],
            M: "Pie Charts",
            T: "boolean",
            C: "A flag to show the sample label when plotting multiple pies",
            D: "true"
        },
        minTextSize: {
            A: "true",
            H: ['{*,"title":"Graph Title"}'],
            M: "Text",
            T: "integer",
            C: "Minimum size for any text in the canvas.",
            D: "4"
        },
        varLabelFontColor: {
            H: ["{*}"],
            M: "Variables",
            T: "color",
            C: "Font color for the variable labels in one dimensional plots",
            D: "foreground color",
            U: {
                Heatmap: "true"
            }
        },
        isBoxPlotCalc: {
            Z: "true",
            M: "Data",
            T: "boolean",
            C: "Flag to indicate if the iqr has been calculated if the graph type is Boxplot."
        },
        acknowledgmentIcon: {
            H: ['{*,"acknowledgment":true}'],
            S: ["acknowledgment", "acknowledgmentIconPosition"],
            O: ["cx.png", "cxn.png"],
            M: "Acknowledgment",
            T: "option",
            C: "Specifies the acknowledgment canvasXpress icon",
            D: "cx.png"
        },
        pieSegmentSeparation: {
            H: ["{*}"],
            M: "Pie Charts",
            T: "integer",
            C: "Length in pixels for the separation of the pieces of the pie charts",
            D: "3"
        },
        nodeFontStyle: {
            A: "true",
            H: ["{*}"],
            O: ["", "bold", "italic", "bold italic"],
            M: "Network Graphs",
            T: "option",
            C: "Font style for the node label. @default"
        },
        smpLabelOrientation: {
            H: ['{*,"data":"Circular","segregateVariablesBy":"Ring","segregateSamplesBy":"Segment"}'],
            O: ["perpendicular", "circular"],
            M: "Circular Graphs",
            T: "option",
            C: "Orientation to show the sample names",
            D: "perpendicular"
        },
        timeTicksFirst: {
            A: "true",
            H: ['{*,"isGraphTime":true,"data":"Random:1:150:0:0:0:0:1","showVolume":false}'],
            M: "X-Axis",
            T: "boolean",
            C: "Flag to indicate whether to use the first date on a time graph or the last",
            D: "false"
        },
        remoteParams: {
            A: "true",
            M: "Remote Procedures",
            T: "object",
            C: "Object to hold parameters used to obtain data remotely. The target property will be always added to the method as well as the direction [next|prev] (see below.",
            D: "{}"
        },
        dotLength: {
            A: "true",
            H: ['{*,"data":"DashDot","calculateLayout":false,"graphType":"Network"}'],
            M: "Lines",
            T: "integer",
            C: "Size in pixels of the length between dots in the doted lines.",
            D: "1"
        },
        zAxisMinorValues: {
            A: "true",
            M: "Z-Axis",
            T: "array",
            C: "Values for the minor ticks in the Z axis",
            D: "[]"
        },
        boxplotDataPointRatio: {
            A: "true",
            S: ["showBoxplotOriginalData", "boxplotDataPointTransparency", "jitter"],
            H: ['{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"boxplotDataPointRatio":2,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"boxplotDataPointRatio":4,"functions":["groupSamples:Factor1"]}'],
            M: "Boxplot Graphs",
            T: "float",
            C: "Ratio to adjust the size of the data points when displaying original data in boxplots. The higher the number the smaller the data points",
            D: "2"
        },
        smpHighlightColor: {
            H: ['{*,"highlightSmp":["Sample1","Sample3"]}'],
            M: "Samples",
            T: "color",
            C: "The color for the higlighted samples.",
            D: "rgb(255,0,0)"
        },
        network2DRotate: {
            A: "true",
            Z: "true",
            M: "Network Graphs",
            T: "integer",
            C: "Number of degrees to rotate network arround the X axis"
        },
        overrideAnchorNodes: {
            A: "true",
            H: ["{*}"],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to override anchor nodes",
            D: "false"
        },
        clusterSamples: {
            S: ["distance", "linkage", "clusterAxis", "imputeMethod", "centerData"],
            M: "Functions",
            T: "void",
            C: "Cluster samples based on data and generate a dendrogram on the sample axis. It takes no parameters",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                StackedLine: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        arrowPointSize: {
            A: "true",
            H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
            M: "Lines",
            T: "integer",
            C: "Size in pixels of the arrow head in arrow lines.",
            D: "10"
        },
        yAxisValues: {
            A: "true",
            M: "Y-Axis",
            T: "array",
            C: "Values for the ticks in the Y axis",
            D: "[]"
        },
        sequenceFill: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the background when showing sequnces in the box or sequence object in the Genome. The default is to use the background of the object. If specied a valid color then all the background of sequences will be uniform",
            D: "false"
        },
        sma25Color: {
            H: ['{*,"stockIndicators":["Sma25"]}'],
            M: "Candlestick Plots",
            T: "color",
            C: "The color for the 25 day single moving average",
            D: "rgb(255,0,255)"
        },
        titleColor: {
            S: ["title", "titleHeight"],
            H: ['{*,"title":"Graph Title"}'],
            M: "Titles and Subtitles",
            T: "color",
            C: "Color for the title",
            D: "rgb(0,0,0)"
        },
        outlineBy: {
            H: ["{*}"],
            S: ["outlineByData"],
            M: "Data Point Attributes",
            T: "string",
            C: "Name of the annotation for the outline when drawing a multidimensional Heatmap",
            D: "false",
            U: {
                Heatmap: "true"
            }
        },
        cullingThreshold: {
            A: "true",
            M: "3D Attributes",
            T: "integer",
            C: "Number of data point to start culling data",
            D: "1000"
        },
        sortVariablesByCategory: {
            S: ["sortDir", "sortVariablesBySample"],
            M: "Functions",
            T: "array",
            C: "Sort the variables by a variable category (data.z object)",
            X: "getZData",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                Correletion: "true",
                StackedPercentLine: "true",
                Pie: "true",
                Barline: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        desegregateVariables: {
            S: ["segregateVariables"],
            M: "Functions",
            T: "void",
            C: "Desegregate variables previously segregated based on a variable category (data.z object)",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                Correletion: "true",
                StackedPercentLine: "true",
                Pie: "true",
                Barline: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        setMax: {
            Z: "true",
            M: "Axis",
            T: "float",
            C: "Maximum value to set the data",
            D: "null"
        },
        selectDataModeDescription: {
            H: ['{"selectDataMode":"name","selectDataModeDescription":false}', '{"selectDataMode":"name","selectDataModeDescription":"Annt1"}'],
            O: ["false"],
            M: "Scatter Plots",
            T: "option",
            C: "Variable label to display when highlighting selected data points that must be in the 'data.z' object. (Shift + mouse drag) @see{selectDataMode}",
            D: "false",
            X: "getZData"
        },
        networkLayoutType: {
            H: ['{"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}', '{"data":"LesMiserables","networkLayoutType":"organic","colorNodeBy":"group"}', '{"data":"NetworkRadial","networkLayoutType":"radial"}'],
            O: ["forceDirected", "organic", "radial"],
            M: "Network Graphs",
            T: "option",
            C: "Type of network layout.",
            D: "forceDirected"
        },
        zoom: {
            A: "true",
            H: ['{*,"graphType":"Heatmap"}'],
            M: "Zooming and Panning",
            T: "float",
            C: "Zoom factor for the networks. A number greater than zero",
            D: "1"
        },
        legendBackgroundColor: {
            S: ["legendBox"],
            H: ["{*}"],
            M: "Legends",
            T: "color",
            C: "Color for the legend background",
            D: "background color"
        },
        citationFont: {
            Z: "true",
            M: "Citations or References",
            T: "font",
            C: "Font for the reference citation"
        },
        initialTemperature: {
            A: "true",
            H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
            M: "Network Graphs",
            T: "integer",
            C: "Initial temperature to limit displacement at later stages of forceDirected and organic layouts. A value based on the number of node and edges will be assigned if not specified",
            D: "0"
        },
        overlayScaleFontFactor: {
            A: "true",
            H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
            M: "Overlays",
            T: "float",
            C: "Scaling factor used to increse or decrease overlays font size in the canvas in one dimensional plots",
            D: "1"
        },
        showNetworkNodesLegend: {
            A: "true",
            H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to show node legends in the networks",
            D: "true"
        },
        shadowBlur: {
            A: "true",
            S: ["showShadow"],
            H: ['{*,"showShadow":true}'],
            M: "Shadows",
            T: "integer",
            C: "Amount in blur for the shadow.",
            D: "2"
        },
        varTitleLabelOverlayPosition: {
            H: ["{*}"],
            O: ["bottom", "top"],
            M: "Heatmap Graphs",
            T: "option",
            C: "Position for variable labels",
            D: "bottom"
        },
        remoteAutoPlay: {
            A: "true",
            M: "Remote Procedures",
            T: "boolean",
            C: "Flag to iterate over remote data sets",
            D: "false"
        },
        recalculateLayout: {
            M: "Functions",
            T: "void",
            C: "Recalculate the network layout",
            U: {
                Scatter3D: "true",
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        varTitleFontStyle: {
            A: "true",
            H: ['{*,"varTitle":"Variable Title"}'],
            O: ["", "bold", "italic", "bold italic"],
            M: "Variables",
            T: "option",
            C: "Font style for the var title. @default",
            U: {
                Heatmap: "true"
            }
        },
        sequenceXColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the any aminoacid code in the genome browser",
            D: "rgb(0,0,0)"
        },
        overlayFontColor: {
            A: "true",
            H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
            M: "Overlays",
            T: "color",
            C: "Color for the overlays in one dimensional plots",
            D: "foregroung color"
        },
        sizeNodeBy: {
            H: ['{"data":"LesMiserables","colorNodeBy":"group","sizeNodeBy":"group"}'],
            M: "Network Graphs",
            T: "string",
            C: "Name of the attribute to size the nodes.",
            D: "false"
        },
        snapshotCopyChangeOnly: {
            A: "true",
            M: "Animation",
            T: "boolean",
            C: "Flag to indicate whether to copy all or only the changed attributes in the network animation. This optimizes memory usage for snapshots.",
            D: "true"
        },
        axisTickFontSize: {
            A: "true",
            S: ["autoScaleFont", "axisTickScaleFontFactor"],
            H: ['{*,"autoScaleFont":false}'],
            M: "Axis",
            T: "integer",
            C: "Font size for the axis ticks in one and two dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the tick scaling factor",
            D: "10"
        },
        sequenceGColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the guanines and glycines in the genome browser",
            D: "rgb(0,0,0)"
        },
        xAxisMinorTicks: {
            A: "true",
            H: ["{*}"],
            M: "X-Axis",
            T: "boolean",
            C: "A flag to show minor tick lines in the X axis",
            D: "true"
        },
        legendPosition: {
            H: ["{*}"],
            O: ["right", "bottom"],
            M: "Legends",
            T: "option",
            C: "Position for the legend in the graphs",
            D: "right"
        },
        dashLength: {
            A: "true",
            H: ['{*,"data":"DashDot","calculateLayout":false,"graphType":"Network"}'],
            M: "Lines",
            T: "integer",
            C: "Size in pixels of the length of the dashes and the separation between the dashes in the dashed lines.",
            D: "8"
        },
        zAxisTitle: {
            H: ['{"graphType":"Scatter3D","zAxisTitle":"Z-axis title"}'],
            M: "Z-Axis",
            T: "string",
            C: "Title for the Z axis",
            D: "false"
        },
        remoteParentId: {
            A: "true",
            Z: "true",
            M: "Remote Procedures",
            T: "string",
            C: "Id for the parent holding the remoteWindow to prevent id collisions"
        },
        groupingFactors: {
            Z: "true",
            M: "Data",
            T: "array",
            C: "An array that holds the group names used for grouping the data. It must be a category in the 'data.x' object",
            D: "[]"
        },
        configuratorWidth: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "integer",
            C: "Size in pixels for the configurator.",
            D: "250"
        },
        featureQualityHeight: {
            A: "true",
            H: ["{*}"],
            M: "Genome Browser",
            T: "integer",
            C: "Default size in pixels of the quality height",
            D: "12"
        },
        joinType: {
            A: "true",
            H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
            O: ["mitter", "bevel", "round"],
            M: "Lines",
            T: "option",
            C: "Default type for joining lines.",
            D: "mitter"
        },
        translateX: {
            A: "true",
            Z: "true",
            M: "Combination Plots",
            T: "float",
            C: "Amount to translate for the X axis."
        },
        networkRoot: {
            H: ['{"data":"NetworkRadial","networkLayoutType":"radial","networkRoot":"Gene1"}', '{"data":"NetworkRadial","networkLayoutType":"radial","networkRoot":"Gene2"}'],
            M: "Network Graphs",
            T: "string",
            C: "Node Id of the network root.",
            D: "false"
        },
        varOverlays: {
            H: ['{"graphType":"Heatmap","data":"Random:10:10:3:0","varOverlays":["Annt1","Annt2","Annt3"]}'],
            M: "Overlays",
            T: "array",
            C: "Variable annotations included in the 'data.z' object used in one dimensional plots",
            D: "[]",
            X: "getZData"
        },
        z3DRatio: {
            A: "true",
            H: ['{"graphType":"Scatter3D","z3DRatio":0.5}', '{"graphType":"Scatter3D","z3DRatio":1}'],
            M: "3D Attributes",
            T: "float",
            C: "Value between 0 - 1 for adjusting the 3D of the Z Axis",
            D: "1",
            U: {
                Scatter3D: "true",
                Bar: "true"
            }
        },
        remoteUpdating: {
            A: "true",
            Z: "true",
            M: "Remote Procedures",
            T: "boolean",
            C: "Flag to indicate that updating data is in progress"
        },
        foreground: {
            H: ['{*,"data":"Random:1:3:0:0","graphType":"Dotplot"}'],
            M: "Foreground",
            T: "color",
            C: "Specifies the foreground color for text or lines not covered in a more specific configuration property.",
            D: "rgb(0,0,0)"
        },
        filterFeatureBy: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "filter",
            C: "Filter features by their properties used in genome browser      *",
            D: "[]",
            X: "getFeatureData"
        },
        plotByVariable: {
            H: ['{*,"graphType":"Bar"}'],
            M: "Plot area",
            T: "boolean",
            C: "Flag to indicate whether to group the data variable rather than by sample",
            D: "false"
        },
        rowHeight: {
            A: "true",
            M: "Data Table",
            T: "integer",
            C: "Mumber of pixels for the height of cells in the data table",
            D: "100"
        },
        smpHairlineWidth: {
            H: ['{*,"graphType":"Bar","smpHairline":true}'],
            M: "Plot area",
            T: "float",
            C: "The width for the thin line that appears in the middle of the sample block just for aesthetics.",
            D: "0.3"
        },
        scatterType: {
            H: ['{*,"graphType":"Scatter2D","scatterType":"image","images":["met.png", "prot9.png", "prot8.png", "prot7.png", "prot6.png", "prot5.png"]}'],
            S: ["images", "isHistogram", "histogramBarWidth"],
            O: ["false", "line", "bar", "image", "lineImage", "lineStep"],
            M: "Scatter Plots",
            T: "option",
            C: "Type of scatter plot",
            D: "false"
        },
        videoCurrentTime: {
            H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Videos",
            T: "boolean",
            C: "Flag to show video current time",
            D: "false"
        },
        dendrogramHang: {
            H: ['{*,"data":"Generic","graphType":"Bar","showSmpDendrogram":true}'],
            M: "Dendrograms",
            T: "boolean",
            C: "Flag to show or not the nodes in the dendrogram as hanging or not similar to that one in R",
            D: "false"
        },
        featureQualityValues: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "boolean",
            C: "Flag use to show values for the quality",
            D: "false"
        },
        bar3DInverseWeight: {
            A: "true",
            H: ['{*,"data":"3DScatter","scatterType":"bar"}'],
            M: "3D Attributes",
            T: "float",
            C: "Value for adjusting the thickness of 3D bars. The larger the value the the thinner the bar",
            D: "1",
            U: {
                Scatter3D: "true"
            }
        },
        resizerPosition: {
            A: "true",
            O: ["top", "rigth", "bottom", "left"],
            M: "Axis Resizer",
            T: "option",
            C: "Position for the axis resizer in complex plots",
            D: "bottom"
        },
        repulsiveForceFunction: {
            A: "true",
            H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
            O: ["square", "log", "pow", "sqrt"],
            M: "Network Graphs",
            T: "option",
            C: "Type of function to apply when calculating repulsive force in forceDirected network layouts",
            D: "square"
        },
        vennGroups: {
            H: ['{"vennGroups":2}', '{"vennGroups":3}', '{"vennGroups":4}'],
            M: "Venn Diagrams",
            T: "integer",
            C: "Number of groups in the Venn diagram",
            D: "4"
        },
        zAxis: {
            A: "true",
            H: ['{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"ScatterBubble2D"}', '{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"Scatter3D"}'],
            M: "Z-Axis",
            T: "array",
            C: "Name of the samples groups or variables to be displayed in the Z axis",
            D: "[]",
            X: "getSamplesAsArray"
        },
        videoPlaybackRate: {
            H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Videos",
            T: "float",
            C: "Video Playback Rate",
            D: "1"
        },
        lineType: {
            H: ['{*,"data":"Random:4:6","graphType":"Line"}'],
            O: ["rect", "spline"],
            M: "Line Graphs",
            T: "option",
            C: "Type of line used to join the points in line graphs",
            D: "rect"
        },
        y3DRatio: {
            A: "true",
            H: ['{"graphType":"Scatter3D","y3DRatio":0.5}', '{"graphType":"Scatter3D","y3DRatio":1}'],
            M: "3D Attributes",
            T: "float",
            C: "Value between 0 - 1 for adjusting the 3D of the Y Axis",
            D: "1",
            U: {
                Scatter3D: "true",
                Bar: "true"
            }
        },
        zscoreAxis: {
            H: ["{*}"],
            O: ["samples", "variables"],
            M: "Data",
            T: "option",
            C: "Default axis to use to zsore the data.",
            D: "samples"
        },
        decorationsWidth: {
            A: "true",
            H: ['{*,"data":"NetworkDecorations","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}'],
            M: "Decorations",
            T: "integer",
            C: "Length in pixels of the width for the decorations in the networks",
            D: "10",
            U: {
                Network: "true"
            }
        },
        featureStaggered: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "boolean",
            C: "Flag use to stagger the features in the genome panel",
            D: "false"
        },
        filterVarBy: {
            H: ["{*}"],
            M: "Variables",
            T: "filter",
            C: "Filter variables by their annotation included in the 'data.z' object used in one dimensional plots",
            D: "[]",
            X: "getZData"
        },
        moveParentsWithChildren: {
            A: "true",
            H: ["{*}"],
            M: "Network Graphs",
            T: "boolean",
            C: "Flag to make parents move when a child is moved",
            D: "false"
        },
        disableMenu: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to disable showing the menu on right clicks",
            D: "false"
        },
        yAxisAbsMax: {
            Z: "true",
            M: "Y-Axis",
            T: "float",
            C: "Maximum non-filtered value for the data plotted in the Y axis"
        },
        maxPieSectors: {
            H: ['{"data":"Generic","maxPieSectors":2}', '{"data":"Generic","maxPieSectors":3}'],
            M: "Pie Charts",
            T: "float",
            C: "Max pie sectors. After that number the sectors will be put in a sector named 'other'.",
            D: "20"
        },
        xAxisAbsMin: {
            Z: "true",
            M: "X-Axis",
            T: "float",
            C: "Minimum non-filtered value for the data plotted in the X axis"
        },
        filterSkipNullKeys: {
            M: "Data Filters",
            T: "boolean",
            C: "Flag to indicate to bypass filtering when a key is non existent in the data objects",
            D: "false"
        },
        correlationLabelInterval: {
            A: "true",
            H: ["{*}"],
            M: "Correlation Graphs",
            T: "integer",
            C: "Interval for the sample or variable labels in the correlation plot",
            D: "1"
        },
        networkForceConstant: {
            A: "true",
            H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
            M: "Network Graphs",
            T: "float",
            C: "Constant used for calculating attractive and repulsive forces in forcedDirected and organic layouts. A value based on the average area per node will be assigned if not specified",
            D: "0"
        },
        selectedBackgroundColor: {
            A: "true",
            Z: "true",
            M: "Skins",
            T: "color",
            C: "Color for the highlight skin automatically calculated"
        },
        patterns: {
            H: ['{"data":"Random:14:1:0:0:1","graphType":"Bar","graphOrientation":"vertical","setMaxX":1,"setMinX":0,"smpLabelRotate":90,"patterns":["hatchForward","hatchReverse","stripeHorizontal","stripeVertical","polkaDot","crossHatch","crossStripe","squares","circles","plus","squigles","brick","art","cx"]}', '{"data":"Random:2:4:0:0::1","colorScheme":"user","colors":["rgb(255,0,0)","rgb(255,0,0)"],"graphOrientation":"vertical","patterns":["solid","hatchReverse"]}', '{"data":"Random:4:4:0:0::1","colorScheme":"user","colors":["rgb(255,0,0)","rgb(255,0,0)","rgb(0,255,0)","rgb(0,255,0)"],"graphOrientation":"vertical","patterns":["solid","hatchReverse"]}'],
            S: ["patternImages", "patternNames"],
            M: "Patterns",
            T: "array",
            C: "Patterns used in visualizations to fill objects. This array must contain one or more pattern names and in concert with the color array can be used to specify the pattern colors for all filled objects in the visualizations."
        },
        networkShowDataTable: {
            A: "true",
            O: ["nodes", "edges"],
            M: "Data Table",
            T: "option",
            C: "Show nodes or edges on data table",
            D: "nodes"
        },
        vennColors: {
            A: "true",
            S: ["colors"],
            H: ['{"vennColors":["rgb(51,151,255)","rgb(151,255,51)","rgb(255,51,125)"],"vennGroups":3}'],
            M: "Venn Diagrams",
            T: "array",
            C: "Colors for the Venn bubles. If not specified the colors will be chosen from the colors array. Colors in this array need to be at least the same number of groups in the Venn diagram",
            D: "[]"
        },
        skipConfigurableProperties: {
            M: "Data Table/Filter",
            T: "boolean",
            C: "Flag to indicate to exclude configurable parameters in the data table and the data filters in Networks and Genome Browser",
            D: "true"
        },
        scaleX: {
            A: "true",
            Z: "true",
            M: "Combination Plots",
            T: "float",
            C: "Scale factor for the X axis"
        },
        configuratorExamplesSize: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "integer",
            C: "Size in pixels for the examples in the configurator.",
            D: "400"
        },
        overlaysWidth: {
            A: "true",
            H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
            M: "Overlays",
            T: "integer",
            C: "Length in pixels of the width for the colored boxes to classify samples and or variables in one dimensional plots",
            D: "30"
        },
        gradientType: {
            A: "true",
            S: ["gradient"],
            O: ["linear", "radial"],
            T: "option",
            H: ['{*,"data":"Random:1:3:0:0","gradient":true}'],
            M: "Gradients",
            D: "radial",
            C: "Specifies the gradient pattern."
        },
        resizerType: {
            A: "true",
            O: ["false", "samples", "box"],
            M: "Axis Resizer",
            T: "option",
            C: "String to indicate the type of axis resizer in complex plots",
            D: "false"
        },
        showDataValues: {
            H: ['{*,"graphType":"Bar"}'],
            M: "Plot area",
            T: "boolean",
            C: "Flag to indicate whether to show data values in the one bar graphs.",
            D: "false",
            U: {
                Bar: "true",
                Heatmap: "true"
            }
        },
        toolbarPermanent: {
            A: "true",
            H: ["{*}"],
            M: "Events",
            T: "boolean",
            C: "Flag to make the toolbar permanently visible.",
            D: "false"
        },
        featureTracesShow: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "boolean",
            C: "Flag use to show traces",
            D: "true"
        },
        hideUnhideSmps: {
            M: "Functions",
            T: "array",
            C: "Hide or unhide samples. It works like a switch",
            X: "getSamplesAsArray",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        decorationsColors: {
            A: "true",
            H: ['{"data":"NetworkDecorations","decorationsPosition":"right","networkFreezeOnLoad":true,"showDecorations":true,"decorationsColors":["rgb(51,125,255)","rgb(125,255,51)","rgb(255,125,51)"],"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}'],
            M: "Decorations",
            T: "array",
            C: "Array of colors used for selection in network decorations not to be confused by its singular form 'decorationsColor' above",
            D: "[]",
            U: {
                Network: "true"
            }
        },
        zAxisAbsMax: {
            Z: "true",
            M: "Z-Axis",
            T: "float",
            C: "Maximum non-filtered value for the data plotted in the Z axis"
        },
        imputeMethod: {
            H: ['{"graphType":"Heatmap","data":"Random:10:10::::::0.15","imputeMethod":"mean","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","data":"Random:10:10::::::0.15","imputeMethod":"median","functions":["clusterSamples","clusterVariables"]}'],
            S: ["distance", "linkage", "clusterAxis", "centerData", "clusterSamples", "clusterVariables"],
            O: ["mean", "median"],
            M: "Clustering",
            T: "option",
            C: "Imputation method for missing data when clustering",
            D: "mean"
        },
        isMarketSwitched: {
            Z: "true",
            M: "Data",
            T: "boolean",
            C: "Flag to indicate if the data is a Candlestick."
        },
        randomMissingDataPercentage: {
            A: "true",
            M: "Random",
            T: "float",
            C: "Default percentage of missing values when creating random data. A value between 0 and 1.",
            D: "0"
        },
        videoPreload: {
            H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            O: ["Auto", "Metadata", "none"],
            M: "Videos",
            T: "option",
            C: "Preload type for videos",
            D: "none"
        },
        highlightVar: {
            H: ['{"highlightVar":["Variable1","Variable3"]}'],
            M: "Variables",
            T: "array",
            C: "Name of variables in the 'data.y' object to highlight.",
            D: "[]",
            X: "getVariablesAsArray",
            U: {
                Heatmap: "true"
            }
        },
        smpHairline: {
            H: ['{*,"graphType":"Bar"}'],
            O: ["false", "solid", "dotted"],
            M: "Plot area",
            T: "option",
            C: "This is a thin line that appears in the middle of the bar graphs just for aesthetics.",
            D: "false"
        },
        sortSamplesByCategory: {
            S: ["sortDir", "sortSamplesByVariable"],
            M: "Functions",
            T: "array",
            C: "Sort the samples by a sample category (data.x object)",
            X: "getXData",
            U: {
                StackedPercent: "true",
                Boxplot: "true",
                Bar: "true",
                Correletion: "true",
                StackedPercentLine: "true",
                Pie: "true",
                Barline: "true",
                Area: "true",
                StackedLine: "true",
                Line: "true",
                Dotplot: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        featuresProperties: {
            M: "Data Table/Filter",
            T: "array",
            C: "Two dimensional array with object properties not at the root level for the features in the Genome graph to include in the Data table and the data filter",
            D: "[]"
        },
        smpOverlayRecycleColors: {
            H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
            M: "Overlays",
            T: "boolean",
            C: "Flag to indicate to recycle sample overlay colors with each overlay",
            D: "false"
        },
        sequenceWColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the degenerate A/T and tryptophans in the genome browser",
            D: "rgb(0,0,255)"
        },
        fontStyle: {
            A: "true",
            H: ['{*,"title":"Graph Title"}'],
            O: ["", "bold", "italic", "bold italic"],
            M: "Text",
            T: "option",
            C: "Font style. @default"
        },
        showBoxplotOriginalData: {
            A: "true",
            S: ["boxplotDataPointRatio", "boxplotDataPointTransparency", "jitter"],
            H: ['{"data":"Boxplot","showBoxplotOriginalData":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","showBoxplotOriginalData":false,"functions":["groupSamples:Factor1"]}'],
            M: "Boxplot Graphs",
            T: "boolean",
            C: "Flag to show original data in boxplots",
            D: "false"
        },
        rAxisTickColor: {
            H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":"Ring","segregateSamplesBy":"Segment"}'],
            M: "R-Axis",
            T: "color",
            C: "Color for the tick lines in the R axis",
            D: "rgb(0,0,0)"
        },
        trackNameFontStyle: {
            A: "true",
            H: ["{*}"],
            O: ["", "bold", "italic", "bold italic"],
            M: "Genome Browser",
            T: "option",
            C: "Font style for the track name. @default"
        },
        videoControls: {
            H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
            M: "Videos",
            T: "boolean",
            C: "Flag to show controls in videos default true"
        },
        showVolume: {
            H: ["{*}"],
            M: "Candlestick Plots",
            T: "boolean",
            C: "Flag to show or not volume in the candlestick graphs",
            D: "true"
        },
        varLabelFontStyle: {
            A: "true",
            H: ["{*}"],
            O: ["", "bold", "italic", "bold italic"],
            M: "Variables",
            T: "option",
            C: "Font style for the variable label. @default",
            U: {
                Heatmap: "true"
            }
        },
        sma10Color: {
            H: ['{*,"stockIndicators":["Sma10"]}'],
            M: "Candlestick Plots",
            T: "color",
            C: "The color for the 5 day single moving average",
            D: "rgb(0,255,0)"
        },
        ringsType: {
            H: ['{"data":"Circular","segregateVariablesBy":"Ring","ringsType":["bar","heatmap","dot"]}'],
            M: "Circular Graphs",
            T: "array",
            C: "Array containing the types for each ring in the circular plots",
            D: "[]"
        },
        gradientOrientation: {
            A: "true",
            S: ["backgroundType"],
            O: ["vertical", "horizontal"],
            T: "option",
            H: ['{*,"data":"Random:1:3:0:0","gradient":true,"gradientType":"linear"}'],
            M: "Gradients",
            D: "vertical",
            C: "Specifies the orientation of the gradient if the gradient type is of the type 'linear'"
        },
        refresehDataTableOnDraw: {
            A: "true",
            M: "Data Table",
            T: "boolean",
            C: "Flag to indicate to refresh data after drawing the plot",
            D: "true"
        },
        randomNetworkReduce: {
            A: "true",
            M: "Random",
            T: "boolean",
            C: "Flag to create or not a single random network for debug and demonstration purposes",
            D: "true",
            U: {
                Network: "true"
            }
        },
        varLabelFontSize: {
            A: "true",
            S: ["autoScaleFont", "varLabelScaleFontFactor"],
            T: "integer",
            H: ['{"autoScaleFont":false,"varLabelFontSize":10}', '{"autoScaleFont":false,"varLabelFontSize":20}'],
            M: "Variables",
            D: "10",
            C: "Size for the variable labels in one dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the variable label scaling factor",
            U: {
                Heatmap: "true"
            }
        },
        smpLabelFontSize: {
            A: "true",
            S: ["autoScaleFont", "smpLabelScaleFontFactor"],
            H: ['{"autoScaleFont":false,"smpLabelFontSize":10}', '{"autoScaleFont":false,"smpLabelFontSize":20}'],
            M: "Samples",
            T: "integer",
            C: "Size for the sample labels in one dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the sample label scaling factor",
            D: "10"
        },
        maxRotate: {
            A: "true",
            M: "3D Attributes",
            T: "float",
            C: "Maximum number of degrees to rotate graph arround axes",
            D: "false"
        },
        sequenceAColor: {
            H: ["{*}"],
            M: "Genome Browser",
            T: "color",
            C: "Color for the adenines and alanines in the genome browser",
            D: "rgb(0,103,0)"
        },
        clusterVariables: {
            S: ["distance", "linkage", "clusterAxis", "imputeMethod", "centerData"],
            M: "Functions",
            T: "void",
            C: "Cluster variables based on data and generate a dendrogram on the variable axis. It takes no parameters",
            U: {
                Heatmap: "true"
            }
        },
        xAxis2TickFormat: {
            A: "true",
            H: ['{"graphType":"BarLine","xAxis2TickFormat":"%.2f cxs","graphOrientation":"vertical"}'],
            M: "X-Axis2",
            T: "string",
            C: "Format for the tick values in the second X axis",
            D: "false"
        },
        dataEvent: {
            A: "true",
            Z: "true",
            M: "Events",
            T: "array",
            C: "Array to store the areas that will trigger an event"
        },
        highlightNode: {
            H: ['{"highlightNode":["Gene1","Gene2"]}'],
            M: "Network Graphs",
            T: "array",
            C: "Name of nodes in the 'data.nodes' object to highlight.",
            D: "[]"
        },
        snapshots: {
            A: "true",
            Z: "true",
            M: "Snapshots",
            T: "array",
            C: "Array to hold the data used in the animation"
        }
    },
    G: {
        name: {
            M: "Genome",
            T: "string",
            C: "Track name"
        }
    },
    E: {
        cap: {
            O: "butt, round, square",
            M: "Network",
            T: "option",
            C: "Type of cap for the end of the lines"
        },
        width: {
            M: "Network",
            T: "integer",
            C: "Pixel width for the edges between nodes"
        },
        anchor: {
            M: "Network",
            T: "boolean",
            C: "Flag make the edge transparent"
        },
        color: {
            M: "Network",
            T: "color",
            C: "Color for the edge"
        },
        hide: {
            M: "Network",
            T: "boolean",
            C: "Flag to hide the edge"
        },
        exact: {
            M: "Network",
            T: "boolean",
            C: "Flag to indicate to create the edge between nodes without subtracting the size of the nodes"
        },
        type: {
            M: "Network",
            T: "string",
            C: "Type of line use to join the nodes"
        }
    }
};
